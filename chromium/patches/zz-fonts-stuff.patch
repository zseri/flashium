diff --git a/build/linux/unbundle/fontconfig.gn b/build/linux/unbundle/fontconfig.gn
index c1e229854be6..49236c9c8ace 100644
--- a/build/linux/unbundle/fontconfig.gn
+++ b/build/linux/unbundle/fontconfig.gn
@@ -2,7 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-assert(is_linux)
+assert(is_linux || is_chromeos)
 
 config("fontconfig_config") {
   libs = [ "fontconfig" ]
diff --git a/components/services/font/BUILD.gn b/components/services/font/BUILD.gn
index a6ce90a915e7..b065131e0352 100644
--- a/components/services/font/BUILD.gn
+++ b/components/services/font/BUILD.gn
@@ -2,45 +2,36 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-import("//build/config/features.gni")
 import("//build/config/features.gni")
 import("//ppapi/buildflags/buildflags.gni")
-import("//ppapi/buildflags/buildflags.gni")
-import("//services/service_manager/public/cpp/service.gni")
-import("//services/service_manager/public/service_manifest.gni")
-import("//services/service_manager/public/tools/test/service_test.gni")
 import("//testing/test.gni")
 
 source_set("lib") {
   sources = [
     "font_service_app.cc",
     "font_service_app.h",
+    "fontconfig_matching.cc",
+    "fontconfig_matching.h",
   ]
 
   deps = [
     "//base",
-    "//components/services/font/public/interfaces",
+    "//components/services/font/public/mojom",
     "//mojo/public/cpp/bindings",
     "//mojo/public/cpp/system",
     "//ppapi/buildflags:buildflags",
-    "//services/service_manager/public/cpp",
+    "//third_party/fontconfig",
     "//ui/gfx",
   ]
 
-  public_deps = [
-    "//skia",
-  ]
+  public_deps = [ "//skia" ]
 
-  if (is_linux && enable_plugins) {
+  if ((is_linux || is_chromeos) && enable_plugins) {
     deps += [ ":ppapi_fontconfig_matching" ]
   }
-
-  if (is_linux) {
-    deps += [ "//base/test:fontconfig_util_linux" ]
-  }
 }
 
-if (is_linux && enable_plugins) {
+if ((is_linux || is_chromeos) && enable_plugins) {
   source_set("ppapi_fontconfig_matching") {
     sources = [
       "ppapi_fontconfig_matching.cc",
@@ -51,47 +42,25 @@ if (is_linux && enable_plugins) {
       "//base:base",
       "//ppapi/buildflags:buildflags",
       "//ppapi/c",
-      "//third_party/fontconfig",
     ]
   }
 }
 
-service("font_service") {
-  sources = [
-    "main.cc",
-  ]
+test("font_service_unittests") {
+  sources = [ "font_loader_unittest.cc" ]
 
   deps = [
     ":lib",
     "//base",
-    "//mojo/public/c/system",
-    "//services/service_manager/public/cpp",
-  ]
-}
-
-service_manifest("manifest") {
-  name = "font_service"
-  source = "manifest.json"
-}
-
-service_test("font_service_unittests") {
-  sources = [
-    "font_loader_test.cc",
-    "font_loader_test.h",
-  ]
-
-  catalog = ":font_service_unittests_catalog"
-
-  deps = [
-    "//base",
+    "//base/test:test_support",
     "//components/services/font/public/cpp",
-    "//components/services/font/public/interfaces",
+    "//components/services/font/public/mojom",
+    "//mojo/core/test:run_all_unittests",
     "//mojo/public/cpp/bindings",
     "//mojo/public/cpp/system",
     "//ppapi/buildflags:buildflags",
-    "//services/service_manager/public/cpp",
-    "//services/service_manager/public/cpp:service_test_support",
     "//skia",
+    "//testing/gtest",
   ]
 
   if (enable_plugins) {
@@ -100,18 +69,4 @@ service_test("font_service_unittests") {
       "//third_party:freetype_harfbuzz",
     ]
   }
-
-  data_deps = [
-    ":font_service",
-  ]
-}
-
-service_manifest("test_manifest") {
-  name = "font_service_unittests"
-  source = "test_manifest.json"
-}
-
-catalog("font_service_unittests_catalog") {
-  embedded_services = [ ":test_manifest" ]
-  standalone_services = [ ":manifest" ]
 }
diff --git a/components/services/font/DEPS b/components/services/font/DEPS
index b81f8787fc91..9f6476397f11 100644
--- a/components/services/font/DEPS
+++ b/components/services/font/DEPS
@@ -1,5 +1,4 @@
 include_rules = [
-  "+services/service_manager",
   "+mojo/public",
   "+ppapi/buildflags",
   "+ppapi/c",
diff --git a/components/services/font/DIR_METADATA b/components/services/font/DIR_METADATA
new file mode 100644
index 000000000000..594a7d6501fc
--- /dev/null
+++ b/components/services/font/DIR_METADATA
@@ -0,0 +1,3 @@
+monorail {
+  component: "Blink>Fonts"
+}
diff --git a/components/services/font/OWNERS b/components/services/font/OWNERS
index 3d43cf0bd5f2..f196c8221df6 100644
--- a/components/services/font/OWNERS
+++ b/components/services/font/OWNERS
@@ -1,6 +1 @@
 drott@chromium.org
-
-per-file manifest.json=set noparent
-per-file manifest.json=file://ipc/SECURITY_OWNERS
-per-file test_manifest.json=set noparent
-per-file test_manifest.json=file://ipc/SECURITY_OWNERS
diff --git a/components/services/font/font_loader_test.h b/components/services/font/font_loader_test.h
deleted file mode 100644
index a0a4499164b9..000000000000
--- a/components/services/font/font_loader_test.h
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright 2018 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef COMPONENTS_SERVICES_FONT_FONT_LOADER_TEST_H_
-#define COMPONENTS_SERVICES_FONT_FONT_LOADER_TEST_H_
-
-#include <utility>
-
-#include "base/bind.h"
-#include "base/macros.h"
-#include "components/services/font/public/cpp/font_loader.h"
-#include "components/services/font/public/interfaces/font_service.mojom.h"
-#include "mojo/public/cpp/bindings/binding.h"
-#include "services/service_manager/public/cpp/service_test.h"
-
-namespace font_service {
-
-class FontLoaderTest : public service_manager::test::ServiceTest {
- public:
-  FontLoaderTest();
-  ~FontLoaderTest() override;
-
-  // Overridden from service_manager::test::ServiceTest:
-  void SetUp() override;
-
- protected:
-  FontLoader* font_loader() { return font_loader_.get(); }
-
- private:
-  std::unique_ptr<FontLoader> font_loader_;
-
-  DISALLOW_COPY_AND_ASSIGN(FontLoaderTest);
-};
-
-}  // namespace font_service
-
-#endif  // COMPONENTS_SERVICES_FONT_FONT_LOADER_TEST_H_
diff --git a/components/services/font/font_loader_test.cc b/components/services/font/font_loader_unittest.cc
similarity index 55%
rename from components/services/font/font_loader_test.cc
rename to components/services/font/font_loader_unittest.cc
index 4425736a9674..a9454d14f09e 100644
--- a/components/services/font/font_loader_test.cc
+++ b/components/services/font/font_loader_unittest.cc
@@ -2,15 +2,20 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "components/services/font/font_loader_test.h"
-
 #include <utility>
 
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/no_destructor.h"
 #include "base/run_loop.h"
-#include "components/services/font/public/interfaces/constants.mojom.h"
-#include "components/services/font/public/interfaces/font_service.mojom.h"
+#include "base/task/post_task.h"
+#include "base/task/thread_pool.h"
+#include "base/test/task_environment.h"
+#include "components/services/font/font_service_app.h"
+#include "components/services/font/public/cpp/font_loader.h"
+#include "components/services/font/public/mojom/font_service.mojom.h"
 #include "ppapi/buildflags/buildflags.h"
-#include "services/service_manager/public/cpp/connector.h"
+#include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/skia/include/core/SkFontStyle.h"
 
 #if BUILDFLAG(ENABLE_PLUGINS)
@@ -19,10 +24,13 @@
 #include "ppapi/c/private/pp_private_font_charset.h"  // nogncheck
 #endif
 
+namespace font_service {
 namespace {
-bool IsInTestFontDirectory(const char* path) {
-  const char kTestFontsDir[] = "test_fonts";
-  return std::string(path).find(kTestFontsDir) != std::string::npos;
+
+bool IsInTestFontDirectory(const base::FilePath& path) {
+  const base::FilePath kTestFontsDir(
+      FILE_PATH_LITERAL("./third_party/test_fonts"));
+  return kTestFontsDir.IsParent(path);
 }
 
 #if BUILDFLAG(ENABLE_PLUGINS)
@@ -32,7 +40,7 @@ std::string GetPostscriptNameFromFile(base::File& font_file) {
     return "";
 
   std::vector<char> file_contents;
-  file_contents.reserve(file_size);
+  file_contents.resize(file_size);
   CHECK_EQ(file_size, font_file.Read(0, file_contents.data(), file_size));
   std::string font_family_name;
   FT_Library library;
@@ -49,19 +57,38 @@ std::string GetPostscriptNameFromFile(base::File& font_file) {
 }
 #endif
 
-}  // namespace
-
-namespace font_service {
-
-FontLoaderTest::FontLoaderTest() : ServiceTest("font_service_unittests") {}
-
-FontLoaderTest::~FontLoaderTest() {}
-
-void FontLoaderTest::SetUp() {
-  ServiceTest::SetUp();
-  font_loader_ = std::make_unique<FontLoader>(connector());
+mojo::PendingRemote<mojom::FontService> ConnectToBackgroundFontService() {
+  mojo::PendingRemote<mojom::FontService> remote;
+  base::ThreadPool::CreateSequencedTaskRunner(
+      {base::MayBlock(), base::WithBaseSyncPrimitives(),
+       base::TaskPriority::USER_BLOCKING})
+      ->PostTask(FROM_HERE,
+                 base::BindOnce(
+                     [](mojo::PendingReceiver<mojom::FontService> receiver) {
+                       static base::NoDestructor<FontServiceApp> service;
+                       service->BindReceiver(std::move(receiver));
+                     },
+                     remote.InitWithNewPipeAndPassReceiver()));
+  return remote;
 }
 
+class FontLoaderTest : public testing::Test {
+ public:
+  FontLoaderTest() = default;
+  ~FontLoaderTest() override = default;
+
+ protected:
+  FontLoader* font_loader() { return &font_loader_; }
+
+ private:
+  base::test::TaskEnvironment task_environment_;
+  FontLoader font_loader_{ConnectToBackgroundFontService()};
+
+  DISALLOW_COPY_AND_ASSIGN(FontLoaderTest);
+};
+
+}  // namespace
+
 TEST_F(FontLoaderTest, BasicMatchingTest) {
   SkFontStyle styles[] = {
       SkFontStyle(SkFontStyle::kNormal_Weight, SkFontStyle::kNormal_Width,
@@ -89,7 +116,8 @@ TEST_F(FontLoaderTest, BasicMatchingTest) {
                                      &result_family_name, &result_style);
       EXPECT_EQ(request_family_name[1],
                 std::string(result_family_name.c_str()));
-      EXPECT_TRUE(IsInTestFontDirectory(font_identity.fString.c_str()));
+      EXPECT_TRUE(
+          IsInTestFontDirectory(base::FilePath(font_identity.fString.c_str())));
       EXPECT_EQ(result_style, request_style);
     }
   }
@@ -118,7 +146,8 @@ TEST_F(FontLoaderTest, EmptyFontName) {
                                  &font_identity, &result_family_name,
                                  &result_style);
   EXPECT_EQ(kDefaultFontName, std::string(result_family_name.c_str()));
-  EXPECT_TRUE(IsInTestFontDirectory(font_identity.fString.c_str()));
+  EXPECT_TRUE(
+      IsInTestFontDirectory(base::FilePath(font_identity.fString.c_str())));
 }
 
 TEST_F(FontLoaderTest, CharacterFallback) {
@@ -146,10 +175,9 @@ TEST_F(FontLoaderTest, CharacterFallback) {
     EXPECT_FALSE(is_bold);
     EXPECT_FALSE(is_italic);
     if (character_family.second.size()) {
-      EXPECT_TRUE(
-          IsInTestFontDirectory(font_identity->str_representation.c_str()));
+      EXPECT_TRUE(IsInTestFontDirectory(font_identity->filepath));
     } else {
-      EXPECT_EQ(font_identity->str_representation.size(), 0u);
+      EXPECT_TRUE(font_identity->filepath.empty());
       EXPECT_EQ(result_family_name, "");
     }
   }
@@ -232,4 +260,101 @@ TEST_F(FontLoaderTest, PPAPIFallback) {
 #endif
 }
 
+TEST_F(FontLoaderTest, LocalMatching) {
+  // The following fonts are ensured to be available by the test harnesses
+  // global FontConfig setup which makes the fonts in third_party/test_fonts
+  // available. (See SetUpFontConfig() in TestSuite::Initialize().
+  std::string postscript_names_test_fonts[] = {"Ahem",
+                                               "Arimo-Bold",
+                                               "Arimo-BoldItalic",
+                                               "Arimo-Italic",
+                                               "Arimo-Regular",
+                                               "Cousine-Bold",
+                                               "Cousine-BoldItalic",
+                                               "Cousine-Italic",
+                                               "Cousine-Regular",
+                                               "DejaVuSans",
+                                               "DejaVuSans-Bold",
+                                               "GardinerModBug",
+                                               "GardinerModCat",
+                                               "Garuda",
+                                               "Gelasio-Bold",
+                                               "Gelasio-BoldItalic",
+                                               "Gelasio-Italic",
+                                               "Gelasio-Regular",
+                                               "Lohit-Devanagari",
+                                               "Lohit-Gurmukhi",
+                                               "Lohit-Tamil",
+                                               "NotoSansKhmer-Regular",
+                                               "Tinos-Bold",
+                                               "Tinos-BoldItalic",
+                                               "Tinos-Italic",
+                                               "Tinos-Regular",
+                                               "muktinarrow"};
+  std::string full_font_names_test_fonts[] = {"Ahem",
+                                              "Arimo Bold Italic",
+                                              "Arimo Bold",
+                                              "Arimo Italic",
+                                              "Arimo Regular",
+                                              "Cousine Bold Italic",
+                                              "Cousine Bold",
+                                              "Cousine Italic",
+                                              "Cousine Regular",
+                                              "DejaVu Sans Bold",
+                                              "DejaVu Sans",
+                                              "GardinerMod",
+                                              "Garuda",
+                                              "Gelasio Bold Italic",
+                                              "Gelasio Bold",
+                                              "Gelasio Italic",
+                                              "Gelasio Regular",
+                                              "Lohit Devanagari",
+                                              "Lohit Gurmukhi",
+                                              "Lohit Tamil",
+                                              "Mukti",
+                                              "Mukti Narrow",
+                                              "Noto Sans Khmer Regular",
+                                              "Tinos Bold Italic",
+                                              "Tinos Bold",
+                                              "Tinos Italic",
+                                              "Tinos Regular"};
+
+  auto match_unique_names = [this](auto& font_list) {
+    for (auto unique_font_name : font_list) {
+      mojom::FontIdentityPtr font_identity;
+      EXPECT_TRUE(font_loader()->MatchFontByPostscriptNameOrFullFontName(
+          unique_font_name, &font_identity));
+      EXPECT_FALSE(font_identity.is_null());
+      EXPECT_TRUE(IsInTestFontDirectory(font_identity->filepath));
+    }
+  };
+  match_unique_names(full_font_names_test_fonts);
+  match_unique_names(postscript_names_test_fonts);
+}
+
+TEST_F(FontLoaderTest, LocalMatchingExpectNoMatchForFamilyNames) {
+  std::string family_names_expect_no_match[] = {"Arimo", "Cousine",   "Gelasio",
+                                                "Lohit", "Noto Sans", "Tinos"};
+  for (auto& family_name : family_names_expect_no_match) {
+    mojom::FontIdentityPtr font_identity;
+    EXPECT_FALSE(font_loader()->MatchFontByPostscriptNameOrFullFontName(
+        family_name, &font_identity));
+    EXPECT_TRUE(font_identity.is_null());
+  }
+}
+
+TEST_F(FontLoaderTest, RejectNonUtf8) {
+  const char* invalid_utf8_font_names[] = {
+      // Trailing U+FDD0 U+FDD1 U+FDD2 U+FDD3
+      "FontNameWithNonCharacters\xEF\xB7\x90\x20\xEF\xB7\x91\x20\xEF\xB7"
+      "\x92\x20\xEF\xB7\x93",
+      "InvalidBytes\xfe\xff"};
+  for (std::string invalid_font_name : invalid_utf8_font_names) {
+    mojom::FontIdentityPtr font_identity;
+    EXPECT_FALSE(font_loader()->MatchFontByPostscriptNameOrFullFontName(
+        invalid_font_name, &font_identity));
+    EXPECT_TRUE(font_identity.is_null());
+  }
+}
+
 }  // namespace font_service
diff --git a/components/services/font/font_service_app.cc b/components/services/font/font_service_app.cc
index aae40ebce0b0..54a7f8d492c0 100644
--- a/components/services/font/font_service_app.cc
+++ b/components/services/font/font_service_app.cc
@@ -6,13 +6,16 @@
 
 #include <utility>
 
+#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/files/file.h"
 #include "base/files/file_path.h"
+#include "base/trace_event/trace_event.h"
 #include "build/build_config.h"
+#include "components/services/font/fontconfig_matching.h"
 #include "mojo/public/cpp/system/platform_handle.h"
 #include "ppapi/buildflags/buildflags.h"
-#include "services/service_manager/public/cpp/service_context.h"
+#include "skia/ext/skia_utils_base.h"
 #include "ui/gfx/font_fallback_linux.h"
 #include "ui/gfx/font_render_params.h"
 
@@ -20,10 +23,6 @@
 #include "components/services/font/ppapi_fontconfig_matching.h"  // nogncheck
 #endif
 
-#if defined(OS_LINUX)
-#include "base/test/fontconfig_util_linux.h"
-#endif
-
 static_assert(
     static_cast<uint32_t>(SkFontStyle::kUpright_Slant) ==
         static_cast<uint32_t>(font_service::mojom::TypefaceSlant::ROMAN),
@@ -82,29 +81,20 @@ font_service::mojom::RenderStyleSwitch ConvertSubpixelRendering(
 
 namespace font_service {
 
-std::unique_ptr<service_manager::Service> FontServiceApp::CreateService() {
-  return std::make_unique<FontServiceApp>();
-}
+FontServiceApp::FontServiceApp() = default;
 
-FontServiceApp::FontServiceApp() {
-  registry_.AddInterface(
-      base::BindRepeating(&FontServiceApp::CreateSelf, base::Unretained(this)));
-}
+FontServiceApp::~FontServiceApp() = default;
 
-FontServiceApp::~FontServiceApp() {}
-
-void FontServiceApp::OnStart() {}
-
-void FontServiceApp::OnBindInterface(
-    const service_manager::BindSourceInfo& source_info,
-    const std::string& interface_name,
-    mojo::ScopedMessagePipeHandle interface_pipe) {
-  registry_.BindInterface(interface_name, std::move(interface_pipe));
+void FontServiceApp::BindReceiver(
+    mojo::PendingReceiver<mojom::FontService> receiver) {
+  receivers_.Add(this, std::move(receiver));
 }
 
 void FontServiceApp::MatchFamilyName(const std::string& family_name,
                                      mojom::TypefaceStylePtr requested_style,
                                      MatchFamilyNameCallback callback) {
+  TRACE_EVENT0("fonts", "FontServiceApp::MatchFamilyName");
+
   SkFontConfigInterface::FontIdentity result_identity;
   SkString result_family;
   SkFontStyle result_style;
@@ -127,12 +117,13 @@ void FontServiceApp::MatchFamilyName(const std::string& family_name,
 
   // Stash away the returned path, so we can give it an ID (index)
   // which will later be given to us in a request to open the file.
-  int index = FindOrAddPath(result_identity.fString);
+  base::FilePath path(result_identity.fString.c_str());
+  size_t index = FindOrAddPath(path);
 
   mojom::FontIdentityPtr identity(mojom::FontIdentity::New());
   identity->id = static_cast<uint32_t>(index);
   identity->ttc_index = result_identity.fTTCIndex;
-  identity->str_representation = result_identity.fString.c_str();
+  identity->filepath = path;
 
   mojom::TypefaceStylePtr style(mojom::TypefaceStyle::New());
   style->weight = result_style.weight();
@@ -145,11 +136,12 @@ void FontServiceApp::MatchFamilyName(const std::string& family_name,
 
 void FontServiceApp::OpenStream(uint32_t id_number,
                                 OpenStreamCallback callback) {
+  TRACE_EVENT0("fonts", "FontServiceApp::OpenStream");
+
   DCHECK_LT(id_number, static_cast<uint32_t>(paths_.size()));
   base::File file;
-  if (id_number < static_cast<uint32_t>(paths_.size())) {
-    file = GetFileForPath(base::FilePath(paths_[id_number].c_str()));
-  }
+  if (id_number < static_cast<uint32_t>(paths_.size()))
+    file = GetFileForPath(paths_[id_number]);
 
   std::move(callback).Run(std::move(file));
 }
@@ -158,16 +150,22 @@ void FontServiceApp::FallbackFontForCharacter(
     uint32_t character,
     const std::string& locale,
     FallbackFontForCharacterCallback callback) {
-  auto fallback_font = gfx::GetFallbackFontForChar(character, locale);
-  int index = FindOrAddPath(SkString(fallback_font.filename.data()));
+  TRACE_EVENT0("fonts", "FontServiceApp::FallbackFontForCharacter");
 
-  mojom::FontIdentityPtr identity(mojom::FontIdentity::New());
-  identity->id = static_cast<uint32_t>(index);
-  identity->ttc_index = fallback_font.ttc_index;
-  identity->str_representation = fallback_font.filename;
+  gfx::FallbackFontData fallback_font;
+  if (gfx::GetFallbackFontForChar(character, locale, &fallback_font)) {
+    size_t index = FindOrAddPath(fallback_font.filepath);
 
-  std::move(callback).Run(std::move(identity), fallback_font.name,
-                          fallback_font.is_bold, fallback_font.is_italic);
+    mojom::FontIdentityPtr identity(mojom::FontIdentity::New());
+    identity->id = static_cast<uint32_t>(index);
+    identity->ttc_index = fallback_font.ttc_index;
+    identity->filepath = fallback_font.filepath;
+
+    std::move(callback).Run(std::move(identity), fallback_font.name,
+                            fallback_font.is_bold, fallback_font.is_italic);
+  } else {
+    std::move(callback).Run(nullptr, "", false, false);
+  }
 }
 
 void FontServiceApp::FontRenderStyleForStrike(
@@ -177,6 +175,8 @@ void FontServiceApp::FontRenderStyleForStrike(
     bool is_italic,
     float device_scale_factor,
     FontRenderStyleForStrikeCallback callback) {
+  TRACE_EVENT0("fonts", "FontServiceApp::FontRenderStyleForStrike");
+
   gfx::FontRenderParamsQuery query;
 
   query.device_scale_factor = device_scale_factor;
@@ -203,6 +203,25 @@ void FontServiceApp::FontRenderStyleForStrike(
   std::move(callback).Run(std::move(font_render_style));
 }
 
+void FontServiceApp::MatchFontByPostscriptNameOrFullFontName(
+    const std::string& family,
+    MatchFontByPostscriptNameOrFullFontNameCallback callback) {
+  TRACE_EVENT0("fonts",
+               "FontServiceApp::MatchFontByPostscriptNameOrFullFontName");
+
+  base::Optional<FontConfigLocalMatching::FontConfigMatchResult> match_result =
+      FontConfigLocalMatching::FindFontByPostscriptNameOrFullFontName(family);
+  if (match_result) {
+    uint32_t fontconfig_interface_id = FindOrAddPath(match_result->file_path);
+    mojom::FontIdentityPtr font_identity(mojom::FontIdentity::New(
+        fontconfig_interface_id, match_result->ttc_index,
+        match_result->file_path));
+    std::move(callback).Run(std::move(font_identity));
+    return;
+  }
+  std::move(callback).Run(nullptr);
+}
+
 void FontServiceApp::MatchFontWithFallback(
     const std::string& family,
     bool is_bold,
@@ -210,6 +229,8 @@ void FontServiceApp::MatchFontWithFallback(
     uint32_t charset,
     uint32_t fallbackFamilyType,
     MatchFontWithFallbackCallback callback) {
+  TRACE_EVENT0("fonts", "FontServiceApp::MatchFontWithFallback");
+
 #if BUILDFLAG(ENABLE_PLUGINS)
   base::File matched_font_file;
   int font_file_descriptor = MatchFontFaceWithFallback(
@@ -223,13 +244,11 @@ void FontServiceApp::MatchFontWithFallback(
 #endif
 }
 
-void FontServiceApp::CreateSelf(mojom::FontServiceRequest request) {
-  bindings_.AddBinding(this, std::move(request));
-}
-
-int FontServiceApp::FindOrAddPath(const SkString& path) {
-  int count = paths_.size();
-  for (int i = 0; i < count; ++i) {
+size_t FontServiceApp::FindOrAddPath(const base::FilePath& path) {
+  TRACE_EVENT1("fonts", "FontServiceApp::FindOrAddPath", "path",
+               path.AsUTF8Unsafe());
+  size_t count = paths_.size();
+  for (size_t i = 0; i < count; ++i) {
     if (path == paths_[i])
       return i;
   }
diff --git a/components/services/font/font_service_app.h b/components/services/font/font_service_app.h
index 9256a46cc514..e46d79f5c6f4 100644
--- a/components/services/font/font_service_app.h
+++ b/components/services/font/font_service_app.h
@@ -8,32 +8,21 @@
 #include <stdint.h>
 #include <vector>
 
+#include "base/files/file_path.h"
 #include "base/macros.h"
-#include "components/services/font/public/interfaces/font_service.mojom.h"
-#include "mojo/public/cpp/bindings/binding_set.h"
-#include "services/service_manager/public/cpp/binder_registry.h"
-#include "services/service_manager/public/cpp/service.h"
-#include "skia/ext/skia_utils_base.h"
+#include "components/services/font/public/mojom/font_service.mojom.h"
+#include "mojo/public/cpp/bindings/receiver_set.h"
 
 namespace font_service {
 
-class FontServiceApp : public service_manager::Service,
-                       public mojom::FontService {
+class FontServiceApp : public mojom::FontService {
  public:
   FontServiceApp();
   ~FontServiceApp() override;
 
-  static std::unique_ptr<service_manager::Service> CreateService();
-
-  void CreateSelf(mojom::FontServiceRequest request);
+  void BindReceiver(mojo::PendingReceiver<mojom::FontService> receiver);
 
  private:
-  // service_manager::Service:
-  void OnStart() override;
-  void OnBindInterface(const service_manager::BindSourceInfo& source_info,
-                       const std::string& interface_name,
-                       mojo::ScopedMessagePipeHandle interface_pipe) override;
-
   // FontService:
   void MatchFamilyName(const std::string& family_name,
                        mojom::TypefaceStylePtr requested_style,
@@ -50,20 +39,22 @@ class FontServiceApp : public service_manager::Service,
       bool bold,
       float device_scale_factor,
       FontRenderStyleForStrikeCallback callback) override;
+  void MatchFontByPostscriptNameOrFullFontName(
+      const std::string& family,
+      MatchFontByPostscriptNameOrFullFontNameCallback callback) override;
   void MatchFontWithFallback(const std::string& family,
                              bool is_bold,
                              bool is_italic,
                              uint32_t charset,
                              uint32_t fallbackFamilyType,
                              MatchFontWithFallbackCallback callback) override;
-  int FindOrAddPath(const SkString& path);
+  size_t FindOrAddPath(const base::FilePath& path);
 
-  service_manager::BinderRegistry registry_;
-  mojo::BindingSet<mojom::FontService> bindings_;
+  mojo::ReceiverSet<mojom::FontService> receivers_;
 
   // We don't want to leak paths to our callers; we thus enumerate the paths of
   // fonts.
-  std::vector<SkString> paths_;
+  std::vector<base::FilePath> paths_;
 
   DISALLOW_COPY_AND_ASSIGN(FontServiceApp);
 };
diff --git a/components/services/font/fontconfig_matching.cc b/components/services/font/fontconfig_matching.cc
new file mode 100644
index 000000000000..8b2f3b112974
--- /dev/null
+++ b/components/services/font/fontconfig_matching.cc
@@ -0,0 +1,112 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/services/font/fontconfig_matching.h"
+
+#include <fontconfig/fontconfig.h>
+#include "base/files/file.h"
+#include "base/posix/eintr_wrapper.h"
+#include "base/strings/string_util.h"
+
+#include <memory>
+
+namespace font_service {
+
+base::Optional<FontConfigLocalMatching::FontConfigMatchResult>
+FontConfigLocalMatching::FindFontByPostscriptNameOrFullFontName(
+    const std::string& font_name) {
+  // TODO(crbug.com/876652): This FontConfig-backed implementation will
+  // match PostScript and full font name in any language, and we're okay
+  // with that for now since it is what FireFox does.
+  base::Optional<FontConfigLocalMatching::FontConfigMatchResult>
+      postscript_result =
+          FindFontBySpecifiedName(FC_POSTSCRIPT_NAME, font_name);
+  if (postscript_result)
+    return postscript_result;
+
+  return FindFontBySpecifiedName(FC_FULLNAME, font_name);
+}
+
+base::Optional<FontConfigLocalMatching::FontConfigMatchResult>
+FontConfigLocalMatching::FindFontBySpecifiedName(
+    const char* fontconfig_parameter_name,
+    const std::string& font_name) {
+  DCHECK(std::string(fontconfig_parameter_name) == std::string(FC_FULLNAME) ||
+         std::string(fontconfig_parameter_name) ==
+             std::string(FC_POSTSCRIPT_NAME));
+
+  if (!base::IsStringUTF8(font_name))
+    return base::nullopt;
+
+  std::unique_ptr<FcPattern, void (*)(FcPattern*)> pattern(FcPatternCreate(),
+                                                           FcPatternDestroy);
+  const FcChar8* fc_font_name =
+      reinterpret_cast<const FcChar8*>(font_name.c_str());
+
+  // TODO(crbug.com/876652): We do not restrict the language that we match
+  // FC_POSTSCRIPT_NAME or FC_FULLNAME against. Pending spec clarification, see
+  // bug.
+  FcPatternAddString(pattern.get(), fontconfig_parameter_name, fc_font_name);
+
+  FcPatternAddBool(pattern.get(), FC_SCALABLE, true);
+
+  std::unique_ptr<FcObjectSet, void (*)(FcObjectSet*)> object_set(
+      FcObjectSetCreate(), FcObjectSetDestroy);
+  FcObjectSetAdd(object_set.get(), "file");
+  FcObjectSetAdd(object_set.get(), "index");
+
+  std::unique_ptr<FcFontSet, void (*)(FcFontSet*)> font_set(
+      FcFontList(nullptr, pattern.get(), object_set.get()), FcFontSetDestroy);
+
+  if (!font_set || !font_set->nfont)
+    return base::nullopt;
+
+  FcPattern* current = font_set->fonts[0];
+
+  const char* c_filename;
+  if (FcPatternGetString(current, FC_FILE, 0,
+                         reinterpret_cast<FcChar8**>(const_cast<char**>(
+                             &c_filename))) != FcResultMatch) {
+    return base::nullopt;
+  }
+  const char* sysroot =
+      reinterpret_cast<const char*>(FcConfigGetSysRoot(nullptr));
+  const std::string filename = std::string(sysroot ? sysroot : "") + c_filename;
+
+  // We only want to return sfnt (TrueType) based fonts. We don't have a
+  // very good way of detecting this so we'll filter based on the
+  // filename.
+  bool is_sfnt = false;
+  static const char kSFNTExtensions[][5] = {".ttf", ".otc", ".TTF", ".ttc", ""};
+  for (size_t j = 0;; j++) {
+    if (kSFNTExtensions[j][0] == 0) {
+      // None of the extensions matched.
+      break;
+    }
+    if (base::EndsWith(filename, kSFNTExtensions[j],
+                       base::CompareCase::SENSITIVE)) {
+      is_sfnt = true;
+      break;
+    }
+  }
+
+  if (!is_sfnt)
+    return base::nullopt;
+
+  base::FilePath font_file_path(filename);
+  base::File verify_file_exists(font_file_path,
+                                base::File::FLAG_OPEN | base::File::FLAG_READ);
+  if (!verify_file_exists.IsValid())
+    return base::nullopt;
+
+  int ttc_index = 0;
+  FcPatternGetInteger(current, FC_INDEX, 0, &ttc_index);
+  if (ttc_index < 0)
+    return base::nullopt;
+  FontConfigMatchResult match_result;
+  match_result.file_path = font_file_path;
+  match_result.ttc_index = ttc_index;
+  return match_result;
+}
+}  // namespace font_service
diff --git a/components/services/font/fontconfig_matching.h b/components/services/font/fontconfig_matching.h
new file mode 100644
index 000000000000..19069c2b33a7
--- /dev/null
+++ b/components/services/font/fontconfig_matching.h
@@ -0,0 +1,33 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_SERVICES_FONT_FONTCONFIG_MATCHING_H_
+#define COMPONENTS_SERVICES_FONT_FONTCONFIG_MATCHING_H_
+
+#include "base/files/file_path.h"
+#include "base/optional.h"
+
+namespace font_service {
+// Searches FontConfig for a system font uniquely identified by full font name
+// or postscript name. The matching algorithm tries to match both. Used for
+// matching @font-face { src: local() } references in Blink.
+class FontConfigLocalMatching {
+ public:
+  struct FontConfigMatchResult {
+    base::FilePath file_path;
+    unsigned ttc_index;
+  };
+
+  static base::Optional<FontConfigMatchResult>
+  FindFontByPostscriptNameOrFullFontName(const std::string& font_name);
+
+ private:
+  static base::Optional<FontConfigMatchResult> FindFontBySpecifiedName(
+      const char* fontconfig_parameter_name,
+      const std::string& font_name);
+};
+
+}  // namespace font_service
+
+#endif
diff --git a/components/services/font/main.cc b/components/services/font/main.cc
deleted file mode 100644
index 6995dab4549f..000000000000
--- a/components/services/font/main.cc
+++ /dev/null
@@ -1,12 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "services/service_manager/public/c/main.h"
-#include "components/services/font/font_service_app.h"
-#include "services/service_manager/public/cpp/service_runner.h"
-
-MojoResult ServiceMain(MojoHandle service_request_handle) {
-  service_manager::ServiceRunner runner(new font_service::FontServiceApp);
-  return runner.Run(service_request_handle);
-}
diff --git a/components/services/font/manifest.json b/components/services/font/manifest.json
deleted file mode 100644
index 77f1006edb7a..000000000000
--- a/components/services/font/manifest.json
+++ /dev/null
@@ -1,15 +0,0 @@
-{
-  "name": "font_service",
-  "display_name": "Font Service",
-  "sandbox_type": "none",
-  "interface_provider_specs": {
-    "service_manager:connector": {
-      "provides": {
-        "font_service": [ "font_service.mojom.FontService" ]
-      },
-      "requires": {
-        "service_manager": [ "service_manager:all_users" ]
-      }
-    }
-  }
-}
diff --git a/components/services/font/ppapi_fontconfig_matching.cc b/components/services/font/ppapi_fontconfig_matching.cc
index 42f40e7469cb..e95ecbe67849 100644
--- a/components/services/font/ppapi_fontconfig_matching.cc
+++ b/components/services/font/ppapi_fontconfig_matching.cc
@@ -11,6 +11,7 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 
+#include <memory>
 #include <string>
 
 #include "base/posix/eintr_wrapper.h"
@@ -127,10 +128,12 @@ int MatchFontFaceWithFallback(const std::string& face,
                               bool is_italic,
                               uint32_t charset,
                               uint32_t fallback_family) {
-  FcLangSet* langset = FcLangSetCreate();
-  bool is_lgc = MSCharSetToFontconfig(langset, charset);
-  FcPattern* pattern = FcPatternCreate();
-  FcPatternAddString(pattern, FC_FAMILY,
+  std::unique_ptr<FcLangSet, decltype(&FcLangSetDestroy)> langset(
+      FcLangSetCreate(), &FcLangSetDestroy);
+  bool is_lgc = MSCharSetToFontconfig(langset.get(), charset);
+  std::unique_ptr<FcPattern, decltype(&FcPatternDestroy)> pattern(
+      FcPatternCreate(), &FcPatternDestroy);
+  FcPatternAddString(pattern.get(), FC_FAMILY,
                      reinterpret_cast<const FcChar8*>(face.c_str()));
 
   // TODO(thestig) Check if we can access Chrome's per-script font preference
@@ -152,24 +155,30 @@ int MatchFontFaceWithFallback(const std::string& face,
   if (!generic_font_name.empty()) {
     const FcChar8* fc_generic_font_name =
         reinterpret_cast<const FcChar8*>(generic_font_name.c_str());
-    FcPatternAddString(pattern, FC_FAMILY, fc_generic_font_name);
+    FcPatternAddString(pattern.get(), FC_FAMILY, fc_generic_font_name);
   }
 
   if (is_bold)
-    FcPatternAddInteger(pattern, FC_WEIGHT, FC_WEIGHT_BOLD);
+    FcPatternAddInteger(pattern.get(), FC_WEIGHT, FC_WEIGHT_BOLD);
   if (is_italic)
-    FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);
-  FcPatternAddLangSet(pattern, FC_LANG, langset);
-  FcPatternAddBool(pattern, FC_SCALABLE, FcTrue);
-  FcConfigSubstitute(nullptr, pattern, FcMatchPattern);
-  FcDefaultSubstitute(pattern);
+    FcPatternAddInteger(pattern.get(), FC_SLANT, FC_SLANT_ITALIC);
+  FcPatternAddLangSet(pattern.get(), FC_LANG, langset.get());
+  FcPatternAddBool(pattern.get(), FC_SCALABLE, FcTrue);
+  FcConfigSubstitute(nullptr, pattern.get(), FcMatchPattern);
+  FcDefaultSubstitute(pattern.get());
 
   FcResult result;
-  FcFontSet* font_set = FcFontSort(nullptr, pattern, 0, nullptr, &result);
+  std::unique_ptr<FcFontSet, decltype(&FcFontSetDestroy)> font_set(
+      FcFontSort(nullptr, pattern.get(), 0, nullptr, &result),
+      &FcFontSetDestroy);
   int font_fd = -1;
   int good_enough_index = -1;
   bool good_enough_index_set = false;
 
+  const char* c_filename;
+  const char* c_sysroot =
+      reinterpret_cast<const char*>(FcConfigGetSysRoot(nullptr));
+  const std::string sysroot = c_sysroot ? c_sysroot : "";
   if (font_set) {
     for (int i = 0; i < font_set->nfont; ++i) {
       FcPattern* current = font_set->fonts[i];
@@ -183,11 +192,12 @@ int MatchFontFaceWithFallback(const std::string& face,
         continue;
       }
 
-      FcChar8* c_filename;
-      if (FcPatternGetString(current, FC_FILE, 0, &c_filename) !=
-          FcResultMatch) {
+      if (FcPatternGetString(current, FC_FILE, 0,
+                             reinterpret_cast<FcChar8**>(const_cast<char**>(
+                                 &c_filename))) != FcResultMatch) {
         continue;
       }
+      const std::string filename = sysroot + c_filename;
 
       // We only want to return sfnt (TrueType) based fonts. We don't have a
       // very good way of detecting this so we'll filter based on the
@@ -200,8 +210,8 @@ int MatchFontFaceWithFallback(const std::string& face,
           // None of the extensions matched.
           break;
         }
-        if (base::EndsWith(std::string(reinterpret_cast<char*>(c_filename)),
-                           kSFNTExtensions[j], base::CompareCase::SENSITIVE)) {
+        if (base::EndsWith(filename, kSFNTExtensions[j],
+                           base::CompareCase::SENSITIVE)) {
           is_sfnt = true;
           break;
         }
@@ -236,8 +246,7 @@ int MatchFontFaceWithFallback(const std::string& face,
         continue;
       }
 
-      font_fd =
-          HANDLE_EINTR(open(reinterpret_cast<char*>(c_filename), O_RDONLY));
+      font_fd = HANDLE_EINTR(open(filename.c_str(), O_RDONLY));
       if (font_fd >= 0)
         break;
     }
@@ -247,15 +256,14 @@ int MatchFontFaceWithFallback(const std::string& face,
     // We didn't find a font that we liked, so we fallback to something
     // acceptable.
     FcPattern* current = font_set->fonts[good_enough_index];
-    FcChar8* c_filename;
-    FcPatternGetString(current, FC_FILE, 0, &c_filename);
-    font_fd = HANDLE_EINTR(open(reinterpret_cast<char*>(c_filename), O_RDONLY));
+    if (!FcPatternGetString(
+            current, FC_FILE, 0,
+            reinterpret_cast<FcChar8**>(const_cast<char**>(&c_filename)))) {
+      const std::string filename = sysroot + c_filename;
+      font_fd = HANDLE_EINTR(open(filename.c_str(), O_RDONLY));
+    }
   }
 
-  if (font_set)
-    FcFontSetDestroy(font_set);
-  FcPatternDestroy(pattern);
-
   return font_fd;
 }
 
diff --git a/components/services/font/public/cpp/BUILD.gn b/components/services/font/public/cpp/BUILD.gn
index da5ce239c02d..259f11696b9b 100644
--- a/components/services/font/public/cpp/BUILD.gn
+++ b/components/services/font/public/cpp/BUILD.gn
@@ -13,12 +13,10 @@ source_set("cpp") {
   ]
 
   deps = [
-    "../interfaces",
     "//base",
+    "//components/services/font/public/mojom",
     "//mojo/public/cpp/bindings",
     "//mojo/public/cpp/system",
-    "//services/service_manager/public/cpp",
-    "//services/service_manager/public/mojom",
     "//skia",
   ]
 }
diff --git a/components/services/font/public/cpp/font_loader.cc b/components/services/font/public/cpp/font_loader.cc
index 4974393ebb48..4be7f118f6e0 100644
--- a/components/services/font/public/cpp/font_loader.cc
+++ b/components/services/font/public/cpp/font_loader.cc
@@ -7,40 +7,34 @@
 #include <utility>
 
 #include "base/bind.h"
+#include "base/memory/ref_counted.h"
 #include "base/trace_event/trace_event.h"
 #include "components/services/font/public/cpp/font_service_thread.h"
-#include "components/services/font/public/interfaces/constants.mojom.h"
-#include "services/service_manager/public/cpp/connector.h"
 
 namespace font_service {
 
-FontLoader::FontLoader(service_manager::Connector* connector) {
-  mojom::FontServicePtr font_service;
-  connector->BindInterface(font_service::mojom::kServiceName, &font_service);
-  thread_ = new internal::FontServiceThread(std::move(font_service));
+FontLoader::FontLoader(
+    mojo::PendingRemote<mojom::FontService> pending_font_service)
+    : thread_(base::MakeRefCounted<internal::FontServiceThread>()) {
+  thread_->Init(std::move(pending_font_service));
 }
 
-FontLoader::~FontLoader() {}
-
-void FontLoader::Shutdown() {
-  thread_->Stop();
-  thread_ = nullptr;
-}
+FontLoader::~FontLoader() = default;
 
 bool FontLoader::matchFamilyName(const char family_name[],
                                  SkFontStyle requested,
                                  FontIdentity* out_font_identifier,
                                  SkString* out_family_name,
                                  SkFontStyle* out_style) {
-  TRACE_EVENT1("font_service", "FontServiceThread::MatchFamilyName",
-               "family_name", family_name);
+  TRACE_EVENT1("fonts", "FontServiceThread::MatchFamilyName", "family_name",
+               TRACE_STR_COPY(family_name));
   return thread_->MatchFamilyName(family_name, requested, out_font_identifier,
                                   out_family_name, out_style);
 }
 
 SkStreamAsset* FontLoader::openStream(const FontIdentity& identity) {
-  TRACE_EVENT2("font_loader", "FontLoader::openStream", "identity",
-               identity.fID, "name", identity.fString.c_str());
+  TRACE_EVENT2("fonts", "FontLoader::openStream", "identity", identity.fID,
+               "name", TRACE_STR_COPY(identity.fString.c_str()));
   {
     base::AutoLock lock(lock_);
     auto mapped_font_files_it = mapped_font_files_.find(identity.fID);
@@ -67,6 +61,11 @@ SkStreamAsset* FontLoader::openStream(const FontIdentity& identity) {
   }
 }
 
+sk_sp<SkTypeface> FontLoader::makeTypeface(const FontIdentity& identity) {
+  TRACE_EVENT0("fonts", "FontServiceThread::makeTypeface");
+  return SkFontConfigInterface::makeTypeface(identity);
+}
+
 // Additional cross-thread accessible methods.
 bool FontLoader::FallbackFontForCharacter(
     uint32_t character,
@@ -92,6 +91,13 @@ bool FontLoader::FontRenderStyleForStrike(
                                            out_font_render_style);
 }
 
+bool FontLoader::MatchFontByPostscriptNameOrFullFontName(
+    std::string postscript_name_or_full_font_name,
+    mojom::FontIdentityPtr* out_identity) {
+  return thread_->MatchFontByPostscriptNameOrFullFontName(
+      std::move(postscript_name_or_full_font_name), out_identity);
+}
+
 void FontLoader::MatchFontWithFallback(std::string family,
                                        bool is_bold,
                                        bool is_italic,
@@ -103,8 +109,8 @@ void FontLoader::MatchFontWithFallback(std::string family,
 }
 
 void FontLoader::OnMappedFontFileDestroyed(internal::MappedFontFile* f) {
-  TRACE_EVENT1("font_loader", "FontLoader::OnMappedFontFileDestroyed",
-               "identity", f->font_id());
+  TRACE_EVENT1("fonts", "FontLoader::OnMappedFontFileDestroyed", "identity",
+               f->font_id());
   base::AutoLock lock(lock_);
   mapped_font_files_.erase(f->font_id());
 }
diff --git a/components/services/font/public/cpp/font_loader.h b/components/services/font/public/cpp/font_loader.h
index 4eebdeac1f92..31bc95d4e195 100644
--- a/components/services/font/public/cpp/font_loader.h
+++ b/components/services/font/public/cpp/font_loader.h
@@ -7,20 +7,16 @@
 
 #include <stdint.h>
 
-#include "base/containers/hash_tables.h"
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
 #include "base/synchronization/lock.h"
 #include "components/services/font/public/cpp/mapped_font_file.h"
-#include "components/services/font/public/interfaces/font_service.mojom.h"
+#include "components/services/font/public/mojom/font_service.mojom.h"
+#include "mojo/public/cpp/bindings/pending_remote.h"
 #include "third_party/skia/include/core/SkStream.h"
 #include "third_party/skia/include/core/SkTypeface.h"
 #include "third_party/skia/include/ports/SkFontConfigInterface.h"
 
-namespace service_manager {
-class Connector;
-}
-
 namespace font_service {
 namespace internal {
 class FontServiceThread;
@@ -35,12 +31,10 @@ class FontServiceThread;
 class FontLoader : public SkFontConfigInterface,
                    public internal::MappedFontFile::Observer {
  public:
-  explicit FontLoader(service_manager::Connector* connector);
+  explicit FontLoader(
+      mojo::PendingRemote<mojom::FontService> pending_font_service);
   ~FontLoader() override;
 
-  // Shuts down the background thread.
-  void Shutdown();
-
   // SkFontConfigInterface:
   bool matchFamilyName(const char family_name[],
                        SkFontStyle requested,
@@ -48,6 +42,7 @@ class FontLoader : public SkFontConfigInterface,
                        SkString* out_family_name,
                        SkFontStyle* out_style) override;
   SkStreamAsset* openStream(const FontIdentity& identity) override;
+  sk_sp<SkTypeface> makeTypeface(const FontIdentity& identity) override;
 
   // Additional cross-thread accessible methods below.
 
@@ -68,6 +63,13 @@ class FontLoader : public SkFontConfigInterface,
       bool is_bold,
       float device_scale_factor,
       mojom::FontRenderStylePtr* out_font_render_style);
+
+  // Out parameters are only guaranteed to be initialized when method returns
+  // true.
+  bool MatchFontByPostscriptNameOrFullFontName(
+      std::string postscript_name_or_full_font_name,
+      mojom::FontIdentityPtr* out_identity);
+
   // Out parameter out_font_file_handle should always be an opened file handle
   // to a matched or default font file. out_font_file_handle is a default
   // initialized base::File on error.
@@ -92,7 +94,7 @@ class FontLoader : public SkFontConfigInterface,
   base::Lock lock_;
 
   // Maps font identity ID to the memory-mapped file with font data.
-  base::hash_map<uint32_t, internal::MappedFontFile*> mapped_font_files_;
+  std::unordered_map<uint32_t, internal::MappedFontFile*> mapped_font_files_;
 
   DISALLOW_COPY_AND_ASSIGN(FontLoader);
 };
diff --git a/components/services/font/public/cpp/font_service_thread.cc b/components/services/font/public/cpp/font_service_thread.cc
index b4f3aa45c343..84446cdf0b20 100644
--- a/components/services/font/public/cpp/font_service_thread.cc
+++ b/components/services/font/public/cpp/font_service_thread.cc
@@ -9,21 +9,29 @@
 #include "base/bind.h"
 #include "base/files/file.h"
 #include "base/synchronization/waitable_event.h"
+#include "base/task/post_task.h"
+#include "base/task/thread_pool.h"
 #include "components/services/font/public/cpp/mapped_font_file.h"
 
 namespace font_service {
 namespace internal {
 
-namespace {
-const char kFontThreadName[] = "Font_Proxy_Thread";
-}  // namespace
+FontServiceThread::FontServiceThread()
+    : task_runner_(base::ThreadPool::CreateSequencedTaskRunner(
+          {base::TaskPriority::USER_VISIBLE, base::MayBlock()})) {}
 
-FontServiceThread::FontServiceThread(mojom::FontServicePtr font_service)
-    : base::Thread(kFontThreadName),
-      font_service_info_(font_service.PassInterface()),
-      weak_factory_(this) {
-  DETACH_FROM_THREAD(thread_checker_);
-  Start();
+FontServiceThread::~FontServiceThread() {
+  // Ensure the remote is unbound on the appropriate sequence.
+  task_runner_->PostTask(FROM_HERE,
+                         base::BindOnce([](mojo::Remote<mojom::FontService>) {},
+                                        std::move(font_service_)));
+}
+
+void FontServiceThread::Init(
+    mojo::PendingRemote<mojom::FontService> pending_font_service) {
+  task_runner_->PostTask(FROM_HERE,
+                         base::BindOnce(&FontServiceThread::InitImpl, this,
+                                        std::move(pending_font_service)));
 }
 
 bool FontServiceThread::MatchFamilyName(
@@ -32,13 +40,12 @@ bool FontServiceThread::MatchFamilyName(
     SkFontConfigInterface::FontIdentity* out_font_identity,
     SkString* out_family_name,
     SkFontStyle* out_style) {
-  DCHECK_NE(GetThreadId(), base::PlatformThread::CurrentId());
-
+  DCHECK(!task_runner_->RunsTasksInCurrentSequence());
   bool out_valid = false;
   // This proxies to the other thread, which proxies to mojo. Only on the reply
   // from mojo do we return from this.
   base::WaitableEvent done_event;
-  task_runner()->PostTask(
+  task_runner_->PostTask(
       FROM_HERE,
       base::BindOnce(&FontServiceThread::MatchFamilyNameImpl, this, &done_event,
                      family_name, requested_style, &out_valid,
@@ -55,10 +62,10 @@ bool FontServiceThread::FallbackFontForCharacter(
     std::string* out_family_name,
     bool* out_is_bold,
     bool* out_is_italic) {
-  DCHECK_NE(GetThreadId(), base::PlatformThread::CurrentId());
+  DCHECK(!task_runner_->RunsTasksInCurrentSequence());
   bool out_valid = false;
   base::WaitableEvent done_event;
-  task_runner()->PostTask(
+  task_runner_->PostTask(
       FROM_HERE,
       base::BindOnce(&FontServiceThread::FallbackFontForCharacterImpl, this,
                      &done_event, character, std::move(locale), &out_valid,
@@ -76,10 +83,10 @@ bool FontServiceThread::FontRenderStyleForStrike(
     bool is_bold,
     float device_scale_factor,
     font_service::mojom::FontRenderStylePtr* out_font_render_style) {
-  DCHECK_NE(GetThreadId(), base::PlatformThread::CurrentId());
+  DCHECK(!task_runner_->RunsTasksInCurrentSequence());
   bool out_valid = false;
   base::WaitableEvent done_event;
-  task_runner()->PostTask(
+  task_runner_->PostTask(
       FROM_HERE,
       base::BindOnce(&FontServiceThread::FontRenderStyleForStrikeImpl, this,
                      &done_event, family, size, is_italic, is_bold,
@@ -88,6 +95,22 @@ bool FontServiceThread::FontRenderStyleForStrike(
   return out_valid;
 }
 
+bool FontServiceThread::MatchFontByPostscriptNameOrFullFontName(
+    std::string postscript_name_or_full_font_name,
+    mojom::FontIdentityPtr* out_identity) {
+  DCHECK(!task_runner_->RunsTasksInCurrentSequence());
+  bool out_valid = false;
+  base::WaitableEvent done_event;
+  task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(
+          &FontServiceThread::MatchFontByPostscriptNameOrFullFontNameImpl, this,
+          &done_event, &out_valid, std::move(postscript_name_or_full_font_name),
+          out_identity));
+  done_event.Wait();
+  return out_valid;
+}
+
 void FontServiceThread::MatchFontWithFallback(
     std::string family,
     bool is_bold,
@@ -95,9 +118,9 @@ void FontServiceThread::MatchFontWithFallback(
     uint32_t charset,
     uint32_t fallback_family_type,
     base::File* out_font_file_handle) {
-  DCHECK_NE(GetThreadId(), base::PlatformThread::CurrentId());
+  DCHECK(!task_runner_->RunsTasksInCurrentSequence());
   base::WaitableEvent done_event;
-  task_runner()->PostTask(
+  task_runner_->PostTask(
       FROM_HERE,
       base::BindOnce(&FontServiceThread::MatchFontWithFallbackImpl, this,
                      &done_event, std::move(family), is_bold, is_italic,
@@ -107,13 +130,13 @@ void FontServiceThread::MatchFontWithFallback(
 
 scoped_refptr<MappedFontFile> FontServiceThread::OpenStream(
     const SkFontConfigInterface::FontIdentity& identity) {
-  DCHECK_NE(GetThreadId(), base::PlatformThread::CurrentId());
+  DCHECK(!task_runner_->RunsTasksInCurrentSequence());
 
   base::File stream_file;
   // This proxies to the other thread, which proxies to mojo. Only on the
   // reply from mojo do we return from this.
   base::WaitableEvent done_event;
-  task_runner()->PostTask(
+  task_runner_->PostTask(
       FROM_HERE, base::BindOnce(&FontServiceThread::OpenStreamImpl, this,
                                 &done_event, &stream_file, identity.fID));
   done_event.Wait();
@@ -132,11 +155,6 @@ scoped_refptr<MappedFontFile> FontServiceThread::OpenStream(
   return mapped_font_file;
 }
 
-FontServiceThread::~FontServiceThread() {
-  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
-  Stop();
-}
-
 void FontServiceThread::MatchFamilyNameImpl(
     base::WaitableEvent* done_event,
     const char family_name[],
@@ -145,9 +163,9 @@ void FontServiceThread::MatchFamilyNameImpl(
     SkFontConfigInterface::FontIdentity* out_font_identity,
     SkString* out_family_name,
     SkFontStyle* out_style) {
-  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  DCHECK(task_runner_->RunsTasksInCurrentSequence());
 
-  if (font_service_.encountered_error()) {
+  if (!font_service_.is_connected()) {
     *out_valid = false;
     done_event->Signal();
     return;
@@ -177,14 +195,15 @@ void FontServiceThread::OnMatchFamilyNameComplete(
     mojom::FontIdentityPtr font_identity,
     const std::string& family_name,
     mojom::TypefaceStylePtr style) {
-  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  DCHECK(task_runner_->RunsTasksInCurrentSequence());
+
   pending_waitable_events_.erase(done_event);
 
   *out_valid = !font_identity.is_null();
   if (font_identity) {
     out_font_identity->fID = font_identity->id;
     out_font_identity->fTTCIndex = font_identity->ttc_index;
-    out_font_identity->fString = font_identity->str_representation.data();
+    out_font_identity->fString = font_identity->filepath.value().data();
     // TODO(erg): fStyle isn't set. This is rather odd, however it matches the
     // behaviour of the current Linux IPC version.
 
@@ -199,8 +218,9 @@ void FontServiceThread::OnMatchFamilyNameComplete(
 void FontServiceThread::OpenStreamImpl(base::WaitableEvent* done_event,
                                        base::File* output_file,
                                        const uint32_t id_number) {
-  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
-  if (font_service_.encountered_error()) {
+  DCHECK(task_runner_->RunsTasksInCurrentSequence());
+
+  if (!font_service_.is_connected()) {
     done_event->Signal();
     return;
   }
@@ -214,7 +234,8 @@ void FontServiceThread::OpenStreamImpl(base::WaitableEvent* done_event,
 void FontServiceThread::OnOpenStreamComplete(base::WaitableEvent* done_event,
                                              base::File* output_file,
                                              base::File file) {
-  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  DCHECK(task_runner_->RunsTasksInCurrentSequence());
+
   pending_waitable_events_.erase(done_event);
   *output_file = std::move(file);
   done_event->Signal();
@@ -229,9 +250,9 @@ void FontServiceThread::FallbackFontForCharacterImpl(
     std::string* out_family_name,
     bool* out_is_bold,
     bool* out_is_italic) {
-  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  DCHECK(task_runner_->RunsTasksInCurrentSequence());
 
-  if (font_service_.encountered_error()) {
+  if (!font_service_.is_connected()) {
     *out_valid = false;
     done_event->Signal();
     return;
@@ -256,7 +277,8 @@ void FontServiceThread::OnFallbackFontForCharacterComplete(
     const std::string& family_name,
     bool is_bold,
     bool is_italic) {
-  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  DCHECK(task_runner_->RunsTasksInCurrentSequence());
+
   pending_waitable_events_.erase(done_event);
 
   *out_valid = !font_identity.is_null();
@@ -278,9 +300,9 @@ void FontServiceThread::FontRenderStyleForStrikeImpl(
     float device_scale_factor,
     bool* out_valid,
     mojom::FontRenderStylePtr* out_font_render_style) {
-  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  DCHECK(task_runner_->RunsTasksInCurrentSequence());
 
-  if (font_service_.encountered_error()) {
+  if (!font_service_.is_connected()) {
     *out_valid = false;
     done_event->Signal();
     return;
@@ -298,7 +320,8 @@ void FontServiceThread::OnFontRenderStyleForStrikeComplete(
     bool* out_valid,
     mojom::FontRenderStylePtr* out_font_render_style,
     mojom::FontRenderStylePtr font_render_style) {
-  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  DCHECK(task_runner_->RunsTasksInCurrentSequence());
+
   pending_waitable_events_.erase(done_event);
 
   *out_valid = !font_render_style.is_null();
@@ -308,6 +331,43 @@ void FontServiceThread::OnFontRenderStyleForStrikeComplete(
   done_event->Signal();
 }
 
+void FontServiceThread::MatchFontByPostscriptNameOrFullFontNameImpl(
+    base::WaitableEvent* done_event,
+    bool* out_valid,
+    std::string postscript_name_or_full_font_name,
+    mojom::FontIdentityPtr* out_font_identity) {
+  DCHECK(task_runner_->RunsTasksInCurrentSequence());
+
+  if (!font_service_.is_connected()) {
+    *out_valid = false;
+    done_event->Signal();
+    return;
+  }
+
+  pending_waitable_events_.insert(done_event);
+  font_service_->MatchFontByPostscriptNameOrFullFontName(
+      std::move(postscript_name_or_full_font_name),
+      base::BindOnce(
+          &FontServiceThread::OnMatchFontByPostscriptNameOrFullFontNameComplete,
+          this, done_event, out_valid, out_font_identity));
+}
+
+void FontServiceThread::OnMatchFontByPostscriptNameOrFullFontNameComplete(
+    base::WaitableEvent* done_event,
+    bool* out_valid,
+    mojom::FontIdentityPtr* out_font_identity,
+    mojom::FontIdentityPtr font_identity) {
+  DCHECK(task_runner_->RunsTasksInCurrentSequence());
+
+  pending_waitable_events_.erase(done_event);
+
+  *out_valid = !font_identity.is_null();
+  if (font_identity) {
+    *out_font_identity = std::move(font_identity);
+  }
+  done_event->Signal();
+}
+
 void FontServiceThread::MatchFontWithFallbackImpl(
     base::WaitableEvent* done_event,
     std::string family,
@@ -316,9 +376,10 @@ void FontServiceThread::MatchFontWithFallbackImpl(
     uint32_t charset,
     uint32_t fallback_family_type,
     base::File* out_font_file_handle) {
-  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  DCHECK(task_runner_->RunsTasksInCurrentSequence());
+
   *out_font_file_handle = base::File();
-  if (font_service_.encountered_error()) {
+  if (!font_service_.is_connected()) {
     done_event->Signal();
     return;
   }
@@ -333,29 +394,29 @@ void FontServiceThread::OnMatchFontWithFallbackComplete(
     base::WaitableEvent* done_event,
     base::File* out_font_file_handle,
     base::File file) {
-  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  DCHECK(task_runner_->RunsTasksInCurrentSequence());
+
   pending_waitable_events_.erase(done_event);
 
   *out_font_file_handle = std::move(file);
   done_event->Signal();
 }
 
-void FontServiceThread::OnFontServiceConnectionError() {
+void FontServiceThread::OnFontServiceDisconnected() {
   std::set<base::WaitableEvent*> events;
   events.swap(pending_waitable_events_);
   for (base::WaitableEvent* event : events)
     event->Signal();
 }
 
-void FontServiceThread::Init() {
-  font_service_.Bind(std::move(font_service_info_));
-  font_service_.set_connection_error_handler(
-      base::BindOnce(&FontServiceThread::OnFontServiceConnectionError,
-                     weak_factory_.GetWeakPtr()));
-}
+void FontServiceThread::InitImpl(
+    mojo::PendingRemote<mojom::FontService> pending_font_service) {
+  font_service_.Bind(std::move(pending_font_service));
 
-void FontServiceThread::CleanUp() {
-  font_service_.reset();
+  // NOTE: Unretained is safe here because the callback can never be invoked
+  // past |font_service_|'s lifetime.
+  font_service_.set_disconnect_handler(base::BindOnce(
+      &FontServiceThread::OnFontServiceDisconnected, base::Unretained(this)));
 }
 
 }  // namespace internal
diff --git a/components/services/font/public/cpp/font_service_thread.h b/components/services/font/public/cpp/font_service_thread.h
index 865c587b398b..5ba397270f15 100644
--- a/components/services/font/public/cpp/font_service_thread.h
+++ b/components/services/font/public/cpp/font_service_thread.h
@@ -11,10 +11,9 @@
 
 #include "base/files/file.h"
 #include "base/macros.h"
-#include "base/memory/weak_ptr.h"
-#include "base/threading/thread.h"
-#include "base/threading/thread_checker.h"
-#include "components/services/font/public/interfaces/font_service.mojom.h"
+#include "components/services/font/public/mojom/font_service.mojom.h"
+#include "mojo/public/cpp/bindings/pending_remote.h"
+#include "mojo/public/cpp/bindings/remote.h"
 #include "third_party/skia/include/core/SkStream.h"
 #include "third_party/skia/include/core/SkTypeface.h"
 #include "third_party/skia/include/ports/SkFontConfigInterface.h"
@@ -31,10 +30,14 @@ class MappedFontFile;
 // of this mismatch, we create a thread which owns the mojo pipe, sends and
 // receives messages. The multiple threads which call through FontLoader class
 // do blocking message calls to this thread.
-class FontServiceThread : public base::Thread,
-                          public base::RefCountedThreadSafe<FontServiceThread> {
+// TODO(936569): Rename FontServiceThread since it's no longer a thread.
+class FontServiceThread : public base::RefCountedThreadSafe<FontServiceThread> {
  public:
-  explicit FontServiceThread(mojom::FontServicePtr font_service);
+  FontServiceThread();
+
+  // Initializes the thread, binding to |pending_font_service| in the
+  // background sequence.
+  void Init(mojo::PendingRemote<mojom::FontService> pending_font_service);
 
   // These methods are proxies which run on your thread, post a blocking task
   // to the FontServiceThread, and wait on an event signaled from the callback.
@@ -60,6 +63,9 @@ class FontServiceThread : public base::Thread,
       bool is_bold,
       float device_scale_factor,
       font_service::mojom::FontRenderStylePtr* out_font_render_style);
+  bool MatchFontByPostscriptNameOrFullFontName(
+      std::string postscript_name_or_full_font_name,
+      mojom::FontIdentityPtr* out_identity);
   void MatchFontWithFallback(std::string family,
                              bool is_bold,
                              bool is_italic,
@@ -69,7 +75,9 @@ class FontServiceThread : public base::Thread,
 
  private:
   friend class base::RefCountedThreadSafe<FontServiceThread>;
-  ~FontServiceThread() override;
+  virtual ~FontServiceThread();
+
+  void InitImpl(mojo::PendingRemote<mojom::FontService> pending_font_service);
 
   // Methods which run on the FontServiceThread. The public MatchFamilyName
   // calls this method, this method calls the mojo interface, and sets up the
@@ -140,6 +148,17 @@ class FontServiceThread : public base::Thread,
       mojom::FontRenderStylePtr* out_font_render_style,
       mojom::FontRenderStylePtr font_render_style);
 
+  void MatchFontByPostscriptNameOrFullFontNameImpl(
+      base::WaitableEvent* done_event,
+      bool* out_valid,
+      std::string postscript_name_or_full_font_name,
+      mojom::FontIdentityPtr* out_font_identity);
+  void OnMatchFontByPostscriptNameOrFullFontNameComplete(
+      base::WaitableEvent* done_event,
+      bool* out_valid,
+      mojom::FontIdentityPtr* out_font_identity,
+      mojom::FontIdentityPtr font_identity);
+
   void MatchFontWithFallbackImpl(base::WaitableEvent* done_event,
                                  std::string family,
                                  bool is_bold,
@@ -153,19 +172,11 @@ class FontServiceThread : public base::Thread,
 
   // Connection to |font_service_| has gone away. Called on the background
   // thread.
-  void OnFontServiceConnectionError();
+  void OnFontServiceDisconnected();
 
-  // base::Thread
-  void Init() override;
-  void CleanUp() override;
-
-  // This member is used to safely pass data from one thread to another. It is
-  // set in the constructor and is consumed in Init().
-  mojo::InterfacePtrInfo<mojom::FontService> font_service_info_;
-
-  // This member is set in Init(). It takes |font_service_info_|, which is
-  // non-thread bound, and binds it to the newly created thread.
-  mojo::InterfacePtr<mojom::FontService> font_service_;
+  // This member is set in InitImpl(), binding to the provided PendingRemote on
+  // the background sequence.
+  mojo::Remote<mojom::FontService> font_service_;
 
   // All WaitableEvents supplied to OpenStreamImpl() and the other *Impl()
   // functions are added here while waiting on the response from the
@@ -176,9 +187,7 @@ class FontServiceThread : public base::Thread,
   // never received.
   std::set<base::WaitableEvent*> pending_waitable_events_;
 
-  THREAD_CHECKER(thread_checker_);
-
-  base::WeakPtrFactory<FontServiceThread> weak_factory_;
+  const scoped_refptr<base::SequencedTaskRunner> task_runner_;
 
   DISALLOW_COPY_AND_ASSIGN(FontServiceThread);
 };
diff --git a/components/services/font/public/interfaces/constants.mojom b/components/services/font/public/interfaces/constants.mojom
deleted file mode 100644
index 087574750fb7..000000000000
--- a/components/services/font/public/interfaces/constants.mojom
+++ /dev/null
@@ -1,7 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-module font_service.mojom;
-
-const string kServiceName = "font_service";
diff --git a/components/services/font/public/interfaces/BUILD.gn b/components/services/font/public/mojom/BUILD.gn
similarity index 60%
rename from components/services/font/public/interfaces/BUILD.gn
rename to components/services/font/public/mojom/BUILD.gn
index e6285c9146c2..d6c3ea1b1cf7 100644
--- a/components/services/font/public/interfaces/BUILD.gn
+++ b/components/services/font/public/mojom/BUILD.gn
@@ -4,13 +4,8 @@
 
 import("//mojo/public/tools/bindings/mojom.gni")
 
-mojom("interfaces") {
-  sources = [
-    "constants.mojom",
-    "font_service.mojom",
-  ]
+mojom("mojom") {
+  sources = [ "font_service.mojom" ]
 
-  public_deps = [
-    "//mojo/public/mojom/base",
-  ]
+  public_deps = [ "//mojo/public/mojom/base" ]
 }
diff --git a/components/services/font/public/interfaces/OWNERS b/components/services/font/public/mojom/OWNERS
similarity index 100%
rename from components/services/font/public/interfaces/OWNERS
rename to components/services/font/public/mojom/OWNERS
diff --git a/components/services/font/public/interfaces/font_service.mojom b/components/services/font/public/mojom/font_service.mojom
similarity index 75%
rename from components/services/font/public/interfaces/font_service.mojom
rename to components/services/font/public/mojom/font_service.mojom
index 346499fe414a..42c9666b4071 100644
--- a/components/services/font/public/interfaces/font_service.mojom
+++ b/components/services/font/public/mojom/font_service.mojom
@@ -4,7 +4,8 @@
 
 module font_service.mojom;
 
-import "mojo/public/mojom/base/file.mojom";
+import "mojo/public/mojom/base/file_path.mojom";
+import "mojo/public/mojom/base/read_only_file.mojom";
 
 enum TypefaceSlant {
   ROMAN = 0,
@@ -22,12 +23,11 @@ struct TypefaceStyle {
 struct FontIdentity {
   uint32 id;
   int32 ttc_index;
-  // TODO(erg): So the string is supposed to be a path. However, the current
-  // chrome code goes out of its way to send this to the renderer process, and
-  // it is passed to blink, even though the openStream() IPC in chrome uses the
-  // id number instead. Do more investigation about what we need to do to plug
-  // this system path leak.
-  string str_representation;
+  // TODO(erg): The current chrome code goes out of its way to send this to the
+  // renderer process, and it is passed to blink, even though the openStream()
+  // IPC in chrome uses the id number instead. Do more investigation about what
+  // we need to do to plug this system path leak.
+  mojo_base.mojom.FilePath filepath;
 };
 
 enum RenderStyleSwitch {
@@ -63,7 +63,7 @@ interface FontService {
       (FontIdentity? identity, string family_name, TypefaceStyle style);
 
   // Returns a handle to the raw font specified by |id_number|.
-  OpenStream(uint32 id_number) => (mojo_base.mojom.File? font_handle);
+  OpenStream(uint32 id_number) => (mojo_base.mojom.ReadOnlyFile? font_handle);
 
   // Returns a fallback FontIdentity and Typeface style for the given character
   // and locale. If no fallback font can be found, returns a null identity.
@@ -83,8 +83,15 @@ interface FontService {
     float device_scale_factor) =>
     (FontRenderStyle? font_render_style);
 
+  // Matches a font uniquely by postscript name or full font name.
+  // Used in Blink for @font-face { src: local(arg) } matching.
+  // Provide full_postscript_name_or_full_font_name encoded as UTF-8.
+  MatchFontByPostscriptNameOrFullFontName(
+      string postscript_name_or_full_font_name) =>
+    (FontIdentity? identity);
+
   // PPAPI Specific font call to match a font family and charset.
   MatchFontWithFallback(string family, bool is_bold, bool is_italic,
       uint32 charset, uint32 fallback_family_type) =>
-      (mojo_base.mojom.File? font_file_handle);
+      (mojo_base.mojom.ReadOnlyFile? font_file_handle);
 };
diff --git a/components/services/font/test_manifest.json b/components/services/font/test_manifest.json
deleted file mode 100644
index a9689872f508..000000000000
--- a/components/services/font/test_manifest.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-  "name": "font_service_unittests",
-  "display_name": "Font Service Unittests",
-  "interface_provider_specs": {
-    "service_manager:connector": {
-      "requires": {
-        "font_service": [ "font_service" ]
-      }
-    }
-  }
-}
diff --git a/content/common/font_list_fontconfig.cc b/content/common/font_list_fontconfig.cc
index a14eae72b773..ed8d8584a15b 100644
--- a/content/common/font_list_fontconfig.cc
+++ b/content/common/font_list_fontconfig.cc
@@ -11,6 +11,7 @@
 
 #include <fontconfig/fontconfig.h>
 
+#include "base/stl_util.h"
 #include "base/values.h"
 
 namespace content {
@@ -38,7 +39,7 @@ std::unique_ptr<base::ListValue> GetFontList_SlowBlocking() {
   // See https://www.freetype.org/freetype2/docs/reference/ft2-font_formats.html
   // for the list of possible formats.
   const char* allowed_formats[] = { "TrueType", "CFF" };
-  for (size_t i = 0; i < arraysize(allowed_formats); ++i) {
+  for (size_t i = 0; i < base::size(allowed_formats); ++i) {
     auto format_pattern = CreateFormatPattern(allowed_formats[i]);
     std::unique_ptr<FcFontSet, decltype(&FcFontSetDestroy)> fontset(
         FcFontList(nullptr, format_pattern.get(), object_set.get()),
diff --git a/content/shell/app/blink_test_platform_support_linux.cc b/content/shell/app/blink_test_platform_support_linux.cc
deleted file mode 100644
index 55576c2d0b84..000000000000
--- a/content/shell/app/blink_test_platform_support_linux.cc
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "content/shell/app/blink_test_platform_support.h"
-
-#include "base/test/fontconfig_util_linux.h"
-
-namespace content {
-
-bool CheckLayoutSystemDeps() {
-  return true;
-}
-
-bool BlinkTestPlatformInitialize() {
-  base::SetUpFontconfig();
-  return true;
-}
-
-}  // namespace content
diff --git a/content/shell/test_runner/resources/fonts/ChromiumAATTest.ttf b/content/shell/test_runner/resources/fonts/ChromiumAATTest.ttf
deleted file mode 100644
index 343d53aaeae6..000000000000
Binary files a/content/shell/test_runner/resources/fonts/ChromiumAATTest.ttf and /dev/null differ
diff --git a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher100.ttf b/content/shell/test_runner/resources/fonts/WebKitWeightWatcher100.ttf
deleted file mode 100644
index d79fa9a3af1b..000000000000
Binary files a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher100.ttf and /dev/null differ
diff --git a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher200.ttf b/content/shell/test_runner/resources/fonts/WebKitWeightWatcher200.ttf
deleted file mode 100644
index 411b803b5f89..000000000000
Binary files a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher200.ttf and /dev/null differ
diff --git a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher300.ttf b/content/shell/test_runner/resources/fonts/WebKitWeightWatcher300.ttf
deleted file mode 100644
index ec6fda873e22..000000000000
Binary files a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher300.ttf and /dev/null differ
diff --git a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher400.ttf b/content/shell/test_runner/resources/fonts/WebKitWeightWatcher400.ttf
deleted file mode 100644
index d0fd278dce05..000000000000
Binary files a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher400.ttf and /dev/null differ
diff --git a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher500.ttf b/content/shell/test_runner/resources/fonts/WebKitWeightWatcher500.ttf
deleted file mode 100644
index e155619452f0..000000000000
Binary files a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher500.ttf and /dev/null differ
diff --git a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher600.ttf b/content/shell/test_runner/resources/fonts/WebKitWeightWatcher600.ttf
deleted file mode 100644
index 348e0e0f3cd5..000000000000
Binary files a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher600.ttf and /dev/null differ
diff --git a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher700.ttf b/content/shell/test_runner/resources/fonts/WebKitWeightWatcher700.ttf
deleted file mode 100644
index bba57447f0fd..000000000000
Binary files a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher700.ttf and /dev/null differ
diff --git a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher800.ttf b/content/shell/test_runner/resources/fonts/WebKitWeightWatcher800.ttf
deleted file mode 100644
index e55ad75a82a9..000000000000
Binary files a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher800.ttf and /dev/null differ
diff --git a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher900.ttf b/content/shell/test_runner/resources/fonts/WebKitWeightWatcher900.ttf
deleted file mode 100644
index 7213c50d6bf2..000000000000
Binary files a/content/shell/test_runner/resources/fonts/WebKitWeightWatcher900.ttf and /dev/null differ
diff --git a/content/shell/test_runner/resources/fonts/android_fallback_fonts.xml b/content/shell/test_runner/resources/fonts/android_fallback_fonts.xml
deleted file mode 100644
index deb434c75d5c..000000000000
--- a/content/shell/test_runner/resources/fonts/android_fallback_fonts.xml
+++ /dev/null
@@ -1,43 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<familyset>
-    <family>
-        <fileset>
-            <file>DejaVuSans.ttf</file>
-        </fileset>
-    </family>
-    <family>
-        <fileset>
-            <file>Garuda.ttf</file>
-        </fileset>
-    </family>
-    <family>
-        <fileset>
-            <file>Lohit-Devanagari.ttf</file>
-        </fileset>
-    </family>
-    <family>
-        <fileset>
-            <file>Lohit-Gurmukhi.ttf</file>
-        </fileset>
-    </family>
-    <family>
-        <fileset>
-            <file>Lohit-Tamil.ttf</file>
-        </fileset>
-    </family>
-    <family>
-        <fileset>
-            <file>MuktiNarrow.ttf</file>
-        </fileset>
-    </family>
-    <family>
-        <fileset>
-            <file>NotoSansCJKjp-Regular.otf</file>
-        </fileset>
-    </family>
-    <family>
-        <fileset>
-            <file>NotoSansKhmer-Regular.ttf</file>
-        </fileset>
-    </family>
-</familyset>
diff --git a/content/shell/test_runner/resources/fonts/android_main_fonts.xml b/content/shell/test_runner/resources/fonts/android_main_fonts.xml
deleted file mode 100644
index 7270306f51f3..000000000000
--- a/content/shell/test_runner/resources/fonts/android_main_fonts.xml
+++ /dev/null
@@ -1,82 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<familyset>
-
-    <family>
-        <nameset>
-            <name>sans</name>
-            <name>sans serif</name>
-            <name>sans-serif</name>
-            <name>Arimo</name>
-            <name>Arial</name>
-            <name>Helvetica</name>
-        </nameset>
-        <fileset>
-            <file>Arimo-Regular.ttf</file>
-            <file>Arimo-Bold.ttf</file>
-            <file>Arimo-Italic.ttf</file>
-            <file>Arimo-BoldItalic.ttf</file>
-        </fileset>
-    </family>
-
-    <family>
-        <nameset>
-            <name>serif</name>
-            <name>Tinos</name>
-            <name>Times</name>
-            <name>Times New Roman</name>
-            <name>Monaco</name>
-            <!-- Match Linux. See comments of SubpixelPositioning in
-                 base/test/fontconfig_util_linux.cc -->
-            <name>SubpixelPositioning</name>
-        </nameset>
-        <fileset>
-            <file>Tinos-Regular.ttf</file>
-            <file>Tinos-Bold.ttf</file>
-            <file>Tinos-Italic.ttf</file>
-            <file>Tinos-BoldItalic.ttf</file>
-        </fileset>
-    </family>
-
-    <family>
-        <nameset>
-            <name>mono</name>
-            <name>monospace</name>
-            <name>Cousine</name>
-            <name>Courier</name>
-            <name>Courier New</name>
-        </nameset>
-        <fileset>
-            <file>Cousine-Regular.ttf</file>
-            <file>Cousine-Bold.ttf</file>
-            <file>Cousine-Italic.ttf</file>
-            <file>Cousine-BoldItalic.ttf</file>
-        </fileset>
-    </family>
-
-    <family>
-        <nameset>
-            <name>Gelasio</name>
-            <name>Georgia</name>
-        </nameset>
-        <fileset>
-            <file>Gelasio-Regular.ttf</file>
-            <file>Gelasio-Bold.ttf</file>
-            <file>Gelasio-Italic.ttf</file>
-            <file>Gelasio-BoldItalic.ttf</file>
-        </fileset>
-    </family>
-
-
-    <family>
-        <nameset>
-            <name>Ahem</name>
-            <!-- Match Linux. See comments of SubpixelPositioning in
-                 base/test/fontconfig_util_linux.cc -->
-            <name>SubpixelPositioningAhem</name>
-        </nameset>
-        <fileset>
-            <file>Ahem.ttf</file>
-        </fileset>
-    </family>
-
-</familyset>
diff --git a/headless/public/util/fontconfig.cc b/headless/public/util/fontconfig.cc
index 2f3cd0b8d7e2..ef0f2bae2d3f 100644
--- a/headless/public/util/fontconfig.cc
+++ b/headless/public/util/fontconfig.cc
@@ -13,6 +13,8 @@
 #include <set>
 #include <string>
 
+#include "base/check.h"
+#include "base/check_op.h"
 #include "base/logging.h"
 
 namespace headless {
diff --git a/pdf/pdfium/DEPS b/pdf/pdfium/DEPS
index f157a81c75d2..446fbe1bfa7d 100644
--- a/pdf/pdfium/DEPS
+++ b/pdf/pdfium/DEPS
@@ -1,8 +1,10 @@
 include_rules = [
   "+gin/array_buffer.h",
-  "+gin/public",
   "+gin/v8_initializer.h",
   "+printing/nup_parameters.h",
+  "+printing/page_setup.h",
+  "+printing/pdf_render_settings.h",
   "+third_party/pdfium/public",
   "+ui/gfx/codec/jpeg_codec.h",
+  "+v8/include/cppgc/platform.h",
 ]
diff --git a/pdf/pdfium/accessibility_unittest.cc b/pdf/pdfium/accessibility_unittest.cc
new file mode 100644
index 000000000000..9de49c7301cf
--- /dev/null
+++ b/pdf/pdfium/accessibility_unittest.cc
@@ -0,0 +1,684 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "pdf/accessibility.h"
+
+#include <string>
+
+#include "pdf/accessibility_structs.h"
+#include "pdf/pdfium/pdfium_engine.h"
+#include "pdf/pdfium/pdfium_test_base.h"
+#include "pdf/test/test_client.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/rect_f.h"
+#include "ui/gfx/geometry/vector2d.h"
+
+namespace chrome_pdf {
+
+using AccessibilityTest = PDFiumTestBase;
+
+float GetExpectedBoundsWidth(bool using_test_fonts, size_t i, float expected) {
+  return (using_test_fonts && i == 0) ? 85.333336f : expected;
+}
+
+double GetExpectedCharWidth(bool using_test_fonts, size_t i, double expected) {
+  if (using_test_fonts) {
+    if (i == 25)
+      return 13.333343;
+    if (i == 26)
+      return 6.666656;
+  }
+  return expected;
+}
+
+// NOTE: This test is sensitive to font metrics from the underlying platform.
+// If changes to fonts on the system or to font code like FreeType cause this
+// test to fail, please feel free to rebase the test expectations here, or
+// update the GetExpected... functions above. If that becomes too much of a
+// burden, consider changing the checks to just make sure the font metrics look
+// sane.
+TEST_F(AccessibilityTest, GetAccessibilityPage) {
+  static constexpr size_t kExpectedTextRunCount = 2;
+  struct {
+    uint32_t len;
+    double font_size;
+    float bounds_x;
+    float bounds_y;
+    float bounds_w;
+    float bounds_h;
+  } static constexpr kExpectedTextRuns[] = {
+      {15, 12, 26.666666f, 189.333328f, 84.000008f, 13.333344f},
+      {15, 16, 28.000000f, 117.333334f, 152.000000f, 19.999992f},
+  };
+  static_assert(base::size(kExpectedTextRuns) == kExpectedTextRunCount,
+                "Bad test expectation count");
+
+  static constexpr size_t kExpectedCharCount = 30;
+  static constexpr AccessibilityCharInfo kExpectedChars[] = {
+      {'H', 12}, {'e', 6.6666}, {'l', 5.3333}, {'l', 4},      {'o', 8},
+      {',', 4},  {' ', 4},      {'w', 12},     {'o', 6.6666}, {'r', 6.6666},
+      {'l', 4},  {'d', 9.3333}, {'!', 4},      {'\r', 0},     {'\n', 0},
+      {'G', 16}, {'o', 12},     {'o', 12},     {'d', 12},     {'b', 10.6666},
+      {'y', 12}, {'e', 12},     {',', 4},      {' ', 6.6666}, {'w', 16},
+      {'o', 12}, {'r', 8},      {'l', 4},      {'d', 12},     {'!', 2.6666},
+  };
+  static_assert(base::size(kExpectedChars) == kExpectedCharCount,
+                "Bad test expectation count");
+
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("hello_world2.pdf"));
+  ASSERT_TRUE(engine);
+
+  ASSERT_EQ(2, engine->GetNumberOfPages());
+  AccessibilityPageInfo page_info;
+  std::vector<AccessibilityTextRunInfo> text_runs;
+  std::vector<AccessibilityCharInfo> chars;
+  AccessibilityPageObjects page_objects;
+  ASSERT_TRUE(GetAccessibilityInfo(engine.get(), 0, page_info, text_runs, chars,
+                                   page_objects));
+  EXPECT_EQ(0u, page_info.page_index);
+  EXPECT_EQ(gfx::Rect(5, 3, 266, 266), page_info.bounds);
+  EXPECT_EQ(text_runs.size(), page_info.text_run_count);
+  EXPECT_EQ(chars.size(), page_info.char_count);
+
+  bool using_test_fonts = UsingTestFonts();
+
+  ASSERT_EQ(kExpectedTextRunCount, text_runs.size());
+  for (size_t i = 0; i < kExpectedTextRunCount; ++i) {
+    const auto& expected = kExpectedTextRuns[i];
+    EXPECT_EQ(expected.len, text_runs[i].len) << i;
+    EXPECT_FLOAT_EQ(expected.font_size, text_runs[i].style.font_size) << i;
+    EXPECT_FLOAT_EQ(expected.bounds_x, text_runs[i].bounds.x()) << i;
+    EXPECT_FLOAT_EQ(expected.bounds_y, text_runs[i].bounds.y()) << i;
+    float expected_bounds_w =
+        GetExpectedBoundsWidth(using_test_fonts, i, expected.bounds_w);
+    EXPECT_FLOAT_EQ(expected_bounds_w, text_runs[i].bounds.width()) << i;
+    EXPECT_FLOAT_EQ(expected.bounds_h, text_runs[i].bounds.height()) << i;
+    EXPECT_EQ(AccessibilityTextDirection::kLeftToRight, text_runs[i].direction);
+  }
+
+  ASSERT_EQ(kExpectedCharCount, chars.size());
+  for (size_t i = 0; i < kExpectedCharCount; ++i) {
+    const auto& expected = kExpectedChars[i];
+    EXPECT_EQ(expected.unicode_character, chars[i].unicode_character) << i;
+    double expected_char_width =
+        GetExpectedCharWidth(using_test_fonts, i, expected.char_width);
+    EXPECT_NEAR(expected_char_width, chars[i].char_width, 0.001) << i;
+  }
+}
+
+TEST_F(AccessibilityTest, GetAccessibilityImageInfo) {
+  static const AccessibilityImageInfo kExpectedImageInfo[] = {
+      {"Image 1", 0, {380, 78, 67, 68}},
+      {"Image 2", 0, {380, 385, 27, 28}},
+      {"Image 3", 0, {380, 678, 1, 1}}};
+
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("image_alt_text.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  AccessibilityPageInfo page_info;
+  std::vector<AccessibilityTextRunInfo> text_runs;
+  std::vector<AccessibilityCharInfo> chars;
+  AccessibilityPageObjects page_objects;
+  ASSERT_TRUE(GetAccessibilityInfo(engine.get(), 0, page_info, text_runs, chars,
+                                   page_objects));
+  EXPECT_EQ(0u, page_info.page_index);
+  EXPECT_EQ(gfx::Rect(5, 3, 816, 1056), page_info.bounds);
+  EXPECT_EQ(text_runs.size(), page_info.text_run_count);
+  EXPECT_EQ(chars.size(), page_info.char_count);
+  ASSERT_EQ(page_objects.images.size(), base::size(kExpectedImageInfo));
+
+  for (size_t i = 0; i < page_objects.images.size(); ++i) {
+    EXPECT_EQ(page_objects.images[i].alt_text, kExpectedImageInfo[i].alt_text);
+    EXPECT_EQ(kExpectedImageInfo[i].bounds, page_objects.images[i].bounds);
+    EXPECT_EQ(page_objects.images[i].text_run_index,
+              kExpectedImageInfo[i].text_run_index);
+  }
+}
+
+TEST_F(AccessibilityTest, GetUnderlyingTextRangeForRect) {
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("hello_world2.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(2, engine->GetNumberOfPages());
+
+  PDFiumPage& page = GetPDFiumPageForTest(*engine, 0);
+
+  // The test rect spans across [0, 4] char indices.
+  int start_index = -1;
+  int char_count = 0;
+  EXPECT_TRUE(page.GetUnderlyingTextRangeForRect(
+      gfx::RectF(20.0f, 50.0f, 26.0f, 8.0f), &start_index, &char_count));
+  EXPECT_EQ(start_index, 0);
+  EXPECT_EQ(char_count, 5);
+
+  // The input rectangle is spanning across multiple lines.
+  // GetUnderlyingTextRangeForRect() should return only the char indices
+  // of first line.
+  start_index = -1;
+  char_count = 0;
+  EXPECT_TRUE(page.GetUnderlyingTextRangeForRect(
+      gfx::RectF(20.0f, 0.0f, 26.0f, 58.0f), &start_index, &char_count));
+  EXPECT_EQ(start_index, 0);
+  EXPECT_EQ(char_count, 5);
+
+  // There is no text below this rectangle. So, GetUnderlyingTextRangeForRect()
+  // will return false and not change the dummy values set here.
+  start_index = -9;
+  char_count = -10;
+  EXPECT_FALSE(page.GetUnderlyingTextRangeForRect(
+      gfx::RectF(10.0f, 10.0f, 0.0f, 0.0f), &start_index, &char_count));
+  EXPECT_EQ(start_index, -9);
+  EXPECT_EQ(char_count, -10);
+}
+
+// This class overrides TestClient to record points received when a scroll
+// call is made by tests.
+class ScrollEnabledTestClient : public TestClient {
+ public:
+  ScrollEnabledTestClient() = default;
+  ~ScrollEnabledTestClient() override = default;
+
+  // Records the scroll delta received in a ScrollBy action request from tests.
+  void ScrollBy(const gfx::Vector2d& scroll_delta) override {
+    received_scroll_delta_ = scroll_delta;
+  }
+
+  // Returns the scroll delta received in a ScrollBy action for validation in
+  // tests.
+  const gfx::Vector2d& GetScrollRequestDelta() const {
+    return received_scroll_delta_;
+  }
+
+ private:
+  gfx::Vector2d received_scroll_delta_;
+};
+
+TEST_F(AccessibilityTest, TestScrollIntoViewActionHandling) {
+  // This test checks that accessibility scroll action is passed
+  // on to the ScrollEnabledTestClient implementation.
+  ScrollEnabledTestClient client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("rectangles_multi_pages.pdf"));
+  ASSERT_TRUE(engine);
+  engine->PluginSizeUpdated({400, 400});
+  AccessibilityActionData action_data;
+  action_data.action = AccessibilityAction::kScrollToMakeVisible;
+  action_data.target_rect = {{120, 0}, {10, 10}};
+
+  // Horizontal and Vertical scroll alignment of none should not scroll.
+  action_data.horizontal_scroll_alignment = AccessibilityScrollAlignment::kNone;
+  action_data.vertical_scroll_alignment = AccessibilityScrollAlignment::kNone;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(0, 0), client.GetScrollRequestDelta());
+
+  action_data.horizontal_scroll_alignment = AccessibilityScrollAlignment::kLeft;
+  action_data.vertical_scroll_alignment = AccessibilityScrollAlignment::kTop;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(120, 0), client.GetScrollRequestDelta());
+
+  action_data.horizontal_scroll_alignment = AccessibilityScrollAlignment::kLeft;
+  action_data.vertical_scroll_alignment = AccessibilityScrollAlignment::kBottom;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(120, -400), client.GetScrollRequestDelta());
+
+  action_data.horizontal_scroll_alignment =
+      AccessibilityScrollAlignment::kRight;
+  action_data.vertical_scroll_alignment = AccessibilityScrollAlignment::kTop;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(-280, 0), client.GetScrollRequestDelta());
+
+  action_data.horizontal_scroll_alignment =
+      AccessibilityScrollAlignment::kRight;
+  action_data.vertical_scroll_alignment = AccessibilityScrollAlignment::kBottom;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(-280, -400), client.GetScrollRequestDelta());
+
+  action_data.horizontal_scroll_alignment =
+      AccessibilityScrollAlignment::kCenter;
+  action_data.vertical_scroll_alignment = AccessibilityScrollAlignment::kCenter;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(-80, -200), client.GetScrollRequestDelta());
+
+  // Simulate a 150% zoom update in the PDFiumEngine.
+  engine->PluginSizeUpdated({600, 600});
+
+  action_data.horizontal_scroll_alignment = AccessibilityScrollAlignment::kNone;
+  action_data.vertical_scroll_alignment = AccessibilityScrollAlignment::kNone;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(0, 0), client.GetScrollRequestDelta());
+
+  action_data.horizontal_scroll_alignment = AccessibilityScrollAlignment::kLeft;
+  action_data.vertical_scroll_alignment = AccessibilityScrollAlignment::kTop;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(120, 0), client.GetScrollRequestDelta());
+
+  action_data.horizontal_scroll_alignment = AccessibilityScrollAlignment::kLeft;
+  action_data.vertical_scroll_alignment = AccessibilityScrollAlignment::kBottom;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(120, -600), client.GetScrollRequestDelta());
+
+  action_data.horizontal_scroll_alignment =
+      AccessibilityScrollAlignment::kRight;
+  action_data.vertical_scroll_alignment = AccessibilityScrollAlignment::kTop;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(-480, 0), client.GetScrollRequestDelta());
+
+  action_data.horizontal_scroll_alignment =
+      AccessibilityScrollAlignment::kRight;
+  action_data.vertical_scroll_alignment = AccessibilityScrollAlignment::kBottom;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(-480, -600), client.GetScrollRequestDelta());
+
+  action_data.horizontal_scroll_alignment =
+      AccessibilityScrollAlignment::kCenter;
+  action_data.vertical_scroll_alignment = AccessibilityScrollAlignment::kCenter;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(-180, -300), client.GetScrollRequestDelta());
+}
+
+TEST_F(AccessibilityTest, TestScrollToNearestEdge) {
+  ScrollEnabledTestClient client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("rectangles_multi_pages.pdf"));
+  ASSERT_TRUE(engine);
+  engine->PluginSizeUpdated({400, 400});
+  AccessibilityActionData action_data;
+  action_data.action = AccessibilityAction::kScrollToMakeVisible;
+
+  action_data.horizontal_scroll_alignment =
+      AccessibilityScrollAlignment::kClosestToEdge;
+  action_data.vertical_scroll_alignment =
+      AccessibilityScrollAlignment::kClosestToEdge;
+  // Point which is in the middle of the viewport.
+  action_data.target_rect = {{200, 200}, {10, 10}};
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(200, 200), client.GetScrollRequestDelta());
+
+  // Point which is near the top left of the viewport.
+  action_data.target_rect = {{199, 199}, {10, 10}};
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(199, 199), client.GetScrollRequestDelta());
+
+  // Point which is near the top right of the viewport
+  action_data.target_rect = {{201, 199}, {10, 10}};
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(-199, 199), client.GetScrollRequestDelta());
+
+  // Point which is near the bottom left of the viewport.
+  action_data.target_rect = {{199, 201}, {10, 10}};
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(199, -199), client.GetScrollRequestDelta());
+
+  // Point which is near the bottom right of the viewport
+  action_data.target_rect = {{201, 201}, {10, 10}};
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(-199, -199), client.GetScrollRequestDelta());
+}
+
+TEST_F(AccessibilityTest, TestScrollToGlobalPoint) {
+  ScrollEnabledTestClient client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("rectangles_multi_pages.pdf"));
+  ASSERT_TRUE(engine);
+  engine->PluginSizeUpdated({400, 400});
+  AccessibilityActionData action_data;
+  action_data.action = AccessibilityAction::kScrollToGlobalPoint;
+
+  // Scroll up if global point is below the target rect
+  action_data.target_rect = {{201, 201}, {10, 10}};
+  action_data.target_point = gfx::Point(230, 230);
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(-29, -29), client.GetScrollRequestDelta());
+
+  // Scroll down if global point is above the target rect
+  action_data.target_rect = {{230, 230}, {10, 10}};
+  action_data.target_point = gfx::Point(201, 201);
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(gfx::Vector2d(29, 29), client.GetScrollRequestDelta());
+}
+
+// This class is required to just override the NavigateTo
+// functionality for testing in a specific way. It will
+// keep the TestClient class clean for extension by others.
+class NavigationEnabledTestClient : public TestClient {
+ public:
+  NavigationEnabledTestClient() = default;
+  ~NavigationEnabledTestClient() override = default;
+
+  void NavigateTo(const std::string& url,
+                  WindowOpenDisposition disposition) override {
+    url_ = url;
+    disposition_ = disposition;
+  }
+
+  void NavigateToDestination(int page,
+                             const float* x_in_pixels,
+                             const float* y_in_pixels,
+                             const float* zoom) override {
+    page_ = page;
+    if (x_in_pixels)
+      x_in_pixels_ = *x_in_pixels;
+    if (y_in_pixels)
+      y_in_pixels_ = *y_in_pixels;
+    if (zoom)
+      zoom_ = *zoom;
+  }
+
+  const std::string& url() const { return url_; }
+  WindowOpenDisposition disposition() const { return disposition_; }
+  int page() const { return page_; }
+  int x_in_pixels() const { return x_in_pixels_; }
+  int y_in_pixels() const { return y_in_pixels_; }
+  float zoom() const { return zoom_; }
+
+ private:
+  std::string url_;
+  WindowOpenDisposition disposition_ = WindowOpenDisposition::UNKNOWN;
+  int page_ = -1;
+  float x_in_pixels_ = 0;
+  float y_in_pixels_ = 0;
+  float zoom_ = 0;
+};
+
+TEST_F(AccessibilityTest, TestWebLinkClickActionHandling) {
+  NavigationEnabledTestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("weblinks.pdf"));
+  ASSERT_TRUE(engine);
+
+  AccessibilityActionData action_data;
+  action_data.action = AccessibilityAction::kDoDefaultAction;
+  action_data.page_index = 0;
+  action_data.annotation_type = AccessibilityAnnotationType::kLink;
+  action_data.annotation_index = 0;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ("http://yahoo.com", client.url());
+  EXPECT_EQ(WindowOpenDisposition::CURRENT_TAB, client.disposition());
+}
+
+TEST_F(AccessibilityTest, TestInternalLinkClickActionHandling) {
+  NavigationEnabledTestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("link_annots.pdf"));
+  ASSERT_TRUE(engine);
+
+  AccessibilityActionData action_data;
+  action_data.action = AccessibilityAction::kDoDefaultAction;
+  action_data.page_index = 0;
+  action_data.annotation_type = AccessibilityAnnotationType::kLink;
+  action_data.annotation_index = 1;
+  engine->HandleAccessibilityAction(action_data);
+  EXPECT_EQ(1, client.page());
+  EXPECT_EQ(266, client.x_in_pixels());
+  EXPECT_EQ(89, client.y_in_pixels());
+  EXPECT_FLOAT_EQ(1.75, client.zoom());
+  EXPECT_TRUE(client.url().empty());
+}
+
+TEST_F(AccessibilityTest, GetAccessibilityLinkInfo) {
+  AccessibilityLinkInfo expected_link_info[] = {
+      {"http://yahoo.com", 0, {75, 191, 110, 16}, {1, 1}},
+      {"http://bing.com", 1, {131, 121, 138, 20}, {4, 1}},
+      {"http://google.com", 2, {82, 67, 161, 21}, {7, 1}}};
+
+  if (UsingTestFonts()) {
+    expected_link_info[0].bounds = {75, 192, 110, 15};
+    expected_link_info[1].bounds = {131, 120, 138, 22};
+  }
+
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("weblinks.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  AccessibilityPageInfo page_info;
+  std::vector<AccessibilityTextRunInfo> text_runs;
+  std::vector<AccessibilityCharInfo> chars;
+  AccessibilityPageObjects page_objects;
+  ASSERT_TRUE(GetAccessibilityInfo(engine.get(), 0, page_info, text_runs, chars,
+                                   page_objects));
+  EXPECT_EQ(0u, page_info.page_index);
+  EXPECT_EQ(gfx::Rect(5, 3, 533, 266), page_info.bounds);
+  EXPECT_EQ(text_runs.size(), page_info.text_run_count);
+  EXPECT_EQ(chars.size(), page_info.char_count);
+  ASSERT_EQ(page_objects.links.size(), base::size(expected_link_info));
+
+  for (size_t i = 0; i < page_objects.links.size(); ++i) {
+    const AccessibilityLinkInfo& link_info = page_objects.links[i];
+    EXPECT_EQ(link_info.url, expected_link_info[i].url);
+    EXPECT_EQ(link_info.index_in_page, expected_link_info[i].index_in_page);
+    EXPECT_EQ(expected_link_info[i].bounds, link_info.bounds);
+    EXPECT_EQ(link_info.text_range.index,
+              expected_link_info[i].text_range.index);
+    EXPECT_EQ(link_info.text_range.count,
+              expected_link_info[i].text_range.count);
+  }
+}
+
+TEST_F(AccessibilityTest, GetAccessibilityHighlightInfo) {
+  constexpr uint32_t kHighlightDefaultColor = MakeARGB(255, 255, 255, 0);
+  constexpr uint32_t kHighlightRedColor = MakeARGB(102, 230, 0, 0);
+  constexpr uint32_t kHighlightNoColor = MakeARGB(0, 0, 0, 0);
+  static const AccessibilityHighlightInfo kExpectedHighlightInfo[] = {
+      {"Text Note", 0, kHighlightDefaultColor, {5, 196, 49, 26}, {0, 1}},
+      {"", 1, kHighlightRedColor, {110, 196, 77, 26}, {2, 1}},
+      {"", 2, kHighlightNoColor, {192, 196, 13, 26}, {3, 1}}};
+
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("highlights.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  AccessibilityPageInfo page_info;
+  std::vector<AccessibilityTextRunInfo> text_runs;
+  std::vector<AccessibilityCharInfo> chars;
+  AccessibilityPageObjects page_objects;
+  ASSERT_TRUE(GetAccessibilityInfo(engine.get(), 0, page_info, text_runs, chars,
+                                   page_objects));
+  EXPECT_EQ(0u, page_info.page_index);
+  EXPECT_EQ(gfx::Rect(5, 3, 533, 266), page_info.bounds);
+  EXPECT_EQ(text_runs.size(), page_info.text_run_count);
+  EXPECT_EQ(chars.size(), page_info.char_count);
+  ASSERT_EQ(page_objects.highlights.size(), base::size(kExpectedHighlightInfo));
+
+  for (size_t i = 0; i < page_objects.highlights.size(); ++i) {
+    const AccessibilityHighlightInfo& highlight_info =
+        page_objects.highlights[i];
+    EXPECT_EQ(highlight_info.index_in_page,
+              kExpectedHighlightInfo[i].index_in_page);
+    EXPECT_EQ(kExpectedHighlightInfo[i].bounds, highlight_info.bounds);
+    EXPECT_EQ(highlight_info.text_range.index,
+              kExpectedHighlightInfo[i].text_range.index);
+    EXPECT_EQ(highlight_info.text_range.count,
+              kExpectedHighlightInfo[i].text_range.count);
+    EXPECT_EQ(highlight_info.color, kExpectedHighlightInfo[i].color);
+    EXPECT_EQ(highlight_info.note_text, kExpectedHighlightInfo[i].note_text);
+  }
+}
+
+TEST_F(AccessibilityTest, GetAccessibilityTextFieldInfo) {
+  static const AccessibilityTextFieldInfo kExpectedTextFieldInfo[] = {
+      {"Text Box", "Text", false, false, false, 0, 5, {138, 230, 135, 41}},
+      {"ReadOnly", "Elephant", true, false, false, 1, 5, {138, 163, 135, 41}},
+      {"Required",
+       "Required Field",
+       false,
+       true,
+       false,
+       2,
+       5,
+       {138, 303, 135, 34}},
+      {"Password", "", false, false, true, 3, 5, {138, 356, 135, 35}}};
+
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("form_text_fields.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  AccessibilityPageInfo page_info;
+  std::vector<AccessibilityTextRunInfo> text_runs;
+  std::vector<AccessibilityCharInfo> chars;
+  AccessibilityPageObjects page_objects;
+  ASSERT_TRUE(GetAccessibilityInfo(engine.get(), 0, page_info, text_runs, chars,
+                                   page_objects));
+  EXPECT_EQ(0u, page_info.page_index);
+  EXPECT_EQ(gfx::Rect(5, 3, 400, 400), page_info.bounds);
+  EXPECT_EQ(text_runs.size(), page_info.text_run_count);
+  EXPECT_EQ(chars.size(), page_info.char_count);
+  ASSERT_EQ(page_objects.form_fields.text_fields.size(),
+            base::size(kExpectedTextFieldInfo));
+
+  for (size_t i = 0; i < page_objects.form_fields.text_fields.size(); ++i) {
+    const AccessibilityTextFieldInfo& text_field_info =
+        page_objects.form_fields.text_fields[i];
+    EXPECT_EQ(kExpectedTextFieldInfo[i].name, text_field_info.name);
+    EXPECT_EQ(kExpectedTextFieldInfo[i].value, text_field_info.value);
+    EXPECT_EQ(kExpectedTextFieldInfo[i].is_read_only,
+              text_field_info.is_read_only);
+    EXPECT_EQ(kExpectedTextFieldInfo[i].is_required,
+              text_field_info.is_required);
+    EXPECT_EQ(kExpectedTextFieldInfo[i].is_password,
+              text_field_info.is_password);
+    EXPECT_EQ(kExpectedTextFieldInfo[i].index_in_page,
+              text_field_info.index_in_page);
+    EXPECT_EQ(kExpectedTextFieldInfo[i].text_run_index,
+              text_field_info.text_run_index);
+    EXPECT_EQ(kExpectedTextFieldInfo[i].bounds, text_field_info.bounds);
+  }
+}
+
+TEST_F(AccessibilityTest, TestSelectionActionHandling) {
+  struct Selection {
+    uint32_t start_page_index;
+    uint32_t start_char_index;
+    uint32_t end_page_index;
+    uint32_t end_char_index;
+  };
+
+  struct TestCase {
+    Selection action;
+    Selection expected_result;
+  };
+
+  static constexpr TestCase kTestCases[] = {
+      {{0, 0, 0, 0}, {0, 0, 0, 0}},
+      {{0, 0, 1, 5}, {0, 0, 1, 5}},
+      // Selection action data with invalid char index.
+      // GetSelection() should return the previous selection in this case.
+      {{0, 0, 0, 50}, {0, 0, 1, 5}},
+      // Selection action data for reverse selection where start selection
+      // index is greater than end selection index. GetSelection() should
+      // return the sanitized selection value where start selection index
+      // is less than end selection index.
+      {{1, 10, 0, 5}, {0, 5, 1, 10}},
+      {{0, 10, 0, 4}, {0, 4, 0, 10}},
+      // Selection action data with invalid page index.
+      // GetSelection() should return the previous selection in this case.
+      {{0, 10, 2, 4}, {0, 4, 0, 10}},
+  };
+
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("hello_world2.pdf"));
+  ASSERT_TRUE(engine);
+
+  for (const auto& test_case : kTestCases) {
+    AccessibilityActionData action_data;
+    action_data.action = AccessibilityAction::kSetSelection;
+    const Selection& sel_action = test_case.action;
+    action_data.selection_start_index.page_index = sel_action.start_page_index;
+    action_data.selection_start_index.char_index = sel_action.start_char_index;
+    action_data.selection_end_index.page_index = sel_action.end_page_index;
+    action_data.selection_end_index.char_index = sel_action.end_char_index;
+    action_data.target_rect = {{0, 0}, {0, 0}};
+
+    engine->HandleAccessibilityAction(action_data);
+    Selection actual_selection;
+    engine->GetSelection(
+        &actual_selection.start_page_index, &actual_selection.start_char_index,
+        &actual_selection.end_page_index, &actual_selection.end_char_index);
+    const Selection& expected_selection = test_case.expected_result;
+    EXPECT_EQ(actual_selection.start_page_index,
+              expected_selection.start_page_index);
+    EXPECT_EQ(actual_selection.start_char_index,
+              expected_selection.start_char_index);
+    EXPECT_EQ(actual_selection.end_page_index,
+              expected_selection.end_page_index);
+    EXPECT_EQ(actual_selection.end_char_index,
+              expected_selection.end_char_index);
+  }
+}
+
+// Tests if PP_PDF_SET_SELECTION updates scroll offsets if the selection is not
+// in the current visible rect.
+TEST_F(AccessibilityTest, TestSetSelectionAndScroll) {
+  struct Selection {
+    uint32_t start_page_index;
+    uint32_t start_char_index;
+    uint32_t end_page_index;
+    uint32_t end_char_index;
+  };
+
+  struct TestCase {
+    Selection action;
+    Selection expected_result;
+    gfx::Vector2d scroll_offset;
+  };
+
+  static constexpr TestCase kTestCases[] = {
+      {{0, 15, 0, 15}, {0, 15, 0, 15}, {0, 0}},
+      {{1, 15, 1, 15}, {1, 15, 1, 15}, {28, 517}},
+  };
+
+  ScrollEnabledTestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("hello_world2.pdf"));
+  ASSERT_TRUE(engine);
+  engine->PluginSizeUpdated({400, 400});
+
+  int index = 0;
+  for (const auto& test_case : kTestCases) {
+    AccessibilityActionData action_data;
+    action_data.action = AccessibilityAction::kSetSelection;
+    const Selection& sel_action = test_case.action;
+    action_data.selection_start_index.page_index = sel_action.start_page_index;
+    action_data.selection_start_index.char_index = sel_action.start_char_index;
+    action_data.selection_end_index.page_index = sel_action.end_page_index;
+    action_data.selection_end_index.char_index = sel_action.end_char_index;
+    gfx::RectF char_bounds = engine->GetCharBounds(sel_action.start_page_index,
+                                                   sel_action.start_char_index);
+    action_data.target_rect = {{char_bounds.x(), char_bounds.y() + 400 * index},
+                               {char_bounds.width(), char_bounds.height()}};
+
+    engine->HandleAccessibilityAction(action_data);
+    Selection actual_selection;
+    engine->GetSelection(
+        &actual_selection.start_page_index, &actual_selection.start_char_index,
+        &actual_selection.end_page_index, &actual_selection.end_char_index);
+    const Selection& expected_selection = test_case.expected_result;
+    EXPECT_EQ(actual_selection.start_page_index,
+              expected_selection.start_page_index);
+    EXPECT_EQ(actual_selection.start_char_index,
+              expected_selection.start_char_index);
+    EXPECT_EQ(actual_selection.end_page_index,
+              expected_selection.end_page_index);
+    EXPECT_EQ(actual_selection.end_char_index,
+              expected_selection.end_char_index);
+    EXPECT_EQ(test_case.scroll_offset, client.GetScrollRequestDelta());
+    index++;
+  }
+}
+
+}  // namespace chrome_pdf
diff --git a/pdf/pdfium/findtext_unittest.cc b/pdf/pdfium/findtext_unittest.cc
index c077b7485151..acca90d79c8e 100644
--- a/pdf/pdfium/findtext_unittest.cc
+++ b/pdf/pdfium/findtext_unittest.cc
@@ -2,108 +2,44 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/files/file_util.h"
 #include "base/optional.h"
-#include "base/path_service.h"
-#include "pdf/document_loader.h"
+#include "base/strings/utf_string_conversions.h"
 #include "pdf/pdfium/pdfium_engine.h"
-#include "pdf/url_loader_wrapper.h"
+#include "pdf/pdfium/pdfium_test_base.h"
+#include "pdf/test/test_client.h"
 #include "testing/gmock/include/gmock/gmock.h"
-#include "testing/gtest/include/gtest/gtest.h"
 
-using testing::InSequence;
 using testing::_;
+using testing::InSequence;
 
 namespace chrome_pdf {
 
 namespace {
 
-class TestDocumentLoader : public DocumentLoader {
+class FindTextTestClient : public TestClient {
  public:
-  explicit TestDocumentLoader(Client* client) : client_(client) {
-    base::FilePath pdf_path;
-    CHECK(base::PathService::Get(base::DIR_SOURCE_ROOT, &pdf_path));
-    pdf_path = pdf_path.Append(FILE_PATH_LITERAL("pdf"))
-                   .Append(FILE_PATH_LITERAL("test"))
-                   .Append(FILE_PATH_LITERAL("data"))
-                   .Append(FILE_PATH_LITERAL("hello_world2.pdf"));
-    CHECK(base::ReadFileToString(pdf_path, &pdf_data_));
-  }
-  ~TestDocumentLoader() override = default;
-
-  // DocumentLoader:
-  bool Init(std::unique_ptr<URLLoaderWrapper> loader,
-            const std::string& url) override {
-    NOTREACHED();
-    return false;
-  }
-
-  bool GetBlock(uint32_t position, uint32_t size, void* buf) const override {
-    if (!IsDataAvailable(position, size))
-      return false;
-
-    memcpy(buf, pdf_data_.data() + position, size);
-    return true;
-  }
-
-  bool IsDataAvailable(uint32_t position, uint32_t size) const override {
-    return position < pdf_data_.size() && size <= pdf_data_.size() &&
-           position + size <= pdf_data_.size();
-  }
-
-  void RequestData(uint32_t position, uint32_t size) override {
-    client_->OnDocumentComplete();
-  }
-
-  bool IsDocumentComplete() const override { return true; }
-
-  uint32_t GetDocumentSize() const override { return pdf_data_.size(); }
-
-  uint32_t BytesReceived() const override { return pdf_data_.size(); }
-
- private:
-  Client* const client_;
-  std::string pdf_data_;
-};
-
-std::unique_ptr<DocumentLoader> CreateTestDocumentLoader(
-    DocumentLoader::Client* client) {
-  return std::make_unique<TestDocumentLoader>(client);
-}
-
-class TestClient : public PDFEngine::Client {
- public:
-  TestClient() = default;
-  ~TestClient() override = default;
+  FindTextTestClient() = default;
+  FindTextTestClient(const FindTextTestClient&) = delete;
+  FindTextTestClient& operator=(const FindTextTestClient&) = delete;
+  ~FindTextTestClient() override = default;
 
   // PDFEngine::Client:
-  MOCK_METHOD2(NotifyNumberOfFindResultsChanged, void(int, bool));
-  MOCK_METHOD1(NotifySelectedFindResultChanged, void((int)));
+  MOCK_METHOD(void, NotifyNumberOfFindResultsChanged, (int, bool), (override));
+  MOCK_METHOD(void, NotifySelectedFindResultChanged, (int), (override));
 
-  bool Confirm(const std::string& message) override { return false; }
-
-  std::string Prompt(const std::string& question,
-                     const std::string& default_answer) override {
-    return std::string();
-  }
-
-  std::string GetURL() override { return std::string(); }
-
-  pp::URLLoader CreateURLLoader() override { return pp::URLLoader(); }
-
-  std::vector<SearchStringResult> SearchString(const base::char16* string,
-                                               const base::char16* term,
+  std::vector<SearchStringResult> SearchString(const char16_t* string,
+                                               const char16_t* term,
                                                bool case_sensitive) override {
     EXPECT_TRUE(case_sensitive);
-    base::string16 haystack = base::string16(string);
-    base::string16 needle = base::string16(term);
+    std::u16string haystack = std::u16string(string);
+    std::u16string needle = std::u16string(term);
 
     std::vector<SearchStringResult> results;
 
     size_t pos = 0;
     while (1) {
       pos = haystack.find(needle, pos);
-      if (pos == base::string16::npos)
+      if (pos == std::u16string::npos)
         break;
 
       SearchStringResult result;
@@ -114,55 +50,17 @@ class TestClient : public PDFEngine::Client {
     }
     return results;
   }
-
-  pp::Instance* GetPluginInstance() override { return nullptr; }
-
-  bool IsPrintPreview() override { return false; }
-
-  uint32_t GetBackgroundColor() override { return 0; }
-
-  float GetToolbarHeightInScreenCoords() override { return 0; }
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(TestClient);
 };
 
 }  // namespace
 
-class FindTextTest : public testing::Test {
- public:
-  FindTextTest() = default;
-  ~FindTextTest() override = default;
-
- protected:
-  void SetUp() override {
-    InitializePDFium();
-    PDFiumEngine::SetCreateDocumentLoaderFunctionForTesting(
-        &CreateTestDocumentLoader);
-  }
-  void TearDown() override {
-    PDFiumEngine::SetCreateDocumentLoaderFunctionForTesting(nullptr);
-    FPDF_DestroyLibrary();
-  }
-
-  void InitializePDFium() {
-    FPDF_LIBRARY_CONFIG config;
-    config.version = 2;
-    config.m_pUserFontPaths = nullptr;
-    config.m_pIsolate = nullptr;
-    config.m_v8EmbedderSlot = 0;
-    FPDF_InitLibraryWithConfig(&config);
-  }
-
-  DISALLOW_COPY_AND_ASSIGN(FindTextTest);
-};
+using FindTextTest = PDFiumTestBase;
 
 TEST_F(FindTextTest, FindText) {
-  pp::URLLoader dummy_loader;
-  TestClient client;
-  PDFiumEngine engine(&client, true);
-  ASSERT_TRUE(engine.New("https://chromium.org/dummy.pdf", ""));
-  ASSERT_TRUE(engine.HandleDocumentLoad(dummy_loader));
+  FindTextTestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("hello_world2.pdf"));
+  ASSERT_TRUE(engine);
 
   {
     InSequence sequence;
@@ -174,7 +72,81 @@ TEST_F(FindTextTest, FindText) {
     EXPECT_CALL(client, NotifyNumberOfFindResultsChanged(10, true));
   }
 
-  engine.StartFind("o", /*case_sensitive=*/true);
+  engine->StartFind("o", /*case_sensitive=*/true);
+}
+
+TEST_F(FindTextTest, FindHyphenatedText) {
+  FindTextTestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("spanner.pdf"));
+  ASSERT_TRUE(engine);
+
+  {
+    InSequence sequence;
+
+    EXPECT_CALL(client, NotifyNumberOfFindResultsChanged(1, false));
+    EXPECT_CALL(client, NotifySelectedFindResultChanged(0));
+    for (int i = 1; i < 6; ++i)
+      EXPECT_CALL(client, NotifyNumberOfFindResultsChanged(i + 1, false));
+    EXPECT_CALL(client, NotifyNumberOfFindResultsChanged(6, true));
+  }
+
+  engine->StartFind("application", /*case_sensitive=*/true);
+}
+
+TEST_F(FindTextTest, FindLineBreakText) {
+  FindTextTestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("spanner.pdf"));
+  ASSERT_TRUE(engine);
+
+  {
+    InSequence sequence;
+
+    EXPECT_CALL(client, NotifyNumberOfFindResultsChanged(1, false));
+    EXPECT_CALL(client, NotifySelectedFindResultChanged(0));
+    EXPECT_CALL(client, NotifyNumberOfFindResultsChanged(1, true));
+  }
+
+  engine->StartFind("is the first system", /*case_sensitive=*/true);
+}
+
+TEST_F(FindTextTest, FindSimpleQuotationMarkText) {
+  FindTextTestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("bug_142627.pdf"));
+  ASSERT_TRUE(engine);
+
+  {
+    InSequence sequence;
+
+    EXPECT_CALL(client, NotifyNumberOfFindResultsChanged(1, false));
+    EXPECT_CALL(client, NotifySelectedFindResultChanged(0));
+    EXPECT_CALL(client, NotifyNumberOfFindResultsChanged(2, false));
+    EXPECT_CALL(client, NotifyNumberOfFindResultsChanged(2, true));
+  }
+
+  engine->StartFind("don't", /*case_sensitive=*/true);
+}
+
+TEST_F(FindTextTest, FindFancyQuotationMarkText) {
+  FindTextTestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("bug_142627.pdf"));
+  ASSERT_TRUE(engine);
+
+  {
+    InSequence sequence;
+
+    EXPECT_CALL(client, NotifyNumberOfFindResultsChanged(1, false));
+    EXPECT_CALL(client, NotifySelectedFindResultChanged(0));
+    EXPECT_CALL(client, NotifyNumberOfFindResultsChanged(2, false));
+    EXPECT_CALL(client, NotifyNumberOfFindResultsChanged(2, true));
+  }
+
+  // don't, using right apostrophe instead of a single quotation mark
+  std::u16string term = {'d', 'o', 'n', 0x2019, 't'};
+  engine->StartFind(base::UTF16ToUTF8(term), /*case_sensitive=*/true);
 }
 
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/fuzzers/BUILD.gn b/pdf/pdfium/fuzzers/BUILD.gn
index ffac41d48fc0..682104a322c0 100644
--- a/pdf/pdfium/fuzzers/BUILD.gn
+++ b/pdf/pdfium/fuzzers/BUILD.gn
@@ -6,9 +6,10 @@
 # When adding a fuzzer_test target make sure to add it to the group
 # 'pdf_fuzzers'
 
-import("//testing/test.gni")
 import("//testing/libfuzzer/fuzzer_test.gni")
+import("//testing/test.gni")
 import("//third_party/pdfium/pdfium.gni")
+import("//third_party/protobuf/proto_library.gni")
 
 group("fuzzers") {
 }
@@ -26,267 +27,307 @@ group("pdf_fuzzers") {
     ":pdf_hint_table_fuzzer",
     ":pdf_jpx_fuzzer",
     ":pdf_psengine_fuzzer",
+    ":pdf_scanlinecompositor_fuzzer",
     ":pdf_streamparser_fuzzer",
+    ":pdf_xml_fuzzer",
     ":pdfium_fuzzer",
   ]
-  if (pdf_enable_xfa) {
+  if (pdf_enable_v8) {
     deps += [
-      ":pdf_bidi_fuzzer",
-      ":pdf_cfx_barcode_fuzzer",
-      ":pdf_codec_jpeg_fuzzer",
-      ":pdf_css_fuzzer",
-      ":pdf_fm2js_fuzzer",
-      ":pdf_formcalc_fuzzer",
-      ":pdf_xml_fuzzer",
-      ":pdfium_xfa_fuzzer",
+      ":pdf_cjs_util_fuzzer",
+      ":pdf_fx_date_helpers_fuzzer",
     ]
-    if (pdf_enable_xfa_bmp) {
-      deps += [ ":pdf_codec_bmp_fuzzer" ]
-    }
-    if (pdf_enable_xfa_gif) {
+    if (pdf_enable_xfa) {
       deps += [
-        ":pdf_codec_gif_fuzzer",
-        ":pdf_lzw_fuzzer",
+        ":pdf_bidi_fuzzer",
+        ":pdf_cfgas_stringformatter_fuzzer",
+        ":pdf_cfx_barcode_fuzzer",
+        ":pdf_codec_jpeg_fuzzer",
+        ":pdf_css_fuzzer",
+        ":pdf_fm2js_fuzzer",
+        ":pdf_formcalc_context_fuzzer",
+        ":pdf_formcalc_fuzzer",
+        ":pdfium_xfa_fuzzer",
+        ":pdfium_xfa_lpm_fuzzer",
       ]
+      if (pdf_enable_xfa_bmp) {
+        deps += [ ":pdf_codec_bmp_fuzzer" ]
+      }
+      if (pdf_enable_xfa_gif) {
+        deps += [
+          ":pdf_codec_gif_fuzzer",
+          ":pdf_lzw_fuzzer",
+        ]
+      }
+      if (pdf_enable_xfa_png) {
+        deps += [ ":pdf_codec_png_fuzzer" ]
+      }
+      if (pdf_enable_xfa_tiff) {
+        deps += [ ":pdf_codec_tiff_fuzzer" ]
+      }
     }
-    if (pdf_enable_xfa_png) {
-      deps += [ ":pdf_codec_png_fuzzer" ]
-    }
-    if (pdf_enable_xfa_tiff) {
-      deps += [ ":pdf_codec_tiff_fuzzer" ]
-    }
+  }
+  if (is_clang) {
+    deps += [ ":pdf_nametree_fuzzer" ]
   }
 }
 
 fuzzer_test("pdfium_fuzzer") {
-  sources = [
-    "pdfium_fuzzer.cc",
-    "pdfium_fuzzer_helper.cc",
-    "pdfium_fuzzer_helper.h",
-  ]
-  deps = [
-    "//third_party/pdfium",
-    "//third_party/pdfium:test_support",
-    "//v8",
-    "//v8:v8_libplatform",
-  ]
-  additional_configs = [
-    "//third_party/pdfium:pdfium_core_config",
-    "//v8:external_startup_data",
-  ]
+  sources = []
+  deps = [ "//third_party/pdfium/testing/fuzzers:pdfium_fuzzer_src" ]
   dict = "dicts/pdf.dict"
   seed_corpus = "//third_party/pdfium/testing/resources"
+  grammar_options = [ "grammar=PDF" ]
 }
 
 fuzzer_test("pdf_cmap_fuzzer") {
   sources = []
-  deps = [
-    "//third_party/pdfium/testing/fuzzers:pdf_cmap_fuzzer_src",
-  ]
+  deps = [ "//third_party/pdfium/testing/fuzzers:pdf_cmap_fuzzer_src" ]
 }
 
 fuzzer_test("pdf_codec_a85_fuzzer") {
   sources = []
-  deps = [
-    "//third_party/pdfium/testing/fuzzers:pdf_codec_a85_fuzzer_src",
-  ]
+  deps = [ "//third_party/pdfium/testing/fuzzers:pdf_codec_a85_fuzzer_src" ]
 }
 
 fuzzer_test("pdf_codec_fax_fuzzer") {
   sources = []
-  deps = [
-    "//third_party/pdfium/testing/fuzzers:pdf_codec_fax_fuzzer_src",
-  ]
+  deps = [ "//third_party/pdfium/testing/fuzzers:pdf_codec_fax_fuzzer_src" ]
 }
 
 fuzzer_test("pdf_codec_rle_fuzzer") {
   sources = []
-  deps = [
-    "//third_party/pdfium/testing/fuzzers:pdf_codec_rle_fuzzer_src",
-  ]
+  deps = [ "//third_party/pdfium/testing/fuzzers:pdf_codec_rle_fuzzer_src" ]
 }
 
 fuzzer_test("pdf_codec_icc_fuzzer") {
   sources = []
-  deps = [
-    "//third_party/pdfium/testing/fuzzers:pdf_codec_icc_fuzzer_src",
-  ]
+  deps = [ "//third_party/pdfium/testing/fuzzers:pdf_codec_icc_fuzzer_src" ]
   dict = "dicts/pdf_codec_icc.dict"
 }
 
 fuzzer_test("pdf_codec_jbig2_fuzzer") {
   sources = []
-  deps = [
-    "//third_party/pdfium/testing/fuzzers:pdf_codec_jbig2_fuzzer_src",
-  ]
-}
-
-fuzzer_test("pdf_hint_table_fuzzer") {
-  sources = []
-  deps = [
-    "//third_party/pdfium/testing/fuzzers:pdf_hint_table_fuzzer_src",
-  ]
-}
-
-fuzzer_test("pdf_jpx_fuzzer") {
-  sources = []
-  deps = [
-    "//third_party/pdfium/testing/fuzzers:pdf_jpx_fuzzer_src",
-  ]
-  seed_corpus = "corpora/pdf_jpx"
+  deps = [ "//third_party/pdfium/testing/fuzzers:pdf_codec_jbig2_fuzzer_src" ]
 }
 
 fuzzer_test("pdf_font_fuzzer") {
   sources = []
-  deps = [
-    "//third_party/pdfium/testing/fuzzers:pdf_font_fuzzer_src",
-  ]
+  deps = [ "//third_party/pdfium/testing/fuzzers:pdf_font_fuzzer_src" ]
+}
+
+fuzzer_test("pdf_hint_table_fuzzer") {
+  sources = []
+  deps = [ "//third_party/pdfium/testing/fuzzers:pdf_hint_table_fuzzer_src" ]
+}
+
+fuzzer_test("pdf_jpx_fuzzer") {
+  sources = []
+  deps = [ "//third_party/pdfium/testing/fuzzers:pdf_jpx_fuzzer_src" ]
+  seed_corpus = "corpora/pdf_jpx"
 }
 
 fuzzer_test("pdf_psengine_fuzzer") {
+  sources = []
+  deps = [ "//third_party/pdfium/testing/fuzzers:pdf_psengine_fuzzer_src" ]
+}
+
+fuzzer_test("pdf_scanlinecompositor_fuzzer") {
   sources = []
   deps = [
-    "//third_party/pdfium/testing/fuzzers:pdf_psengine_fuzzer_src",
+    "//third_party/pdfium/testing/fuzzers:pdf_scanlinecompositor_fuzzer_src",
   ]
 }
 
 fuzzer_test("pdf_streamparser_fuzzer") {
   sources = []
-  deps = [
-    "//third_party/pdfium/testing/fuzzers:pdf_streamparser_fuzzer_src",
-  ]
+  deps = [ "//third_party/pdfium/testing/fuzzers:pdf_streamparser_fuzzer_src" ]
 }
 
-if (pdf_enable_xfa) {
-  if (pdf_enable_xfa_bmp) {
-    fuzzer_test("pdf_codec_bmp_fuzzer") {
+fuzzer_test("pdf_xml_fuzzer") {
+  sources = []
+  deps = [ "//third_party/pdfium/testing/fuzzers:pdf_xml_fuzzer_src" ]
+  dict = "dicts/pdf_xml.dict"
+  seed_corpus = "//third_party/libxml/fuzz/seed_corpus"
+}
+
+if (pdf_enable_v8) {
+  fuzzer_test("pdf_cjs_util_fuzzer") {
+    sources = []
+    deps = [ "//third_party/pdfium/testing/fuzzers:pdf_cjs_util_fuzzer_src" ]
+  }
+
+  fuzzer_test("pdf_fx_date_helpers_fuzzer") {
+    sources = []
+    deps = [
+      "//third_party/pdfium/testing/fuzzers:pdf_fx_date_helpers_fuzzer_src",
+    ]
+  }
+
+  if (pdf_enable_xfa) {
+    if (pdf_enable_xfa_bmp) {
+      fuzzer_test("pdf_codec_bmp_fuzzer") {
+        sources = []
+        deps =
+            [ "//third_party/pdfium/testing/fuzzers:pdf_codec_bmp_fuzzer_src" ]
+        seed_corpus = "corpora/pdf_codec_bmp"
+      }
+    }
+
+    if (pdf_enable_xfa_gif) {
+      fuzzer_test("pdf_codec_gif_fuzzer") {
+        sources = []
+        deps =
+            [ "//third_party/pdfium/testing/fuzzers:pdf_codec_gif_fuzzer_src" ]
+        dict = "dicts/pdf_codec_gif.dict"
+        seed_corpus = "corpora/pdf_codec_gif"
+      }
+    }
+
+    fuzzer_test("pdf_codec_jpeg_fuzzer") {
+      sources = []
+      deps =
+          [ "//third_party/pdfium/testing/fuzzers:pdf_codec_jpeg_fuzzer_src" ]
+      dict = "dicts/pdf_codec_jpeg.dict"
+      seed_corpus = "corpora/pdf_codec_jpeg"
+    }
+
+    if (pdf_enable_xfa_png) {
+      fuzzer_test("pdf_codec_png_fuzzer") {
+        sources = []
+        deps =
+            [ "//third_party/pdfium/testing/fuzzers:pdf_codec_png_fuzzer_src" ]
+        dict = "dicts/pdf_codec_png.dict"
+        seed_corpuses = [
+          "corpora/pdf_codec_png",
+          "//components/viz/test/data",
+          "//third_party/blink/web_tests/images/png-suite/samples",
+          "//third_party/blink/web_tests/images/resources/pngfuzz",
+        ]
+      }
+    }
+
+    if (pdf_enable_xfa_tiff) {
+      fuzzer_test("pdf_codec_tiff_fuzzer") {
+        sources = []
+        deps =
+            [ "//third_party/pdfium/testing/fuzzers:pdf_codec_tiff_fuzzer_src" ]
+        dict = "dicts/pdf_codec_tiff.dict"
+        seed_corpus = "corpora/pdf_codec_tiff"
+      }
+    }
+
+    fuzzer_test("pdf_css_fuzzer") {
+      sources = []
+      deps = [ "//third_party/pdfium/testing/fuzzers:pdf_css_fuzzer_src" ]
+      dict = "dicts/pdf_css.dict"
+    }
+
+    fuzzer_test("pdf_fm2js_fuzzer") {
+      sources = []
+      deps = [ "//third_party/pdfium/testing/fuzzers:pdf_fm2js_fuzzer_src" ]
+      dict = "dicts/pdf_formcalc.dict"
+    }
+
+    fuzzer_test("pdf_formcalc_context_fuzzer") {
       sources = []
       deps = [
-        "//third_party/pdfium/testing/fuzzers:pdf_codec_bmp_fuzzer_src",
+        "//third_party/pdfium/testing/fuzzers:pdf_formcalc_context_fuzzer_src",
       ]
-      seed_corpus = "corpora/pdf_codec_bmp"
+      dict = "dicts/pdf_xfa_js.dict"
     }
-  }
 
-  if (pdf_enable_xfa_gif) {
-    fuzzer_test("pdf_codec_gif_fuzzer") {
+    fuzzer_test("pdf_formcalc_fuzzer") {
       sources = []
-      deps = [
-        "//third_party/pdfium/testing/fuzzers:pdf_codec_gif_fuzzer_src",
-      ]
-      dict = "dicts/pdf_codec_gif.dict"
-      seed_corpus = "corpora/pdf_codec_gif"
+      deps = [ "//third_party/pdfium/testing/fuzzers:pdf_formcalc_fuzzer_src" ]
+      dict = "dicts/pdf_formcalc.dict"
     }
-  }
 
-  fuzzer_test("pdf_codec_jpeg_fuzzer") {
-    sources = []
-    deps = [
-      "//third_party/pdfium/testing/fuzzers:pdf_codec_jpeg_fuzzer_src",
-    ]
-    dict = "dicts/pdf_codec_jpeg.dict"
-    seed_corpus = "corpora/pdf_codec_jpeg"
-  }
+    if (pdf_enable_xfa_gif) {
+      fuzzer_test("pdf_lzw_fuzzer") {
+        sources = []
+        deps = [ "//third_party/pdfium/testing/fuzzers:pdf_lzw_fuzzer_src" ]
+      }
+    }
 
-  if (pdf_enable_xfa_png) {
-    fuzzer_test("pdf_codec_png_fuzzer") {
+    fuzzer_test("pdf_bidi_fuzzer") {
       sources = []
-      deps = [
-        "//third_party/pdfium/testing/fuzzers:pdf_codec_png_fuzzer_src",
-      ]
-      dict = "dicts/pdf_codec_png.dict"
-      seed_corpuses = [
-        "corpora/pdf_codec_png",
-        "//components/viz/test/data",
-        "//third_party/WebKit/LayoutTests/images/png-suite/samples",
-        "//third_party/WebKit/LayoutTests/images/resources/pngfuzz",
-      ]
+      deps = [ "//third_party/pdfium/testing/fuzzers:pdf_bidi_fuzzer_src" ]
     }
-  }
 
-  if (pdf_enable_xfa_tiff) {
-    fuzzer_test("pdf_codec_tiff_fuzzer") {
+    fuzzer_test("pdf_cfx_barcode_fuzzer") {
       sources = []
-      deps = [
-        "//third_party/pdfium/testing/fuzzers:pdf_codec_tiff_fuzzer_src",
-      ]
-      dict = "dicts/pdf_codec_tiff.dict"
-      seed_corpus = "corpora/pdf_codec_tiff"
+      deps =
+          [ "//third_party/pdfium/testing/fuzzers:pdf_cfx_barcode_fuzzer_src" ]
     }
-  }
 
-  fuzzer_test("pdf_css_fuzzer") {
-    sources = []
-    deps = [
-      "//third_party/pdfium/testing/fuzzers:pdf_css_fuzzer_src",
-    ]
-    dict = "dicts/pdf_css.dict"
-  }
-
-  fuzzer_test("pdf_fm2js_fuzzer") {
-    sources = []
-    deps = [
-      "//third_party/pdfium/testing/fuzzers:pdf_fm2js_fuzzer_src",
-    ]
-    dict = "dicts/pdf_formcalc.dict"
-  }
-
-  fuzzer_test("pdf_formcalc_fuzzer") {
-    sources = []
-    deps = [
-      "//third_party/pdfium/testing/fuzzers:pdf_formcalc_fuzzer_src",
-    ]
-    dict = "dicts/pdf_formcalc.dict"
-  }
-
-  if (pdf_enable_xfa_gif) {
-    fuzzer_test("pdf_lzw_fuzzer") {
+    fuzzer_test("pdf_cfgas_stringformatter_fuzzer") {
       sources = []
+      deps = [ "//third_party/pdfium/testing/fuzzers:pdf_cfgas_stringformatter_fuzzer_src" ]
+    }
+
+    fuzzer_test("pdfium_xfa_fuzzer") {
+      sources = []
+      deps = [ "//third_party/pdfium/testing/fuzzers:pdfium_xfa_fuzzer_src" ]
+      dict = "dicts/pdf.dict"
+      seed_corpus = "corpora/xfa"
+      grammar_options = [ "grammar=PDF" ]
+    }
+
+    static_library("proto_to_xfa") {
+      sources = [
+        "pdfium_xfa_lpm_fuzzer/proto_to_xfa.cc",
+        "pdfium_xfa_lpm_fuzzer/proto_to_xfa.h",
+        "pdfium_xfa_lpm_fuzzer/simple_xfa_pdf.cc",
+        "pdfium_xfa_lpm_fuzzer/simple_xfa_pdf.h",
+      ]
+      deps = [ "//base" ]
+      public_deps = [ ":xfa_proto" ]
+    }
+
+    fuzzer_test("pdfium_xfa_lpm_fuzzer") {
+      sources = [ "pdfium_xfa_lpm_fuzzer/fuzzer.cc" ]
       deps = [
-        "//third_party/pdfium/testing/fuzzers:pdf_lzw_fuzzer_src",
+        ":proto_to_xfa",
+        "//base",
+        "//third_party/libprotobuf-mutator",
+        "//third_party/pdfium",
+        "//third_party/pdfium/testing/fuzzers:fuzzer_init_public",
+      ]
+      if (is_component_build) {
+        deps += [
+          "//third_party/pdfium/testing/fuzzers:pdfium_xfa_lpm_fuzzer_impl",
+        ]
+      } else {
+        deps +=
+            [ "//third_party/pdfium/testing/fuzzers:pdfium_xfa_lpm_fuzzer_src" ]
+      }
+      include_dirs = [ "//third_party/pdfium" ]
+
+      # Don't build the fuzzer while it isn't actually producing XFA.
+      # TODO(metzman): Remove this once the fuzzer actually fuzzes XFA.
+      additional_configs = [ "//testing/libfuzzer:no_clusterfuzz" ]
+    }
+
+    test("pdfium_xfa_lpm_unittest") {
+      sources = [ "pdfium_xfa_lpm_fuzzer/simple_xfa_pdf_unittest.cc" ]
+
+      deps = [
+        ":proto_to_xfa",
+        "//base/test:run_all_unittests",
+        "//testing/gtest",
       ]
     }
   }
-
-  fuzzer_test("pdf_xml_fuzzer") {
-    sources = []
-    deps = [
-      "//third_party/pdfium/testing/fuzzers:pdf_xml_fuzzer_src",
-    ]
-    dict = "dicts/pdf_xml.dict"
-  }
-
-  fuzzer_test("pdf_bidi_fuzzer") {
-    sources = []
-    deps = [
-      "//third_party/pdfium/testing/fuzzers:pdf_bidi_fuzzer_src",
-    ]
-  }
-
-  fuzzer_test("pdf_cfx_barcode_fuzzer") {
-    sources = []
-    deps = [
-      "//third_party/pdfium/testing/fuzzers:pdf_cfx_barcode_fuzzer_src",
-    ]
-  }
-
-  fuzzer_test("pdfium_xfa_fuzzer") {
-    sources = [
-      "pdfium_fuzzer_helper.cc",
-      "pdfium_fuzzer_helper.h",
-      "pdfium_xfa_fuzzer.cc",
-    ]
-    deps = [
-      "//third_party/pdfium",
-      "//third_party/pdfium:test_support",
-      "//v8",
-      "//v8:v8_libplatform",
-    ]
-    additional_configs = [
-      "//third_party/pdfium:pdfium_core_config",
-      "//v8:external_startup_data",
-    ]
-    dict = "dicts/pdf.dict"
-    seed_corpus = "//third_party/pdfium/testing/resources"
-  }
+}
+
+if (is_clang) {
+  fuzzer_test("pdf_nametree_fuzzer") {
+    sources = []
+    deps = [ "//third_party/pdfium/testing/fuzzers:pdf_nametree_fuzzer_src" ]
+  }
+}
+
+proto_library("xfa_proto") {
+  sources = [ "pdfium_xfa_lpm_fuzzer/xfa.proto" ]
 }
diff --git a/pdf/pdfium/fuzzers/DEPS b/pdf/pdfium/fuzzers/DEPS
index aca641cc4ddc..dcafbfc4dcf5 100644
--- a/pdf/pdfium/fuzzers/DEPS
+++ b/pdf/pdfium/fuzzers/DEPS
@@ -1,4 +1,3 @@
 include_rules = [
-  "+third_party/pdfium/testing/test_support.h",
-  "+v8/include/v8-platform.h",
-]
+  "+third_party/pdfium/testing/fuzzers",
+]
\ No newline at end of file
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/bug_1258_1.pdf b/pdf/pdfium/fuzzers/corpora/xfa/bug_1258_1.pdf
new file mode 100644
index 000000000000..b5ac39c094a8
Binary files /dev/null and b/pdf/pdfium/fuzzers/corpora/xfa/bug_1258_1.pdf differ
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/bug_1258_2.pdf b/pdf/pdfium/fuzzers/corpora/xfa/bug_1258_2.pdf
new file mode 100644
index 000000000000..8dfc40fc26b8
Binary files /dev/null and b/pdf/pdfium/fuzzers/corpora/xfa/bug_1258_2.pdf differ
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/bug_1258_3.pdf b/pdf/pdfium/fuzzers/corpora/xfa/bug_1258_3.pdf
new file mode 100644
index 000000000000..eca3719a16c5
Binary files /dev/null and b/pdf/pdfium/fuzzers/corpora/xfa/bug_1258_3.pdf differ
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/bug_1269_1.pdf b/pdf/pdfium/fuzzers/corpora/xfa/bug_1269_1.pdf
new file mode 100644
index 000000000000..b2d4784e0ca7
--- /dev/null
+++ b/pdf/pdfium/fuzzers/corpora/xfa/bug_1269_1.pdf
@@ -0,0 +1,45 @@
+%PDF-1.7
+%
+1 0 obj <<
+  /AcroForm 2 0 R
+  /Extensions <<
+    /ADBE <<
+      /BaseVersion /1.7
+      /ExtensionLevel 8
+    >>
+  >>
+  /NeedsRendering true
+  /Pages 8 0 R
+  /Type /Catalog
+>>
+endobj
+2 0 obj <<
+  /XFA 3 0 R
+>>
+endobj
+3 0 obj <<
+  /Length 114
+>>
+stream
+<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/">
+<template>
+<subform use=" .[$host.calculationsEnabled=$]">
+<field>
+endstream
+endobj
+8 0 obj <<
+  /Type /Pages
+  /Count 1
+  /Kids [9 0 R]
+>>
+endobj
+9 0 obj <<
+  /Type /Page
+  /Parent 2 0 R
+  /MediaBox [0 0 612 792]
+>>
+endobj
+trailer <<
+  /Root 1 0 R
+>>
+%%EOF
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/bug_1269_2.pdf b/pdf/pdfium/fuzzers/corpora/xfa/bug_1269_2.pdf
new file mode 100644
index 000000000000..5a15eae6884e
--- /dev/null
+++ b/pdf/pdfium/fuzzers/corpora/xfa/bug_1269_2.pdf
@@ -0,0 +1,46 @@
+%PDF-1.7
+%
+1 0 obj <<
+  /AcroForm 2 0 R
+  /Extensions <<
+    /ADBE <<
+      /BaseVersion /1.7
+      /ExtensionLevel 8
+    >>
+  >>
+  /NeedsRendering true
+  /Pages 8 0 R
+  /Type /Catalog
+>>
+endobj
+2 0 obj <<
+  /XFA 3 0 R
+>>
+endobj
+3 0 obj <<
+  /Length 115
+>>
+stream
+<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/">
+<template>
+<defaultUi use=" .[c=$]">
+<field>
+<contentArea name="c">
+endstream
+endobj
+8 0 obj <<
+  /Type /Pages
+  /Count 1
+  /Kids [9 0 R]
+>>
+endobj
+9 0 obj <<
+  /Type /Page
+  /Parent 2 0 R
+  /MediaBox [0 0 612 792]
+>>
+endobj
+trailer <<
+  /Root 1 0 R
+>>
+%%EOF
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/bug_1269_3.pdf b/pdf/pdfium/fuzzers/corpora/xfa/bug_1269_3.pdf
new file mode 100644
index 000000000000..804553764482
--- /dev/null
+++ b/pdf/pdfium/fuzzers/corpora/xfa/bug_1269_3.pdf
@@ -0,0 +1,45 @@
+%PDF-1.7
+%
+1 0 obj <<
+  /AcroForm 2 0 R
+  /Extensions <<
+    /ADBE <<
+      /BaseVersion /1.7
+      /ExtensionLevel 8
+    >>
+  >>
+  /NeedsRendering true
+  /Pages 8 0 R
+  /Type /Catalog
+>>
+endobj
+2 0 obj <<
+  /XFA 3 0 R
+>>
+endobj
+3 0 obj <<
+  /Length 96
+>>
+stream
+<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/">
+<template>
+<template use=" .[Space($)]">
+<field>
+endstream
+endobj
+8 0 obj <<
+  /Type /Pages
+  /Count 1
+  /Kids [9 0 R]
+>>
+endobj
+9 0 obj <<
+  /Type /Page
+  /Parent 2 0 R
+  /MediaBox [0 0 612 792]
+>>
+endobj
+trailer <<
+  /Root 1 0 R
+>>
+%%EOF
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/bug_1270.pdf b/pdf/pdfium/fuzzers/corpora/xfa/bug_1270.pdf
new file mode 100644
index 000000000000..637b775799b6
--- /dev/null
+++ b/pdf/pdfium/fuzzers/corpora/xfa/bug_1270.pdf
@@ -0,0 +1,45 @@
+%PDF-1.7
+%
+1 0 obj <<
+  /AcroForm 2 0 R
+  /Extensions <<
+    /ADBE <<
+      /BaseVersion /1.7
+      /ExtensionLevel 8
+    >>
+  >>
+  /NeedsRendering true
+  /Pages 8 0 R
+  /Type /Catalog
+>>
+endobj
+2 0 obj <<
+  /XFA 3 0 R
+>>
+endobj
+3 0 obj <<
+  /Length 84
+>>
+stream
+<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/">
+<template>
+<subform use="$">
+<field>
+endstream
+endobj
+8 0 obj <<
+  /Type /Pages
+  /Count 1
+  /Kids [9 0 R]
+>>
+endobj
+9 0 obj <<
+  /Type /Page
+  /Parent 2 0 R
+  /MediaBox [0 0 612 792]
+>>
+endobj
+trailer <<
+  /Root 1 0 R
+>>
+%%EOF
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/bug_1272.pdf b/pdf/pdfium/fuzzers/corpora/xfa/bug_1272.pdf
new file mode 100644
index 000000000000..3e600cc63911
--- /dev/null
+++ b/pdf/pdfium/fuzzers/corpora/xfa/bug_1272.pdf
@@ -0,0 +1,45 @@
+%PDF-1.7
+%
+1 0 obj <<
+  /AcroForm 2 0 R
+  /Extensions <<
+    /ADBE <<
+      /BaseVersion /1.7
+      /ExtensionLevel 8
+    >>
+  >>
+  /NeedsRendering true
+  /Pages 8 0 R
+  /Type /Catalog
+>>
+endobj
+2 0 obj <<
+  /XFA 3 0 R
+>>
+endobj
+3 0 obj <<
+  /Length 101
+>>
+stream
+<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/">
+<template>
+<subform use=" .[$.clone(1)]">
+<bindItems>
+endstream
+endobj
+8 0 obj <<
+  /Type /Pages
+  /Count 1
+  /Kids [9 0 R]
+>>
+endobj
+9 0 obj <<
+  /Type /Page
+  /Parent 2 0 R
+  /MediaBox [0 0 612 792]
+>>
+endobj
+trailer <<
+  /Root 1 0 R
+>>
+%%EOF
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/bug_1273.pdf b/pdf/pdfium/fuzzers/corpora/xfa/bug_1273.pdf
new file mode 100644
index 000000000000..88325971f06b
--- /dev/null
+++ b/pdf/pdfium/fuzzers/corpora/xfa/bug_1273.pdf
@@ -0,0 +1,46 @@
+%PDF-1.7
+%
+1 0 obj <<
+  /AcroForm 2 0 R
+  /Extensions <<
+    /ADBE <<
+      /BaseVersion /1.7
+      /ExtensionLevel 8
+    >>
+  >>
+  /NeedsRendering true
+  /Pages 8 0 R
+  /Type /Catalog
+>>
+endobj
+2 0 obj <<
+  /XFA 3 0 R
+>>
+endobj
+3 0 obj <<
+  /Length 119
+>>
+stream
+<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/">
+<template>
+<subform>
+<breakBefore>
+<script>host.openList("""")</script>
+endstream
+endobj
+8 0 obj <<
+  /Type /Pages
+  /Count 1
+  /Kids [9 0 R]
+>>
+endobj
+9 0 obj <<
+  /Type /Page
+  /Parent 2 0 R
+  /MediaBox [0 0 612 792]
+>>
+endobj
+trailer <<
+  /Root 1 0 R
+>>
+%%EOF
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/xfa_combobox.pdf b/pdf/pdfium/fuzzers/corpora/xfa/xfa_combobox.pdf
new file mode 100644
index 000000000000..bdff67c2eb6b
--- /dev/null
+++ b/pdf/pdfium/fuzzers/corpora/xfa/xfa_combobox.pdf
@@ -0,0 +1,234 @@
+%PDF-1.7
+%
+1 0 obj <<
+  /AcroForm 2 0 R
+  /Extensions <<
+    /ADBE <<
+      /BaseVersion /1.7
+      /ExtensionLevel 8
+    >>
+  >>
+  /NeedsRendering true
+  /Pages 8 0 R
+  /Type /Catalog
+>>
+endobj
+2 0 obj <<
+  /XFA [
+    (preamble)
+    3 0 R
+    (config)
+    4 0 R
+    (template)
+    5 0 R
+    (localeSet)
+    6 0 R
+    (postamble)
+    7 0 R
+  ]
+>>
+endobj
+3 0 obj <<
+  /Length 124
+>>
+stream
+<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/" timeStamp="2018-02-23T21:37:11Z" uuid="21482798-7bf0-40a4-bc5d-3cefdccf32b5">
+endstream
+endobj
+4 0 obj <<
+  /Length 642
+>>
+stream
+<config xmlns="http://www.xfa.org/schema/xci/3.0/">
+<agent name="designer">
+  <destination>pdf</destination>
+  <pdf>
+    <fontInfo/>
+  </pdf>
+</agent>
+<present>
+  <pdf>
+    <version>1.7</version>
+    <adobeExtensionLevel>8</adobeExtensionLevel>
+    <renderPolicy>client</renderPolicy>
+    <scriptModel>XFA</scriptModel>
+    <interactive>1</interactive>
+  </pdf>
+  <xdp>
+    <packets>*</packets>
+  </xdp>
+  <destination>pdf</destination>
+  <script>
+    <runScripts>server</runScripts>
+  </script>
+</present>
+<acrobat>
+  <acrobat7>
+    <dynamicRender>required</dynamicRender>
+  </acrobat7>
+  <validate>preSubmit</validate>
+</acrobat>
+</config>
+endstream
+endobj
+5 0 obj <<
+  /Length 716
+>>
+stream
+<template xmlns="http://www.xfa.org/schema/xfa-template/3.3/">
+  <subform name="form1" layout="tb" locale="en_US" restoreState="auto">
+    <pageSet>
+      <pageArea name="Page1" id="Page1">
+        <contentArea x="18pt" y="18pt" w="612pt" h="792pt"/>
+        <medium stock="default" short="612pt" long="792pt"/>
+      </pageArea>
+    </pageSet>
+    <subform w="576pt" h="756pt" name="Page1">
+      <field name="ImageField1" y="0pt" x="0pt" w="425pt" h="80pt">
+        <ui>
+          <choiceList open="userControl"/>
+        </ui>
+        <items save="1">
+          <text>clams</text>
+          <text>oysters</text>
+          <text>crabs</text>
+        </items>
+      </field>
+    </subform>
+  </subform>
+</template>
+endstream
+endobj
+6 0 obj <<
+  /Length 3455
+>>
+stream
+<localeSet xmlns="http://www.xfa.org/schema/xfa-locale-set/2.7/">
+  <locale name="en_US" desc="English (United States)">
+    <calendarSymbols name="gregorian">
+      <monthNames>
+        <month>January</month>
+        <month>February</month>
+        <month>March</month>
+        <month>April</month>
+        <month>May</month>
+        <month>June</month>
+        <month>July</month>
+        <month>August</month>
+        <month>September</month>
+        <month>October</month>
+        <month>November</month>
+        <month>December</month>
+      </monthNames>
+      <monthNames abbr="1">
+        <month>Jan</month>
+        <month>Feb</month>
+        <month>Mar</month>
+        <month>Apr</month>
+        <month>May</month>
+        <month>Jun</month>
+        <month>Jul</month>
+        <month>Aug</month>
+        <month>Sep</month>
+        <month>Oct</month>
+        <month>Nov</month>
+        <month>Dec</month>
+      </monthNames>
+      <dayNames>
+        <day>Sunday</day>
+        <day>Monday</day>
+        <day>Tuesday</day>
+        <day>Wednesday</day>
+        <day>Thursday</day>
+        <day>Friday</day>
+        <day>Saturday</day>
+      </dayNames>
+      <dayNames abbr="1">
+        <day>Sun</day>
+        <day>Mon</day>
+        <day>Tue</day>
+        <day>Wed</day>
+        <day>Thu</day>
+        <day>Fri</day>
+        <day>Sat</day>
+      </dayNames>
+      <meridiemNames>
+        <meridiem>AM</meridiem>
+        <meridiem>PM</meridiem>
+      </meridiemNames>
+      <eraNames>
+        <era>BC</era>
+        <era>AD</era>
+      </eraNames>
+    </calendarSymbols>
+    <datePatterns>
+      <datePattern name="full">EEEE, MMMM D, YYYY</datePattern>
+      <datePattern name="long">MMMM D, YYYY</datePattern>
+      <datePattern name="med">MMM D, YYYY</datePattern>
+      <datePattern name="short">M/D/YY</datePattern>
+    </datePatterns>
+    <timePatterns>
+      <timePattern name="full">h:MM:SS A Z</timePattern>
+      <timePattern name="long">h:MM:SS A Z</timePattern>
+      <timePattern name="med">h:MM:SS A</timePattern>
+      <timePattern name="short">h:MM A</timePattern>
+    </timePatterns>
+    <dateTimeSymbols>GyMdkHmsSEDFwWahKzZ</dateTimeSymbols>
+    <numberPatterns>
+      <numberPattern name="numeric">z,zz9.zzz</numberPattern>
+      <numberPattern name="currency">$z,zz9.99|($z,zz9.99)</numberPattern>
+      <numberPattern name="percent">z,zz9%</numberPattern>
+    </numberPatterns>
+    <numberSymbols>
+      <numberSymbol name="decimal">.</numberSymbol>
+      <numberSymbol name="grouping">,</numberSymbol>
+      <numberSymbol name="percent">%</numberSymbol>
+      <numberSymbol name="minus">-</numberSymbol>
+      <numberSymbol name="zero">0</numberSymbol>
+    </numberSymbols>
+    <currencySymbols>
+      <currencySymbol name="symbol">$</currencySymbol>
+      <currencySymbol name="isoname">USD</currencySymbol>
+      <currencySymbol name="decimal">.</currencySymbol>
+    </currencySymbols>
+    <typefaces>
+      <typeface name="Myriad Pro"/>
+      <typeface name="Minion Pro"/>
+      <typeface name="Courier Std"/>
+      <typeface name="Adobe Pi Std"/>
+      <typeface name="Adobe Hebrew"/>
+      <typeface name="Adobe Arabic"/>
+      <typeface name="Adobe Thai"/>
+      <typeface name="Kozuka Gothic Pro-VI M"/>
+      <typeface name="Kozuka Mincho Pro-VI R"/>
+      <typeface name="Adobe Ming Std L"/>
+      <typeface name="Adobe Song Std L"/>
+      <typeface name="Adobe Myungjo Std M"/>
+    </typefaces>
+  </locale>
+</localeSet>
+endstream
+endobj
+7 0 obj <<
+  /Length 11
+>>
+stream
+</xdp:xdp>
+endstream
+endobj
+8 0 obj <<
+  /Type /Pages
+  /Count 1
+  /Kids [9 0 R]
+>>
+endobj
+9 0 obj <<
+  /Type /Page
+  /Parent 2 0 R
+  /MediaBox [0 0 612 792]
+>>
+endobj
+trailer <<
+  /Root 1 0 R
+>>
+%%EOF
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/xfa_date_time_edit.pdf b/pdf/pdfium/fuzzers/corpora/xfa/xfa_date_time_edit.pdf
new file mode 100644
index 000000000000..b6dc9ffde279
--- /dev/null
+++ b/pdf/pdfium/fuzzers/corpora/xfa/xfa_date_time_edit.pdf
@@ -0,0 +1,229 @@
+%PDF-1.7
+%
+1 0 obj <<
+  /AcroForm 2 0 R
+  /Extensions <<
+    /ADBE <<
+      /BaseVersion /1.7
+      /ExtensionLevel 8
+    >>
+  >>
+  /NeedsRendering true
+  /Pages 8 0 R
+  /Type /Catalog
+>>
+endobj
+2 0 obj <<
+  /XFA [
+    (preamble)
+    3 0 R
+    (config)
+    4 0 R
+    (template)
+    5 0 R
+    (localeSet)
+    6 0 R
+    (postamble)
+    7 0 R
+  ]
+>>
+endobj
+3 0 obj <<
+  /Length 124
+>>
+stream
+<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/" timeStamp="2018-02-23T21:37:11Z" uuid="21482798-7bf0-40a4-bc5d-3cefdccf32b5">
+endstream
+endobj
+4 0 obj <<
+  /Length 642
+>>
+stream
+<config xmlns="http://www.xfa.org/schema/xci/3.0/">
+<agent name="designer">
+  <destination>pdf</destination>
+  <pdf>
+    <fontInfo/>
+  </pdf>
+</agent>
+<present>
+  <pdf>
+    <version>1.7</version>
+    <adobeExtensionLevel>8</adobeExtensionLevel>
+    <renderPolicy>client</renderPolicy>
+    <scriptModel>XFA</scriptModel>
+    <interactive>1</interactive>
+  </pdf>
+  <xdp>
+    <packets>*</packets>
+  </xdp>
+  <destination>pdf</destination>
+  <script>
+    <runScripts>server</runScripts>
+  </script>
+</present>
+<acrobat>
+  <acrobat7>
+    <dynamicRender>required</dynamicRender>
+  </acrobat7>
+  <validate>preSubmit</validate>
+</acrobat>
+</config>
+endstream
+endobj
+5 0 obj <<
+  /Length 567
+>>
+stream
+<template xmlns="http://www.xfa.org/schema/xfa-template/3.3/">
+  <subform name="form1" layout="tb" locale="en_US" restoreState="auto">
+    <pageSet>
+      <pageArea name="Page1" id="Page1">
+        <contentArea x="18pt" y="18pt" w="612pt" h="792pt"/>
+        <medium stock="default" short="612pt" long="792pt"/>
+      </pageArea>
+    </pageSet>
+    <subform w="576pt" h="756pt" name="Page1">
+      <field name="TextField1" y="0pt" x="0pt" w="425pt" h="80pt">
+        <ui>
+          <dateTimeEdit/>
+        </ui>
+      </field>
+    </subform>
+  </subform>
+</template>
+endstream
+endobj
+6 0 obj <<
+  /Length 3455
+>>
+stream
+<localeSet xmlns="http://www.xfa.org/schema/xfa-locale-set/2.7/">
+  <locale name="en_US" desc="English (United States)">
+    <calendarSymbols name="gregorian">
+      <monthNames>
+        <month>January</month>
+        <month>February</month>
+        <month>March</month>
+        <month>April</month>
+        <month>May</month>
+        <month>June</month>
+        <month>July</month>
+        <month>August</month>
+        <month>September</month>
+        <month>October</month>
+        <month>November</month>
+        <month>December</month>
+      </monthNames>
+      <monthNames abbr="1">
+        <month>Jan</month>
+        <month>Feb</month>
+        <month>Mar</month>
+        <month>Apr</month>
+        <month>May</month>
+        <month>Jun</month>
+        <month>Jul</month>
+        <month>Aug</month>
+        <month>Sep</month>
+        <month>Oct</month>
+        <month>Nov</month>
+        <month>Dec</month>
+      </monthNames>
+      <dayNames>
+        <day>Sunday</day>
+        <day>Monday</day>
+        <day>Tuesday</day>
+        <day>Wednesday</day>
+        <day>Thursday</day>
+        <day>Friday</day>
+        <day>Saturday</day>
+      </dayNames>
+      <dayNames abbr="1">
+        <day>Sun</day>
+        <day>Mon</day>
+        <day>Tue</day>
+        <day>Wed</day>
+        <day>Thu</day>
+        <day>Fri</day>
+        <day>Sat</day>
+      </dayNames>
+      <meridiemNames>
+        <meridiem>AM</meridiem>
+        <meridiem>PM</meridiem>
+      </meridiemNames>
+      <eraNames>
+        <era>BC</era>
+        <era>AD</era>
+      </eraNames>
+    </calendarSymbols>
+    <datePatterns>
+      <datePattern name="full">EEEE, MMMM D, YYYY</datePattern>
+      <datePattern name="long">MMMM D, YYYY</datePattern>
+      <datePattern name="med">MMM D, YYYY</datePattern>
+      <datePattern name="short">M/D/YY</datePattern>
+    </datePatterns>
+    <timePatterns>
+      <timePattern name="full">h:MM:SS A Z</timePattern>
+      <timePattern name="long">h:MM:SS A Z</timePattern>
+      <timePattern name="med">h:MM:SS A</timePattern>
+      <timePattern name="short">h:MM A</timePattern>
+    </timePatterns>
+    <dateTimeSymbols>GyMdkHmsSEDFwWahKzZ</dateTimeSymbols>
+    <numberPatterns>
+      <numberPattern name="numeric">z,zz9.zzz</numberPattern>
+      <numberPattern name="currency">$z,zz9.99|($z,zz9.99)</numberPattern>
+      <numberPattern name="percent">z,zz9%</numberPattern>
+    </numberPatterns>
+    <numberSymbols>
+      <numberSymbol name="decimal">.</numberSymbol>
+      <numberSymbol name="grouping">,</numberSymbol>
+      <numberSymbol name="percent">%</numberSymbol>
+      <numberSymbol name="minus">-</numberSymbol>
+      <numberSymbol name="zero">0</numberSymbol>
+    </numberSymbols>
+    <currencySymbols>
+      <currencySymbol name="symbol">$</currencySymbol>
+      <currencySymbol name="isoname">USD</currencySymbol>
+      <currencySymbol name="decimal">.</currencySymbol>
+    </currencySymbols>
+    <typefaces>
+      <typeface name="Myriad Pro"/>
+      <typeface name="Minion Pro"/>
+      <typeface name="Courier Std"/>
+      <typeface name="Adobe Pi Std"/>
+      <typeface name="Adobe Hebrew"/>
+      <typeface name="Adobe Arabic"/>
+      <typeface name="Adobe Thai"/>
+      <typeface name="Kozuka Gothic Pro-VI M"/>
+      <typeface name="Kozuka Mincho Pro-VI R"/>
+      <typeface name="Adobe Ming Std L"/>
+      <typeface name="Adobe Song Std L"/>
+      <typeface name="Adobe Myungjo Std M"/>
+    </typefaces>
+  </locale>
+</localeSet>
+endstream
+endobj
+7 0 obj <<
+  /Length 11
+>>
+stream
+</xdp:xdp>
+endstream
+endobj
+8 0 obj <<
+  /Type /Pages
+  /Count 1
+  /Kids [9 0 R]
+>>
+endobj
+9 0 obj <<
+  /Type /Page
+  /Parent 2 0 R
+  /MediaBox [0 0 612 792]
+>>
+endobj
+trailer <<
+  /Root 1 0 R
+>>
+%%EOF
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/xfa_example.pdf b/pdf/pdfium/fuzzers/corpora/xfa/xfa_example.pdf
new file mode 100644
index 000000000000..84647764f66c
--- /dev/null
+++ b/pdf/pdfium/fuzzers/corpora/xfa/xfa_example.pdf
@@ -0,0 +1,230 @@
+%PDF-1.7
+%
+1 0 obj <<
+  /AcroForm 2 0 R
+  /Extensions <<
+    /ADBE <<
+      /BaseVersion /1.7
+      /ExtensionLevel 8
+    >>
+  >>
+  /NeedsRendering true
+  /Pages 8 0 R
+  /Type /Catalog
+>>
+endobj
+2 0 obj <<
+  /XFA [
+    (preamble)
+    3 0 R
+    (config)
+    4 0 R
+    (template)
+    5 0 R
+    (localeSet)
+    6 0 R
+    (postamble)
+    7 0 R
+  ]
+>>
+endobj
+3 0 obj <<
+  /Length 124
+>>
+stream
+<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/" timeStamp="2018-02-23T21:37:11Z" uuid="21482798-7bf0-40a4-bc5d-3cefdccf32b5">
+endstream
+endobj
+4 0 obj <<
+  /Length 642
+>>
+stream
+<config xmlns="http://www.xfa.org/schema/xci/3.0/">
+<agent name="designer">
+  <destination>pdf</destination>
+  <pdf>
+    <fontInfo/>
+  </pdf>
+</agent>
+<present>
+  <pdf>
+    <version>1.7</version>
+    <adobeExtensionLevel>8</adobeExtensionLevel>
+    <renderPolicy>client</renderPolicy>
+    <scriptModel>XFA</scriptModel>
+    <interactive>1</interactive>
+  </pdf>
+  <xdp>
+    <packets>*</packets>
+  </xdp>
+  <destination>pdf</destination>
+  <script>
+    <runScripts>server</runScripts>
+  </script>
+</present>
+<acrobat>
+  <acrobat7>
+    <dynamicRender>required</dynamicRender>
+  </acrobat7>
+  <validate>preSubmit</validate>
+</acrobat>
+</config>
+endstream
+endobj
+5 0 obj <<
+  /Length 633
+>>
+stream
+<template xmlns="http://www.xfa.org/schema/xfa-template/3.3/">
+  <subform name="form1" layout="tb" locale="zh_CN" restoreState="auto">
+    <pageSet>
+      <pageArea name="Page1" id="Page1">
+        <contentArea x="0.25in" y="0.25in" w="7.75in" h="11.25in"/>
+        <medium stock="default" short="612pt" long="792pt"/>
+      </pageArea>
+    </pageSet>
+    <subform w="576pt" h="756pt" name="Page1">
+      <draw name="HelloWorld" y="0.5in" x="0.5in" w="5in" h="2in">
+       <font typeface="Ahem" size="20pt"/>
+        <value>
+          <text>Hello, world.</text>
+        </value>
+      </draw>
+    </subform>
+  </subform>
+</template>
+endstream
+endobj
+6 0 obj <<
+  /Length 3455
+>>
+stream
+<localeSet xmlns="http://www.xfa.org/schema/xfa-locale-set/2.7/">
+  <locale name="en_US" desc="English (United States)">
+    <calendarSymbols name="gregorian">
+      <monthNames>
+        <month>January</month>
+        <month>February</month>
+        <month>March</month>
+        <month>April</month>
+        <month>May</month>
+        <month>June</month>
+        <month>July</month>
+        <month>August</month>
+        <month>September</month>
+        <month>October</month>
+        <month>November</month>
+        <month>December</month>
+      </monthNames>
+      <monthNames abbr="1">
+        <month>Jan</month>
+        <month>Feb</month>
+        <month>Mar</month>
+        <month>Apr</month>
+        <month>May</month>
+        <month>Jun</month>
+        <month>Jul</month>
+        <month>Aug</month>
+        <month>Sep</month>
+        <month>Oct</month>
+        <month>Nov</month>
+        <month>Dec</month>
+      </monthNames>
+      <dayNames>
+        <day>Sunday</day>
+        <day>Monday</day>
+        <day>Tuesday</day>
+        <day>Wednesday</day>
+        <day>Thursday</day>
+        <day>Friday</day>
+        <day>Saturday</day>
+      </dayNames>
+      <dayNames abbr="1">
+        <day>Sun</day>
+        <day>Mon</day>
+        <day>Tue</day>
+        <day>Wed</day>
+        <day>Thu</day>
+        <day>Fri</day>
+        <day>Sat</day>
+      </dayNames>
+      <meridiemNames>
+        <meridiem>AM</meridiem>
+        <meridiem>PM</meridiem>
+      </meridiemNames>
+      <eraNames>
+        <era>BC</era>
+        <era>AD</era>
+      </eraNames>
+    </calendarSymbols>
+    <datePatterns>
+      <datePattern name="full">EEEE, MMMM D, YYYY</datePattern>
+      <datePattern name="long">MMMM D, YYYY</datePattern>
+      <datePattern name="med">MMM D, YYYY</datePattern>
+      <datePattern name="short">M/D/YY</datePattern>
+    </datePatterns>
+    <timePatterns>
+      <timePattern name="full">h:MM:SS A Z</timePattern>
+      <timePattern name="long">h:MM:SS A Z</timePattern>
+      <timePattern name="med">h:MM:SS A</timePattern>
+      <timePattern name="short">h:MM A</timePattern>
+    </timePatterns>
+    <dateTimeSymbols>GyMdkHmsSEDFwWahKzZ</dateTimeSymbols>
+    <numberPatterns>
+      <numberPattern name="numeric">z,zz9.zzz</numberPattern>
+      <numberPattern name="currency">$z,zz9.99|($z,zz9.99)</numberPattern>
+      <numberPattern name="percent">z,zz9%</numberPattern>
+    </numberPatterns>
+    <numberSymbols>
+      <numberSymbol name="decimal">.</numberSymbol>
+      <numberSymbol name="grouping">,</numberSymbol>
+      <numberSymbol name="percent">%</numberSymbol>
+      <numberSymbol name="minus">-</numberSymbol>
+      <numberSymbol name="zero">0</numberSymbol>
+    </numberSymbols>
+    <currencySymbols>
+      <currencySymbol name="symbol">$</currencySymbol>
+      <currencySymbol name="isoname">USD</currencySymbol>
+      <currencySymbol name="decimal">.</currencySymbol>
+    </currencySymbols>
+    <typefaces>
+      <typeface name="Myriad Pro"/>
+      <typeface name="Minion Pro"/>
+      <typeface name="Courier Std"/>
+      <typeface name="Adobe Pi Std"/>
+      <typeface name="Adobe Hebrew"/>
+      <typeface name="Adobe Arabic"/>
+      <typeface name="Adobe Thai"/>
+      <typeface name="Kozuka Gothic Pro-VI M"/>
+      <typeface name="Kozuka Mincho Pro-VI R"/>
+      <typeface name="Adobe Ming Std L"/>
+      <typeface name="Adobe Song Std L"/>
+      <typeface name="Adobe Myungjo Std M"/>
+    </typefaces>
+  </locale>
+</localeSet>
+endstream
+endobj
+7 0 obj <<
+  /Length 11
+>>
+stream
+</xdp:xdp>
+endstream
+endobj
+8 0 obj <<
+  /Type /Pages
+  /Count 1
+  /Kids [9 0 R]
+>>
+endobj
+9 0 obj <<
+  /Type /Page
+  /Parent 2 0 R
+  /MediaBox [0 0 612 792]
+>>
+endobj
+trailer <<
+  /Root 1 0 R
+>>
+%%EOF
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/xfa_multiline_textfield.pdf b/pdf/pdfium/fuzzers/corpora/xfa/xfa_multiline_textfield.pdf
new file mode 100644
index 000000000000..85a63d562a67
--- /dev/null
+++ b/pdf/pdfium/fuzzers/corpora/xfa/xfa_multiline_textfield.pdf
@@ -0,0 +1,231 @@
+%PDF-1.7
+%
+1 0 obj <<
+  /AcroForm 2 0 R
+  /Extensions <<
+    /ADBE <<
+      /BaseVersion /1.7
+      /ExtensionLevel 8
+    >>
+  >>
+  /NeedsRendering true
+  /Pages 8 0 R
+  /Type /Catalog
+>>
+endobj
+2 0 obj <<
+  /XFA [
+    (preamble)
+    3 0 R
+    (config)
+    4 0 R
+    (template)
+    5 0 R
+    (localeSet)
+    6 0 R
+    (postamble)
+    7 0 R
+  ]
+>>
+endobj
+3 0 obj <<
+  /Length 124
+>>
+stream
+<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/" timeStamp="2018-02-23T21:37:11Z" uuid="21482798-7bf0-40a4-bc5d-3cefdccf32b5">
+endstream
+endobj
+4 0 obj <<
+  /Length 642
+>>
+stream
+<config xmlns="http://www.xfa.org/schema/xci/3.0/">
+<agent name="designer">
+  <destination>pdf</destination>
+  <pdf>
+    <fontInfo/>
+  </pdf>
+</agent>
+<present>
+  <pdf>
+    <version>1.7</version>
+    <adobeExtensionLevel>8</adobeExtensionLevel>
+    <renderPolicy>client</renderPolicy>
+    <scriptModel>XFA</scriptModel>
+    <interactive>1</interactive>
+  </pdf>
+  <xdp>
+    <packets>*</packets>
+  </xdp>
+  <destination>pdf</destination>
+  <script>
+    <runScripts>server</runScripts>
+  </script>
+</present>
+<acrobat>
+  <acrobat7>
+    <dynamicRender>required</dynamicRender>
+  </acrobat7>
+  <validate>preSubmit</validate>
+</acrobat>
+</config>
+endstream
+endobj
+5 0 obj <<
+  /Length 651
+>>
+stream
+<template xmlns="http://www.xfa.org/schema/xfa-template/3.3/">
+  <subform name="form1" layout="tb" locale="en_US" restoreState="auto">
+    <pageSet>
+      <pageArea name="Page1" id="Page1">
+        <contentArea x="18pt" y="18pt" w="612pt" h="792pt"/>
+        <medium stock="default" short="612pt" long="792pt"/>
+      </pageArea>
+    </pageSet>
+    <subform w="576pt" h="756pt" name="Page1">
+      <field name="TextField1" y="0pt" x="0pt" w="425pt" h="80pt">
+        <ui>
+          <textEdit multiLine="1">
+            <font typeface="Helvetica" size="16pt"/>
+          </textEdit>
+        </ui>
+      </field>
+    </subform>
+  </subform>
+</template>
+endstream
+endobj
+6 0 obj <<
+  /Length 3455
+>>
+stream
+<localeSet xmlns="http://www.xfa.org/schema/xfa-locale-set/2.7/">
+  <locale name="en_US" desc="English (United States)">
+    <calendarSymbols name="gregorian">
+      <monthNames>
+        <month>January</month>
+        <month>February</month>
+        <month>March</month>
+        <month>April</month>
+        <month>May</month>
+        <month>June</month>
+        <month>July</month>
+        <month>August</month>
+        <month>September</month>
+        <month>October</month>
+        <month>November</month>
+        <month>December</month>
+      </monthNames>
+      <monthNames abbr="1">
+        <month>Jan</month>
+        <month>Feb</month>
+        <month>Mar</month>
+        <month>Apr</month>
+        <month>May</month>
+        <month>Jun</month>
+        <month>Jul</month>
+        <month>Aug</month>
+        <month>Sep</month>
+        <month>Oct</month>
+        <month>Nov</month>
+        <month>Dec</month>
+      </monthNames>
+      <dayNames>
+        <day>Sunday</day>
+        <day>Monday</day>
+        <day>Tuesday</day>
+        <day>Wednesday</day>
+        <day>Thursday</day>
+        <day>Friday</day>
+        <day>Saturday</day>
+      </dayNames>
+      <dayNames abbr="1">
+        <day>Sun</day>
+        <day>Mon</day>
+        <day>Tue</day>
+        <day>Wed</day>
+        <day>Thu</day>
+        <day>Fri</day>
+        <day>Sat</day>
+      </dayNames>
+      <meridiemNames>
+        <meridiem>AM</meridiem>
+        <meridiem>PM</meridiem>
+      </meridiemNames>
+      <eraNames>
+        <era>BC</era>
+        <era>AD</era>
+      </eraNames>
+    </calendarSymbols>
+    <datePatterns>
+      <datePattern name="full">EEEE, MMMM D, YYYY</datePattern>
+      <datePattern name="long">MMMM D, YYYY</datePattern>
+      <datePattern name="med">MMM D, YYYY</datePattern>
+      <datePattern name="short">M/D/YY</datePattern>
+    </datePatterns>
+    <timePatterns>
+      <timePattern name="full">h:MM:SS A Z</timePattern>
+      <timePattern name="long">h:MM:SS A Z</timePattern>
+      <timePattern name="med">h:MM:SS A</timePattern>
+      <timePattern name="short">h:MM A</timePattern>
+    </timePatterns>
+    <dateTimeSymbols>GyMdkHmsSEDFwWahKzZ</dateTimeSymbols>
+    <numberPatterns>
+      <numberPattern name="numeric">z,zz9.zzz</numberPattern>
+      <numberPattern name="currency">$z,zz9.99|($z,zz9.99)</numberPattern>
+      <numberPattern name="percent">z,zz9%</numberPattern>
+    </numberPatterns>
+    <numberSymbols>
+      <numberSymbol name="decimal">.</numberSymbol>
+      <numberSymbol name="grouping">,</numberSymbol>
+      <numberSymbol name="percent">%</numberSymbol>
+      <numberSymbol name="minus">-</numberSymbol>
+      <numberSymbol name="zero">0</numberSymbol>
+    </numberSymbols>
+    <currencySymbols>
+      <currencySymbol name="symbol">$</currencySymbol>
+      <currencySymbol name="isoname">USD</currencySymbol>
+      <currencySymbol name="decimal">.</currencySymbol>
+    </currencySymbols>
+    <typefaces>
+      <typeface name="Myriad Pro"/>
+      <typeface name="Minion Pro"/>
+      <typeface name="Courier Std"/>
+      <typeface name="Adobe Pi Std"/>
+      <typeface name="Adobe Hebrew"/>
+      <typeface name="Adobe Arabic"/>
+      <typeface name="Adobe Thai"/>
+      <typeface name="Kozuka Gothic Pro-VI M"/>
+      <typeface name="Kozuka Mincho Pro-VI R"/>
+      <typeface name="Adobe Ming Std L"/>
+      <typeface name="Adobe Song Std L"/>
+      <typeface name="Adobe Myungjo Std M"/>
+    </typefaces>
+  </locale>
+</localeSet>
+endstream
+endobj
+7 0 obj <<
+  /Length 11
+>>
+stream
+</xdp:xdp>
+endstream
+endobj
+8 0 obj <<
+  /Type /Pages
+  /Count 1
+  /Kids [9 0 R]
+>>
+endobj
+9 0 obj <<
+  /Type /Page
+  /Parent 2 0 R
+  /MediaBox [0 0 612 792]
+>>
+endobj
+trailer <<
+  /Root 1 0 R
+>>
+%%EOF
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/xfa_rectangle_node.pdf b/pdf/pdfium/fuzzers/corpora/xfa/xfa_rectangle_node.pdf
new file mode 100644
index 000000000000..df109542f06a
--- /dev/null
+++ b/pdf/pdfium/fuzzers/corpora/xfa/xfa_rectangle_node.pdf
@@ -0,0 +1,235 @@
+%PDF-1.7
+%
+1 0 obj <<
+  /AcroForm 2 0 R
+  /Extensions <<
+    /ADBE <<
+      /BaseVersion /1.7
+      /ExtensionLevel 8
+    >>
+  >>
+  /NeedsRendering true
+  /Pages 8 0 R
+  /Type /Catalog
+>>
+endobj
+2 0 obj <<
+  /XFA [
+    (preamble)
+    3 0 R
+    (config)
+    4 0 R
+    (template)
+    5 0 R
+    (localeSet)
+    6 0 R
+    (postamble)
+    7 0 R
+  ]
+>>
+endobj
+3 0 obj <<
+  /Length 124
+>>
+stream
+<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/" timeStamp="2018-02-23T21:37:11Z" uuid="21482798-7bf0-40a4-bc5d-3cefdccf32b5">
+endstream
+endobj
+4 0 obj <<
+  /Length 642
+>>
+stream
+<config xmlns="http://www.xfa.org/schema/xci/3.0/">
+<agent name="designer">
+  <destination>pdf</destination>
+  <pdf>
+    <fontInfo/>
+  </pdf>
+</agent>
+<present>
+  <pdf>
+    <version>1.7</version>
+    <adobeExtensionLevel>8</adobeExtensionLevel>
+    <renderPolicy>client</renderPolicy>
+    <scriptModel>XFA</scriptModel>
+    <interactive>1</interactive>
+  </pdf>
+  <xdp>
+    <packets>*</packets>
+  </xdp>
+  <destination>pdf</destination>
+  <script>
+    <runScripts>server</runScripts>
+  </script>
+</present>
+<acrobat>
+  <acrobat7>
+    <dynamicRender>required</dynamicRender>
+  </acrobat7>
+  <validate>preSubmit</validate>
+</acrobat>
+</config>
+endstream
+endobj
+5 0 obj <<
+  /Length 716
+>>
+stream
+<template xmlns="http://www.xfa.org/schema/xfa-template/3.3/">
+  <subform name="form1" layout="tb" locale="en_US" restoreState="auto">
+    <pageSet>
+      <pageArea name="Page1" id="Page1">
+        <contentArea x="18pt" y="18pt" w="612pt" h="792pt"/>
+        <medium stock="default" short="612pt" long="792pt"/>
+      </pageArea>
+    </pageSet>
+    <subform w="576pt" h="756pt" name="Page1">
+      <draw h="11.43mm" name="Rectangle3" w="30.48mm" x="170.18mm" y="65.868mm">
+        <ui>
+          <defaultUi />
+        </ui>
+        <value>
+          <rectangle>
+            <corner radius="5.08mm" />
+            <edge />
+          </rectangle>
+        </value>
+      </draw>
+    </subform>
+  </subform>
+</template>
+endstream
+endobj
+6 0 obj <<
+  /Length 3455
+>>
+stream
+<localeSet xmlns="http://www.xfa.org/schema/xfa-locale-set/2.7/">
+  <locale name="en_US" desc="English (United States)">
+    <calendarSymbols name="gregorian">
+      <monthNames>
+        <month>January</month>
+        <month>February</month>
+        <month>March</month>
+        <month>April</month>
+        <month>May</month>
+        <month>June</month>
+        <month>July</month>
+        <month>August</month>
+        <month>September</month>
+        <month>October</month>
+        <month>November</month>
+        <month>December</month>
+      </monthNames>
+      <monthNames abbr="1">
+        <month>Jan</month>
+        <month>Feb</month>
+        <month>Mar</month>
+        <month>Apr</month>
+        <month>May</month>
+        <month>Jun</month>
+        <month>Jul</month>
+        <month>Aug</month>
+        <month>Sep</month>
+        <month>Oct</month>
+        <month>Nov</month>
+        <month>Dec</month>
+      </monthNames>
+      <dayNames>
+        <day>Sunday</day>
+        <day>Monday</day>
+        <day>Tuesday</day>
+        <day>Wednesday</day>
+        <day>Thursday</day>
+        <day>Friday</day>
+        <day>Saturday</day>
+      </dayNames>
+      <dayNames abbr="1">
+        <day>Sun</day>
+        <day>Mon</day>
+        <day>Tue</day>
+        <day>Wed</day>
+        <day>Thu</day>
+        <day>Fri</day>
+        <day>Sat</day>
+      </dayNames>
+      <meridiemNames>
+        <meridiem>AM</meridiem>
+        <meridiem>PM</meridiem>
+      </meridiemNames>
+      <eraNames>
+        <era>BC</era>
+        <era>AD</era>
+      </eraNames>
+    </calendarSymbols>
+    <datePatterns>
+      <datePattern name="full">EEEE, MMMM D, YYYY</datePattern>
+      <datePattern name="long">MMMM D, YYYY</datePattern>
+      <datePattern name="med">MMM D, YYYY</datePattern>
+      <datePattern name="short">M/D/YY</datePattern>
+    </datePatterns>
+    <timePatterns>
+      <timePattern name="full">h:MM:SS A Z</timePattern>
+      <timePattern name="long">h:MM:SS A Z</timePattern>
+      <timePattern name="med">h:MM:SS A</timePattern>
+      <timePattern name="short">h:MM A</timePattern>
+    </timePatterns>
+    <dateTimeSymbols>GyMdkHmsSEDFwWahKzZ</dateTimeSymbols>
+    <numberPatterns>
+      <numberPattern name="numeric">z,zz9.zzz</numberPattern>
+      <numberPattern name="currency">$z,zz9.99|($z,zz9.99)</numberPattern>
+      <numberPattern name="percent">z,zz9%</numberPattern>
+    </numberPatterns>
+    <numberSymbols>
+      <numberSymbol name="decimal">.</numberSymbol>
+      <numberSymbol name="grouping">,</numberSymbol>
+      <numberSymbol name="percent">%</numberSymbol>
+      <numberSymbol name="minus">-</numberSymbol>
+      <numberSymbol name="zero">0</numberSymbol>
+    </numberSymbols>
+    <currencySymbols>
+      <currencySymbol name="symbol">$</currencySymbol>
+      <currencySymbol name="isoname">USD</currencySymbol>
+      <currencySymbol name="decimal">.</currencySymbol>
+    </currencySymbols>
+    <typefaces>
+      <typeface name="Myriad Pro"/>
+      <typeface name="Minion Pro"/>
+      <typeface name="Courier Std"/>
+      <typeface name="Adobe Pi Std"/>
+      <typeface name="Adobe Hebrew"/>
+      <typeface name="Adobe Arabic"/>
+      <typeface name="Adobe Thai"/>
+      <typeface name="Kozuka Gothic Pro-VI M"/>
+      <typeface name="Kozuka Mincho Pro-VI R"/>
+      <typeface name="Adobe Ming Std L"/>
+      <typeface name="Adobe Song Std L"/>
+      <typeface name="Adobe Myungjo Std M"/>
+    </typefaces>
+  </locale>
+</localeSet>
+endstream
+endobj
+7 0 obj <<
+  /Length 11
+>>
+stream
+</xdp:xdp>
+endstream
+endobj
+8 0 obj <<
+  /Type /Pages
+  /Count 1
+  /Kids [9 0 R]
+>>
+endobj
+9 0 obj <<
+  /Type /Page
+  /Parent 2 0 R
+  /MediaBox [0 0 612 792]
+>>
+endobj
+trailer <<
+  /Root 1 0 R
+>>
+%%EOF
diff --git a/pdf/pdfium/fuzzers/corpora/xfa/xfa_textfield.pdf b/pdf/pdfium/fuzzers/corpora/xfa/xfa_textfield.pdf
new file mode 100644
index 000000000000..38aaf0e11cc3
--- /dev/null
+++ b/pdf/pdfium/fuzzers/corpora/xfa/xfa_textfield.pdf
@@ -0,0 +1,249 @@
+%PDF-1.7
+%
+1 0 obj <<
+  /AcroForm 2 0 R
+  /Extensions <<
+    /ADBE <<
+      /BaseVersion /1.7
+      /ExtensionLevel 8
+    >>
+  >>
+  /NeedsRendering true
+  /Pages 8 0 R
+  /Type /Catalog
+>>
+endobj
+2 0 obj <<
+  /XFA [
+    (preamble)
+    3 0 R
+    (config)
+    4 0 R
+    (template)
+    5 0 R
+    (localeSet)
+    6 0 R
+    (postamble)
+    7 0 R
+  ]
+>>
+endobj
+3 0 obj <<
+  /Length 124
+>>
+stream
+<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/" timeStamp="2018-02-23T21:37:11Z" uuid="21482798-7bf0-40a4-bc5d-3cefdccf32b5">
+endstream
+endobj
+4 0 obj <<
+  /Length 642
+>>
+stream
+<config xmlns="http://www.xfa.org/schema/xci/3.0/">
+<agent name="designer">
+  <destination>pdf</destination>
+  <pdf>
+    <fontInfo/>
+  </pdf>
+</agent>
+<present>
+  <pdf>
+    <version>1.7</version>
+    <adobeExtensionLevel>8</adobeExtensionLevel>
+    <renderPolicy>client</renderPolicy>
+    <scriptModel>XFA</scriptModel>
+    <interactive>1</interactive>
+  </pdf>
+  <xdp>
+    <packets>*</packets>
+  </xdp>
+  <destination>pdf</destination>
+  <script>
+    <runScripts>server</runScripts>
+  </script>
+</present>
+<acrobat>
+  <acrobat7>
+    <dynamicRender>required</dynamicRender>
+  </acrobat7>
+  <validate>preSubmit</validate>
+</acrobat>
+</config>
+endstream
+endobj
+5 0 obj <<
+  /Length 1144
+>>
+stream
+<template xmlns="http://www.xfa.org/schema/xfa-template/3.3/">
+  <subform name="form1" layout="tb" locale="en_US" restoreState="auto">
+    <pageSet>
+      <pageArea name="Page1" id="Page1">
+        <contentArea x="18pt" y="18pt" w="612pt" h="792pt"/>
+        <medium stock="default" short="612pt" long="792pt"/>
+      </pageArea>
+    </pageSet>
+    <subform w="576pt" h="756pt" name="Page1">
+      <field name="TextField1" y="0pt" x="0pt" w="200pt" h="32pt">
+        <font typeface="Ahem" size="20pt"/>
+        <ui>
+          <textEdit/>
+        </ui>
+        <para vAlign="middle"/>
+      </field>
+      <field name="Button1" y="42pt" x="0pt" w="100pt" h="32pt">
+        <ui>
+          <button highlight="inverted"/>
+        </ui>
+        <font typeface="Ahem" size="20pt"/>
+        <caption>
+          <value>
+            <text>Dummy</text>
+          </value>
+          <para vAlign="middle" hAlign="center"/>
+        </caption>
+        <border hand="right">
+          <edge stroke="raised"/>
+          <fill>
+            <color value="212,208,200"/>
+          </fill>
+        </border>
+      </field>
+    </subform>
+  </subform>
+</template>
+endstream
+endobj
+6 0 obj <<
+  /Length 3455
+>>
+stream
+<localeSet xmlns="http://www.xfa.org/schema/xfa-locale-set/2.7/">
+  <locale name="en_US" desc="English (United States)">
+    <calendarSymbols name="gregorian">
+      <monthNames>
+        <month>January</month>
+        <month>February</month>
+        <month>March</month>
+        <month>April</month>
+        <month>May</month>
+        <month>June</month>
+        <month>July</month>
+        <month>August</month>
+        <month>September</month>
+        <month>October</month>
+        <month>November</month>
+        <month>December</month>
+      </monthNames>
+      <monthNames abbr="1">
+        <month>Jan</month>
+        <month>Feb</month>
+        <month>Mar</month>
+        <month>Apr</month>
+        <month>May</month>
+        <month>Jun</month>
+        <month>Jul</month>
+        <month>Aug</month>
+        <month>Sep</month>
+        <month>Oct</month>
+        <month>Nov</month>
+        <month>Dec</month>
+      </monthNames>
+      <dayNames>
+        <day>Sunday</day>
+        <day>Monday</day>
+        <day>Tuesday</day>
+        <day>Wednesday</day>
+        <day>Thursday</day>
+        <day>Friday</day>
+        <day>Saturday</day>
+      </dayNames>
+      <dayNames abbr="1">
+        <day>Sun</day>
+        <day>Mon</day>
+        <day>Tue</day>
+        <day>Wed</day>
+        <day>Thu</day>
+        <day>Fri</day>
+        <day>Sat</day>
+      </dayNames>
+      <meridiemNames>
+        <meridiem>AM</meridiem>
+        <meridiem>PM</meridiem>
+      </meridiemNames>
+      <eraNames>
+        <era>BC</era>
+        <era>AD</era>
+      </eraNames>
+    </calendarSymbols>
+    <datePatterns>
+      <datePattern name="full">EEEE, MMMM D, YYYY</datePattern>
+      <datePattern name="long">MMMM D, YYYY</datePattern>
+      <datePattern name="med">MMM D, YYYY</datePattern>
+      <datePattern name="short">M/D/YY</datePattern>
+    </datePatterns>
+    <timePatterns>
+      <timePattern name="full">h:MM:SS A Z</timePattern>
+      <timePattern name="long">h:MM:SS A Z</timePattern>
+      <timePattern name="med">h:MM:SS A</timePattern>
+      <timePattern name="short">h:MM A</timePattern>
+    </timePatterns>
+    <dateTimeSymbols>GyMdkHmsSEDFwWahKzZ</dateTimeSymbols>
+    <numberPatterns>
+      <numberPattern name="numeric">z,zz9.zzz</numberPattern>
+      <numberPattern name="currency">$z,zz9.99|($z,zz9.99)</numberPattern>
+      <numberPattern name="percent">z,zz9%</numberPattern>
+    </numberPatterns>
+    <numberSymbols>
+      <numberSymbol name="decimal">.</numberSymbol>
+      <numberSymbol name="grouping">,</numberSymbol>
+      <numberSymbol name="percent">%</numberSymbol>
+      <numberSymbol name="minus">-</numberSymbol>
+      <numberSymbol name="zero">0</numberSymbol>
+    </numberSymbols>
+    <currencySymbols>
+      <currencySymbol name="symbol">$</currencySymbol>
+      <currencySymbol name="isoname">USD</currencySymbol>
+      <currencySymbol name="decimal">.</currencySymbol>
+    </currencySymbols>
+    <typefaces>
+      <typeface name="Myriad Pro"/>
+      <typeface name="Minion Pro"/>
+      <typeface name="Courier Std"/>
+      <typeface name="Adobe Pi Std"/>
+      <typeface name="Adobe Hebrew"/>
+      <typeface name="Adobe Arabic"/>
+      <typeface name="Adobe Thai"/>
+      <typeface name="Kozuka Gothic Pro-VI M"/>
+      <typeface name="Kozuka Mincho Pro-VI R"/>
+      <typeface name="Adobe Ming Std L"/>
+      <typeface name="Adobe Song Std L"/>
+      <typeface name="Adobe Myungjo Std M"/>
+    </typefaces>
+  </locale>
+</localeSet>
+endstream
+endobj
+7 0 obj <<
+  /Length 11
+>>
+stream
+</xdp:xdp>
+endstream
+endobj
+8 0 obj <<
+  /Type /Pages
+  /Count 1
+  /Kids [9 0 R]
+>>
+endobj
+9 0 obj <<
+  /Type /Page
+  /Parent 2 0 R
+  /MediaBox [0 0 612 792]
+>>
+endobj
+trailer <<
+  /Root 1 0 R
+>>
+%%EOF
diff --git a/pdf/pdfium/fuzzers/dicts/pdf_xfa_js.dict b/pdf/pdfium/fuzzers/dicts/pdf_xfa_js.dict
new file mode 100644
index 000000000000..824328d05ee4
--- /dev/null
+++ b/pdf/pdfium/fuzzers/dicts/pdf_xfa_js.dict
@@ -0,0 +1,215 @@
+# Copyright 2019 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+# Extracted from JSE_METHOD and JSE_PROP entries in PDFium's fxjs/xfa directory.
+
+# JSE_METHOD
+
+"absPage"
+"absPageCount"
+"absPageCountInBatch"
+"absPageInBatch"
+"absPageSpan"
+"addInstance"
+"addItem"
+"addNew"
+"append"
+"applyXSL"
+"assignNode"
+"beep"
+"boundItem"
+"cancel"
+"cancelBatch"
+"clear"
+"clearErrorList"
+"clearItems"
+"clone"
+"close"
+"createNode"
+"deleteItem"
+"documentCountInBatch"
+"documentInBatch"
+"emit"
+"enumerate"
+"evaluate"
+"execCalculate"
+"execEvent"
+"execInitialize"
+"execute"
+"execValidate"
+"exportData"
+"first"
+"formNodes"
+"getAttribute"
+"getDelta"
+"getDeltas"
+"getDisplayItem"
+"getElement"
+"getFocus"
+"getItemState"
+"getSaveItem"
+"gotoRecord"
+"gotoURL"
+"h"
+"hasDataChanged"
+"importData"
+"insert"
+"insertInstance"
+"isBOF"
+"isCompatibleNS"
+"isEOF"
+"isPropertySpecified"
+"isRecordGroup"
+"item"
+"last"
+"loadXML"
+"message"
+"messageBox"
+"metadata"
+"method_name"
+"moveCurrentRecord"
+"moveInstance"
+"namedItem"
+"next"
+"open"
+"openList"
+"page"
+"pageContent"
+"pageCount"
+"pageDown"
+"pageSpan"
+"pageUp"
+"previous"
+"print"
+"recalculate"
+"record"
+"relayout"
+"relayoutPageArea"
+"remerge"
+"remove"
+"removeAttribute"
+"removeInstance"
+"requery"
+"reset"
+"resetData"
+"resolveNode"
+"resolveNodes"
+"response"
+"restore"
+"resync"
+"saveFilteredXML"
+"saveXML"
+"selectedMember"
+"setAttribute"
+"setElement"
+"setFocus"
+"setInstances"
+"setItemState"
+"sheet"
+"sheetCount"
+"sheetCountInBatch"
+"sheetInBatch"
+"sign"
+"trace"
+"traceActivate"
+"traceDeactivate"
+"traceEnabled"
+"update"
+"updateBatch"
+"verifySignature"
+"w"
+"x"
+"y"
+
+# JSE_PROP
+
+"aliasNode"
+"all"
+"appType"
+"calculationsEnabled"
+"cancelAction"
+"change"
+"checksumS"
+"classAll"
+"classIndex"
+"className"
+"commitKey"
+"content"
+"context"
+"count"
+"currentPage"
+"currentRecordNumber"
+"currentValue"
+"db"
+"defaultValue"
+"editValue"
+"errorText"
+"format"
+"formatMessage"
+"formattedValue"
+"fullText"
+"index"
+"instanceManager"
+"isContainer"
+"isDefined"
+"isNull"
+"keyDown"
+"language"
+"length"
+"locale"
+"max"
+"min"
+"model"
+"modifier"
+"name"
+"newContentType"
+"newText"
+"nodes"
+"ns"
+"numPages"
+"oneOfChild"
+"parent"
+"parentSubform"
+"platform"
+"prevContentType"
+"prevText"
+"prop_name"
+"rawValue"
+"ready"
+"recordsAfter"
+"recordsBefore"
+"reenter"
+"savedValue"
+"ScriptAttributeBool"
+"ScriptAttributeInteger"
+"ScriptAttributeString"
+"ScriptSomBorderColor"
+"ScriptSomBorderWidth"
+"ScriptSomDataNode"
+"ScriptSomDefaultValue"
+"ScriptSomDefaultValue_Read"
+"ScriptSomFillColor"
+"ScriptSomFontColor"
+"ScriptSomInstanceIndex"
+"ScriptSomMandatory"
+"ScriptSomMandatoryMessage"
+"ScriptSomValidationMessage"
+"ScriptSubmitFormatMode"
+"selectedIndex"
+"selEnd"
+"selStart"
+"shift"
+"soapFaultCode"
+"soapFaultString"
+"somExpression"
+"stateless"
+"target"
+"thisValue"
+"title"
+"transient"
+"type"
+"validationsEnabled"
+"value"
+"variation"
+"version"
diff --git a/pdf/pdfium/fuzzers/pdfium_fuzzer.cc b/pdf/pdfium/fuzzers/pdfium_fuzzer.cc
deleted file mode 100644
index 1e8d9c210823..000000000000
--- a/pdf/pdfium/fuzzers/pdfium_fuzzer.cc
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "pdf/pdfium/fuzzers/pdfium_fuzzer_helper.h"
-
-class PDFiumFuzzer : public PDFiumFuzzerHelper {
- public:
-  PDFiumFuzzer() : PDFiumFuzzerHelper() {}
-  ~PDFiumFuzzer() override = default;
-
-  int GetFormCallbackVersion() const override { return 1; }
-};
-
-extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
-  PDFiumFuzzer fuzzer;
-  fuzzer.RenderPdf(reinterpret_cast<const char*>(data), size);
-  return 0;
-}
diff --git a/pdf/pdfium/fuzzers/pdfium_fuzzer_helper.cc b/pdf/pdfium/fuzzers/pdfium_fuzzer_helper.cc
deleted file mode 100644
index ac704de2ffca..000000000000
--- a/pdf/pdfium/fuzzers/pdfium_fuzzer_helper.cc
+++ /dev/null
@@ -1,262 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-// This fuzzer is simplified & cleaned up pdfium/samples/pdfium_test.cc
-
-#include "pdf/pdfium/fuzzers/pdfium_fuzzer_helper.h"
-
-#include <assert.h>
-#include <limits.h>
-
-#include <stddef.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#ifdef _WIN32
-#include <Windows.h>
-#elif defined(__APPLE__)
-#include <mach-o/dyld.h>
-#else  // Linux
-#include <unistd.h>
-#endif  // _WIN32
-
-#include <memory>
-#include <sstream>
-#include <string>
-#include <utility>
-
-#include "base/memory/free_deleter.h"
-#include "third_party/pdfium/public/cpp/fpdf_scopers.h"
-#include "third_party/pdfium/public/fpdf_dataavail.h"
-#include "third_party/pdfium/public/fpdf_text.h"
-#include "third_party/pdfium/testing/test_support.h"
-#include "v8/include/v8-platform.h"
-
-namespace {
-
-int ExampleAppAlert(IPDF_JSPLATFORM*,
-                    FPDF_WIDESTRING,
-                    FPDF_WIDESTRING,
-                    int,
-                    int) {
-  return 0;
-}
-
-int ExampleAppResponse(IPDF_JSPLATFORM*,
-                       FPDF_WIDESTRING question,
-                       FPDF_WIDESTRING title,
-                       FPDF_WIDESTRING default_value,
-                       FPDF_WIDESTRING label,
-                       FPDF_BOOL is_password,
-                       void* response,
-                       int length) {
-  // UTF-16, always LE regardless of platform.
-  uint8_t* ptr = static_cast<uint8_t*>(response);
-  ptr[0] = 'N';
-  ptr[1] = 0;
-  ptr[2] = 'o';
-  ptr[3] = 0;
-  return 4;
-}
-
-void ExampleDocGotoPage(IPDF_JSPLATFORM*, int pageNumber) {}
-
-void ExampleDocMail(IPDF_JSPLATFORM*,
-                    void* mailData,
-                    int length,
-                    FPDF_BOOL UI,
-                    FPDF_WIDESTRING To,
-                    FPDF_WIDESTRING Subject,
-                    FPDF_WIDESTRING CC,
-                    FPDF_WIDESTRING BCC,
-                    FPDF_WIDESTRING Msg) {}
-
-void ExampleUnsupportedHandler(UNSUPPORT_INFO*, int type) {}
-
-FPDF_BOOL Is_Data_Avail(FX_FILEAVAIL* pThis, size_t offset, size_t size) {
-  return true;
-}
-
-void Add_Segment(FX_DOWNLOADHINTS* pThis, size_t offset, size_t size) {}
-
-std::string ProgramPath() {
-  std::string result;
-
-#ifdef _WIN32
-  wchar_t wpath[MAX_PATH];
-  char path[MAX_PATH];
-  DWORD len = GetModuleFileNameA(NULL, path, MAX_PATH);
-  if (len != 0)
-    result = std::string(path, len);
-#elif defined(__APPLE__)
-  char path[PATH_MAX];
-  unsigned int len = PATH_MAX;
-  if (!_NSGetExecutablePath(path, &len)) {
-    std::unique_ptr<char, base::FreeDeleter> resolved_path(
-        realpath(path, nullptr));
-    if (resolved_path.get())
-      result = std::string(resolved_path.get());
-  }
-#else  // Linux
-  char path[PATH_MAX];
-  ssize_t len = readlink("/proc/self/exe", path, PATH_MAX);
-  if (len > 0)
-    result = std::string(path, len);
-#endif
-  return result;
-}
-
-}  // namespace
-
-PDFiumFuzzerHelper::PDFiumFuzzerHelper() = default;
-
-PDFiumFuzzerHelper::~PDFiumFuzzerHelper() = default;
-
-bool PDFiumFuzzerHelper::OnFormFillEnvLoaded(FPDF_DOCUMENT doc) {
-  return true;
-}
-
-void PDFiumFuzzerHelper::RenderPdf(const char* pBuf, size_t len) {
-  IPDF_JSPLATFORM platform_callbacks;
-  memset(&platform_callbacks, '\0', sizeof(platform_callbacks));
-  platform_callbacks.version = 3;
-  platform_callbacks.app_alert = ExampleAppAlert;
-  platform_callbacks.app_response = ExampleAppResponse;
-  platform_callbacks.Doc_gotoPage = ExampleDocGotoPage;
-  platform_callbacks.Doc_mail = ExampleDocMail;
-
-  FPDF_FORMFILLINFO form_callbacks;
-  memset(&form_callbacks, '\0', sizeof(form_callbacks));
-  form_callbacks.version = GetFormCallbackVersion();
-  form_callbacks.m_pJsPlatform = &platform_callbacks;
-
-  TestLoader loader(pBuf, len);
-  FPDF_FILEACCESS file_access;
-  memset(&file_access, '\0', sizeof(file_access));
-  file_access.m_FileLen = static_cast<unsigned long>(len);
-  file_access.m_GetBlock = TestLoader::GetBlock;
-  file_access.m_Param = &loader;
-
-  FX_FILEAVAIL file_avail;
-  memset(&file_avail, '\0', sizeof(file_avail));
-  file_avail.version = 1;
-  file_avail.IsDataAvail = Is_Data_Avail;
-
-  FX_DOWNLOADHINTS hints;
-  memset(&hints, '\0', sizeof(hints));
-  hints.version = 1;
-  hints.AddSegment = Add_Segment;
-
-  ScopedFPDFAvail pdf_avail(FPDFAvail_Create(&file_avail, &file_access));
-
-  int nRet = PDF_DATA_NOTAVAIL;
-  bool bIsLinearized = false;
-  ScopedFPDFDocument doc;
-  if (FPDFAvail_IsLinearized(pdf_avail.get()) == PDF_LINEARIZED) {
-    doc.reset(FPDFAvail_GetDocument(pdf_avail.get(), nullptr));
-    if (doc) {
-      while (nRet == PDF_DATA_NOTAVAIL)
-        nRet = FPDFAvail_IsDocAvail(pdf_avail.get(), &hints);
-
-      if (nRet == PDF_DATA_ERROR)
-        return;
-
-      nRet = FPDFAvail_IsFormAvail(pdf_avail.get(), &hints);
-      if (nRet == PDF_FORM_ERROR || nRet == PDF_FORM_NOTAVAIL)
-        return;
-
-      bIsLinearized = true;
-    }
-  } else {
-    doc.reset(FPDF_LoadCustomDocument(&file_access, nullptr));
-  }
-
-  if (!doc)
-    return;
-
-  (void)FPDF_GetDocPermissions(doc.get());
-
-  ScopedFPDFFormHandle form(
-      FPDFDOC_InitFormFillEnvironment(doc.get(), &form_callbacks));
-  if (!OnFormFillEnvLoaded(doc.get()))
-    return;
-
-  FPDF_SetFormFieldHighlightColor(form.get(), FPDF_FORMFIELD_UNKNOWN, 0xFFE4DD);
-  FPDF_SetFormFieldHighlightAlpha(form.get(), 100);
-  FORM_DoDocumentJSAction(form.get());
-  FORM_DoDocumentOpenAction(form.get());
-
-  int page_count = FPDF_GetPageCount(doc.get());
-  for (int i = 0; i < page_count; ++i) {
-    if (bIsLinearized) {
-      nRet = PDF_DATA_NOTAVAIL;
-      while (nRet == PDF_DATA_NOTAVAIL)
-        nRet = FPDFAvail_IsPageAvail(pdf_avail.get(), i, &hints);
-
-      if (nRet == PDF_DATA_ERROR)
-        return;
-    }
-    RenderPage(doc.get(), form.get(), i);
-  }
-  FORM_DoDocumentAAction(form.get(), FPDFDOC_AACTION_WC);
-}
-
-bool PDFiumFuzzerHelper::RenderPage(FPDF_DOCUMENT doc,
-                                    FPDF_FORMHANDLE form,
-                                    const int page_index) {
-  ScopedFPDFPage page(FPDF_LoadPage(doc, page_index));
-  if (!page)
-    return false;
-
-  ScopedFPDFTextPage text_page(FPDFText_LoadPage(page.get()));
-  FORM_OnAfterLoadPage(page.get(), form);
-  FORM_DoPageAAction(page.get(), form, FPDFPAGE_AACTION_OPEN);
-
-  const double scale = 1.0;
-  int width = static_cast<int>(FPDF_GetPageWidth(page.get()) * scale);
-  int height = static_cast<int>(FPDF_GetPageHeight(page.get()) * scale);
-  ScopedFPDFBitmap bitmap(FPDFBitmap_Create(width, height, 0));
-  if (bitmap) {
-    FPDFBitmap_FillRect(bitmap.get(), 0, 0, width, height, 0xFFFFFFFF);
-    FPDF_RenderPageBitmap(bitmap.get(), page.get(), 0, 0, width, height, 0, 0);
-    FPDF_FFLDraw(form, bitmap.get(), page.get(), 0, 0, width, height, 0, 0);
-  }
-  FORM_DoPageAAction(page.get(), form, FPDFPAGE_AACTION_CLOSE);
-  FORM_OnBeforeClosePage(page.get(), form);
-  return !!bitmap;
-}
-
-// Initialize the library once for all runs of the fuzzer.
-struct TestCase {
-  TestCase() {
-#ifdef V8_USE_EXTERNAL_STARTUP_DATA
-    platform = InitializeV8ForPDFiumWithStartupData(
-        ProgramPath(), "", &natives_blob, &snapshot_blob);
-#else
-    platform = InitializeV8ForPDFium(ProgramPath());
-#endif
-
-    memset(&config, '\0', sizeof(config));
-    config.version = 2;
-    config.m_pUserFontPaths = nullptr;
-    config.m_pIsolate = nullptr;
-    config.m_v8EmbedderSlot = 0;
-    FPDF_InitLibraryWithConfig(&config);
-
-    memset(&unsupport_info, '\0', sizeof(unsupport_info));
-    unsupport_info.version = 1;
-    unsupport_info.FSDK_UnSupport_Handler = ExampleUnsupportedHandler;
-    FSDK_SetUnSpObjProcessHandler(&unsupport_info);
-  }
-
-  std::unique_ptr<v8::Platform> platform;
-  v8::StartupData natives_blob;
-  v8::StartupData snapshot_blob;
-  FPDF_LIBRARY_CONFIG config;
-  UNSUPPORT_INFO unsupport_info;
-};
-
-static TestCase* test_case = new TestCase();
diff --git a/pdf/pdfium/fuzzers/pdfium_fuzzer_helper.h b/pdf/pdfium/fuzzers/pdfium_fuzzer_helper.h
deleted file mode 100644
index 8a3fe8cac9dd..000000000000
--- a/pdf/pdfium/fuzzers/pdfium_fuzzer_helper.h
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef PDF_PDFIUM_FUZZERS_PDFIUM_FUZZER_HELPER_H_
-#define PDF_PDFIUM_FUZZERS_PDFIUM_FUZZER_HELPER_H_
-
-// This fuzzer is simplified & cleaned up pdfium/samples/pdfium_test.cc
-
-#include "third_party/pdfium/public/fpdf_ext.h"
-#include "third_party/pdfium/public/fpdf_formfill.h"
-#include "third_party/pdfium/public/fpdfview.h"
-#include "v8/include/v8.h"
-
-class PDFiumFuzzerHelper {
- public:
-  virtual ~PDFiumFuzzerHelper();
-
-  void RenderPdf(const char* pBuf, size_t len);
-
-  virtual int GetFormCallbackVersion() const = 0;
-  virtual bool OnFormFillEnvLoaded(FPDF_DOCUMENT doc);
-
- protected:
-  PDFiumFuzzerHelper();
-
- private:
-  bool RenderPage(FPDF_DOCUMENT doc,
-                  FPDF_FORMHANDLE form,
-                  const int page_index);
-};
-
-#endif  // PDF_PDFIUM_FUZZERS_PDFIUM_FUZZER_HELPER_H_
diff --git a/pdf/pdfium/fuzzers/pdfium_xfa_fuzzer.cc b/pdf/pdfium/fuzzers/pdfium_xfa_fuzzer.cc
deleted file mode 100644
index bac055c83e01..000000000000
--- a/pdf/pdfium/fuzzers/pdfium_xfa_fuzzer.cc
+++ /dev/null
@@ -1,28 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "pdf/pdfium/fuzzers/pdfium_fuzzer_helper.h"
-
-class PDFiumXFAFuzzer : public PDFiumFuzzerHelper {
- public:
-  PDFiumXFAFuzzer() : PDFiumFuzzerHelper() {}
-  ~PDFiumXFAFuzzer() override {}
-
-  int GetFormCallbackVersion() const override { return 2; }
-
-  // Return false if XFA doesn't load as otherwise we're duplicating the work
-  // done by the non-xfa fuzzer.
-  bool OnFormFillEnvLoaded(FPDF_DOCUMENT doc) override {
-    int form_type = FPDF_GetFormType(doc);
-    if (form_type != FORMTYPE_XFA_FULL && form_type != FORMTYPE_XFA_FOREGROUND)
-      return false;
-    return FPDF_LoadXFA(doc);
-  }
-};
-
-extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
-  PDFiumXFAFuzzer fuzzer;
-  fuzzer.RenderPdf(reinterpret_cast<const char*>(data), size);
-  return 0;
-}
diff --git a/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/fuzzer.cc b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/fuzzer.cc
new file mode 100644
index 000000000000..b9dcafacef98
--- /dev/null
+++ b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/fuzzer.cc
@@ -0,0 +1,26 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stdio.h>
+
+#include "pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/proto_to_xfa.h"
+#include "pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/simple_xfa_pdf.h"
+#include "pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/xfa.pb.h"
+#include "testing/libfuzzer/proto/lpm_interface.h"
+#include "third_party/pdfium/testing/fuzzers/pdfium_xfa_lpm_fuzz_stub.h"
+
+namespace pdfium_xfa_lpm_fuzzer {
+
+DEFINE_PROTO_FUZZER(const xfa_proto::Xfa& xfa) {
+  xfa_proto::ProtoToXfa proto_to_xfa;
+  std::string xfa_string = proto_to_xfa.Convert(xfa);
+  std::string pdf_string = CreateSimpleXfaPdf(xfa_string);
+  if (getenv("LPM_DUMP_NATIVE_INPUT")) {
+    for (auto c : pdf_string)
+      putc(c, stdout);
+  }
+  PdfiumXFALPMFuzzStub(pdf_string.c_str(), pdf_string.size());
+}
+
+}  // namespace pdfium_xfa_lpm_fuzzer
diff --git a/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/proto_to_xfa.cc b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/proto_to_xfa.cc
new file mode 100644
index 000000000000..aabf0cbf865a
--- /dev/null
+++ b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/proto_to_xfa.cc
@@ -0,0 +1,17 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/proto_to_xfa.h"
+
+namespace xfa_proto {
+
+ProtoToXfa::ProtoToXfa() = default;
+ProtoToXfa::~ProtoToXfa() = default;
+
+std::string ProtoToXfa::Convert(const Xfa& xfa) {
+  // TODO(metzman): Actually return an XFA form rather than an empty string.
+  return "";
+}
+
+}  // namespace xfa_proto
diff --git a/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/proto_to_xfa.h b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/proto_to_xfa.h
new file mode 100644
index 000000000000..6b830915c3f0
--- /dev/null
+++ b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/proto_to_xfa.h
@@ -0,0 +1,24 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef PDF_PDFIUM_FUZZERS_PDFIUM_XFA_LPM_FUZZER_PROTO_TO_XFA_H_
+#define PDF_PDFIUM_FUZZERS_PDFIUM_XFA_LPM_FUZZER_PROTO_TO_XFA_H_
+
+#include <string>
+
+#include "pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/xfa.pb.h"
+
+namespace xfa_proto {
+
+class ProtoToXfa {
+ public:
+  ProtoToXfa();
+  ~ProtoToXfa();
+
+  std::string Convert(const Xfa& xfa);
+};
+
+}  // namespace xfa_proto
+
+#endif  // PDF_PDFIUM_FUZZERS_PDFIUM_XFA_LPM_FUZZER_PROTO_TO_XFA_H_
diff --git a/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/simple_xfa_pdf.cc b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/simple_xfa_pdf.cc
new file mode 100644
index 000000000000..45201c819be9
--- /dev/null
+++ b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/simple_xfa_pdf.cc
@@ -0,0 +1,89 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <string>
+#include <vector>
+
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/simple_xfa_pdf.h"
+
+namespace pdfium_xfa_lpm_fuzzer {
+
+namespace {
+
+const char kSimplePdfTemplate[] = R"(%PDF-1.7
+%
+  
+1 0 obj <<
+/XFA 5 0 R
+>>
+endobj
+2 0 obj <<
+/Type /Pages
+/Count 1
+/Kids [3 0 R]
+>>
+endobj
+3 0 obj <<
+/Type /Page
+/MediaBox [0 0 600 800]
+/Parent 2 0 R
+>>
+endobj
+4 0 obj <<
+/Extensions <<
+/ADBE <<
+/BaseVersion /1.0
+/ExtensionLevel 8
+>>
+>>
+/Pages 2 0 R
+/Type /Catalog
+/AcroForm 1 0 R
+/NeedsRendering true
+>>
+endobj
+5 0 obj <<
+/Length $1
+>>
+stream
+$2
+endstream
+endobj
+xref
+6 0
+0000000000 65535 f 
+0000000015 00000 n 
+0000000047 00000 n 
+0000000104 00000 n 
+0000000175 00000 n 
+0000000327 00000 n 
+trailer <<
+/Size 6
+/Root 4 0 R
+>>
+startxref
+$3
+%%EOF)";
+
+}  // namespace
+
+std::string CreateSimpleXfaPdf(const std::string& xfa_string) {
+  // Add 1 for newline before endstream.
+  std::string xfa_stream_len = base::NumberToString(xfa_string.size() + 1);
+  // Each placeholder is two bytes. Two of them precede xref.
+  const size_t kPlaceholderSizes = 2 * 2;
+  static const size_t kCurrentXrefPosition =
+      std::string(kSimplePdfTemplate).find("xref");
+  std::string startxref =
+      base::NumberToString(kCurrentXrefPosition - kPlaceholderSizes +
+                           xfa_string.size() + xfa_stream_len.size() + 1);
+  std::vector<std::string> replacements(
+      {xfa_stream_len, xfa_string, startxref});
+  return base::ReplaceStringPlaceholders(kSimplePdfTemplate, replacements,
+                                         nullptr);
+}
+
+}  // namespace pdfium_xfa_lpm_fuzzer
diff --git a/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/simple_xfa_pdf.h b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/simple_xfa_pdf.h
new file mode 100644
index 000000000000..e2f2990b9c6a
--- /dev/null
+++ b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/simple_xfa_pdf.h
@@ -0,0 +1,16 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef PDF_PDFIUM_FUZZERS_PDFIUM_XFA_LPM_FUZZER_SIMPLE_XFA_PDF_H_
+#define PDF_PDFIUM_FUZZERS_PDFIUM_XFA_LPM_FUZZER_SIMPLE_XFA_PDF_H_
+
+#include <string>
+
+namespace pdfium_xfa_lpm_fuzzer {
+
+std::string CreateSimpleXfaPdf(const std::string& xfa_string);
+
+}  // namespace pdfium_xfa_lpm_fuzzer
+
+#endif  // PDF_PDFIUM_FUZZERS_PDFIUM_XFA_LPM_FUZZER_SIMPLE_XFA_PDF_H_
diff --git a/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/simple_xfa_pdf_unittest.cc b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/simple_xfa_pdf_unittest.cc
new file mode 100644
index 000000000000..50e53ef0840c
--- /dev/null
+++ b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/simple_xfa_pdf_unittest.cc
@@ -0,0 +1,84 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/simple_xfa_pdf.h"
+
+#include <string>
+#include <utility>
+
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace {
+
+const char kEmptyXfa[] = "";
+const char kEmptyXfaPdf[] = R"(%PDF-1.7
+%
+  
+1 0 obj <<
+/XFA 5 0 R
+>>
+endobj
+2 0 obj <<
+/Type /Pages
+/Count 1
+/Kids [3 0 R]
+>>
+endobj
+3 0 obj <<
+/Type /Page
+/MediaBox [0 0 600 800]
+/Parent 2 0 R
+>>
+endobj
+4 0 obj <<
+/Extensions <<
+/ADBE <<
+/BaseVersion /1.0
+/ExtensionLevel 8
+>>
+>>
+/Pages 2 0 R
+/Type /Catalog
+/AcroForm 1 0 R
+/NeedsRendering true
+>>
+endobj
+5 0 obj <<
+/Length 1
+>>
+stream
+
+endstream
+endobj
+xref
+6 0
+0000000000 65535 f 
+0000000015 00000 n 
+0000000047 00000 n 
+0000000104 00000 n 
+0000000175 00000 n 
+0000000327 00000 n 
+trailer <<
+/Size 6
+/Root 4 0 R
+>>
+startxref
+376
+%%EOF)";
+
+}  // namespace
+
+class SimpleXfaPdfTest
+    : public ::testing::TestWithParam<std::pair<std::string, std::string>> {};
+
+TEST_P(SimpleXfaPdfTest, CheckTranslation) {
+  const std::pair<std::string, std::string>& param = GetParam();
+  ASSERT_EQ(param.second,
+            pdfium_xfa_lpm_fuzzer::CreateSimpleXfaPdf(param.first));
+}
+
+INSTANTIATE_TEST_SUITE_P(LpmFuzzer,
+                         SimpleXfaPdfTest,
+                         ::testing::Values(std::make_pair(kEmptyXfa,
+                                                          kEmptyXfaPdf)));
diff --git a/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/xfa.proto b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/xfa.proto
new file mode 100644
index 000000000000..b0c18f8bb24d
--- /dev/null
+++ b/pdf/pdfium/fuzzers/pdfium_xfa_lpm_fuzzer/xfa.proto
@@ -0,0 +1,5 @@
+syntax = "proto2";
+
+package xfa_proto;
+
+message Xfa {}
\ No newline at end of file
diff --git a/pdf/pdfium/pdfium_api_string_buffer_adapter.cc b/pdf/pdfium/pdfium_api_string_buffer_adapter.cc
index d7ddd8513214..35da69a615e1 100644
--- a/pdf/pdfium/pdfium_api_string_buffer_adapter.cc
+++ b/pdf/pdfium/pdfium_api_string_buffer_adapter.cc
@@ -6,14 +6,13 @@
 
 #include <stddef.h>
 
-#include <string>
-
-#include "base/logging.h"
-#include "base/strings/string16.h"
+#include "base/check_op.h"
 #include "base/strings/string_util.h"
 
 namespace chrome_pdf {
 
+namespace internal {
+
 template <class StringType>
 PDFiumAPIStringBufferAdapter<StringType>::PDFiumAPIStringBufferAdapter(
     StringType* str,
@@ -52,36 +51,30 @@ void PDFiumAPIStringBufferAdapter<StringType>::Close(size_t actual_size) {
   }
 }
 
-template <class StringType>
-PDFiumAPIStringBufferSizeInBytesAdapter<StringType>::
-    PDFiumAPIStringBufferSizeInBytesAdapter(StringType* str,
+PDFiumAPIStringBufferSizeInBytesAdapter::
+    PDFiumAPIStringBufferSizeInBytesAdapter(std::u16string* str,
                                             size_t expected_size,
                                             bool check_expected_size)
-    : adapter_(str,
-               expected_size / sizeof(typename StringType::value_type),
-               check_expected_size) {
-  DCHECK(expected_size % sizeof(typename StringType::value_type) == 0);
+    : adapter_(str, expected_size / sizeof(char16_t), check_expected_size) {
+  DCHECK(expected_size % sizeof(char16_t) == 0);
 }
 
-template <class StringType>
-PDFiumAPIStringBufferSizeInBytesAdapter<
-    StringType>::~PDFiumAPIStringBufferSizeInBytesAdapter() = default;
+PDFiumAPIStringBufferSizeInBytesAdapter::
+    ~PDFiumAPIStringBufferSizeInBytesAdapter() = default;
 
-template <class StringType>
-void* PDFiumAPIStringBufferSizeInBytesAdapter<StringType>::GetData() {
+void* PDFiumAPIStringBufferSizeInBytesAdapter::GetData() {
   return adapter_.GetData();
 }
 
-template <class StringType>
-void PDFiumAPIStringBufferSizeInBytesAdapter<StringType>::Close(
-    size_t actual_size) {
-  DCHECK(actual_size % sizeof(typename StringType::value_type) == 0);
-  adapter_.Close(actual_size / sizeof(typename StringType::value_type));
+void PDFiumAPIStringBufferSizeInBytesAdapter::Close(size_t actual_size) {
+  DCHECK(actual_size % sizeof(char16_t) == 0);
+  adapter_.Close(actual_size / sizeof(char16_t));
 }
 
 // explicit instantiations
 template class PDFiumAPIStringBufferAdapter<std::string>;
-template class PDFiumAPIStringBufferAdapter<base::string16>;
-template class PDFiumAPIStringBufferSizeInBytesAdapter<base::string16>;
+template class PDFiumAPIStringBufferAdapter<std::u16string>;
+
+}  // namespace internal
 
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_api_string_buffer_adapter.h b/pdf/pdfium/pdfium_api_string_buffer_adapter.h
index d3a413cd5a7f..4eaaf3c76637 100644
--- a/pdf/pdfium/pdfium_api_string_buffer_adapter.h
+++ b/pdf/pdfium/pdfium_api_string_buffer_adapter.h
@@ -7,16 +7,20 @@
 
 #include <stddef.h>
 
-#include "base/macros.h"
+#include <string>
+
+#include "base/callback.h"
 #include "base/numerics/safe_math.h"
+#include "base/optional.h"
 
 namespace chrome_pdf {
 
-// Helper to deal with the fact that many PDFium APIs write the null-terminator
-// into string buffers that are passed to them, but the PDF plugin likes to pass
-// in std::strings / base::string16s, where one should not count on the internal
-// string buffers to be null-terminated.
+namespace internal {
 
+// Helper to deal with the fact that many PDFium APIs write the null-terminator
+// into string buffers that are passed to them, but the PDF code likes to use
+// std::strings / std::u16strings, where one should not count on the internal
+// string buffers to be null-terminated.
 template <class StringType>
 class PDFiumAPIStringBufferAdapter {
  public:
@@ -28,6 +32,9 @@ class PDFiumAPIStringBufferAdapter {
   PDFiumAPIStringBufferAdapter(StringType* str,
                                size_t expected_size,
                                bool check_expected_size);
+  PDFiumAPIStringBufferAdapter(const PDFiumAPIStringBufferAdapter&) = delete;
+  PDFiumAPIStringBufferAdapter& operator=(const PDFiumAPIStringBufferAdapter&) =
+      delete;
   ~PDFiumAPIStringBufferAdapter();
 
   // Returns a pointer to |str_|'s buffer. The buffer's size is large enough to
@@ -51,16 +58,14 @@ class PDFiumAPIStringBufferAdapter {
   const size_t expected_size_;
   const bool check_expected_size_;
   bool is_closed_;
-
-  DISALLOW_COPY_AND_ASSIGN(PDFiumAPIStringBufferAdapter);
 };
 
 // Helper to deal with the fact that many PDFium APIs write the null-terminator
-// into string buffers that are passed to them, but the PDF plugin likes to pass
-// in std::strings / base::string16s, where one should not count on the internal
+// into string buffers that are passed to them, but the PDF code likes to use
+// std::strings / std::u16strings, where one should not count on the internal
 // string buffers to be null-terminated. This version is suitable for APIs that
-// work in terms of number of bytes instead of the number of characters.
-template <class StringType>
+// work in terms of number of bytes instead of the number of characters. Though
+// for std::strings, PDFiumAPIStringBufferAdapter is equivalent.
 class PDFiumAPIStringBufferSizeInBytesAdapter {
  public:
   // |str| is the string to write into.
@@ -69,19 +74,19 @@ class PDFiumAPIStringBufferSizeInBytesAdapter {
   // character in bytes.
   // |check_expected_size| whether to check the actual number of bytes
   // written into |str| against |expected_size| when calling Close().
-  PDFiumAPIStringBufferSizeInBytesAdapter(StringType* str,
+  PDFiumAPIStringBufferSizeInBytesAdapter(std::u16string* str,
                                           size_t expected_size,
                                           bool check_expected_size);
   ~PDFiumAPIStringBufferSizeInBytesAdapter();
 
   // Returns a pointer to |str_|'s buffer. The buffer's size is large enough to
-  // hold |expected_size_| + sizeof(StringType::value_type) bytes, so the PDFium
-  // API that uses the pointer has space to write a null-terminator.
+  // hold |expected_size_| + sizeof(char16_t) bytes, so the PDFium API that
+  // uses the pointer has space to write a null-terminator.
   void* GetData();
 
-  // Resizes |str_| to |actual_size| - sizeof(StringType::value_type) bytes,
-  // thereby removing the extra null-terminator. This must be called prior to
-  // the adapter's destruction. The pointer returned by GetData() should be
+  // Resizes |str_| to |actual_size| - sizeof(char16_t) bytes, thereby
+  // removing the extra null-terminator. This must be called prior to the
+  // adapter's destruction. The pointer returned by GetData() should be
   // considered invalid.
   void Close(size_t actual_size);
 
@@ -91,9 +96,82 @@ class PDFiumAPIStringBufferSizeInBytesAdapter {
   }
 
  private:
-  PDFiumAPIStringBufferAdapter<StringType> adapter_;
+  PDFiumAPIStringBufferAdapter<std::u16string> adapter_;
 };
 
+template <class AdapterType,
+          class StringType,
+          typename BufferType,
+          typename ReturnType>
+base::Optional<StringType> CallPDFiumStringBufferApiAndReturnOptional(
+    base::RepeatingCallback<ReturnType(BufferType*, ReturnType)> api,
+    bool check_expected_size) {
+  ReturnType expected_size = api.Run(nullptr, 0);
+  if (expected_size == 0)
+    return base::nullopt;
+
+  StringType str;
+  AdapterType api_string_adapter(&str, expected_size, check_expected_size);
+  auto* data = reinterpret_cast<BufferType*>(api_string_adapter.GetData());
+  api_string_adapter.Close(api.Run(data, expected_size));
+  return str;
+}
+
+template <class AdapterType,
+          class StringType,
+          typename BufferType,
+          typename ReturnType>
+StringType CallPDFiumStringBufferApi(
+    base::RepeatingCallback<ReturnType(BufferType*, ReturnType)> api,
+    bool check_expected_size) {
+  base::Optional<StringType> result =
+      CallPDFiumStringBufferApiAndReturnOptional<AdapterType, StringType>(
+          api, check_expected_size);
+  return result.value_or(StringType());
+}
+
+}  // namespace internal
+
+// Helper function to call PDFium APIs where the output buffer is expected to
+// hold UTF-16 data, and the buffer length is specified in bytes.
+template <typename BufferType>
+std::u16string CallPDFiumWideStringBufferApi(
+    base::RepeatingCallback<unsigned long(BufferType*, unsigned long)> api,
+    bool check_expected_size) {
+  using adapter_type = internal::PDFiumAPIStringBufferSizeInBytesAdapter;
+  return internal::CallPDFiumStringBufferApi<adapter_type, std::u16string>(
+      api, check_expected_size);
+}
+
+// Variant of CallPDFiumWideStringBufferApi() that distinguishes between API
+// call failures and empty string return values.
+template <typename BufferType>
+base::Optional<std::u16string> CallPDFiumWideStringBufferApiAndReturnOptional(
+    base::RepeatingCallback<unsigned long(BufferType*, unsigned long)> api,
+    bool check_expected_size) {
+  using adapter_type = internal::PDFiumAPIStringBufferSizeInBytesAdapter;
+  return internal::CallPDFiumStringBufferApiAndReturnOptional<adapter_type,
+                                                              std::u16string>(
+      api, check_expected_size);
+}
+
+// Helper function to call PDFium APIs where the output buffer is expected to
+// hold ASCII or UTF-8 data, and the buffer length is specified in bytes.
+template <typename BufferType, typename ReturnType>
+std::string CallPDFiumStringBufferApi(
+    base::RepeatingCallback<ReturnType(BufferType*, ReturnType)> api,
+    bool check_expected_size) {
+  using adapter_type = internal::PDFiumAPIStringBufferAdapter<std::string>;
+  return internal::CallPDFiumStringBufferApi<adapter_type, std::string>(
+      api, check_expected_size);
+}
+
+// Expose internal::PDFiumAPIStringBufferAdapter for special cases that cannot
+// use the CallPDFiumStringBuffer* functions above.
+template <class StringType>
+using PDFiumAPIStringBufferAdapter =
+    internal::PDFiumAPIStringBufferAdapter<StringType>;
+
 }  // namespace chrome_pdf
 
 #endif  // PDF_PDFIUM_PDFIUM_API_STRING_BUFFER_ADAPTER_H_
diff --git a/pdf/pdfium/pdfium_assert_matching_enums.cc b/pdf/pdfium/pdfium_assert_matching_enums.cc
index e89225af38fb..0943ce91409a 100644
--- a/pdf/pdfium/pdfium_assert_matching_enums.cc
+++ b/pdf/pdfium/pdfium_assert_matching_enums.cc
@@ -3,31 +3,77 @@
 // found in the LICENSE file.
 
 #include "build/build_config.h"
-#include "pdf/pdf.h"
+#include "pdf/accessibility_structs.h"
+#include "pdf/document_metadata.h"
+#include "pdf/ppapi_migration/input_event_conversions.h"
 #include "ppapi/c/pp_input_event.h"
 #include "ppapi/c/private/ppb_pdf.h"
 #include "ppapi/c/private/ppp_pdf.h"
 #include "third_party/pdfium/public/fpdf_edit.h"
+#include "third_party/pdfium/public/fpdf_formfill.h"
 #include "third_party/pdfium/public/fpdf_fwlevent.h"
 #include "third_party/pdfium/public/fpdf_sysfontinfo.h"
+#include "third_party/pdfium/public/fpdfview.h"
 #include "ui/events/keycodes/keyboard_codes.h"
 
+#if defined(OS_WIN)
+#include "pdf/pdf.h"
+#endif
+
 #define STATIC_ASSERT_ENUM(a, b)                            \
   static_assert(static_cast<int>(a) == static_cast<int>(b), \
                 "mismatching enums: " #a)
 
-STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_SHIFTKEY, FWL_EVENTFLAG_ShiftKey);
-STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_CONTROLKEY, FWL_EVENTFLAG_ControlKey);
-STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_ALTKEY, FWL_EVENTFLAG_AltKey);
-STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_METAKEY, FWL_EVENTFLAG_MetaKey);
-STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_ISKEYPAD, FWL_EVENTFLAG_KeyPad);
+// Enum asserts between PP_INPUTEVENT_MODIFIER* and InputEventModifier
+// modifiers.
+STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_SHIFTKEY,
+                   chrome_pdf::kInputEventModifierShiftKey);
+STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_CONTROLKEY,
+                   chrome_pdf::kInputEventModifierControlKey);
+STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_ALTKEY,
+                   chrome_pdf::kInputEventModifierAltKey);
+STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_METAKEY,
+                   chrome_pdf::kInputEventModifierMetaKey);
+STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_ISKEYPAD,
+                   chrome_pdf::kInputEventModifierIsKeyPad);
 STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_ISAUTOREPEAT,
-                   FWL_EVENTFLAG_AutoRepeat);
+                   chrome_pdf::kInputEventModifierIsAutoRepeat);
 STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_LEFTBUTTONDOWN,
-                   FWL_EVENTFLAG_LeftButtonDown);
+                   chrome_pdf::kInputEventModifierLeftButtonDown);
 STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_MIDDLEBUTTONDOWN,
-                   FWL_EVENTFLAG_MiddleButtonDown);
+                   chrome_pdf::kInputEventModifierMiddleButtonDown);
 STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_RIGHTBUTTONDOWN,
+                   chrome_pdf::kInputEventModifierRightButtonDown);
+STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_CAPSLOCKKEY,
+                   chrome_pdf::kInputEventModifierCapsLockKey);
+STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_NUMLOCKKEY,
+                   chrome_pdf::kInputEventModifierNumLockKey);
+STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_ISLEFT,
+                   chrome_pdf::kInputEventModifierIsLeft);
+STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_ISRIGHT,
+                   chrome_pdf::kInputEventModifierIsRight);
+STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_ISPEN,
+                   chrome_pdf::kInputEventModifierIsPen);
+STATIC_ASSERT_ENUM(PP_INPUTEVENT_MODIFIER_ISERASER,
+                   chrome_pdf::kInputEventModifierIsEraser);
+
+// Enum asserts between InputEventModifier and FWL_* modifiers.
+STATIC_ASSERT_ENUM(chrome_pdf::kInputEventModifierShiftKey,
+                   FWL_EVENTFLAG_ShiftKey);
+STATIC_ASSERT_ENUM(chrome_pdf::kInputEventModifierControlKey,
+                   FWL_EVENTFLAG_ControlKey);
+STATIC_ASSERT_ENUM(chrome_pdf::kInputEventModifierAltKey, FWL_EVENTFLAG_AltKey);
+STATIC_ASSERT_ENUM(chrome_pdf::kInputEventModifierMetaKey,
+                   FWL_EVENTFLAG_MetaKey);
+STATIC_ASSERT_ENUM(chrome_pdf::kInputEventModifierIsKeyPad,
+                   FWL_EVENTFLAG_KeyPad);
+STATIC_ASSERT_ENUM(chrome_pdf::kInputEventModifierIsAutoRepeat,
+                   FWL_EVENTFLAG_AutoRepeat);
+STATIC_ASSERT_ENUM(chrome_pdf::kInputEventModifierLeftButtonDown,
+                   FWL_EVENTFLAG_LeftButtonDown);
+STATIC_ASSERT_ENUM(chrome_pdf::kInputEventModifierMiddleButtonDown,
+                   FWL_EVENTFLAG_MiddleButtonDown);
+STATIC_ASSERT_ENUM(chrome_pdf::kInputEventModifierRightButtonDown,
                    FWL_EVENTFLAG_RightButtonDown);
 
 STATIC_ASSERT_ENUM(ui::VKEY_BACK, FWL_VKEY_Back);
@@ -214,9 +260,137 @@ STATIC_ASSERT_ENUM(PP_PRIVATEDUPLEXMODE_SIMPLEX, Simplex);
 STATIC_ASSERT_ENUM(PP_PRIVATEDUPLEXMODE_SHORT_EDGE, DuplexFlipShortEdge);
 STATIC_ASSERT_ENUM(PP_PRIVATEDUPLEXMODE_LONG_EDGE, DuplexFlipLongEdge);
 
+STATIC_ASSERT_ENUM(PP_TEXTRENDERINGMODE_UNKNOWN, FPDF_TEXTRENDERMODE_UNKNOWN);
+STATIC_ASSERT_ENUM(PP_TEXTRENDERINGMODE_FIRST, FPDF_TEXTRENDERMODE_UNKNOWN);
+STATIC_ASSERT_ENUM(PP_TEXTRENDERINGMODE_FILL, FPDF_TEXTRENDERMODE_FILL);
+STATIC_ASSERT_ENUM(PP_TEXTRENDERINGMODE_STROKE, FPDF_TEXTRENDERMODE_STROKE);
+STATIC_ASSERT_ENUM(PP_TEXTRENDERINGMODE_FILLSTROKE,
+                   FPDF_TEXTRENDERMODE_FILL_STROKE);
+STATIC_ASSERT_ENUM(PP_TEXTRENDERINGMODE_INVISIBLE,
+                   FPDF_TEXTRENDERMODE_INVISIBLE);
+STATIC_ASSERT_ENUM(PP_TEXTRENDERINGMODE_FILLCLIP,
+                   FPDF_TEXTRENDERMODE_FILL_CLIP);
+STATIC_ASSERT_ENUM(PP_TEXTRENDERINGMODE_STROKECLIP,
+                   FPDF_TEXTRENDERMODE_STROKE_CLIP);
+STATIC_ASSERT_ENUM(PP_TEXTRENDERINGMODE_FILLSTROKECLIP,
+                   FPDF_TEXTRENDERMODE_FILL_STROKE_CLIP);
+STATIC_ASSERT_ENUM(PP_TEXTRENDERINGMODE_CLIP, FPDF_TEXTRENDERMODE_CLIP);
+STATIC_ASSERT_ENUM(PP_TEXTRENDERINGMODE_LAST, FPDF_TEXTRENDERMODE_LAST);
+
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextRenderMode::kUnknown,
+                   PP_TEXTRENDERINGMODE_UNKNOWN);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextRenderMode::kFill,
+                   PP_TEXTRENDERINGMODE_FILL);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextRenderMode::kStroke,
+                   PP_TEXTRENDERINGMODE_STROKE);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextRenderMode::kFillStroke,
+                   PP_TEXTRENDERINGMODE_FILLSTROKE);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextRenderMode::kInvisible,
+                   PP_TEXTRENDERINGMODE_INVISIBLE);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextRenderMode::kFillClip,
+                   PP_TEXTRENDERINGMODE_FILLCLIP);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextRenderMode::kStrokeClip,
+                   PP_TEXTRENDERINGMODE_STROKECLIP);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextRenderMode::kFillStrokeClip,
+                   PP_TEXTRENDERINGMODE_FILLSTROKECLIP);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextRenderMode::kClip,
+                   PP_TEXTRENDERINGMODE_CLIP);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextRenderMode::kMaxValue,
+                   PP_TEXTRENDERINGMODE_LAST);
+
+STATIC_ASSERT_ENUM(chrome_pdf::FormType::kNone, FORMTYPE_NONE);
+STATIC_ASSERT_ENUM(chrome_pdf::FormType::kAcroForm, FORMTYPE_ACRO_FORM);
+STATIC_ASSERT_ENUM(chrome_pdf::FormType::kXFAFull, FORMTYPE_XFA_FULL);
+STATIC_ASSERT_ENUM(chrome_pdf::FormType::kXFAForeground,
+                   FORMTYPE_XFA_FOREGROUND);
+STATIC_ASSERT_ENUM(chrome_pdf::FormType::kMaxValue, FORMTYPE_COUNT - 1);
+
+STATIC_ASSERT_ENUM(PP_PRIVATEBUTTON_PUSHBUTTON, FPDF_FORMFIELD_PUSHBUTTON);
+STATIC_ASSERT_ENUM(PP_PRIVATEBUTTON_CHECKBOX, FPDF_FORMFIELD_CHECKBOX);
+STATIC_ASSERT_ENUM(PP_PRIVATEBUTTON_RADIOBUTTON, FPDF_FORMFIELD_RADIOBUTTON);
+
 #if defined(OS_WIN)
 STATIC_ASSERT_ENUM(chrome_pdf::kEmf, FPDF_PRINTMODE_EMF);
 STATIC_ASSERT_ENUM(chrome_pdf::kTextOnly, FPDF_PRINTMODE_TEXTONLY);
 STATIC_ASSERT_ENUM(chrome_pdf::kPostScript2, FPDF_PRINTMODE_POSTSCRIPT2);
 STATIC_ASSERT_ENUM(chrome_pdf::kPostScript3, FPDF_PRINTMODE_POSTSCRIPT3);
+STATIC_ASSERT_ENUM(chrome_pdf::kEmfWithReducedRasterization,
+                   FPDF_PRINTMODE_EMF_IMAGE_MASKS);
 #endif
+
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextDirection::kNone,
+                   PP_PRIVATEDIRECTION_NONE);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextDirection::kLeftToRight,
+                   PP_PRIVATEDIRECTION_LTR);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextDirection::kRightToLeft,
+                   PP_PRIVATEDIRECTION_RTL);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextDirection::kTopToBottom,
+                   PP_PRIVATEDIRECTION_TTB);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextDirection::kBottomToTop,
+                   PP_PRIVATEDIRECTION_BTT);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityTextDirection::kMaxValue,
+                   PP_PRIVATEDIRECTION_LAST);
+
+STATIC_ASSERT_ENUM(chrome_pdf::ChoiceFieldType::kListBox,
+                   PP_PRIVATECHOICEFIELD_LISTBOX);
+STATIC_ASSERT_ENUM(chrome_pdf::ChoiceFieldType::kComboBox,
+                   PP_PRIVATECHOICEFIELD_COMBOBOX);
+STATIC_ASSERT_ENUM(chrome_pdf::ChoiceFieldType::kMaxValue,
+                   PP_PRIVATECHOICEFIELD_LAST);
+
+STATIC_ASSERT_ENUM(chrome_pdf::ButtonType::kPushButton,
+                   PP_PRIVATEBUTTON_PUSHBUTTON);
+STATIC_ASSERT_ENUM(chrome_pdf::ButtonType::kPushButton, PP_PRIVATEBUTTON_FIRST);
+STATIC_ASSERT_ENUM(chrome_pdf::ButtonType::kCheckBox,
+                   PP_PRIVATEBUTTON_CHECKBOX);
+STATIC_ASSERT_ENUM(chrome_pdf::ButtonType::kRadioButton,
+                   PP_PRIVATEBUTTON_RADIOBUTTON);
+STATIC_ASSERT_ENUM(chrome_pdf::ButtonType::kMaxValue, PP_PRIVATEBUTTON_LAST);
+
+STATIC_ASSERT_ENUM(chrome_pdf::FocusObjectType::kNone,
+                   PP_PRIVATEFOCUSOBJECT_NONE);
+STATIC_ASSERT_ENUM(chrome_pdf::FocusObjectType::kDocument,
+                   PP_PRIVATEFOCUSOBJECT_DOCUMENT);
+STATIC_ASSERT_ENUM(chrome_pdf::FocusObjectType::kLink,
+                   PP_PRIVATEFOCUSOBJECT_LINK);
+STATIC_ASSERT_ENUM(chrome_pdf::FocusObjectType::kHighlight,
+                   PP_PRIVATEFOCUSOBJECT_HIGHLIGHT);
+STATIC_ASSERT_ENUM(chrome_pdf::FocusObjectType::kTextField,
+                   PP_PRIVATEFOCUSOBJECT_TEXT_FIELD);
+STATIC_ASSERT_ENUM(chrome_pdf::FocusObjectType::kMaxValue,
+                   PP_PRIVATEFOCUSOBJECT_LAST);
+
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityAction::kNone, PP_PDF_ACTION_NONE);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityAction::kScrollToMakeVisible,
+                   PP_PDF_SCROLL_TO_MAKE_VISIBLE);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityAction::kDoDefaultAction,
+                   PP_PDF_DO_DEFAULT_ACTION);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityAction::kScrollToGlobalPoint,
+                   PP_PDF_SCROLL_TO_GLOBAL_POINT);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityAction::kSetSelection,
+                   PP_PDF_SET_SELECTION);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityAction::kMaxValue,
+                   PP_PDF_ACCESSIBILITYACTION_LAST);
+
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityAnnotationType::kNone,
+                   PP_PDF_TYPE_NONE);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityAnnotationType::kLink, PP_PDF_LINK);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityAnnotationType::kMaxValue,
+                   PP_PDF_ACCESSIBILITY_ANNOTATIONTYPE_LAST);
+
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityScrollAlignment::kNone,
+                   PP_PDF_SCROLL_NONE);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityScrollAlignment::kCenter,
+                   PP_PDF_SCROLL_ALIGNMENT_CENTER);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityScrollAlignment::kTop,
+                   PP_PDF_SCROLL_ALIGNMENT_TOP);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityScrollAlignment::kBottom,
+                   PP_PDF_SCROLL_ALIGNMENT_BOTTOM);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityScrollAlignment::kLeft,
+                   PP_PDF_SCROLL_ALIGNMENT_LEFT);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityScrollAlignment::kRight,
+                   PP_PDF_SCROLL_ALIGNMENT_RIGHT);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityScrollAlignment::kClosestToEdge,
+                   PP_PDF_SCROLL_ALIGNMENT_CLOSEST_EDGE);
+STATIC_ASSERT_ENUM(chrome_pdf::AccessibilityScrollAlignment::kMaxValue,
+                   PP_PDF_ACCESSIBILITYSCROLLALIGNMENT_LAST);
diff --git a/pdf/pdfium/pdfium_document.cc b/pdf/pdfium/pdfium_document.cc
index ff6dc27b5613..35ab07c98807 100644
--- a/pdf/pdfium/pdfium_document.cc
+++ b/pdf/pdfium/pdfium_document.cc
@@ -6,7 +6,7 @@
 
 #include <utility>
 
-#include "base/logging.h"
+#include "base/check.h"
 #include "pdf/document_loader.h"
 
 namespace chrome_pdf {
@@ -94,13 +94,15 @@ void PDFiumDocument::ResetFPDFAvailability() {
   fpdf_availability_.reset();
 }
 
-void PDFiumDocument::LoadDocument(const char* password) {
+void PDFiumDocument::LoadDocument(const std::string& password) {
+  const char* password_cstr = password.empty() ? nullptr : password.c_str();
   if (doc_loader_->IsDocumentComplete() &&
       !FPDFAvail_IsLinearized(fpdf_availability_.get())) {
-    doc_handle_.reset(FPDF_LoadCustomDocument(file_access_.get(), password));
+    doc_handle_.reset(
+        FPDF_LoadCustomDocument(file_access_.get(), password_cstr));
   } else {
     doc_handle_.reset(
-        FPDFAvail_GetDocument(fpdf_availability_.get(), password));
+        FPDFAvail_GetDocument(fpdf_availability_.get(), password_cstr));
   }
 }
 
diff --git a/pdf/pdfium/pdfium_document.h b/pdf/pdfium/pdfium_document.h
index a5cebaca3cab..0df76d8bdc1a 100644
--- a/pdf/pdfium/pdfium_document.h
+++ b/pdf/pdfium/pdfium_document.h
@@ -5,7 +5,9 @@
 #ifndef PDF_PDFIUM_PDFIUM_DOCUMENT_H_
 #define PDF_PDFIUM_PDFIUM_DOCUMENT_H_
 
-#include "base/macros.h"
+#include <memory>
+#include <string>
+
 #include "third_party/pdfium/public/cpp/fpdf_scopers.h"
 #include "third_party/pdfium/public/fpdf_dataavail.h"
 #include "third_party/pdfium/public/fpdfview.h"
@@ -17,6 +19,8 @@ class DocumentLoader;
 class PDFiumDocument {
  public:
   explicit PDFiumDocument(DocumentLoader* doc_loader);
+  PDFiumDocument(const PDFiumDocument&) = delete;
+  PDFiumDocument& operator=(const PDFiumDocument&) = delete;
   ~PDFiumDocument();
 
   FPDF_FILEACCESS& file_access() { return *file_access_; }
@@ -32,7 +36,7 @@ class PDFiumDocument {
   void CreateFPDFAvailability();
   void ResetFPDFAvailability();
 
-  void LoadDocument(const char* password);
+  void LoadDocument(const std::string& password);
 
   void SetFormStatus();
   void InitializeForm(FPDF_FORMFILLINFO* form_info);
@@ -62,8 +66,6 @@ class PDFiumDocument {
 
   // Current form availability status.
   int form_status_ = PDF_FORM_NOTAVAIL;
-
-  DISALLOW_COPY_AND_ASSIGN(PDFiumDocument);
 };
 
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_engine.cc b/pdf/pdfium/pdfium_engine.cc
index d67cb1af557d..753fc5ecf8ed 100644
--- a/pdf/pdfium/pdfium_engine.cc
+++ b/pdf/pdfium/pdfium_engine.cc
@@ -12,84 +12,90 @@
 #include <limits>
 #include <memory>
 #include <set>
+#include <string>
 #include <utility>
 
 #include "base/auto_reset.h"
-#include "base/i18n/encoding_detection.h"
-#include "base/i18n/icu_string_conversions.h"
-#include "base/logging.h"
+#include "base/bind.h"
+#include "base/check_op.h"
+#include "base/debug/alias.h"
+#include "base/feature_list.h"
+#include "base/notreached.h"
 #include "base/stl_util.h"
 #include "base/strings/string_util.h"
 #include "base/strings/stringprintf.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/threading/thread_task_runner_handle.h"
+#include "base/time/time.h"
 #include "build/build_config.h"
 #include "gin/array_buffer.h"
 #include "gin/public/gin_embedders.h"
 #include "gin/public/isolate_holder.h"
+#include "gin/public/v8_platform.h"
+#include "pdf/accessibility_structs.h"
 #include "pdf/document_loader_impl.h"
-#include "pdf/draw_utils.h"
+#include "pdf/draw_utils/coordinates.h"
+#include "pdf/draw_utils/shadow.h"
+#include "pdf/pdf_features.h"
 #include "pdf/pdf_transform.h"
+#include "pdf/pdf_utils/dates.h"
 #include "pdf/pdfium/pdfium_api_string_buffer_adapter.h"
 #include "pdf/pdfium/pdfium_document.h"
 #include "pdf/pdfium/pdfium_mem_buffer_file_read.h"
 #include "pdf/pdfium/pdfium_mem_buffer_file_write.h"
+#include "pdf/pdfium/pdfium_permissions.h"
 #include "pdf/pdfium/pdfium_unsupported_features.h"
+#include "pdf/ppapi_migration/bitmap.h"
+#include "pdf/ppapi_migration/geometry_conversions.h"
+#include "pdf/ppapi_migration/input_event_conversions.h"
+#include "pdf/ppapi_migration/url_loader.h"
 #include "pdf/url_loader_wrapper_impl.h"
 #include "ppapi/cpp/instance.h"
 #include "ppapi/cpp/private/pdf.h"
-#include "ppapi/cpp/trusted/browser_font_trusted.h"
-#include "ppapi/cpp/var_dictionary.h"
 #include "printing/units.h"
 #include "third_party/pdfium/public/cpp/fpdf_scopers.h"
 #include "third_party/pdfium/public/fpdf_annot.h"
 #include "third_party/pdfium/public/fpdf_attachment.h"
 #include "third_party/pdfium/public/fpdf_catalog.h"
 #include "third_party/pdfium/public/fpdf_ext.h"
+#include "third_party/pdfium/public/fpdf_fwlevent.h"
 #include "third_party/pdfium/public/fpdf_ppo.h"
 #include "third_party/pdfium/public/fpdf_searchex.h"
-#include "third_party/pdfium/public/fpdf_sysfontinfo.h"
+#include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/events/keycodes/keyboard_codes.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/point_conversions.h"
 #include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/rect_f.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/geometry/vector2d.h"
 #include "v8/include/v8.h"
 
+#if defined(PDF_ENABLE_XFA)
+#include "v8/include/cppgc/platform.h"
+#endif
+
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#include "pdf/pdfium/pdfium_font_linux.h"
+#endif
+
 using printing::ConvertUnit;
 using printing::ConvertUnitDouble;
-using printing::kPointsPerInch;
 using printing::kPixelsPerInch;
+using printing::kPointsPerInch;
 
 namespace chrome_pdf {
 
-static_assert(static_cast<int>(PDFEngine::FormType::kNone) == FORMTYPE_NONE,
-              "None form types must match");
-static_assert(static_cast<int>(PDFEngine::FormType::kAcroForm) ==
-                  FORMTYPE_ACRO_FORM,
-              "AcroForm form types must match");
-static_assert(static_cast<int>(PDFEngine::FormType::kXFAFull) ==
-                  FORMTYPE_XFA_FULL,
-              "XFA full form types must match");
-static_assert(static_cast<int>(PDFEngine::FormType::kXFAForeground) ==
-                  FORMTYPE_XFA_FOREGROUND,
-              "XFA foreground form types must match");
-static_assert(static_cast<int>(PDFEngine::FormType::kCount) == FORMTYPE_COUNT,
-              "Form type counts must match");
-
 namespace {
 
-const int32_t kPageShadowTop = 3;
-const int32_t kPageShadowBottom = 7;
-const int32_t kPageShadowLeft = 5;
-const int32_t kPageShadowRight = 5;
+constexpr int32_t kHighlightColorR = 153;
+constexpr int32_t kHighlightColorG = 193;
+constexpr int32_t kHighlightColorB = 218;
 
-const int32_t kPageSeparatorThickness = 4;
-const int32_t kHighlightColorR = 153;
-const int32_t kHighlightColorG = 193;
-const int32_t kHighlightColorB = 218;
+constexpr uint32_t kPendingPageColor = 0xFFEEEEEE;
 
-const uint32_t kPendingPageColor = 0xFFEEEEEE;
-
-const uint32_t kFormHighlightColor = 0xFFE4DD;
-const int32_t kFormHighlightAlpha = 100;
+constexpr uint32_t kFormHighlightColor = 0xFFE4DD;
+constexpr int32_t kFormHighlightAlpha = 100;
 
 constexpr int kMaxPasswordTries = 3;
 
@@ -103,14 +109,7 @@ constexpr bool kViewerImplementedPanning = false;
 constexpr bool kViewerImplementedPanning = true;
 #endif
 
-// See Table 3.20 in
-// http://www.adobe.com/devnet/acrobat/pdfs/pdf_reference_1-7.pdf
-const uint32_t kPDFPermissionPrintLowQualityMask = 1 << 2;
-const uint32_t kPDFPermissionPrintHighQualityMask = 1 << 11;
-const uint32_t kPDFPermissionCopyMask = 1 << 4;
-const uint32_t kPDFPermissionCopyAccessibleMask = 1 << 9;
-
-const int32_t kLoadingTextVerticalOffset = 50;
+constexpr int32_t kLoadingTextVerticalOffset = 50;
 
 // The maximum amount of time we'll spend doing a paint before we give back
 // control of the thread.
@@ -131,297 +130,6 @@ constexpr base::TimeDelta kMaxProgressivePaintTime =
 constexpr base::TimeDelta kMaxInitialProgressivePaintTime =
     base::TimeDelta::FromMilliseconds(250);
 
-// Flag to turn edit mode tracking on.
-// Do not flip until form saving is completely functional.
-constexpr bool kIsEditModeTracked = false;
-
-PDFiumEngine* g_engine_for_fontmapper = nullptr;
-
-#if defined(OS_LINUX)
-
-PP_Instance g_last_instance_id;
-
-// TODO(npm): Move font stuff to another file to reduce the size of this one
-PP_BrowserFont_Trusted_Weight WeightToBrowserFontTrustedWeight(int weight) {
-  static_assert(PP_BROWSERFONT_TRUSTED_WEIGHT_100 == 0,
-                "PP_BrowserFont_Trusted_Weight min");
-  static_assert(PP_BROWSERFONT_TRUSTED_WEIGHT_900 == 8,
-                "PP_BrowserFont_Trusted_Weight max");
-  const int kMinimumWeight = 100;
-  const int kMaximumWeight = 900;
-  int normalized_weight =
-      std::min(std::max(weight, kMinimumWeight), kMaximumWeight);
-  normalized_weight = (normalized_weight / 100) - 1;
-  return static_cast<PP_BrowserFont_Trusted_Weight>(normalized_weight);
-}
-
-// This list is for CPWL_FontMap::GetDefaultFontByCharset().
-// We pretend to have these font natively and let the browser (or underlying
-// fontconfig) to pick the proper font on the system.
-void EnumFonts(FPDF_SYSFONTINFO* sysfontinfo, void* mapper) {
-  FPDF_AddInstalledFont(mapper, "Arial", FXFONT_DEFAULT_CHARSET);
-
-  const FPDF_CharsetFontMap* font_map = FPDF_GetDefaultTTFMap();
-  for (; font_map->charset != -1; ++font_map) {
-    FPDF_AddInstalledFont(mapper, font_map->fontname, font_map->charset);
-  }
-}
-
-void* MapFont(FPDF_SYSFONTINFO*,
-              int weight,
-              int italic,
-              int charset,
-              int pitch_family,
-              const char* face,
-              int* exact) {
-  // Do not attempt to map fonts if pepper is not initialized (for privet local
-  // printing).
-  // TODO(noamsml): Real font substitution (http://crbug.com/391978)
-  if (!pp::Module::Get())
-    return nullptr;
-
-  pp::BrowserFontDescription description;
-
-  // Pretend the system does not have the Symbol font to force a fallback to
-  // the built in Symbol font in CFX_FontMapper::FindSubstFont().
-  if (strcmp(face, "Symbol") == 0)
-    return nullptr;
-
-  if (pitch_family & FXFONT_FF_FIXEDPITCH) {
-    description.set_family(PP_BROWSERFONT_TRUSTED_FAMILY_MONOSPACE);
-  } else if (pitch_family & FXFONT_FF_ROMAN) {
-    description.set_family(PP_BROWSERFONT_TRUSTED_FAMILY_SERIF);
-  }
-
-  static const struct {
-    const char* pdf_name;
-    const char* face;
-    bool bold;
-    bool italic;
-  } kPdfFontSubstitutions[] = {
-      {"Courier", "Courier New", false, false},
-      {"Courier-Bold", "Courier New", true, false},
-      {"Courier-BoldOblique", "Courier New", true, true},
-      {"Courier-Oblique", "Courier New", false, true},
-      {"Helvetica", "Arial", false, false},
-      {"Helvetica-Bold", "Arial", true, false},
-      {"Helvetica-BoldOblique", "Arial", true, true},
-      {"Helvetica-Oblique", "Arial", false, true},
-      {"Times-Roman", "Times New Roman", false, false},
-      {"Times-Bold", "Times New Roman", true, false},
-      {"Times-BoldItalic", "Times New Roman", true, true},
-      {"Times-Italic", "Times New Roman", false, true},
-
-      // MS P?(Mincho|Gothic) are the most notable fonts in Japanese PDF files
-      // without embedding the glyphs. Sometimes the font names are encoded
-      // in Japanese Windows's locale (CP932/Shift_JIS) without space.
-      // Most Linux systems don't have the exact font, but for outsourcing
-      // fontconfig to find substitutable font in the system, we pass ASCII
-      // font names to it.
-      {"MS-PGothic", "MS PGothic", false, false},
-      {"MS-Gothic", "MS Gothic", false, false},
-      {"MS-PMincho", "MS PMincho", false, false},
-      {"MS-Mincho", "MS Mincho", false, false},
-      // MS PGothic in Shift_JIS encoding.
-      {"\x82\x6C\x82\x72\x82\x6F\x83\x53\x83\x56\x83\x62\x83\x4E", "MS PGothic",
-       false, false},
-      // MS Gothic in Shift_JIS encoding.
-      {"\x82\x6C\x82\x72\x83\x53\x83\x56\x83\x62\x83\x4E", "MS Gothic", false,
-       false},
-      // MS PMincho in Shift_JIS encoding.
-      {"\x82\x6C\x82\x72\x82\x6F\x96\xBE\x92\xA9", "MS PMincho", false, false},
-      // MS Mincho in Shift_JIS encoding.
-      {"\x82\x6C\x82\x72\x96\xBE\x92\xA9", "MS Mincho", false, false},
-  };
-
-  // Similar logic exists in PDFium's CFX_FolderFontInfo::FindFont().
-  if (charset == FXFONT_ANSI_CHARSET && (pitch_family & FXFONT_FF_FIXEDPITCH))
-    face = "Courier New";
-
-  // Map from the standard PDF fonts to TrueType font names.
-  size_t i;
-  for (i = 0; i < arraysize(kPdfFontSubstitutions); ++i) {
-    if (strcmp(face, kPdfFontSubstitutions[i].pdf_name) == 0) {
-      description.set_face(kPdfFontSubstitutions[i].face);
-      if (kPdfFontSubstitutions[i].bold)
-        description.set_weight(PP_BROWSERFONT_TRUSTED_WEIGHT_BOLD);
-      if (kPdfFontSubstitutions[i].italic)
-        description.set_italic(true);
-      break;
-    }
-  }
-
-  if (i == arraysize(kPdfFontSubstitutions)) {
-    // Convert to UTF-8 before calling set_face().
-    std::string face_utf8;
-    if (base::IsStringUTF8(face)) {
-      face_utf8 = face;
-    } else {
-      std::string encoding;
-      if (base::DetectEncoding(face, &encoding)) {
-        // ConvertToUtf8AndNormalize() clears |face_utf8| on failure.
-        base::ConvertToUtf8AndNormalize(face, encoding, &face_utf8);
-      }
-    }
-
-    if (face_utf8.empty())
-      return nullptr;
-
-    description.set_face(face_utf8);
-    description.set_weight(WeightToBrowserFontTrustedWeight(weight));
-    description.set_italic(italic > 0);
-  }
-
-  if (!pp::PDF::IsAvailable()) {
-    NOTREACHED();
-    return nullptr;
-  }
-
-  if (g_engine_for_fontmapper)
-    g_engine_for_fontmapper->FontSubstituted();
-
-  PP_Resource font_resource = pp::PDF::GetFontFileWithFallback(
-      pp::InstanceHandle(g_last_instance_id),
-      &description.pp_font_description(),
-      static_cast<PP_PrivateFontCharset>(charset));
-  long res_id = font_resource;
-  return reinterpret_cast<void*>(res_id);
-}
-
-unsigned long GetFontData(FPDF_SYSFONTINFO*,
-                          void* font_id,
-                          unsigned int table,
-                          unsigned char* buffer,
-                          unsigned long buf_size) {
-  if (!pp::PDF::IsAvailable()) {
-    NOTREACHED();
-    return 0;
-  }
-
-  uint32_t size = buf_size;
-  long res_id = reinterpret_cast<long>(font_id);
-  if (!pp::PDF::GetFontTableForPrivateFontFile(res_id, table, buffer, &size))
-    return 0;
-  return size;
-}
-
-void DeleteFont(FPDF_SYSFONTINFO*, void* font_id) {
-  long res_id = reinterpret_cast<long>(font_id);
-  pp::Module::Get()->core()->ReleaseResource(res_id);
-}
-
-FPDF_SYSFONTINFO g_font_info = {1,           0, EnumFonts, MapFont,   0,
-                                GetFontData, 0, 0,         DeleteFont};
-#else
-struct FPDF_SYSFONTINFO_WITHMETRICS : public FPDF_SYSFONTINFO {
-  explicit FPDF_SYSFONTINFO_WITHMETRICS(FPDF_SYSFONTINFO* sysfontinfo) {
-    version = sysfontinfo->version;
-    default_sysfontinfo = sysfontinfo;
-  }
-
-  ~FPDF_SYSFONTINFO_WITHMETRICS() {
-    FPDF_FreeDefaultSystemFontInfo(default_sysfontinfo);
-  }
-
-  FPDF_SYSFONTINFO* default_sysfontinfo;
-};
-
-FPDF_SYSFONTINFO_WITHMETRICS* g_font_info = nullptr;
-
-void* MapFontWithMetrics(FPDF_SYSFONTINFO* sysfontinfo,
-                         int weight,
-                         int italic,
-                         int charset,
-                         int pitch_family,
-                         const char* face,
-                         int* exact) {
-  auto* fontinfo_with_metrics =
-      static_cast<FPDF_SYSFONTINFO_WITHMETRICS*>(sysfontinfo);
-  if (!fontinfo_with_metrics->default_sysfontinfo->MapFont)
-    return nullptr;
-  void* mapped_font = fontinfo_with_metrics->default_sysfontinfo->MapFont(
-      fontinfo_with_metrics->default_sysfontinfo, weight, italic, charset,
-      pitch_family, face, exact);
-  if (mapped_font && g_engine_for_fontmapper)
-    g_engine_for_fontmapper->FontSubstituted();
-  return mapped_font;
-}
-
-void DeleteFont(FPDF_SYSFONTINFO* sysfontinfo, void* font_id) {
-  auto* fontinfo_with_metrics =
-      static_cast<FPDF_SYSFONTINFO_WITHMETRICS*>(sysfontinfo);
-  if (!fontinfo_with_metrics->default_sysfontinfo->DeleteFont)
-    return;
-  fontinfo_with_metrics->default_sysfontinfo->DeleteFont(
-      fontinfo_with_metrics->default_sysfontinfo, font_id);
-}
-
-void EnumFonts(FPDF_SYSFONTINFO* sysfontinfo, void* mapper) {
-  auto* fontinfo_with_metrics =
-      static_cast<FPDF_SYSFONTINFO_WITHMETRICS*>(sysfontinfo);
-  if (!fontinfo_with_metrics->default_sysfontinfo->EnumFonts)
-    return;
-  fontinfo_with_metrics->default_sysfontinfo->EnumFonts(
-      fontinfo_with_metrics->default_sysfontinfo, mapper);
-}
-
-unsigned long GetFaceName(FPDF_SYSFONTINFO* sysfontinfo,
-                          void* hFont,
-                          char* buffer,
-                          unsigned long buffer_size) {
-  auto* fontinfo_with_metrics =
-      static_cast<FPDF_SYSFONTINFO_WITHMETRICS*>(sysfontinfo);
-  if (!fontinfo_with_metrics->default_sysfontinfo->GetFaceName)
-    return 0;
-  return fontinfo_with_metrics->default_sysfontinfo->GetFaceName(
-      fontinfo_with_metrics->default_sysfontinfo, hFont, buffer, buffer_size);
-}
-
-void* GetFont(FPDF_SYSFONTINFO* sysfontinfo, const char* face) {
-  auto* fontinfo_with_metrics =
-      static_cast<FPDF_SYSFONTINFO_WITHMETRICS*>(sysfontinfo);
-  if (!fontinfo_with_metrics->default_sysfontinfo->GetFont)
-    return nullptr;
-  return fontinfo_with_metrics->default_sysfontinfo->GetFont(
-      fontinfo_with_metrics->default_sysfontinfo, face);
-}
-
-int GetFontCharset(FPDF_SYSFONTINFO* sysfontinfo, void* hFont) {
-  auto* fontinfo_with_metrics =
-      static_cast<FPDF_SYSFONTINFO_WITHMETRICS*>(sysfontinfo);
-  if (!fontinfo_with_metrics->default_sysfontinfo->GetFontCharset)
-    return 0;
-  return fontinfo_with_metrics->default_sysfontinfo->GetFontCharset(
-      fontinfo_with_metrics->default_sysfontinfo, hFont);
-}
-
-unsigned long GetFontData(FPDF_SYSFONTINFO* sysfontinfo,
-                          void* hFont,
-                          unsigned int table,
-                          unsigned char* buffer,
-                          unsigned long buf_size) {
-  auto* fontinfo_with_metrics =
-      static_cast<FPDF_SYSFONTINFO_WITHMETRICS*>(sysfontinfo);
-  if (!fontinfo_with_metrics->default_sysfontinfo->GetFontData)
-    return 0;
-  return fontinfo_with_metrics->default_sysfontinfo->GetFontData(
-      fontinfo_with_metrics->default_sysfontinfo, hFont, table, buffer,
-      buf_size);
-}
-
-void Release(FPDF_SYSFONTINFO* sysfontinfo) {
-  auto* fontinfo_with_metrics =
-      static_cast<FPDF_SYSFONTINFO_WITHMETRICS*>(sysfontinfo);
-  if (!fontinfo_with_metrics->default_sysfontinfo->Release)
-    return;
-  fontinfo_with_metrics->default_sysfontinfo->Release(
-      fontinfo_with_metrics->default_sysfontinfo);
-}
-#endif  // defined(OS_LINUX)
-
-PDFiumEngine::CreateDocumentLoaderFunction
-    g_create_document_loader_for_testing = nullptr;
-
 template <class S>
 bool IsAboveOrDirectlyLeftOf(const S& lhs, const S& rhs) {
   return lhs.y() < rhs.y() || (lhs.y() == rhs.y() && lhs.x() < rhs.x());
@@ -437,7 +145,7 @@ int CalculateCenterForZoom(int center, int length, double zoom) {
 // as Adobe Reader. When a hyphen is encountered, the next non-CR/LF whitespace
 // becomes CR+LF and the hyphen is erased. If there is no whitespace between
 // two hyphens, the latter hyphen is erased and ignored.
-void FormatStringWithHyphens(base::string16* text) {
+void FormatStringWithHyphens(std::u16string* text) {
   // First pass marks all the hyphen positions.
   struct HyphenPosition {
     HyphenPosition() : position(0), next_whitespace_position(0) {}
@@ -447,10 +155,10 @@ void FormatStringWithHyphens(base::string16* text) {
   std::vector<HyphenPosition> hyphen_positions;
   HyphenPosition current_hyphen_position;
   bool current_hyphen_position_is_valid = false;
-  const base::char16 kPdfiumHyphenEOL = 0xfffe;
+  constexpr char16_t kPdfiumHyphenEOL = 0xfffe;
 
   for (size_t i = 0; i < text->size(); ++i) {
-    const base::char16& current_char = (*text)[i];
+    const char16_t& current_char = (*text)[i];
     if (current_char == kPdfiumHyphenEOL) {
       if (current_hyphen_position_is_valid)
         hyphen_positions.push_back(current_hyphen_position);
@@ -471,7 +179,7 @@ void FormatStringWithHyphens(base::string16* text) {
 
   // With all the hyphen positions, do the search and replace.
   while (!hyphen_positions.empty()) {
-    static const base::char16 kCr[] = {L'\r', L'\0'};
+    static constexpr char16_t kCr[] = {L'\r', L'\0'};
     const HyphenPosition& position = hyphen_positions.back();
     if (position.next_whitespace_position != 0) {
       (*text)[position.next_whitespace_position] = L'\n';
@@ -482,16 +190,16 @@ void FormatStringWithHyphens(base::string16* text) {
   }
 
   // Adobe Reader also get rid of trailing spaces right before a CRLF.
-  static const base::char16 kSpaceCrCn[] = {L' ', L'\r', L'\n', L'\0'};
-  static const base::char16 kCrCn[] = {L'\r', L'\n', L'\0'};
+  static constexpr char16_t kSpaceCrCn[] = {L' ', L'\r', L'\n', L'\0'};
+  static constexpr char16_t kCrCn[] = {L'\r', L'\n', L'\0'};
   base::ReplaceSubstringsAfterOffset(text, 0, kSpaceCrCn, kCrCn);
 }
 
 // Replace CR/LF with just LF on POSIX.
-void FormatStringForOS(base::string16* text) {
+void FormatStringForOS(std::u16string* text) {
 #if defined(OS_POSIX)
-  static const base::char16 kCr[] = {L'\r', L'\0'};
-  static const base::char16 kBlank[] = {L'\0'};
+  static constexpr char16_t kCr[] = {L'\r', L'\0'};
+  static constexpr char16_t kBlank[] = {L'\0'};
   base::ReplaceChars(*text, kCr, kBlank, text);
 #elif defined(OS_WIN)
   // Do nothing
@@ -505,7 +213,7 @@ void FormatStringForOS(base::string16* text) {
 // For triple clicks, look for line breaks.
 // The actual algorithm used in Blink is much more complicated, so do a simple
 // approximation.
-bool FindMultipleClickBoundary(bool is_double_click, base::char16 cur) {
+bool FindMultipleClickBoundary(bool is_double_click, char16_t cur) {
   if (!is_double_click)
     return cur == '\n';
 
@@ -515,43 +223,45 @@ bool FindMultipleClickBoundary(bool is_double_click, base::char16 cur) {
   if (cur < 128)
     return true;
 
-  static constexpr base::char16 kZeroWidthSpace = 0x200B;
   if (cur == kZeroWidthSpace)
     return true;
 
   return false;
 }
 
-std::string GetDocumentMetadata(FPDF_DOCUMENT doc, const std::string& key) {
-  size_t size = FPDF_GetMetaText(doc, key.c_str(), nullptr, 0);
-  if (size == 0)
-    return std::string();
-
-  base::string16 value;
-  PDFiumAPIStringBufferSizeInBytesAdapter<base::string16> string_adapter(
-      &value, size, false);
-  string_adapter.Close(
-      FPDF_GetMetaText(doc, key.c_str(), string_adapter.GetData(), size));
-  return base::UTF16ToUTF8(value);
-}
-
+#if defined(PDF_ENABLE_V8)
 gin::IsolateHolder* g_isolate_holder = nullptr;
 
+bool IsV8Initialized() {
+  return !!g_isolate_holder;
+}
+
 void SetUpV8() {
-  gin::IsolateHolder::Initialize(gin::IsolateHolder::kNonStrictMode,
-                                 gin::IsolateHolder::kStableV8Extras,
-                                 gin::ArrayBufferAllocator::SharedInstance());
+  const char* recommended = FPDF_GetRecommendedV8Flags();
+  v8::V8::SetFlagsFromString(recommended, strlen(recommended));
+  gin::IsolateHolder::Initialize(
+      gin::IsolateHolder::kNonStrictMode,
+      static_cast<v8::ArrayBuffer::Allocator*>(
+          FPDF_GetArrayBufferAllocatorSharedInstance()));
   DCHECK(!g_isolate_holder);
-  g_isolate_holder = new gin::IsolateHolder(base::ThreadTaskRunnerHandle::Get(),
-                                            gin::IsolateHolder::kSingleThread);
+  g_isolate_holder = new gin::IsolateHolder(
+      base::ThreadTaskRunnerHandle::Get(), gin::IsolateHolder::kSingleThread,
+      gin::IsolateHolder::IsolateType::kUtility);
   g_isolate_holder->isolate()->Enter();
+#if defined(PDF_ENABLE_XFA)
+  cppgc::InitializeProcess(gin::V8Platform::Get()->GetPageAllocator());
+#endif
 }
 
 void TearDownV8() {
+#if defined(PDF_ENABLE_XFA)
+  cppgc::ShutdownProcess();
+#endif
   g_isolate_holder->isolate()->Exit();
   delete g_isolate_holder;
   g_isolate_holder = nullptr;
 }
+#endif  // defined(PDF_ENABLE_V8)
 
 // Returns true if the given |area| and |form_type| combination from
 // PDFiumEngine::GetCharIndex() indicates it is a form text area.
@@ -583,19 +293,18 @@ bool IsLinkArea(PDFiumPage::Area area) {
 
 // Normalize a MouseInputEvent. For Mac, this means transforming ctrl + left
 // button down events into a right button down events.
-pp::MouseInputEvent NormalizeMouseEvent(pp::Instance* instance,
-                                        const pp::MouseInputEvent& event) {
-  pp::MouseInputEvent normalized_event = event;
-#if defined(OS_MACOSX)
+MouseInputEvent NormalizeMouseEvent(const MouseInputEvent& event) {
+  MouseInputEvent normalized_event = event;
+#if defined(OS_MAC)
   uint32_t modifiers = event.GetModifiers();
-  if ((modifiers & PP_INPUTEVENT_MODIFIER_CONTROLKEY) &&
-      event.GetButton() == PP_INPUTEVENT_MOUSEBUTTON_LEFT &&
-      event.GetType() == PP_INPUTEVENT_TYPE_MOUSEDOWN) {
-    uint32_t new_modifiers = modifiers & ~PP_INPUTEVENT_MODIFIER_CONTROLKEY;
-    normalized_event = pp::MouseInputEvent(
-        instance, PP_INPUTEVENT_TYPE_MOUSEDOWN, event.GetTimeStamp(),
-        new_modifiers, PP_INPUTEVENT_MOUSEBUTTON_RIGHT, event.GetPosition(), 1,
-        event.GetMovement());
+  if ((event.GetModifiers() & kInputEventModifierControlKey) &&
+      event.GetButton() == InputEventMouseButtonType::kLeft &&
+      event.GetEventType() == InputEventType::kMouseDown) {
+    uint32_t new_modifiers = modifiers & ~kInputEventModifierControlKey;
+    normalized_event =
+        MouseInputEvent(InputEventType::kMouseDown, event.GetTimeStamp(),
+                        new_modifiers, InputEventMouseButtonType::kRight,
+                        event.GetPosition(), 1, event.GetMovement());
   }
 #endif
   return normalized_event;
@@ -629,72 +338,212 @@ std::string ConvertViewIntToViewString(unsigned long view_int) {
   }
 }
 
+// Simplify to \" for searching
+constexpr wchar_t kHebrewPunctuationGershayimCharacter = 0x05F4;
+constexpr wchar_t kLeftDoubleQuotationMarkCharacter = 0x201C;
+constexpr wchar_t kRightDoubleQuotationMarkCharacter = 0x201D;
+
+// Simplify \' for searching
+constexpr wchar_t kHebrewPunctuationGereshCharacter = 0x05F3;
+constexpr wchar_t kLeftSingleQuotationMarkCharacter = 0x2018;
+constexpr wchar_t kRightSingleQuotationMarkCharacter = 0x2019;
+
+wchar_t SimplifyForSearch(wchar_t c) {
+  switch (c) {
+    case kHebrewPunctuationGershayimCharacter:
+    case kLeftDoubleQuotationMarkCharacter:
+    case kRightDoubleQuotationMarkCharacter:
+      return L'\"';
+    case kHebrewPunctuationGereshCharacter:
+    case kLeftSingleQuotationMarkCharacter:
+    case kRightSingleQuotationMarkCharacter:
+      return L'\'';
+    default:
+      return c;
+  }
+}
+
+PP_PrivateFocusObjectType GetAnnotationFocusType(
+    FPDF_ANNOTATION_SUBTYPE annot_type) {
+  switch (annot_type) {
+    case FPDF_ANNOT_LINK:
+      return PP_PrivateFocusObjectType::PP_PRIVATEFOCUSOBJECT_LINK;
+    case FPDF_ANNOT_HIGHLIGHT:
+      return PP_PrivateFocusObjectType::PP_PRIVATEFOCUSOBJECT_HIGHLIGHT;
+    case FPDF_ANNOT_WIDGET:
+      return PP_PrivateFocusObjectType::PP_PRIVATEFOCUSOBJECT_TEXT_FIELD;
+    default:
+      return PP_PrivateFocusObjectType::PP_PRIVATEFOCUSOBJECT_NONE;
+  }
+}
+
+std::u16string GetAttachmentAttribute(FPDF_ATTACHMENT attachment,
+                                      FPDF_BYTESTRING field) {
+  return CallPDFiumWideStringBufferApi(
+      base::BindRepeating(&FPDFAttachment_GetStringValue, attachment, field),
+      /*check_expected_size=*/true);
+}
+
+std::u16string GetAttachmentName(FPDF_ATTACHMENT attachment) {
+  return CallPDFiumWideStringBufferApi(
+      base::BindRepeating(&FPDFAttachment_GetName, attachment),
+      /*check_expected_size=*/true);
+}
+
+std::string GetXYZParamsString(FPDF_DEST dest, PDFiumPage* page) {
+  FPDF_BOOL has_x_coord;
+  FPDF_BOOL has_y_coord;
+  FPDF_BOOL has_zoom;
+  FS_FLOAT x;
+  FS_FLOAT y;
+  FS_FLOAT zoom;
+  if (!FPDFDest_GetLocationInPage(dest, &has_x_coord, &has_y_coord, &has_zoom,
+                                  &x, &y, &zoom)) {
+    return "";
+  }
+
+  // Handle out-of-range page coordinates.
+  x = has_x_coord ? page->PreProcessInPageCoordX(x) : 0;
+  y = has_y_coord ? page->PreProcessInPageCoordY(y) : 0;
+
+  // Convert in-page coordinates to in-screen coordinates.
+  gfx::PointF xy(x, y);
+  gfx::PointF screen_coords = page->TransformPageToScreenXY(xy);
+
+  // Generate a string of the parameters
+  std::string xyz_params;
+  if (has_x_coord)
+    xyz_params = base::NumberToString(screen_coords.x()) + ",";
+  else
+    xyz_params = "null,";
+
+  if (has_y_coord)
+    xyz_params += base::NumberToString(screen_coords.y()) + ",";
+  else
+    xyz_params += "null,";
+
+  if (has_zoom) {
+    if (zoom == 0.0f)
+      NOTREACHED();
+
+    xyz_params += base::NumberToString(zoom);
+  } else {
+    xyz_params += "null";
+  }
+
+  return xyz_params;
+}
+
+void SetXYZParamsInScreenCoords(PDFiumPage* page, float* params) {
+  gfx::PointF page_coords(params[0], params[1]);
+  gfx::PointF screen_coords = page->TransformPageToScreenXY(page_coords);
+  params[0] = screen_coords.x();
+  params[1] = screen_coords.y();
+}
+
+void SetFitRParamsInScreenCoords(PDFiumPage* page, float* params) {
+  gfx::PointF point_1 =
+      page->TransformPageToScreenXY(gfx::PointF(params[0], params[1]));
+  gfx::PointF point_2 =
+      page->TransformPageToScreenXY(gfx::PointF(params[2], params[3]));
+  params[0] = point_1.x();
+  params[1] = point_1.y();
+  params[2] = point_2.x();
+  params[3] = point_2.y();
+}
+
+// A helper function that transforms the in-page coordinates in `params` to
+// in-screen coordinates depending on the view's fit type. `params` is both an
+// input and a output parameter.
+void ParamsTransformPageToScreen(unsigned long view_fit_type,
+                                 PDFiumPage* page,
+                                 float* params) {
+  switch (view_fit_type) {
+    case PDFDEST_VIEW_XYZ:
+      SetXYZParamsInScreenCoords(page, params);
+      break;
+    case PDFDEST_VIEW_FIT:
+    case PDFDEST_VIEW_FITB:
+      // No parameters for coordinates to be transformed.
+      break;
+    case PDFDEST_VIEW_FITBH:
+    case PDFDEST_VIEW_FITH:
+      // FitH/FitBH only has 1 parameter for y coordinate.
+      params[0] = page->TransformPageToScreenY(params[0]);
+      break;
+    case PDFDEST_VIEW_FITBV:
+    case PDFDEST_VIEW_FITV:
+      // FitV/FitBV only has 1 parameter for x coordinate.
+      params[0] = page->TransformPageToScreenX(params[0]);
+      break;
+    case PDFDEST_VIEW_FITR:
+      SetFitRParamsInScreenCoords(page, params);
+      break;
+    case PDFDEST_VIEW_UNKNOWN_MODE:
+      break;
+    default:
+      NOTREACHED();
+      break;
+  }
+}
+
 }  // namespace
 
-bool InitializeSDK() {
-  SetUpV8();
-
+void InitializeSDK(bool enable_v8) {
   FPDF_LIBRARY_CONFIG config;
-  config.version = 2;
+  config.version = 3;
   config.m_pUserFontPaths = nullptr;
-  config.m_pIsolate = v8::Isolate::GetCurrent();
+  config.m_pIsolate = nullptr;
+  config.m_pPlatform = nullptr;
   config.m_v8EmbedderSlot = gin::kEmbedderPDFium;
+
+#if defined(PDF_ENABLE_V8)
+  if (enable_v8) {
+    SetUpV8();
+    config.m_pIsolate = v8::Isolate::GetCurrent();
+    // NOTE: static_cast<> prior to assigning to (void*) is safer since it
+    // will manipulate the pointer value should gin::V8Platform someday have
+    // multiple base classes.
+    config.m_pPlatform = static_cast<v8::Platform*>(gin::V8Platform::Get());
+  }
+#endif  // defined(PDF_ENABLE_V8)
+
   FPDF_InitLibraryWithConfig(&config);
 
-#if defined(OS_LINUX)
-  // Font loading doesn't work in the renderer sandbox in Linux.
-  FPDF_SetSystemFontInfo(&g_font_info);
-#else
-  g_font_info =
-      new FPDF_SYSFONTINFO_WITHMETRICS(FPDF_GetDefaultSystemFontInfo());
-  g_font_info->Release = Release;
-  g_font_info->EnumFonts = EnumFonts;
-  // Set new MapFont that calculates metrics
-  g_font_info->MapFont = MapFontWithMetrics;
-  g_font_info->GetFont = GetFont;
-  g_font_info->GetFaceName = GetFaceName;
-  g_font_info->GetFontCharset = GetFontCharset;
-  g_font_info->GetFontData = GetFontData;
-  g_font_info->DeleteFont = DeleteFont;
-  FPDF_SetSystemFontInfo(g_font_info);
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+  InitializeLinuxFontMapper();
 #endif
 
   InitializeUnsupportedFeaturesHandler();
-
-  return true;
 }
 
 void ShutdownSDK() {
   FPDF_DestroyLibrary();
-#if !defined(OS_LINUX)
-  delete g_font_info;
-#endif
-  TearDownV8();
+#if defined(PDF_ENABLE_V8)
+  if (IsV8Initialized())
+    TearDownV8();
+#endif  // defined(PDF_ENABLE_V8)
 }
 
-std::unique_ptr<PDFEngine> PDFEngine::Create(PDFEngine::Client* client,
-                                             bool enable_javascript) {
-  return std::make_unique<PDFiumEngine>(client, enable_javascript);
-}
-
-PDFiumEngine::PDFiumEngine(PDFEngine::Client* client, bool enable_javascript)
+PDFiumEngine::PDFiumEngine(PDFEngine::Client* client,
+                           PDFiumFormFiller::ScriptOption script_option)
     : client_(client),
-      form_filler_(this, enable_javascript),
+      form_filler_(this, script_option),
       mouse_down_state_(PDFiumPage::NONSELECTABLE_AREA,
                         PDFiumPage::LinkTarget()),
       print_(this) {
-  find_factory_.Initialize(this);
-  password_factory_.Initialize(this);
+#if defined(PDF_ENABLE_V8)
+  if (script_option != PDFiumFormFiller::ScriptOption::kNoJavaScript)
+    DCHECK(IsV8Initialized());
+#endif  // defined(PDF_ENABLE_V8)
 
   IFSDK_PAUSE::version = 1;
   IFSDK_PAUSE::user = nullptr;
   IFSDK_PAUSE::NeedToPauseNow = Pause_NeedToPauseNow;
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
   // PreviewModeClient does not know its pp::Instance.
-  pp::Instance* instance = client_->GetPluginInstance();
-  if (instance)
-    g_last_instance_id = instance->pp_instance();
+  SetLastInstance(client_->GetPluginInstance());
 #endif
 }
 
@@ -706,10 +555,12 @@ PDFiumEngine::~PDFiumEngine() {
     FORM_DoDocumentAAction(form(), FPDFDOC_AACTION_WC);
 }
 
-// static
-void PDFiumEngine::SetCreateDocumentLoaderFunctionForTesting(
-    CreateDocumentLoaderFunction function) {
-  g_create_document_loader_for_testing = function;
+void PDFiumEngine::SetDocumentLoaderForTesting(
+    std::unique_ptr<DocumentLoader> loader) {
+  DCHECK(loader);
+  DCHECK(!doc_loader_);
+  doc_loader_ = std::move(loader);
+  doc_loader_set_for_testing_ = true;
 }
 
 bool PDFiumEngine::New(const char* url, const char* headers) {
@@ -721,11 +572,11 @@ bool PDFiumEngine::New(const char* url, const char* headers) {
   return true;
 }
 
-void PDFiumEngine::PageOffsetUpdated(const pp::Point& page_offset) {
+void PDFiumEngine::PageOffsetUpdated(const gfx::Vector2d& page_offset) {
   page_offset_ = page_offset;
 }
 
-void PDFiumEngine::PluginSizeUpdated(const pp::Size& size) {
+void PDFiumEngine::PluginSizeUpdated(const gfx::Size& size) {
   CancelPaints();
 
   plugin_size_ = size;
@@ -738,7 +589,7 @@ void PDFiumEngine::ScrolledToXPosition(int position) {
   int old_x = position_.x();
   position_.set_x(position);
   CalculateVisiblePages();
-  client_->DidScroll(pp::Point(old_x - position, 0));
+  client_->DidScroll(gfx::Vector2d(old_x - position, 0));
   OnSelectionPositionChanged();
 }
 
@@ -748,7 +599,7 @@ void PDFiumEngine::ScrolledToYPosition(int position) {
   int old_y = position_.y();
   position_.set_y(position);
   CalculateVisiblePages();
-  client_->DidScroll(pp::Point(0, old_y - position));
+  client_->DidScroll(gfx::Vector2d(0, old_y - position));
   OnSelectionPositionChanged();
 }
 
@@ -757,15 +608,11 @@ void PDFiumEngine::PrePaint() {
     paint.set_painted(false);
 }
 
-void PDFiumEngine::Paint(const pp::Rect& rect,
-                         pp::ImageData* image_data,
-                         std::vector<pp::Rect>* ready,
-                         std::vector<pp::Rect>* pending) {
-  DCHECK(image_data);
-  DCHECK(ready);
-  DCHECK(pending);
-
-  pp::Rect leftover = rect;
+void PDFiumEngine::Paint(const gfx::Rect& rect,
+                         SkBitmap& image_data,
+                         std::vector<gfx::Rect>& ready,
+                         std::vector<gfx::Rect>& pending) {
+  gfx::Rect leftover = rect;
   for (size_t i = 0; i < visible_pages_.size(); ++i) {
     int index = visible_pages_[i];
     // Convert the current page's rectangle to screen rectangle.  We do this
@@ -773,21 +620,28 @@ void PDFiumEngine::Paint(const pp::Rect& rect,
     // page coordinates) because then we'd have to convert back to screen
     // coordinates, and the rounding errors sometime leave pixels dirty or even
     // move the text up or down a pixel when zoomed.
-    pp::Rect page_rect_in_screen = GetPageScreenRect(index);
-    pp::Rect dirty_in_screen = page_rect_in_screen.Intersect(leftover);
+    gfx::Rect page_rect_in_screen = GetPageScreenRect(index);
+    gfx::Rect dirty_in_screen =
+        gfx::IntersectRects(page_rect_in_screen, leftover);
     if (dirty_in_screen.IsEmpty())
       continue;
 
     // Compute the leftover dirty region. The first page may have blank space
     // above it, in which case we also need to subtract that space from the
     // dirty region.
-    if (i == 0) {
-      pp::Rect blank_space_in_screen = dirty_in_screen;
-      blank_space_in_screen.set_y(0);
-      blank_space_in_screen.set_height(dirty_in_screen.y());
-      leftover = leftover.Subtract(blank_space_in_screen);
+    // If two-up view is enabled, we don't need to recompute |leftover| since
+    // subtracting |leftover| with a two-up view page won't result in a
+    // rectangle.
+    if (!layout_.options().two_up_view_enabled()) {
+      if (i == 0) {
+        gfx::Rect blank_space_in_screen = dirty_in_screen;
+        blank_space_in_screen.set_y(0);
+        blank_space_in_screen.set_height(dirty_in_screen.y());
+        leftover.Subtract(blank_space_in_screen);
+      }
+
+      leftover.Subtract(dirty_in_screen);
     }
-    leftover = leftover.Subtract(dirty_in_screen);
 
     if (pages_[index]->available()) {
       int progressive = GetProgressiveIndex(index);
@@ -800,7 +654,7 @@ void PDFiumEngine::Paint(const pp::Rect& rect,
           // happened, but it made scrolling up on complex PDFs very slow since
           // there would be a damaged rect at the top (from scroll) and at the
           // bottom (from toolbar).
-          pending->push_back(dirty_in_screen);
+          pending.push_back(dirty_in_screen);
           continue;
         }
       }
@@ -815,13 +669,13 @@ void PDFiumEngine::Paint(const pp::Rect& rect,
       progressive_paints_[progressive].set_painted(true);
       if (ContinuePaint(progressive, image_data)) {
         FinishPaint(progressive, image_data);
-        ready->push_back(dirty_in_screen);
+        ready.push_back(dirty_in_screen);
       } else {
-        pending->push_back(dirty_in_screen);
+        pending.push_back(dirty_in_screen);
       }
     } else {
       PaintUnavailablePage(index, dirty_in_screen, image_data);
-      ready->push_back(dirty_in_screen);
+      ready.push_back(dirty_in_screen);
     }
   }
 }
@@ -841,15 +695,14 @@ void PDFiumEngine::PostPaint() {
   }
 }
 
-bool PDFiumEngine::HandleDocumentLoad(const pp::URLLoader& loader) {
+bool PDFiumEngine::HandleDocumentLoad(std::unique_ptr<UrlLoader> loader) {
   password_tries_remaining_ = kMaxPasswordTries;
-  process_when_pending_request_complete_ = true;
+  process_when_pending_request_complete_ =
+      base::FeatureList::IsEnabled(features::kPdfIncrementalLoading);
 
-  if (g_create_document_loader_for_testing) {
-    doc_loader_ = g_create_document_loader_for_testing(this);
-  } else {
+  if (!doc_loader_set_for_testing_) {
     auto loader_wrapper =
-        std::make_unique<URLLoaderWrapperImpl>(GetPluginInstance(), loader);
+        std::make_unique<URLLoaderWrapperImpl>(std::move(loader));
     loader_wrapper->SetResponseHeaders(headers_);
 
     doc_loader_ = std::make_unique<DocumentLoaderImpl>(this);
@@ -868,26 +721,30 @@ pp::Instance* PDFiumEngine::GetPluginInstance() {
 }
 
 std::unique_ptr<URLLoaderWrapper> PDFiumEngine::CreateURLLoader() {
-  return std::make_unique<URLLoaderWrapperImpl>(GetPluginInstance(),
-                                                client_->CreateURLLoader());
+  return std::make_unique<URLLoaderWrapperImpl>(client_->CreateUrlLoader());
 }
 
 void PDFiumEngine::AppendPage(PDFEngine* engine, int index) {
   // Unload and delete the blank page before appending.
   pages_[index]->Unload();
   pages_[index]->set_calculated_links(false);
-  pp::Size curr_page_size = GetPageSize(index);
+  gfx::Size curr_page_size = GetPageSize(index);
   FPDFPage_Delete(doc(), index);
   FPDF_ImportPages(doc(), static_cast<PDFiumEngine*>(engine)->doc(), "1",
                    index);
-  pp::Size new_page_size = GetPageSize(index);
-  if (curr_page_size != new_page_size)
-    LoadPageInfo(true);
+  gfx::Size new_page_size = GetPageSize(index);
+  if (curr_page_size != new_page_size) {
+    DCHECK(document_loaded_);
+    LoadPageInfo();
+  }
   client_->Invalidate(GetPageScreenRect(index));
 }
 
-std::string PDFiumEngine::GetMetadata(const std::string& key) {
-  return GetDocumentMetadata(doc(), key);
+std::vector<uint8_t> PDFiumEngine::GetSaveData() {
+  PDFiumMemBufferFileWrite output_file_write;
+  if (!FPDF_SaveAsCopy(doc(), &output_file_write, 0))
+    return std::vector<uint8_t>();
+  return output_file_write.TakeBuffer();
 }
 
 void PDFiumEngine::OnPendingRequestComplete() {
@@ -897,13 +754,13 @@ void PDFiumEngine::OnPendingRequestComplete() {
   if (!fpdf_availability()) {
     document_->file_access().m_FileLen = doc_loader_->GetDocumentSize();
     document_->CreateFPDFAvailability();
-    DCHECK(fpdf_availability());
+
     // Currently engine does not deal efficiently with some non-linearized
     // files.
     // See http://code.google.com/p/chromium/issues/detail?id=59400
     // To improve user experience we download entire file for non-linearized
     // PDF.
-    if (FPDFAvail_IsLinearized(fpdf_availability()) != PDF_LINEARIZED) {
+    if (!IsLinearized()) {
       // Wait complete document.
       process_when_pending_request_complete_ = false;
       document_->ResetFPDFAvailability();
@@ -928,16 +785,15 @@ void PDFiumEngine::OnPendingRequestComplete() {
   for (int pending_page : pending_pages_) {
     if (CheckPageAvailable(pending_page, &still_pending)) {
       update_pages = true;
-      if (IsPageVisible(pending_page)) {
-        client_->NotifyPageBecameVisible(
-            pages_[pending_page]->GetPageFeatures());
+      if (IsPageVisible(pending_page))
         client_->Invalidate(GetPageScreenRect(pending_page));
-      }
     }
   }
   pending_pages_.swap(still_pending);
-  if (update_pages)
-    LoadPageInfo(true);
+  if (update_pages) {
+    DCHECK(!document_loaded_);
+    LoadPageInfo();
+  }
 }
 
 void PDFiumEngine::OnNewDataReceived() {
@@ -964,10 +820,6 @@ void PDFiumEngine::OnDocumentCanceled() {
     OnDocumentComplete();
 }
 
-void PDFiumEngine::CancelBrowserDownload() {
-  client_->CancelBrowserDownload();
-}
-
 void PDFiumEngine::FinishLoadingDocument() {
   DCHECK(doc());
   DCHECK(doc_loader_->IsDocumentComplete());
@@ -980,7 +832,7 @@ void PDFiumEngine::FinishLoadingDocument() {
     if (pages_[i]->available())
       continue;
 
-    pages_[i]->set_available(true);
+    pages_[i]->MarkAvailable();
     // We still need to call IsPageAvail() even if the whole document is
     // already downloaded.
     FPDFAvail_IsPageAvail(fpdf_availability(), i, &download_hints);
@@ -988,8 +840,19 @@ void PDFiumEngine::FinishLoadingDocument() {
     if (IsPageVisible(i))
       client_->Invalidate(GetPageScreenRect(i));
   }
+
+  // Transition |document_loaded_| to true after finishing any calls to
+  // FPDFAvail_IsPageAvail(), since we no longer need to defer calls to this
+  // function from LoadPageInfo(). Note that LoadBody() calls LoadPageInfo()
+  // indirectly, so we cannot make this transition earlier.
+  document_loaded_ = true;
+
   if (need_update)
-    LoadPageInfo(true);
+    LoadPageInfo();
+
+  LoadDocumentAttachmentInfoList();
+
+  LoadDocumentMetadata();
 
   if (called_do_document_action_)
     return;
@@ -1003,28 +866,13 @@ void PDFiumEngine::FinishLoadingDocument() {
     FORM_DoPageAAction(new_page, form(), FPDFPAGE_AACTION_OPEN);
   }
 
-  if (doc()) {
-    DocumentFeatures document_features;
-    document_features.page_count = pages_.size();
-    document_features.has_attachments = (FPDFDoc_GetAttachmentCount(doc()) > 0);
-    document_features.is_linearized =
-        (FPDFAvail_IsLinearized(fpdf_availability()) == PDF_LINEARIZED);
-    document_features.is_tagged = FPDFCatalog_IsTagged(doc());
-    document_features.form_type =
-        static_cast<FormType>(FPDF_GetFormType(doc()));
-    client_->DocumentLoadComplete(document_features,
-                                  doc_loader_->BytesReceived());
-  }
+  client_->DocumentLoadComplete();
 }
 
 void PDFiumEngine::UnsupportedFeature(const std::string& feature) {
   client_->DocumentHasUnsupportedFeature(feature);
 }
 
-void PDFiumEngine::FontSubstituted() {
-  client_->FontSubstituted();
-}
-
 FPDF_AVAIL PDFiumEngine::fpdf_availability() const {
   return document_ ? document_->fpdf_availability() : nullptr;
 }
@@ -1037,48 +885,52 @@ FPDF_FORMHANDLE PDFiumEngine::form() const {
   return document_ ? document_->form() : nullptr;
 }
 
+bool PDFiumEngine::IsValidLink(const std::string& url) {
+  return client_->IsValidLink(url);
+}
+
 void PDFiumEngine::ContinueFind(int32_t result) {
   StartFind(current_find_text_, result != 0);
 }
 
-bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
+bool PDFiumEngine::HandleEvent(const InputEvent& event) {
   DCHECK(!defer_page_unload_);
   defer_page_unload_ = true;
   bool rv = false;
-  switch (event.GetType()) {
-    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
-      rv = OnMouseDown(pp::MouseInputEvent(event));
+  switch (event.GetEventType()) {
+    case InputEventType::kMouseDown:
+      rv = OnMouseDown(static_cast<const MouseInputEvent&>(event));
       break;
-    case PP_INPUTEVENT_TYPE_MOUSEUP:
-      rv = OnMouseUp(pp::MouseInputEvent(event));
+    case InputEventType::kMouseUp:
+      rv = OnMouseUp(static_cast<const MouseInputEvent&>(event));
       break;
-    case PP_INPUTEVENT_TYPE_MOUSEMOVE:
-      rv = OnMouseMove(pp::MouseInputEvent(event));
+    case InputEventType::kMouseMove:
+      rv = OnMouseMove(static_cast<const MouseInputEvent&>(event));
       break;
-    case PP_INPUTEVENT_TYPE_MOUSEENTER:
-      OnMouseEnter(pp::MouseInputEvent(event));
+    case InputEventType::kMouseEnter:
+      OnMouseEnter(static_cast<const MouseInputEvent&>(event));
       break;
-    case PP_INPUTEVENT_TYPE_KEYDOWN:
-      rv = OnKeyDown(pp::KeyboardInputEvent(event));
+    case InputEventType::kKeyDown:
+      rv = OnKeyDown(static_cast<const KeyboardInputEvent&>(event));
       break;
-    case PP_INPUTEVENT_TYPE_KEYUP:
-      rv = OnKeyUp(pp::KeyboardInputEvent(event));
+    case InputEventType::kKeyUp:
+      rv = OnKeyUp(static_cast<const KeyboardInputEvent&>(event));
       break;
-    case PP_INPUTEVENT_TYPE_CHAR:
-      rv = OnChar(pp::KeyboardInputEvent(event));
+    case InputEventType::kChar:
+      rv = OnChar(static_cast<const KeyboardInputEvent&>(event));
       break;
-    case PP_INPUTEVENT_TYPE_TOUCHSTART: {
+    case InputEventType::kTouchStart: {
       KillTouchTimer();
 
-      pp::TouchInputEvent touch_event(event);
-      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)
+      const auto& touch_event = static_cast<const TouchInputEvent&>(event);
+      if (touch_event.GetTouchCount() == 1)
         ScheduleTouchTimer(touch_event);
       break;
     }
-    case PP_INPUTEVENT_TYPE_TOUCHEND:
+    case InputEventType::kTouchEnd:
       KillTouchTimer();
       break;
-    case PP_INPUTEVENT_TYPE_TOUCHMOVE:
+    case InputEventType::kTouchMove:
       // TODO(dsinclair): This should allow a little bit of movement (up to the
       // touch radii) to account for finger jiggle.
       KillTouchTimer();
@@ -1118,23 +970,22 @@ pp::Resource PDFiumEngine::PrintPages(
     uint32_t page_range_count,
     const PP_PrintSettings_Dev& print_settings,
     const PP_PdfPrintSettings_Dev& pdf_print_settings) {
-  ScopedSubstFont scoped_subst_font(this);
   if (!page_range_count)
     return pp::Resource();
 
   if ((print_settings.format & PP_PRINTOUTPUTFORMAT_PDF) &&
       HasPermission(PERMISSION_PRINT_HIGH_QUALITY)) {
-    return PrintPagesAsPDF(page_ranges, page_range_count, print_settings,
+    return PrintPagesAsPdf(page_ranges, page_range_count, print_settings,
                            pdf_print_settings);
   }
   if (HasPermission(PERMISSION_PRINT_LOW_QUALITY)) {
-    return PrintPagesAsRasterPDF(page_ranges, page_range_count, print_settings,
+    return PrintPagesAsRasterPdf(page_ranges, page_range_count, print_settings,
                                  pdf_print_settings);
   }
   return pp::Resource();
 }
 
-pp::Buffer_Dev PDFiumEngine::PrintPagesAsRasterPDF(
+pp::Buffer_Dev PDFiumEngine::PrintPagesAsRasterPdf(
     const PP_PrintPageNumberRange_Dev* page_ranges,
     uint32_t page_range_count,
     const PP_PrintSettings_Dev& print_settings,
@@ -1147,15 +998,16 @@ pp::Buffer_Dev PDFiumEngine::PrintPagesAsRasterPDF(
 
   KillFormFocus();
 
-#if defined(OS_LINUX)
-  g_last_instance_id = client_->GetPluginInstance()->pp_instance();
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+  SetLastInstance(client_->GetPluginInstance());
 #endif
 
-  return print_.PrintPagesAsRasterPDF(page_ranges, page_range_count,
-                                      print_settings, pdf_print_settings);
+  return ConvertPdfToBufferDev(
+      print_.PrintPagesAsPdf(page_ranges, page_range_count, print_settings,
+                             pdf_print_settings, /*raster=*/true));
 }
 
-pp::Buffer_Dev PDFiumEngine::PrintPagesAsPDF(
+pp::Buffer_Dev PDFiumEngine::PrintPagesAsPdf(
     const PP_PrintPageNumberRange_Dev* page_ranges,
     uint32_t page_range_count,
     const PP_PrintSettings_Dev& print_settings,
@@ -1174,8 +1026,20 @@ pp::Buffer_Dev PDFiumEngine::PrintPagesAsPDF(
       pages_[page_number]->Unload();
   }
 
-  return print_.PrintPagesAsPDF(page_ranges, page_range_count, print_settings,
-                                pdf_print_settings);
+  return ConvertPdfToBufferDev(
+      print_.PrintPagesAsPdf(page_ranges, page_range_count, print_settings,
+                             pdf_print_settings, /*raster=*/false));
+}
+
+pp::Buffer_Dev PDFiumEngine::ConvertPdfToBufferDev(
+    const std::vector<uint8_t>& pdf_data) {
+  pp::Buffer_Dev buffer;
+  if (!pdf_data.empty()) {
+    buffer = pp::Buffer_Dev(GetPluginInstance(), pdf_data.size());
+    if (!buffer.is_null())
+      memcpy(buffer.data(), pdf_data.data(), pdf_data.size());
+  }
+  return buffer;
 }
 
 void PDFiumEngine::KillFormFocus() {
@@ -1183,30 +1047,105 @@ void PDFiumEngine::KillFormFocus() {
   SetInFormTextArea(false);
 }
 
+void PDFiumEngine::UpdateFocus(bool has_focus) {
+  base::AutoReset<bool> updating_focus_guard(&updating_focus_, true);
+  if (has_focus && !IsReadOnly()) {
+    UpdateFocusItemType(last_focused_item_type_);
+    if (focus_item_type_ == FocusElementType::kPage &&
+        PageIndexInBounds(last_focused_page_) &&
+        last_focused_annot_index_ != -1) {
+      ScopedFPDFAnnotation last_focused_annot(FPDFPage_GetAnnot(
+          pages_[last_focused_page_]->GetPage(), last_focused_annot_index_));
+      if (last_focused_annot) {
+        FPDF_BOOL ret = FORM_SetFocusedAnnot(form(), last_focused_annot.get());
+        DCHECK(ret);
+      }
+    }
+  } else {
+    last_focused_item_type_ = focus_item_type_;
+    if (focus_item_type_ == FocusElementType::kDocument) {
+      UpdateFocusItemType(FocusElementType::kNone);
+    } else if (focus_item_type_ == FocusElementType::kPage) {
+      FPDF_ANNOTATION last_focused_annot = nullptr;
+      FPDF_BOOL ret = FORM_GetFocusedAnnot(form(), &last_focused_page_,
+                                           &last_focused_annot);
+      if (ret && PageIndexInBounds(last_focused_page_) && last_focused_annot) {
+        last_focused_annot_index_ = FPDFPage_GetAnnotIndex(
+            pages_[last_focused_page_]->GetPage(), last_focused_annot);
+      } else {
+        last_focused_annot_index_ = -1;
+      }
+      FPDFPage_CloseAnnot(last_focused_annot);
+    }
+    KillFormFocus();
+  }
+}
+
+PP_PrivateAccessibilityFocusInfo PDFiumEngine::GetFocusInfo() {
+  PP_PrivateAccessibilityFocusInfo focus_info = {
+      PP_PrivateFocusObjectType::PP_PRIVATEFOCUSOBJECT_NONE, 0, 0};
+
+  switch (focus_item_type_) {
+    case FocusElementType::kNone: {
+      break;
+    }
+    case FocusElementType::kPage: {
+      int page_index = -1;
+      FPDF_ANNOTATION focused_annot = nullptr;
+      FPDF_BOOL ret = FORM_GetFocusedAnnot(form(), &page_index, &focused_annot);
+      DCHECK(ret);
+
+      if (PageIndexInBounds(page_index) && focused_annot) {
+        PP_PrivateFocusObjectType type =
+            GetAnnotationFocusType(FPDFAnnot_GetSubtype(focused_annot));
+        int annot_index = FPDFPage_GetAnnotIndex(pages_[page_index]->GetPage(),
+                                                 focused_annot);
+        if (type != PP_PrivateFocusObjectType::PP_PRIVATEFOCUSOBJECT_NONE &&
+            annot_index >= 0) {
+          focus_info.focused_object_type = type;
+          focus_info.focused_object_page_index = page_index;
+          focus_info.focused_annotation_index_in_page = annot_index;
+        }
+      }
+      FPDFPage_CloseAnnot(focused_annot);
+      break;
+    }
+    case FocusElementType::kDocument: {
+      focus_info.focused_object_type =
+          PP_PrivateFocusObjectType::PP_PRIVATEFOCUSOBJECT_DOCUMENT;
+      break;
+    }
+  }
+  return focus_info;
+}
+
+uint32_t PDFiumEngine::GetLoadedByteSize() {
+  return doc_loader_->GetDocumentSize();
+}
+
+bool PDFiumEngine::ReadLoadedBytes(uint32_t length, void* buffer) {
+  DCHECK_LE(length, GetLoadedByteSize());
+  return doc_loader_->GetBlock(0, length, buffer);
+}
+
 void PDFiumEngine::SetFormSelectedText(FPDF_FORMHANDLE form_handle,
                                        FPDF_PAGE page) {
-  unsigned long form_sel_text_len =
-      FORM_GetSelectedText(form_handle, page, nullptr, 0);
+  std::u16string selected_form_text16 = CallPDFiumWideStringBufferApi(
+      base::BindRepeating(&FORM_GetSelectedText, form_handle, page),
+      /*check_expected_size=*/false);
 
   // If form selected text is empty and there was no previous form text
-  // selection, exit early because nothing has changed. When |form_sel_text_len|
-  // is 2, that represents a wide string with just a NUL-terminator.
-  if (form_sel_text_len <= 2 && selected_form_text_.empty())
+  // selection, exit early because nothing has changed.
+  if (selected_form_text16.empty() && selected_form_text_.empty())
     return;
 
-  base::string16 selected_form_text16;
-  PDFiumAPIStringBufferSizeInBytesAdapter<base::string16> string_adapter(
-      &selected_form_text16, form_sel_text_len, false);
-  string_adapter.Close(FORM_GetSelectedText(
-      form_handle, page, string_adapter.GetData(), form_sel_text_len));
-
   // Update previous and current selections, then compare them to check if
   // selection has changed. If so, set plugin text selection.
   std::string selected_form_text = selected_form_text_;
   selected_form_text_ = base::UTF16ToUTF8(selected_form_text16);
   if (selected_form_text != selected_form_text_) {
     DCHECK(in_form_text_area_);
-    pp::PDF::SetSelectedText(GetPluginInstance(), selected_form_text_.c_str());
+    client_->SetSelectedText(selected_form_text_);
   }
 }
 
@@ -1214,13 +1153,13 @@ void PDFiumEngine::PrintEnd() {
   FORM_DoDocumentAAction(form(), FPDFDOC_AACTION_DP);
 }
 
-PDFiumPage::Area PDFiumEngine::GetCharIndex(const pp::Point& point,
+PDFiumPage::Area PDFiumEngine::GetCharIndex(const gfx::Point& point,
                                             int* page_index,
                                             int* char_index,
                                             int* form_type,
                                             PDFiumPage::LinkTarget* target) {
   int page = -1;
-  pp::Point point_in_page(
+  gfx::Point point_in_page(
       static_cast<int>((point.x() + position_.x()) / current_zoom_),
       static_cast<int>((point.y() + position_.y()) / current_zoom_));
   for (int visible_page : visible_pages_) {
@@ -1241,20 +1180,20 @@ PDFiumPage::Area PDFiumEngine::GetCharIndex(const pp::Point& point,
 
   *page_index = page;
   PDFiumPage::Area result = pages_[page]->GetCharIndex(
-      point_in_page, current_rotation_, char_index, form_type, target);
+      point_in_page, layout_.options().default_page_orientation(), char_index,
+      form_type, target);
   return (client_->IsPrintPreview() && result == PDFiumPage::WEBLINK_AREA)
              ? PDFiumPage::NONSELECTABLE_AREA
              : result;
 }
 
-bool PDFiumEngine::OnMouseDown(const pp::MouseInputEvent& event) {
-  pp::MouseInputEvent normalized_event =
-      NormalizeMouseEvent(client_->GetPluginInstance(), event);
-  if (normalized_event.GetButton() == PP_INPUTEVENT_MOUSEBUTTON_LEFT)
+bool PDFiumEngine::OnMouseDown(const MouseInputEvent& event) {
+  MouseInputEvent normalized_event = NormalizeMouseEvent(event);
+  if (normalized_event.GetButton() == InputEventMouseButtonType::kLeft)
     return OnLeftMouseDown(normalized_event);
-  if (normalized_event.GetButton() == PP_INPUTEVENT_MOUSEBUTTON_MIDDLE)
+  if (normalized_event.GetButton() == InputEventMouseButtonType::kMiddle)
     return OnMiddleMouseDown(normalized_event);
-  if (normalized_event.GetButton() == PP_INPUTEVENT_MOUSEBUTTON_RIGHT)
+  if (normalized_event.GetButton() == InputEventMouseButtonType::kRight)
     return OnRightMouseDown(normalized_event);
   return false;
 }
@@ -1274,7 +1213,7 @@ void PDFiumEngine::OnMultipleClick(int click_count,
   // now it doesn't.
   int start_index = char_index;
   do {
-    base::char16 cur = pages_[page_index]->GetCharAtIndex(start_index);
+    char16_t cur = pages_[page_index]->GetCharAtIndex(start_index);
     if (FindMultipleClickBoundary(is_double_click, cur))
       break;
   } while (--start_index >= 0);
@@ -1284,16 +1223,19 @@ void PDFiumEngine::OnMultipleClick(int click_count,
   int end_index = char_index;
   int total = pages_[page_index]->GetCharCount();
   while (end_index++ <= total) {
-    base::char16 cur = pages_[page_index]->GetCharAtIndex(end_index);
+    char16_t cur = pages_[page_index]->GetCharAtIndex(end_index);
     if (FindMultipleClickBoundary(is_double_click, cur))
       break;
   }
 
   selection_.push_back(PDFiumRange(pages_[page_index].get(), start_index,
                                    end_index - start_index));
+
+  if (handling_long_press_)
+    client_->NotifyTouchSelectionOccurred();
 }
 
-bool PDFiumEngine::OnLeftMouseDown(const pp::MouseInputEvent& event) {
+bool PDFiumEngine::OnLeftMouseDown(const MouseInputEvent& event) {
   SetMouseLeftButtonDown(true);
 
   auto selection_invalidator =
@@ -1304,7 +1246,7 @@ bool PDFiumEngine::OnLeftMouseDown(const pp::MouseInputEvent& event) {
   int char_index = -1;
   int form_type = FPDF_FORMFIELD_UNKNOWN;
   PDFiumPage::LinkTarget target;
-  pp::Point point = event.GetPosition();
+  gfx::Point point = event.GetPosition();
   PDFiumPage::Area area =
       GetCharIndex(point, &page_index, &char_index, &form_type, &target);
   DCHECK_GE(form_type, FPDF_FORMFIELD_UNKNOWN);
@@ -1316,19 +1258,15 @@ bool PDFiumEngine::OnLeftMouseDown(const pp::MouseInputEvent& event) {
     return true;
 
   if (page_index != -1) {
-    last_page_mouse_down_ = page_index;
+    UpdateFocusItemType(FocusElementType::kPage);
+    last_focused_page_ = page_index;
     double page_x;
     double page_y;
     DeviceToPage(page_index, point, &page_x, &page_y);
 
-    bool is_form_text_area = IsFormTextArea(area, form_type);
-    FPDF_PAGE page = pages_[page_index]->GetPage();
-    bool is_editable_form_text_area =
-        is_form_text_area &&
-        IsPointInEditableFormTextArea(page, page_x, page_y, form_type);
-
-    FORM_OnLButtonDown(form(), page, event.GetModifiers(), page_x, page_y);
     if (form_type != FPDF_FORMFIELD_UNKNOWN) {
+      // FORM_OnLButton*() will trigger a callback to
+      // OnFocusedAnnotationUpdated() which will call SetInFormTextArea().
       // Destroy SelectionChangeInvalidator object before SetInFormTextArea()
       // changes plugin's focus to be in form text area. This way, regular text
       // selection can be cleared when a user clicks into a form text area
@@ -1336,11 +1274,18 @@ bool PDFiumEngine::OnLeftMouseDown(const pp::MouseInputEvent& event) {
       // ~SelectionChangeInvalidator() still goes to the Mimehandler
       // (not the Renderer).
       selection_invalidator.reset();
-
-      SetInFormTextArea(is_form_text_area);
-      editable_form_text_area_ = is_editable_form_text_area;
-      return true;  // Return now before we get into the selection code.
     }
+
+    FPDF_PAGE page = pages_[page_index]->GetPage();
+
+    if (event.GetClickCount() == 1) {
+      FORM_OnLButtonDown(form(), page, event.GetModifiers(), page_x, page_y);
+    } else if (event.GetClickCount() == 2) {
+      FORM_OnLButtonDoubleClick(form(), page, event.GetModifiers(), page_x,
+                                page_y);
+    }
+    if (form_type != FPDF_FORMFIELD_UNKNOWN)
+      return true;  // Return now before we get into the selection code.
   }
   SetInFormTextArea(false);
 
@@ -1355,7 +1300,7 @@ bool PDFiumEngine::OnLeftMouseDown(const pp::MouseInputEvent& event) {
   return true;
 }
 
-bool PDFiumEngine::OnMiddleMouseDown(const pp::MouseInputEvent& event) {
+bool PDFiumEngine::OnMiddleMouseDown(const MouseInputEvent& event) {
   SetMouseLeftButtonDown(false);
   mouse_middle_button_down_ = true;
   mouse_middle_button_last_position_ = event.GetPosition();
@@ -1386,10 +1331,10 @@ bool PDFiumEngine::OnMiddleMouseDown(const pp::MouseInputEvent& event) {
   return false;
 }
 
-bool PDFiumEngine::OnRightMouseDown(const pp::MouseInputEvent& event) {
-  DCHECK_EQ(PP_INPUTEVENT_MOUSEBUTTON_RIGHT, event.GetButton());
+bool PDFiumEngine::OnRightMouseDown(const MouseInputEvent& event) {
+  DCHECK_EQ(InputEventMouseButtonType::kRight, event.GetButton());
 
-  pp::Point point = event.GetPosition();
+  gfx::Point point = event.GetPosition();
   int page_index = -1;
   int char_index = -1;
   int form_type = FPDF_FORMFIELD_UNKNOWN;
@@ -1399,7 +1344,6 @@ bool PDFiumEngine::OnRightMouseDown(const pp::MouseInputEvent& event) {
   DCHECK_GE(form_type, FPDF_FORMFIELD_UNKNOWN);
 
   bool is_form_text_area = IsFormTextArea(area, form_type);
-  bool is_editable_form_text_area = false;
 
   double page_x = -1;
   double page_y = -1;
@@ -1409,8 +1353,6 @@ bool PDFiumEngine::OnRightMouseDown(const pp::MouseInputEvent& event) {
 
     DeviceToPage(page_index, point, &page_x, &page_y);
     page = pages_[page_index]->GetPage();
-    is_editable_form_text_area =
-        IsPointInEditableFormTextArea(page, page_x, page_y, form_type);
   }
 
   // Handle the case when focus starts inside a form text area.
@@ -1428,13 +1370,6 @@ bool PDFiumEngine::OnRightMouseDown(const pp::MouseInputEvent& event) {
   // Handle the case when focus starts outside a form text area and transitions
   // into a form text area.
   if (is_form_text_area) {
-    {
-      SelectionChangeInvalidator selection_invalidator(this);
-      selection_.clear();
-    }
-
-    SetInFormTextArea(true);
-    editable_form_text_area_ = is_editable_form_text_area;
     FORM_OnFocus(form(), page, 0, page_x, page_y);
     return true;
   }
@@ -1444,11 +1379,10 @@ bool PDFiumEngine::OnRightMouseDown(const pp::MouseInputEvent& event) {
   if (selection_.empty())
     return false;
 
-  std::vector<pp::Rect> selection_rect_vector;
-  GetAllScreenRectsUnion(&selection_, GetVisibleRect().point(),
-                         &selection_rect_vector);
+  std::vector<gfx::Rect> selection_rect_vector =
+      GetAllScreenRectsUnion(selection_, GetVisibleRect().origin());
   for (const auto& rect : selection_rect_vector) {
-    if (rect.Contains(point.x(), point.y()))
+    if (rect.Contains(point))
       return false;
   }
   SelectionChangeInvalidator selection_invalidator(this);
@@ -1456,71 +1390,75 @@ bool PDFiumEngine::OnRightMouseDown(const pp::MouseInputEvent& event) {
   return true;
 }
 
-bool PDFiumEngine::OnMouseUp(const pp::MouseInputEvent& event) {
-  if (event.GetButton() != PP_INPUTEVENT_MOUSEBUTTON_LEFT &&
-      event.GetButton() != PP_INPUTEVENT_MOUSEBUTTON_MIDDLE) {
+bool PDFiumEngine::NavigateToLinkDestination(
+    PDFiumPage::Area area,
+    const PDFiumPage::LinkTarget& target,
+    WindowOpenDisposition disposition) {
+  if (area == PDFiumPage::WEBLINK_AREA) {
+    client_->NavigateTo(target.url, disposition);
+    SetInFormTextArea(false);
+    return true;
+  }
+  if (area == PDFiumPage::DOCLINK_AREA) {
+    if (!PageIndexInBounds(target.page))
+      return true;
+
+    if (disposition == WindowOpenDisposition::CURRENT_TAB) {
+      client_->NavigateToDestination(
+          target.page, base::OptionalOrNullptr(target.x_in_pixels),
+          base::OptionalOrNullptr(target.y_in_pixels),
+          base::OptionalOrNullptr(target.zoom));
+    } else {
+      std::string parameters = base::StringPrintf("#page=%d", target.page + 1);
+      parameters += base::StringPrintf(
+          "&zoom=%d,%d,%d", static_cast<int>(target.zoom.value_or(1.0) * 100),
+          static_cast<int>(target.x_in_pixels.value_or(0)),
+          static_cast<int>(target.y_in_pixels.value_or(0)));
+
+      client_->NavigateTo(parameters, disposition);
+    }
+    SetInFormTextArea(false);
+    return true;
+  }
+  return false;
+}
+
+bool PDFiumEngine::OnMouseUp(const MouseInputEvent& event) {
+  if (event.GetButton() != InputEventMouseButtonType::kLeft &&
+      event.GetButton() != InputEventMouseButtonType::kMiddle) {
     return false;
   }
 
-  if (event.GetButton() == PP_INPUTEVENT_MOUSEBUTTON_LEFT)
+  if (event.GetButton() == InputEventMouseButtonType::kLeft)
     SetMouseLeftButtonDown(false);
-  else if (event.GetButton() == PP_INPUTEVENT_MOUSEBUTTON_MIDDLE)
+  else if (event.GetButton() == InputEventMouseButtonType::kMiddle)
     mouse_middle_button_down_ = false;
 
   int page_index = -1;
   int char_index = -1;
   int form_type = FPDF_FORMFIELD_UNKNOWN;
   PDFiumPage::LinkTarget target;
-  pp::Point point = event.GetPosition();
+  gfx::Point point = event.GetPosition();
   PDFiumPage::Area area =
       GetCharIndex(point, &page_index, &char_index, &form_type, &target);
 
   // Open link on mouse up for same link for which mouse down happened earlier.
   if (mouse_down_state_.Matches(area, target)) {
     uint32_t modifiers = event.GetModifiers();
-    bool middle_button =
-        !!(modifiers & PP_INPUTEVENT_MODIFIER_MIDDLEBUTTONDOWN);
-    bool alt_key = !!(modifiers & PP_INPUTEVENT_MODIFIER_ALTKEY);
-    bool ctrl_key = !!(modifiers & PP_INPUTEVENT_MODIFIER_CONTROLKEY);
-    bool meta_key = !!(modifiers & PP_INPUTEVENT_MODIFIER_METAKEY);
-    bool shift_key = !!(modifiers & PP_INPUTEVENT_MODIFIER_SHIFTKEY);
+    bool middle_button = !!(modifiers & kInputEventModifierMiddleButtonDown);
+    bool alt_key = !!(modifiers & kInputEventModifierAltKey);
+    bool ctrl_key = !!(modifiers & kInputEventModifierControlKey);
+    bool meta_key = !!(modifiers & kInputEventModifierMetaKey);
+    bool shift_key = !!(modifiers & kInputEventModifierShiftKey);
 
     WindowOpenDisposition disposition = ui::DispositionFromClick(
         middle_button, alt_key, ctrl_key, meta_key, shift_key);
 
-    if (area == PDFiumPage::WEBLINK_AREA) {
-      client_->NavigateTo(target.url, disposition);
-      SetInFormTextArea(false);
+    if (NavigateToLinkDestination(area, target, disposition))
       return true;
-    }
-    if (area == PDFiumPage::DOCLINK_AREA) {
-      if (!PageIndexInBounds(target.page))
-        return true;
-
-      if (disposition == WindowOpenDisposition::CURRENT_TAB) {
-        pp::Rect page_rect(GetPageScreenRect(target.page));
-        int y = position_.y() + page_rect.y();
-        if (target.y_in_pixels)
-          y += target.y_in_pixels.value() * current_zoom_;
-
-        client_->ScrollToY(y, /*compensate_for_toolbar=*/true);
-      } else {
-        std::string parameters =
-            base::StringPrintf("#page=%d", target.page + 1);
-        if (target.y_in_pixels) {
-          parameters += base::StringPrintf(
-              "&zoom=100,0,%d", static_cast<int>(target.y_in_pixels.value()));
-        }
-
-        client_->NavigateTo(parameters, disposition);
-      }
-      SetInFormTextArea(false);
-
-      return true;
-    }
   }
 
-  if (event.GetButton() == PP_INPUTEVENT_MOUSEBUTTON_MIDDLE) {
+  if (event.GetButton() == InputEventMouseButtonType::kMiddle) {
     if (kViewerImplementedPanning) {
       // Update the cursor when panning stops.
       client_->UpdateCursor(DetermineCursorType(area, form_type));
@@ -1545,12 +1483,12 @@ bool PDFiumEngine::OnMouseUp(const pp::MouseInputEvent& event) {
   return true;
 }
 
-bool PDFiumEngine::OnMouseMove(const pp::MouseInputEvent& event) {
+bool PDFiumEngine::OnMouseMove(const MouseInputEvent& event) {
   int page_index = -1;
   int char_index = -1;
   int form_type = FPDF_FORMFIELD_UNKNOWN;
   PDFiumPage::LinkTarget target;
-  pp::Point point = event.GetPosition();
+  gfx::Point point = event.GetPosition();
   PDFiumPage::Area area =
       GetCharIndex(point, &page_index, &char_index, &form_type, &target);
 
@@ -1570,17 +1508,13 @@ bool PDFiumEngine::OnMouseMove(const pp::MouseInputEvent& event) {
                        page_y);
     }
 
-    std::string url = GetLinkAtPosition(event.GetPosition());
-    if (url != link_under_cursor_) {
-      link_under_cursor_ = url;
-      pp::PDF::SetLinkUnderCursor(GetPluginInstance(), url.c_str());
-    }
+    UpdateLinkUnderCursor(GetLinkAtPosition(point));
 
     // If in form text area while left mouse button is held down, check if form
     // text selection needs to be updated.
     if (mouse_left_button_down_ && area == PDFiumPage::FORM_TEXT_AREA &&
-        last_page_mouse_down_ != -1) {
-      SetFormSelectedText(form(), pages_[last_page_mouse_down_]->GetPage());
+        last_focused_page_ != -1) {
+      SetFormSelectedText(form(), pages_[last_focused_page_]->GetPage());
     }
 
     if (kViewerImplementedPanning && mouse_middle_button_down_) {
@@ -1588,7 +1522,7 @@ bool PDFiumEngine::OnMouseMove(const pp::MouseInputEvent& event) {
       // moving the page, rather than the delta the mouse moved.
       // GetMovement() does not work here, as small mouse movements are
       // considered zero.
-      pp::Point page_position_delta =
+      gfx::Vector2d page_position_delta =
           mouse_middle_button_last_position_ - event.GetPosition();
       if (page_position_delta.x() != 0 || page_position_delta.y() != 0) {
         client_->ScrollBy(page_position_delta);
@@ -1651,8 +1585,8 @@ PP_CursorType_Dev PDFiumEngine::DetermineCursorType(PDFiumPage::Area area,
   }
 }
 
-void PDFiumEngine::OnMouseEnter(const pp::MouseInputEvent& event) {
-  if (event.GetModifiers() & PP_INPUTEVENT_MODIFIER_MIDDLEBUTTONDOWN) {
+void PDFiumEngine::OnMouseEnter(const MouseInputEvent& event) {
+  if (event.GetModifiers() & kInputEventModifierMiddleButtonDown) {
     if (!mouse_middle_button_down_) {
       mouse_middle_button_down_ = true;
       mouse_middle_button_last_position_ = event.GetPosition();
@@ -1677,9 +1611,8 @@ bool PDFiumEngine::ExtendSelection(int page_index, int char_index) {
   if (selection_.empty())
     return false;
 
-  PDFiumRange& last_selection = selection_.back();
-  const int last_page_index = last_selection.page_index();
-  const int last_char_index = last_selection.char_index();
+  const int last_page_index = selection_.back().page_index();
+  const int last_char_index = selection_.back().char_index();
   if (last_page_index == page_index) {
     // Selecting within a page.
     int count = char_index - last_char_index;
@@ -1689,10 +1622,15 @@ bool PDFiumEngine::ExtendSelection(int page_index, int char_index) {
     } else {
       --count;
     }
-    last_selection.SetCharCount(count);
+    selection_.back().SetCharCount(count);
   } else if (last_page_index < page_index) {
     // Selecting into the next page.
 
+    // Save the current last selection for use below.
+    // Warning: Do not use references / pointers into |selection_|, as the code
+    // below can modify |selection_| and invalidate those references / pointers.
+    const size_t last_selection_index = selection_.size() - 1;
+
     // First make sure that there are no gaps in selection, i.e. if mousedown on
     // page one but we only get mousemove over page three, we want page two.
     for (int i = last_page_index + 1; i < page_index; ++i) {
@@ -1701,14 +1639,14 @@ bool PDFiumEngine::ExtendSelection(int page_index, int char_index) {
     }
 
     int count = pages_[last_page_index]->GetCharCount();
-    last_selection.SetCharCount(count - last_char_index);
+    selection_[last_selection_index].SetCharCount(count - last_char_index);
     selection_.push_back(PDFiumRange(pages_[page_index].get(), 0, char_index));
   } else {
     // Selecting into the previous page.
     // The selection's char_index is 0-based, so the character count is one
     // more than the index. The character count needs to be negative to
     // indicate a backwards selection.
-    last_selection.SetCharCount(-last_char_index - 1);
+    selection_.back().SetCharCount(-last_char_index - 1);
 
     // First make sure that there are no gaps in selection, i.e. if mousedown on
     // page three but we only get mousemove over page one, we want page two.
@@ -1725,11 +1663,16 @@ bool PDFiumEngine::ExtendSelection(int page_index, int char_index) {
   return true;
 }
 
-bool PDFiumEngine::OnKeyDown(const pp::KeyboardInputEvent& event) {
-  if (last_page_mouse_down_ == -1)
+bool PDFiumEngine::OnKeyDown(const KeyboardInputEvent& event) {
+  // Handle tab events first as we might need to transition focus to an
+  // annotation in PDF.
+  if (event.GetKeyCode() == FWL_VKEY_Tab)
+    return HandleTabEvent(event.GetModifiers());
+
+  if (last_focused_page_ == -1)
     return false;
 
-  bool rv = !!FORM_OnKeyDown(form(), pages_[last_page_mouse_down_]->GetPage(),
+  bool rv = !!FORM_OnKeyDown(form(), pages_[last_focused_page_]->GetPage(),
                              event.GetKeyCode(), event.GetModifiers());
 
   if (event.GetKeyCode() == ui::VKEY_BACK ||
@@ -1739,34 +1682,54 @@ bool PDFiumEngine::OnKeyDown(const pp::KeyboardInputEvent& event) {
     // So just fake one since PDFium uses it.
     std::string str;
     str.push_back(event.GetKeyCode());
-    pp::KeyboardInputEvent synthesized(pp::KeyboardInputEvent(
-        client_->GetPluginInstance(), PP_INPUTEVENT_TYPE_CHAR,
-        event.GetTimeStamp(), event.GetModifiers(), event.GetKeyCode(), str));
+    KeyboardInputEvent synthesized(InputEventType::kChar, event.GetTimeStamp(),
+                                   event.GetModifiers(), event.GetKeyCode(),
+                                   str);
     OnChar(synthesized);
   }
 
+#if !defined(OS_MAC)
+  // macOS doesn't have keyboard-triggered context menus.
+  // Scroll focused annotation into view when context menu is invoked through
+  // keyboard <Shift-F10>.
+  if (event.GetKeyCode() == FWL_VKEY_F10 &&
+      (event.GetModifiers() & kInputEventModifierShiftKey)) {
+    DCHECK(!rv);
+    ScrollFocusedAnnotationIntoView();
+  }
+#endif
+
   return rv;
 }
 
-bool PDFiumEngine::OnKeyUp(const pp::KeyboardInputEvent& event) {
-  if (last_page_mouse_down_ == -1)
+bool PDFiumEngine::OnKeyUp(const KeyboardInputEvent& event) {
+  if (last_focused_page_ == -1)
     return false;
 
   // Check if form text selection needs to be updated.
-  FPDF_PAGE page = pages_[last_page_mouse_down_]->GetPage();
+  FPDF_PAGE page = pages_[last_focused_page_]->GetPage();
   if (in_form_text_area_)
     SetFormSelectedText(form(), page);
 
   return !!FORM_OnKeyUp(form(), page, event.GetKeyCode(), event.GetModifiers());
 }
 
-bool PDFiumEngine::OnChar(const pp::KeyboardInputEvent& event) {
-  if (last_page_mouse_down_ == -1)
+bool PDFiumEngine::OnChar(const KeyboardInputEvent& event) {
+  if (last_focused_page_ == -1)
     return false;
 
-  base::string16 str = base::UTF8ToUTF16(event.GetCharacterText().AsString());
-  return !!FORM_OnChar(form(), pages_[last_page_mouse_down_]->GetPage(), str[0],
-                       event.GetModifiers());
+  std::u16string str = base::UTF8ToUTF16(event.GetKeyChar());
+  bool rv = !!FORM_OnChar(form(), pages_[last_focused_page_]->GetPage(), str[0],
+                          event.GetModifiers());
+
+  // Scroll editable form text into view on char events. We should not scroll
+  // focused annotation on escape char event since escape char is used to
+  // dismiss focus from form controls.
+  if (rv && editable_form_text_area_ && event.GetKeyCode() != ui::VKEY_ESCAPE) {
+    ScrollFocusedAnnotationIntoView();
+  }
+
+  return rv;
 }
 
 void PDFiumEngine::StartFind(const std::string& text, bool case_sensitive) {
@@ -1777,8 +1740,10 @@ void PDFiumEngine::StartFind(const std::string& text, bool case_sensitive) {
 
   // If StartFind() gets called before we have any page information (i.e.
   // before the first call to LoadDocument has happened). Handle this case.
-  if (pages_.empty())
+  if (pages_.empty()) {
+    client_->NotifyNumberOfFindResultsChanged(0, true);
     return;
+  }
 
   bool first_search = (current_find_text_ != text);
   int character_to_start_searching_from = 0;
@@ -1805,10 +1770,11 @@ void PDFiumEngine::StartFind(const std::string& text, bool case_sensitive) {
   int current_page = next_page_to_search_;
 
   if (pages_[current_page]->available()) {
-    base::string16 str = base::UTF8ToUTF16(text);
+    std::u16string str = base::UTF8ToUTF16(text);
     // Don't use PDFium to search for now, since it doesn't support unicode
     // text. Leave the code for now to avoid bit-rot, in case it's fixed later.
-    if (0) {
+    // The extra parens suppress a -Wunreachable-code warning.
+    if ((0)) {
       SearchUsingPDFium(str, case_sensitive, first_search,
                         character_to_start_searching_from, current_page);
     } else {
@@ -1848,17 +1814,18 @@ void PDFiumEngine::StartFind(const std::string& text, bool case_sensitive) {
 
   // In unit tests, PPAPI is not initialized, so just call ContinueFind()
   // directly.
-  if (g_create_document_loader_for_testing) {
+  if (doc_loader_set_for_testing_) {
     ContinueFind(case_sensitive ? 1 : 0);
   } else {
-    pp::CompletionCallback callback =
-        find_factory_.NewCallback(&PDFiumEngine::ContinueFind);
-    pp::Module::Get()->core()->CallOnMainThread(0, callback,
-                                                case_sensitive ? 1 : 0);
+    client_->ScheduleTaskOnMainThread(
+        base::TimeDelta(),
+        base::BindOnce(&PDFiumEngine::ContinueFind,
+                       find_weak_factory_.GetWeakPtr()),
+        case_sensitive ? 1 : 0);
   }
 }
 
-void PDFiumEngine::SearchUsingPDFium(const base::string16& term,
+void PDFiumEngine::SearchUsingPDFium(const std::u16string& term,
                                      bool case_sensitive,
                                      bool first_search,
                                      int character_to_start_searching_from,
@@ -1890,13 +1857,19 @@ void PDFiumEngine::SearchUsingPDFium(const base::string16& term,
   FPDFText_FindClose(find);
 }
 
-void PDFiumEngine::SearchUsingICU(const base::string16& term,
+void PDFiumEngine::SearchUsingICU(const std::u16string& term,
                                   bool case_sensitive,
                                   bool first_search,
                                   int character_to_start_searching_from,
                                   int current_page) {
   DCHECK(!term.empty());
 
+  // Various types of quotions marks need to be converted to the simple ASCII
+  // version for searching to get better matching.
+  std::u16string adjusted_term = term;
+  for (char16_t& c : adjusted_term)
+    c = SimplifyForSearch(c);
+
   const int original_text_length = pages_[current_page]->GetCharCount();
   int text_length = original_text_length;
   if (character_to_start_searching_from) {
@@ -1908,8 +1881,8 @@ void PDFiumEngine::SearchUsingICU(const base::string16& term,
   if (text_length <= 0)
     return;
 
-  base::string16 page_text;
-  PDFiumAPIStringBufferAdapter<base::string16> api_string_adapter(
+  std::u16string page_text;
+  PDFiumAPIStringBufferAdapter<std::u16string> api_string_adapter(
       &page_text, text_length, false);
   unsigned short* data =
       reinterpret_cast<unsigned short*>(api_string_adapter.GetData());
@@ -1918,28 +1891,88 @@ void PDFiumEngine::SearchUsingICU(const base::string16& term,
                        character_to_start_searching_from, text_length, data);
   api_string_adapter.Close(written);
 
+  std::u16string adjusted_page_text;
+  adjusted_page_text.reserve(page_text.size());
+  // Values in |removed_indices| are in the adjusted text index space and
+  // indicate a character was removed from the page text before the given
+  // index. If multiple characters are removed in a row then there will be
+  // multiple entries with the same value.
+  std::vector<size_t> removed_indices;
+  // When walking through the page text collapse any whitespace regions,
+  // including \r and \n, down to a single ' ' character. This code does
+  // not use base::CollapseWhitespace(), because that function does not
+  // return where the collapsing occurs, but uses the same underlying list of
+  // whitespace characters. Calculating where the collapsed regions are after
+  // the fact is as complex as collapsing them manually.
+  for (size_t i = 0; i < page_text.size(); i++) {
+    char16_t c = page_text[i];
+    // Collapse whitespace regions by inserting a ' ' into the
+    // adjusted text and recording any removed whitespace indices as preceding
+    // it.
+    if (base::IsUnicodeWhitespace(c)) {
+      size_t whitespace_region_begin = i;
+      while (i < page_text.size() && base::IsUnicodeWhitespace(page_text[i]))
+        ++i;
+
+      size_t count = i - whitespace_region_begin - 1;
+      removed_indices.insert(removed_indices.end(), count,
+                             adjusted_page_text.size());
+      adjusted_page_text.push_back(' ');
+      if (i >= page_text.size())
+        break;
+      c = page_text[i];
+    }
+
+    if (IsIgnorableCharacter(c))
+      removed_indices.push_back(adjusted_page_text.size());
+    else
+      adjusted_page_text.push_back(SimplifyForSearch(c));
+  }
+
   std::vector<PDFEngine::Client::SearchStringResult> results =
-      client_->SearchString(page_text.c_str(), term.c_str(), case_sensitive);
+      client_->SearchString(adjusted_page_text.c_str(), adjusted_term.c_str(),
+                            case_sensitive);
   for (const auto& result : results) {
+    // Need to convert from adjusted page text start to page text start, by
+    // incrementing for all the characters adjusted before it in the string.
+    auto removed_indices_begin = std::upper_bound(
+        removed_indices.begin(), removed_indices.end(), result.start_index);
+    size_t page_text_result_start_index =
+        result.start_index +
+        std::distance(removed_indices.begin(), removed_indices_begin);
+
+    // Need to convert the adjusted page length into a page text length, since
+    // the matching range may have adjusted characters within it. This
+    // conversion only cares about skipped characters in the result interval.
+    auto removed_indices_end =
+        std::upper_bound(removed_indices_begin, removed_indices.end(),
+                         result.start_index + result.length);
+    int term_removed_count =
+        std::distance(removed_indices_begin, removed_indices_end);
+    int page_text_result_length = result.length + term_removed_count;
+
     // Need to map the indexes from the page text, which may have generated
     // characters like space etc, to character indices from the page.
     int text_to_start_searching_from = FPDFText_GetTextIndexFromCharIndex(
         pages_[current_page]->GetTextPage(), character_to_start_searching_from);
-    int temp_start = result.start_index + text_to_start_searching_from;
+    int temp_start =
+        page_text_result_start_index + text_to_start_searching_from;
     int start = FPDFText_GetCharIndexFromTextIndex(
         pages_[current_page]->GetTextPage(), temp_start);
     int end = FPDFText_GetCharIndexFromTextIndex(
-        pages_[current_page]->GetTextPage(), temp_start + result.length);
+        pages_[current_page]->GetTextPage(),
+        temp_start + page_text_result_length);
 
     // If |term| occurs at the end of a page, then |end| will be -1 due to the
     // index being out of bounds. Compensate for this case so the range
     // character count calculation below works out.
-    if (temp_start + result.length == original_text_length) {
+    if (temp_start + page_text_result_length == original_text_length) {
       DCHECK_EQ(-1, end);
       end = original_text_length;
     }
     DCHECK_LT(start, end);
-    DCHECK_EQ(term.size(), static_cast<size_t>(end - start));
+    DCHECK_EQ(term.size() + term_removed_count,
+              static_cast<size_t>(end - start));
     AddFindResult(PDFiumRange(pages_[current_page].get(), start, end - start));
   }
 }
@@ -1969,10 +2002,8 @@ void PDFiumEngine::AddFindResult(const PDFiumRange& result) {
 }
 
 bool PDFiumEngine::SelectFindResult(bool forward) {
-  if (find_results_.empty()) {
-    NOTREACHED();
+  if (find_results_.empty())
     return false;
-  }
 
   SelectionChangeInvalidator selection_invalidator(this);
 
@@ -2005,20 +2036,27 @@ bool PDFiumEngine::SelectFindResult(bool forward) {
   selection_.push_back(find_results_[current_find_index_.value()]);
 
   // If the result is not in view, scroll to it.
-  pp::Rect bounding_rect;
-  pp::Rect visible_rect = GetVisibleRect();
+  gfx::Rect bounding_rect;
+  gfx::Rect visible_rect = GetVisibleRect();
+
+  // TODO(crbug.com/1108574): Remove after fixing the issue.
+  size_t find_results_size = find_results_.size();
+  base::debug::Alias(&find_results_size);
+  size_t current_find_index_value = current_find_index_.value();
+  base::debug::Alias(&current_find_index_value);
+
   // Use zoom of 1.0 since |visible_rect| is without zoom.
-  const std::vector<pp::Rect>& rects =
+  const std::vector<gfx::Rect>& rects =
       find_results_[current_find_index_.value()].GetScreenRects(
-          pp::Point(), 1.0, current_rotation_);
+          gfx::Point(), 1.0, layout_.options().default_page_orientation());
   for (const auto& rect : rects)
-    bounding_rect = bounding_rect.Union(rect);
+    bounding_rect.Union(rect);
   if (!visible_rect.Contains(bounding_rect)) {
-    pp::Point center = bounding_rect.CenterPoint();
+    gfx::Point center = bounding_rect.CenterPoint();
     // Make the page centered.
     int new_y = CalculateCenterForZoom(center.y(), visible_rect.height(),
                                        current_zoom_);
-    client_->ScrollToY(new_y, /*compensate_for_toolbar=*/false);
+    client_->ScrollToY(new_y);
 
     // Only move horizontally if it's not visible.
     if (center.x() < visible_rect.x() || center.x() > visible_rect.right()) {
@@ -2048,25 +2086,28 @@ void PDFiumEngine::StopFind() {
   current_find_text_.clear();
 
   UpdateTickMarks();
-  find_factory_.CancelAll();
+  find_weak_factory_.InvalidateWeakPtrs();
 }
 
-void PDFiumEngine::GetAllScreenRectsUnion(std::vector<PDFiumRange>* rect_range,
-                                          const pp::Point& offset_point,
-                                          std::vector<pp::Rect>* rect_vector) {
-  for (auto& range : *rect_range) {
-    pp::Rect result_rect;
-    const std::vector<pp::Rect>& rects =
-        range.GetScreenRects(offset_point, current_zoom_, current_rotation_);
+std::vector<gfx::Rect> PDFiumEngine::GetAllScreenRectsUnion(
+    const std::vector<PDFiumRange>& rect_range,
+    const gfx::Point& point) const {
+  std::vector<gfx::Rect> rect_vector;
+  rect_vector.reserve(rect_range.size());
+  for (const auto& range : rect_range) {
+    gfx::Rect result_rect;
+    const std::vector<gfx::Rect>& rects = range.GetScreenRects(
+        point, current_zoom_, layout_.options().default_page_orientation());
     for (const auto& rect : rects)
-      result_rect = result_rect.Union(rect);
-    rect_vector->push_back(result_rect);
+      result_rect.Union(rect);
+    rect_vector.push_back(result_rect);
   }
+  return rect_vector;
 }
 
 void PDFiumEngine::UpdateTickMarks() {
-  std::vector<pp::Rect> tickmarks;
-  GetAllScreenRectsUnion(&find_results_, pp::Point(0, 0), &tickmarks);
+  std::vector<gfx::Rect> tickmarks =
+      GetAllScreenRectsUnion(find_results_, gfx::Point());
   client_->UpdateTickMarks(tickmarks);
 }
 
@@ -2080,30 +2121,66 @@ void PDFiumEngine::ZoomUpdated(double new_zoom_level) {
 }
 
 void PDFiumEngine::RotateClockwise() {
-  current_rotation_ = (current_rotation_ + 1) % 4;
-  RotateInternal();
+  desired_layout_options_.RotatePagesClockwise();
+  ProposeNextDocumentLayout();
 }
 
 void PDFiumEngine::RotateCounterclockwise() {
-  current_rotation_ = (current_rotation_ - 1) % 4;
-  RotateInternal();
+  desired_layout_options_.RotatePagesCounterclockwise();
+  ProposeNextDocumentLayout();
+}
+
+bool PDFiumEngine::IsReadOnly() const {
+  return read_only_;
+}
+
+void PDFiumEngine::SetReadOnly(bool enable) {
+  read_only_ = enable;
+
+  // Restore form highlights.
+  if (!read_only_) {
+    FPDF_SetFormFieldHighlightAlpha(form(), kFormHighlightAlpha);
+    return;
+  }
+
+  // Hide form highlights.
+  FPDF_SetFormFieldHighlightAlpha(form(), /*alpha=*/0);
+  KillFormFocus();
+
+  // Unselect text.
+  SelectionChangeInvalidator selection_invalidator(this);
+  selection_.clear();
+}
+
+void PDFiumEngine::SetTwoUpView(bool enable) {
+  desired_layout_options_.set_two_up_view_enabled(enable);
+  ProposeNextDocumentLayout();
+}
+
+void PDFiumEngine::DisplayAnnotations(bool display) {
+  if (render_annots_ == display)
+    return;
+
+  render_annots_ = display;
+  InvalidateAllPages();
 }
 
 void PDFiumEngine::InvalidateAllPages() {
   CancelPaints();
   StopFind();
-  LoadPageInfo(true);
-  client_->Invalidate(pp::Rect(plugin_size_));
+  DCHECK(document_loaded_);
+  RefreshCurrentDocumentLayout();
+  client_->Invalidate(gfx::Rect(plugin_size_));
 }
 
 std::string PDFiumEngine::GetSelectedText() {
   if (!HasPermission(PDFEngine::PERMISSION_COPY))
     return std::string();
 
-  base::string16 result;
+  std::u16string result;
   for (size_t i = 0; i < selection_.size(); ++i) {
-    static constexpr base::char16 kNewLineChar = L'\n';
-    base::string16 current_selection_text = selection_[i].GetText();
+    static constexpr char16_t kNewLineChar = L'\n';
+    std::u16string current_selection_text = selection_[i].GetText();
     if (i != 0) {
       if (selection_[i - 1].page_index() > selection_[i].page_index())
         std::swap(current_selection_text, result);
@@ -2123,48 +2200,92 @@ bool PDFiumEngine::CanEditText() {
 
 bool PDFiumEngine::HasEditableText() {
   DCHECK(CanEditText());
-  if (last_page_mouse_down_ == -1)
+  if (last_focused_page_ == -1)
     return false;
-  FPDF_PAGE page = pages_[last_page_mouse_down_]->GetPage();
+  FPDF_PAGE page = pages_[last_focused_page_]->GetPage();
   // If the return value is 2, that corresponds to "\0\0".
   return FORM_GetFocusedText(form(), page, nullptr, 0) > 2;
 }
 
 void PDFiumEngine::ReplaceSelection(const std::string& text) {
   DCHECK(CanEditText());
-  if (last_page_mouse_down_ != -1) {
-    base::string16 text_wide = base::UTF8ToUTF16(text);
+  if (last_focused_page_ != -1) {
+    std::u16string text_wide = base::UTF8ToUTF16(text);
     FPDF_WIDESTRING text_pdf_wide =
         reinterpret_cast<FPDF_WIDESTRING>(text_wide.c_str());
 
-    FORM_ReplaceSelection(form(), pages_[last_page_mouse_down_]->GetPage(),
+    FORM_ReplaceSelection(form(), pages_[last_focused_page_]->GetPage(),
                           text_pdf_wide);
   }
 }
 
 bool PDFiumEngine::CanUndo() {
-  if (last_page_mouse_down_ == -1)
+  if (last_focused_page_ == -1)
     return false;
-  return !!FORM_CanUndo(form(), pages_[last_page_mouse_down_]->GetPage());
+  return !!FORM_CanUndo(form(), pages_[last_focused_page_]->GetPage());
 }
 
 bool PDFiumEngine::CanRedo() {
-  if (last_page_mouse_down_ == -1)
+  if (last_focused_page_ == -1)
     return false;
-  return !!FORM_CanRedo(form(), pages_[last_page_mouse_down_]->GetPage());
+  return !!FORM_CanRedo(form(), pages_[last_focused_page_]->GetPage());
 }
 
 void PDFiumEngine::Undo() {
-  if (last_page_mouse_down_ != -1)
-    FORM_Undo(form(), pages_[last_page_mouse_down_]->GetPage());
+  if (last_focused_page_ != -1)
+    FORM_Undo(form(), pages_[last_focused_page_]->GetPage());
 }
 
 void PDFiumEngine::Redo() {
-  if (last_page_mouse_down_ != -1)
-    FORM_Redo(form(), pages_[last_page_mouse_down_]->GetPage());
+  if (last_focused_page_ != -1)
+    FORM_Redo(form(), pages_[last_focused_page_]->GetPage());
 }
 
-std::string PDFiumEngine::GetLinkAtPosition(const pp::Point& point) {
+void PDFiumEngine::HandleAccessibilityAction(
+    const AccessibilityActionData& action_data) {
+  switch (action_data.action) {
+    case AccessibilityAction::kScrollToMakeVisible: {
+      ScrollBasedOnScrollAlignment(action_data.target_rect,
+                                   action_data.horizontal_scroll_alignment,
+                                   action_data.vertical_scroll_alignment);
+      break;
+    }
+    case AccessibilityAction::kDoDefaultAction: {
+      if (PageIndexInBounds(action_data.page_index)) {
+        if (action_data.annotation_type == AccessibilityAnnotationType::kLink) {
+          PDFiumPage::LinkTarget target;
+          PDFiumPage::Area area =
+              pages_[action_data.page_index]->GetLinkTargetAtIndex(
+                  action_data.annotation_index, &target);
+          NavigateToLinkDestination(area, target,
+                                    WindowOpenDisposition::CURRENT_TAB);
+        }
+      }
+      break;
+    }
+    case AccessibilityAction::kScrollToGlobalPoint: {
+      ScrollToGlobalPoint(action_data.target_rect, action_data.target_point);
+      break;
+    }
+    case AccessibilityAction::kSetSelection: {
+      if (IsPageCharacterIndexInBounds(action_data.selection_start_index) &&
+          IsPageCharacterIndexInBounds(action_data.selection_end_index)) {
+        SetSelection(action_data.selection_start_index,
+                     action_data.selection_end_index);
+        gfx::Rect target_rect = action_data.target_rect;
+        if (GetVisibleRect().Contains(target_rect))
+          return;
+        client_->ScrollBy(GetScreenRect(target_rect).OffsetFromOrigin());
+      }
+      break;
+    }
+    default:
+      NOTREACHED();
+      break;
+  }
+}
+
+std::string PDFiumEngine::GetLinkAtPosition(const gfx::Point& point) {
   std::string url;
   int temp;
   int page_index = -1;
@@ -2178,39 +2299,14 @@ std::string PDFiumEngine::GetLinkAtPosition(const pp::Point& point) {
 }
 
 bool PDFiumEngine::HasPermission(DocumentPermission permission) const {
-  // PDF 1.7 spec, section 3.5.2 says: "If the revision number is 2 or greater,
-  // the operations to which user access can be controlled are as follows: ..."
-  //
-  // Thus for revision numbers less than 2, permissions are ignored and this
-  // always returns true.
-  if (permissions_handler_revision_ < 2)
+  // No |permissions_| means no restrictions.
+  if (!permissions_)
     return true;
-
-  // Handle high quality printing permission separately for security handler
-  // revision 3+. See table 3.20 in the PDF 1.7 spec.
-  if (permission == PERMISSION_PRINT_HIGH_QUALITY &&
-      permissions_handler_revision_ >= 3) {
-    return (permissions_ & kPDFPermissionPrintLowQualityMask) != 0 &&
-           (permissions_ & kPDFPermissionPrintHighQualityMask) != 0;
-  }
-
-  switch (permission) {
-    case PERMISSION_COPY:
-      return (permissions_ & kPDFPermissionCopyMask) != 0;
-    case PERMISSION_COPY_ACCESSIBLE:
-      return (permissions_ & kPDFPermissionCopyAccessibleMask) != 0;
-    case PERMISSION_PRINT_LOW_QUALITY:
-    case PERMISSION_PRINT_HIGH_QUALITY:
-      // With security handler revision 2 rules, check the same bit for high
-      // and low quality. See table 3.20 in the PDF 1.7 spec.
-      return (permissions_ & kPDFPermissionPrintLowQualityMask) != 0;
-    default:
-      return true;
-  }
+  return permissions_->HasPermission(permission);
 }
 
 void PDFiumEngine::SelectAll() {
-  if (in_form_text_area_)
+  if (in_form_text_area_ || IsReadOnly())
     return;
 
   SelectionChangeInvalidator selection_invalidator(this);
@@ -2222,85 +2318,176 @@ void PDFiumEngine::SelectAll() {
   }
 }
 
-int PDFiumEngine::GetNumberOfPages() {
+const std::vector<DocumentAttachmentInfo>&
+PDFiumEngine::GetDocumentAttachmentInfoList() const {
+  DCHECK(document_loaded_);
+  return doc_attachment_info_list_;
+}
+
+std::vector<uint8_t> PDFiumEngine::GetAttachmentData(size_t index) {
+  DCHECK_LT(index, doc_attachment_info_list_.size());
+  DCHECK(doc_attachment_info_list_[index].is_readable);
+  unsigned long length_bytes = doc_attachment_info_list_[index].size_bytes;
+  DCHECK_NE(length_bytes, 0u);
+
+  FPDF_ATTACHMENT attachment = FPDFDoc_GetAttachment(doc(), index);
+  std::vector<uint8_t> content_buf(length_bytes);
+  unsigned long data_size_bytes;
+  bool is_attachment_readable = FPDFAttachment_GetFile(
+      attachment, content_buf.data(), length_bytes, &data_size_bytes);
+  if (!is_attachment_readable || length_bytes != data_size_bytes) {
+    NOTREACHED();
+    return std::vector<uint8_t>();
+  }
+
+  return content_buf;
+}
+
+const DocumentMetadata& PDFiumEngine::GetDocumentMetadata() const {
+  DCHECK(document_loaded_);
+  return doc_metadata_;
+}
+
+int PDFiumEngine::GetNumberOfPages() const {
   return pages_.size();
 }
 
-pp::VarArray PDFiumEngine::GetBookmarks() {
-  pp::VarDictionary dict = TraverseBookmarks(nullptr, 0);
+base::Value PDFiumEngine::GetBookmarks() {
+  base::Value dict = TraverseBookmarks(nullptr, 0);
+  DCHECK(dict.is_dict());
   // The root bookmark contains no useful information.
-  return pp::VarArray(dict.Get(pp::Var("children")));
+  base::Value* children = dict.FindListKey("children");
+  DCHECK(children);
+  return std::move(*children);
 }
 
-pp::VarDictionary PDFiumEngine::TraverseBookmarks(FPDF_BOOKMARK bookmark,
-                                                  unsigned int depth) {
-  pp::VarDictionary dict;
-  base::string16 title;
-  unsigned long buffer_size = FPDFBookmark_GetTitle(bookmark, nullptr, 0);
-  if (buffer_size > 0) {
-    PDFiumAPIStringBufferSizeInBytesAdapter<base::string16> api_string_adapter(
-        &title, buffer_size, true);
-    api_string_adapter.Close(FPDFBookmark_GetTitle(
-        bookmark, api_string_adapter.GetData(), buffer_size));
-  }
-  dict.Set(pp::Var("title"), pp::Var(base::UTF16ToUTF8(title)));
+base::Value PDFiumEngine::TraverseBookmarks(FPDF_BOOKMARK bookmark,
+                                            unsigned int depth) {
+  base::Value dict(base::Value::Type::DICTIONARY);
+  std::u16string title = CallPDFiumWideStringBufferApi(
+      base::BindRepeating(&FPDFBookmark_GetTitle, bookmark),
+      /*check_expected_size=*/true);
+  dict.SetStringKey("title", title);
 
   FPDF_DEST dest = FPDFBookmark_GetDest(doc(), bookmark);
   // Some bookmarks don't have a page to select.
   if (dest) {
     int page_index = FPDFDest_GetDestPageIndex(doc(), dest);
     if (PageIndexInBounds(page_index)) {
-      dict.Set(pp::Var("page"), pp::Var(page_index));
+      dict.SetIntKey("page", page_index);
 
-      base::Optional<gfx::PointF> xy =
-          pages_[page_index]->GetPageXYTarget(dest);
-      if (xy)
-        dict.Set(pp::Var("y"), pp::Var(static_cast<int>(xy.value().y())));
+      base::Optional<float> x;
+      base::Optional<float> y;
+      base::Optional<float> zoom;
+      pages_[page_index]->GetPageDestinationTarget(dest, &x, &y, &zoom);
+
+      if (x)
+        dict.SetIntKey("x", static_cast<int>(x.value()));
+      if (y)
+        dict.SetIntKey("y", static_cast<int>(y.value()));
+      if (zoom)
+        dict.SetDoubleKey("zoom", zoom.value());
     }
   } else {
     // Extract URI for bookmarks linking to an external page.
     FPDF_ACTION action = FPDFBookmark_GetAction(bookmark);
-    buffer_size = FPDFAction_GetURIPath(doc(), action, nullptr, 0);
-    if (buffer_size > 0) {
-      std::string uri;
-      PDFiumAPIStringBufferAdapter<std::string> api_string_adapter(
-          &uri, buffer_size, true);
-      api_string_adapter.Close(FPDFAction_GetURIPath(
-          doc(), action, api_string_adapter.GetData(), buffer_size));
-      dict.Set(pp::Var("uri"), pp::Var(uri));
-    }
+    std::string uri = CallPDFiumStringBufferApi(
+        base::BindRepeating(&FPDFAction_GetURIPath, doc(), action),
+        /*check_expected_size=*/true);
+    if (!uri.empty())
+      dict.SetStringKey("uri", uri);
   }
 
-  pp::VarArray children;
+  base::Value children(base::Value::Type::LIST);
 
   // Don't trust PDFium to handle circular bookmarks.
-  const unsigned int kMaxDepth = 128;
+  constexpr unsigned int kMaxDepth = 128;
   if (depth < kMaxDepth) {
-    int child_index = 0;
     std::set<FPDF_BOOKMARK> seen_bookmarks;
     for (FPDF_BOOKMARK child_bookmark =
              FPDFBookmark_GetFirstChild(doc(), bookmark);
          child_bookmark;
          child_bookmark = FPDFBookmark_GetNextSibling(doc(), child_bookmark)) {
-      if (base::ContainsKey(seen_bookmarks, child_bookmark))
+      if (base::Contains(seen_bookmarks, child_bookmark))
         break;
 
       seen_bookmarks.insert(child_bookmark);
-      children.Set(child_index, TraverseBookmarks(child_bookmark, depth + 1));
-      child_index++;
+      children.Append(TraverseBookmarks(child_bookmark, depth + 1));
     }
   }
-  dict.Set(pp::Var("children"), children);
+  dict.SetKey("children", std::move(children));
   return dict;
 }
 
+void PDFiumEngine::ScrollBasedOnScrollAlignment(
+    const gfx::Rect& scroll_rect,
+    const AccessibilityScrollAlignment& horizontal_scroll_alignment,
+    const AccessibilityScrollAlignment& vertical_scroll_alignment) {
+  gfx::Vector2d scroll_offset = GetScreenRect(scroll_rect).OffsetFromOrigin();
+  switch (horizontal_scroll_alignment) {
+    case AccessibilityScrollAlignment::kRight:
+      scroll_offset.set_x(scroll_offset.x() - plugin_size_.width());
+      break;
+    case AccessibilityScrollAlignment::kCenter:
+      scroll_offset.set_x(scroll_offset.x() - (plugin_size_.width() / 2));
+      break;
+    case AccessibilityScrollAlignment::kClosestToEdge: {
+      scroll_offset.set_x((std::abs(scroll_offset.x()) <=
+                           std::abs(scroll_offset.x() - plugin_size_.width()))
+                              ? scroll_offset.x()
+                              : scroll_offset.x() - plugin_size_.width());
+      break;
+    }
+    case AccessibilityScrollAlignment::kNone:
+      scroll_offset.set_x(0);
+      break;
+    case AccessibilityScrollAlignment::kLeft:
+    case AccessibilityScrollAlignment::kTop:
+    case AccessibilityScrollAlignment::kBottom:
+    default:
+      break;
+  }
+
+  switch (vertical_scroll_alignment) {
+    case AccessibilityScrollAlignment::kBottom:
+      scroll_offset.set_y(scroll_offset.y() - plugin_size_.height());
+      break;
+    case AccessibilityScrollAlignment::kCenter:
+      scroll_offset.set_y(scroll_offset.y() - (plugin_size_.height() / 2));
+      break;
+    case AccessibilityScrollAlignment::kClosestToEdge: {
+      scroll_offset.set_y((std::abs(scroll_offset.y()) <=
+                           std::abs(scroll_offset.y() - plugin_size_.height()))
+                              ? scroll_offset.y()
+                              : scroll_offset.y() - plugin_size_.height());
+      break;
+    }
+    case AccessibilityScrollAlignment::kNone:
+      scroll_offset.set_y(0);
+      break;
+    case AccessibilityScrollAlignment::kTop:
+    case AccessibilityScrollAlignment::kLeft:
+    case AccessibilityScrollAlignment::kRight:
+    default:
+      break;
+  }
+
+  client_->ScrollBy(scroll_offset);
+}
+
+void PDFiumEngine::ScrollToGlobalPoint(const gfx::Rect& target_rect,
+                                       const gfx::Point& global_point) {
+  gfx::Point scroll_offset = GetScreenRect(target_rect).origin();
+  client_->ScrollBy(scroll_offset - global_point);
+}
+
 base::Optional<PDFEngine::NamedDestination> PDFiumEngine::GetNamedDestination(
     const std::string& destination) {
   // Look for the destination.
   FPDF_DEST dest = FPDF_GetNamedDestByName(doc(), destination.c_str());
   if (!dest) {
     // Look for a bookmark with the same name.
-    base::string16 destination_wide = base::UTF8ToUTF16(destination);
+    std::u16string destination_wide = base::UTF8ToUTF16(destination);
     FPDF_WIDESTRING destination_pdf_wide =
         reinterpret_cast<FPDF_WIDESTRING>(destination_wide.c_str());
     FPDF_BOOKMARK bookmark = FPDFBookmark_Find(doc(), destination_pdf_wide);
@@ -2319,16 +2506,20 @@ base::Optional<PDFEngine::NamedDestination> PDFiumEngine::GetNamedDestination(
   result.page = page;
   unsigned long view_int =
       FPDFDest_GetView(dest, &result.num_params, result.params);
+
+  // FPDFDest_GetView() gets the in-page coordinates directly from the PDF
+  // document. The in-page coordinates need to be transformed into in-screen
+  // coordinates before getting sent to the viewport.
+  PDFiumPage* page_ptr = pages_[page].get();
+  ParamsTransformPageToScreen(view_int, page_ptr, result.params);
+
+  if (view_int == PDFDEST_VIEW_XYZ)
+    result.xyz_params = GetXYZParamsString(dest, page_ptr);
+
   result.view = ConvertViewIntToViewString(view_int);
   return result;
 }
 
-gfx::PointF PDFiumEngine::TransformPagePoint(int page_index,
-                                             const gfx::PointF& page_xy) {
-  DCHECK(PageIndexInBounds(page_index));
-  return pages_[page_index]->TransformPageToScreenXY(page_xy);
-}
-
 int PDFiumEngine::GetMostVisiblePage() {
   if (in_flight_visible_page_)
     return *in_flight_visible_page_;
@@ -2342,18 +2533,11 @@ int PDFiumEngine::GetMostVisiblePage() {
   return most_visible_page_;
 }
 
-pp::Rect PDFiumEngine::GetPageRect(int index) {
-  pp::Rect rc(pages_[index]->rect());
-  rc.Inset(-kPageShadowLeft, -kPageShadowTop, -kPageShadowRight,
-           -kPageShadowBottom);
-  return rc;
-}
-
-pp::Rect PDFiumEngine::GetPageBoundsRect(int index) {
+gfx::Rect PDFiumEngine::GetPageBoundsRect(int index) {
   return pages_[index]->rect();
 }
 
-pp::Rect PDFiumEngine::GetPageContentsRect(int index) {
+gfx::Rect PDFiumEngine::GetPageContentsRect(int index) {
   return GetScreenRect(pages_[index]->rect());
 }
 
@@ -2365,18 +2549,14 @@ void PDFiumEngine::SetGrayscale(bool grayscale) {
   render_grayscale_ = grayscale;
 }
 
-void PDFiumEngine::HandleLongPress(const pp::TouchInputEvent& event) {
-  pp::FloatPoint fp =
-      event.GetTouchByIndex(PP_TOUCHLIST_TYPE_TARGETTOUCHES, 0).position();
-  pp::Point point;
-  point.set_x(fp.x());
-  point.set_y(fp.y());
+void PDFiumEngine::HandleLongPress(const TouchInputEvent& event) {
+  base::AutoReset<bool> handling_long_press_guard(&handling_long_press_, true);
+  gfx::Point point = gfx::ToRoundedPoint(event.GetTargetTouchPoint());
 
   // Send a fake mouse down to trigger the multi-click selection code.
-  pp::MouseInputEvent mouse_event(
-      client_->GetPluginInstance(), PP_INPUTEVENT_TYPE_MOUSEDOWN,
-      event.GetTimeStamp(), event.GetModifiers(),
-      PP_INPUTEVENT_MOUSEBUTTON_LEFT, point, 2, point);
+  MouseInputEvent mouse_event(
+      InputEventType::kMouseDown, event.GetTimeStamp(), event.GetModifiers(),
+      InputEventMouseButtonType::kLeft, point, 2, point);
 
   OnMouseDown(mouse_event);
 }
@@ -2386,7 +2566,7 @@ int PDFiumEngine::GetCharCount(int page_index) {
   return pages_[page_index]->GetCharCount();
 }
 
-pp::FloatRect PDFiumEngine::GetCharBounds(int page_index, int char_index) {
+gfx::RectF PDFiumEngine::GetCharBounds(int page_index, int char_index) {
   DCHECK(PageIndexInBounds(page_index));
   return pages_[page_index]->GetCharBounds(char_index);
 }
@@ -2396,14 +2576,42 @@ uint32_t PDFiumEngine::GetCharUnicode(int page_index, int char_index) {
   return pages_[page_index]->GetCharUnicode(char_index);
 }
 
-void PDFiumEngine::GetTextRunInfo(int page_index,
-                                  int start_char_index,
-                                  uint32_t* out_len,
-                                  double* out_font_size,
-                                  pp::FloatRect* out_bounds) {
+base::Optional<AccessibilityTextRunInfo> PDFiumEngine::GetTextRunInfo(
+    int page_index,
+    int start_char_index) {
   DCHECK(PageIndexInBounds(page_index));
-  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
-                                            out_font_size, out_bounds);
+  auto info = pages_[page_index]->GetTextRunInfo(start_char_index);
+  if (!client_->IsPrintPreview() && start_char_index >= 0)
+    pages_[page_index]->LogOverlappingAnnotations();
+  return info;
+}
+
+std::vector<AccessibilityLinkInfo> PDFiumEngine::GetLinkInfo(
+    int page_index,
+    const std::vector<AccessibilityTextRunInfo>& text_runs) {
+  DCHECK(PageIndexInBounds(page_index));
+  return pages_[page_index]->GetLinkInfo(text_runs);
+}
+
+std::vector<AccessibilityImageInfo> PDFiumEngine::GetImageInfo(
+    int page_index,
+    uint32_t text_run_count) {
+  DCHECK(PageIndexInBounds(page_index));
+  return pages_[page_index]->GetImageInfo(text_run_count);
+}
+
+std::vector<AccessibilityHighlightInfo> PDFiumEngine::GetHighlightInfo(
+    int page_index,
+    const std::vector<AccessibilityTextRunInfo>& text_runs) {
+  DCHECK(PageIndexInBounds(page_index));
+  return pages_[page_index]->GetHighlightInfo(text_runs);
+}
+
+std::vector<AccessibilityTextFieldInfo> PDFiumEngine::GetTextFieldInfo(
+    int page_index,
+    uint32_t text_run_count) {
+  DCHECK(PageIndexInBounds(page_index));
+  return pages_[page_index]->GetTextFieldInfo(text_run_count);
 }
 
 bool PDFiumEngine::GetPrintScaling() {
@@ -2418,26 +2626,24 @@ int PDFiumEngine::GetDuplexType() {
   return static_cast<int>(FPDF_VIEWERREF_GetDuplex(doc()));
 }
 
-bool PDFiumEngine::GetPageSizeAndUniformity(pp::Size* size) {
+base::Optional<gfx::Size> PDFiumEngine::GetUniformPageSizePoints() {
   if (pages_.empty())
-    return false;
+    return base::nullopt;
 
-  pp::Size page_size = GetPageSize(0);
+  gfx::Size page_size = GetPageSize(0);
   for (size_t i = 1; i < pages_.size(); ++i) {
     if (page_size != GetPageSize(i))
-      return false;
+      return base::nullopt;
   }
 
   // Convert |page_size| back to points.
-  size->set_width(
-      ConvertUnit(page_size.width(), kPixelsPerInch, kPointsPerInch));
-  size->set_height(
+  return gfx::Size(
+      ConvertUnit(page_size.width(), kPixelsPerInch, kPointsPerInch),
       ConvertUnit(page_size.height(), kPixelsPerInch, kPointsPerInch));
-  return true;
 }
 
-void PDFiumEngine::AppendBlankPages(int num_pages) {
-  DCHECK_NE(num_pages, 0);
+void PDFiumEngine::AppendBlankPages(size_t num_pages) {
+  DCHECK_GT(num_pages, 0U);
 
   if (!doc())
     return;
@@ -2451,45 +2657,27 @@ void PDFiumEngine::AppendBlankPages(int num_pages) {
     FPDFPage_Delete(doc(), pages_.size());
   }
 
-  // Calculate document size and all page sizes.
-  std::vector<pp::Rect> page_rects;
-  pp::Size page_size = GetPageSize(0);
-  page_size.Enlarge(kPageShadowLeft + kPageShadowRight,
-                    kPageShadowTop + kPageShadowBottom);
-  pp::Size old_document_size = document_size_;
-  document_size_ = pp::Size(page_size.width(), 0);
-  for (int i = 0; i < num_pages; ++i) {
-    if (i != 0) {
-      // Add space for horizontal separator.
-      document_size_.Enlarge(0, kPageSeparatorThickness);
-    }
+  // Create blank pages with the same size as the first page.
+  gfx::Size page_0_size = GetPageSize(0);
+  double page_0_width_in_points =
+      ConvertUnitDouble(page_0_size.width(), kPixelsPerInch, kPointsPerInch);
+  double page_0_height_in_points =
+      ConvertUnitDouble(page_0_size.height(), kPixelsPerInch, kPointsPerInch);
 
-    pp::Rect rect(pp::Point(0, document_size_.height()), page_size);
-    page_rects.push_back(rect);
-
-    document_size_.Enlarge(0, page_size.height());
-  }
-
-  // Create blank pages.
-  for (int i = 1; i < num_pages; ++i) {
-    pp::Rect page_rect(page_rects[i]);
-    page_rect.Inset(kPageShadowLeft, kPageShadowTop, kPageShadowRight,
-                    kPageShadowBottom);
-    double width_in_points =
-        ConvertUnitDouble(page_rect.width(), kPixelsPerInch, kPointsPerInch);
-    double height_in_points =
-        ConvertUnitDouble(page_rect.height(), kPixelsPerInch, kPointsPerInch);
+  for (size_t i = 1; i < num_pages; ++i) {
     {
       // Add a new page to the document, but delete the FPDF_PAGE object.
-      ScopedFPDFPage temp_page(
-          FPDFPage_New(doc(), i, width_in_points, height_in_points));
+      ScopedFPDFPage temp_page(FPDFPage_New(doc(), i, page_0_width_in_points,
+                                            page_0_height_in_points));
     }
-    pages_.push_back(std::make_unique<PDFiumPage>(this, i, page_rect, true));
+
+    auto page = std::make_unique<PDFiumPage>(this, i);
+    page->MarkAvailable();
+    pages_.push_back(std::move(page));
   }
 
-  CalculateVisiblePages();
-  if (document_size_ != old_document_size)
-    client_->DocumentSizeUpdated(document_size_);
+  DCHECK(document_loaded_);
+  LoadPageInfo();
 }
 
 void PDFiumEngine::LoadDocument() {
@@ -2506,8 +2694,6 @@ void PDFiumEngine::LoadDocument() {
   if (getting_password_)
     return;
 
-  ScopedUnsupportedFeature scoped_unsupported_feature(this);
-  ScopedSubstFont scoped_subst_font(this);
   bool needs_password = false;
   if (TryLoadingDoc(std::string(), &needs_password)) {
     ContinueLoadingDocument(std::string());
@@ -2531,12 +2717,14 @@ bool PDFiumEngine::TryLoadingDoc(const std::string& password,
     return true;
   }
 
-  const char* password_cstr = nullptr;
-  if (!password.empty()) {
-    password_cstr = password.c_str();
+  if (!password.empty())
     password_tries_remaining_--;
+
+  {
+    ScopedUnsupportedFeature scoped_unsupported_feature(this);
+    document_->LoadDocument(password);
   }
-  document_->LoadDocument(password_cstr);
+
   if (!doc()) {
     if (FPDF_GetLastError() == FPDF_ERR_PASSWORD)
       *needs_password = true;
@@ -2554,24 +2742,16 @@ void PDFiumEngine::GetPasswordAndLoad() {
   getting_password_ = true;
   DCHECK(!doc());
   DCHECK_EQ(static_cast<unsigned long>(FPDF_ERR_PASSWORD), FPDF_GetLastError());
-  client_->GetDocumentPassword(password_factory_.NewCallbackWithOutput(
-      &PDFiumEngine::OnGetPasswordComplete));
+  client_->GetDocumentPassword(base::BindOnce(
+      &PDFiumEngine::OnGetPasswordComplete, weak_factory_.GetWeakPtr()));
 }
 
-void PDFiumEngine::OnGetPasswordComplete(int32_t result,
-                                         const pp::Var& password) {
+void PDFiumEngine::OnGetPasswordComplete(const std::string& password) {
   getting_password_ = false;
-
-  std::string password_text;
-  if (result == PP_OK && password.is_string())
-    password_text = password.AsString();
-  ContinueLoadingDocument(password_text);
+  ContinueLoadingDocument(password);
 }
 
 void PDFiumEngine::ContinueLoadingDocument(const std::string& password) {
-  ScopedUnsupportedFeature scoped_unsupported_feature(this);
-  ScopedSubstFont scoped_subst_font(this);
-
   bool needs_password = false;
   bool loaded = TryLoadingDoc(password, &needs_password);
   bool password_incorrect = !loaded && needs_password && !password.empty();
@@ -2588,8 +2768,7 @@ void PDFiumEngine::ContinueLoadingDocument(const std::string& password) {
   if (FPDFDoc_GetPageMode(doc()) == PAGEMODE_USEOUTLINES)
     client_->DocumentHasUnsupportedFeature("Bookmarks");
 
-  permissions_ = FPDF_GetDocPermissions(doc());
-  permissions_handler_revision_ = FPDF_GetSecurityHandlerRevision(doc());
+  permissions_ = std::make_unique<PDFiumPermissions>(doc());
 
   LoadBody();
 
@@ -2597,31 +2776,73 @@ void PDFiumEngine::ContinueLoadingDocument(const std::string& password) {
     FinishLoadingDocument();
 }
 
-void PDFiumEngine::LoadPageInfo(bool reload) {
-  if (!doc_loader_)
-    return;
-  if (pages_.empty() && reload)
-    return;
-  pending_pages_.clear();
-  pp::Size old_document_size = document_size_;
-  document_size_ = pp::Size();
-  std::vector<pp::Rect> page_rects;
-  int page_count = FPDF_GetPageCount(doc());
-  bool doc_complete = doc_loader_->IsDocumentComplete();
-  bool is_linear =
-      FPDFAvail_IsLinearized(fpdf_availability()) == PDF_LINEARIZED;
-  for (int i = 0; i < page_count; ++i) {
-    if (i != 0) {
-      // Add space for horizontal separator.
-      document_size_.Enlarge(0, kPageSeparatorThickness);
-    }
+void PDFiumEngine::LoadPageInfo() {
+  RefreshCurrentDocumentLayout();
 
-    // Get page availability. If |reload| == true, then the document has been
-    // constructed already. Get page availability flag from already existing
-    // PDFiumPage class.
-    // If |reload| == false, then the document may not be fully loaded yet.
+  // TODO(crbug.com/1013800): RefreshCurrentDocumentLayout() should send some
+  // sort of "current layout changed" notification, instead of proposing a new
+  // layout. Proposals are never rejected currently, so this is OK for now.
+  ProposeNextDocumentLayout();
+}
+
+void PDFiumEngine::RefreshCurrentDocumentLayout() {
+  UpdateDocumentLayout(&layout_);
+  if (!layout_.dirty())
+    return;
+
+  DCHECK_EQ(pages_.size(), layout_.page_count());
+  for (size_t i = 0; i < layout_.page_count(); ++i) {
+    // TODO(kmoon): This should be the only place that sets |PDFiumPage::rect_|.
+    pages_[i]->set_rect(layout_.page_bounds_rect(i));
+  }
+
+  layout_.clear_dirty();
+
+  CalculateVisiblePages();
+}
+
+void PDFiumEngine::ProposeNextDocumentLayout() {
+  DocumentLayout next_layout;
+  next_layout.SetOptions(desired_layout_options_);
+  UpdateDocumentLayout(&next_layout);
+
+  // The time windows between proposal and application may overlap, so we must
+  // always propose a new layout, regardless of the current layout state.
+  client_->ProposeDocumentLayout(next_layout);
+}
+
+void PDFiumEngine::UpdateDocumentLayout(DocumentLayout* layout) {
+  std::vector<gfx::Size> page_sizes = LoadPageSizes(layout->options());
+  if (page_sizes.empty())
+    return;
+
+  if (layout->options().two_up_view_enabled()) {
+    layout->ComputeTwoUpViewLayout(page_sizes);
+  } else {
+    layout->ComputeSingleViewLayout(page_sizes);
+  }
+}
+
+std::vector<gfx::Size> PDFiumEngine::LoadPageSizes(
+    const DocumentLayout::Options& layout_options) {
+  std::vector<gfx::Size> page_sizes;
+  if (!doc_loader_)
+    return page_sizes;
+  if (pages_.empty() && document_loaded_)
+    return page_sizes;
+
+  pending_pages_.clear();
+  size_t new_page_count = FPDF_GetPageCount(doc());
+
+  const bool doc_complete = doc_loader_->IsDocumentComplete();
+  const bool is_linear = IsLinearized();
+  for (size_t i = 0; i < new_page_count; ++i) {
+    // Get page availability. If |document_loaded_| == true and the page is not
+    // new, then the page has been constructed already. Get page availability
+    // flag from already existing PDFiumPage object. If |document_loaded_| ==
+    // false or the page is new, then the page may not be fully loaded yet.
     bool page_available;
-    if (reload) {
+    if (document_loaded_ && i < pages_.size()) {
       page_available = pages_[i]->available();
     } else if (is_linear) {
       FX_DOWNLOADHINTS& download_hints = document_->download_hints();
@@ -2632,47 +2853,43 @@ void PDFiumEngine::LoadPageInfo(bool reload) {
       page_available = doc_complete;
     }
 
-    pp::Size size = page_available ? GetPageSize(i) : default_page_size_;
-    size.Enlarge(kPageShadowLeft + kPageShadowRight,
-                 kPageShadowTop + kPageShadowBottom);
-    pp::Rect rect(pp::Point(0, document_size_.height()), size);
-    page_rects.push_back(rect);
-
-    if (size.width() > document_size_.width())
-      document_size_.set_width(size.width());
-
-    document_size_.Enlarge(0, size.height());
+    // TODO(crbug.com/1013800): It'd be better if page size were independent of
+    // layout options, and handled in the layout code.
+    gfx::Size size = page_available ? GetPageSizeForLayout(i, layout_options)
+                                    : default_page_size_;
+    EnlargePage(layout_options, i, new_page_count, &size);
+    page_sizes.push_back(size);
   }
 
-  for (int i = 0; i < page_count; ++i) {
-    // Center pages relative to the entire document.
-    page_rects[i].set_x((document_size_.width() - page_rects[i].width()) / 2);
-    pp::Rect page_rect(page_rects[i]);
-    page_rect.Inset(kPageShadowLeft, kPageShadowTop, kPageShadowRight,
-                    kPageShadowBottom);
-    if (reload) {
-      pages_[i]->set_rect(page_rect);
-    } else {
-      // The page is marked as not being available even if |doc_complete| is
-      // true because FPDFAvail_IsPageAvail() still has to be called for this
-      // page, which will be done in FinishLoadingDocument().
-      pages_.push_back(std::make_unique<PDFiumPage>(this, i, page_rect, false));
-    }
+  // Add new pages. If |document_loaded_| == false, do not mark page as
+  // available even if |doc_complete| is true because FPDFAvail_IsPageAvail()
+  // still has to be called for this page, which will be done in
+  // FinishLoadingDocument().
+  for (size_t i = pages_.size(); i < new_page_count; ++i) {
+    auto page = std::make_unique<PDFiumPage>(this, i);
+    if (document_loaded_ &&
+        FPDFAvail_IsPageAvail(fpdf_availability(), i, nullptr))
+      page->MarkAvailable();
+    pages_.push_back(std::move(page));
   }
 
-  CalculateVisiblePages();
-  if (document_size_ != old_document_size)
-    client_->DocumentSizeUpdated(document_size_);
+  // Remove pages that do not exist anymore.
+  if (pages_.size() > new_page_count) {
+    for (size_t i = new_page_count; i < pages_.size(); ++i)
+      pages_[i]->Unload();
+
+    pages_.resize(new_page_count);
+  }
+
+  return page_sizes;
 }
 
 void PDFiumEngine::LoadBody() {
   DCHECK(doc());
-  DCHECK(fpdf_availability());
   if (doc_loader_->IsDocumentComplete()) {
     LoadForm();
-  } else if (FPDFAvail_IsLinearized(fpdf_availability()) == PDF_LINEARIZED &&
-             FPDF_GetPageCount(doc()) == 1) {
-    // If we have only one page we should load form first, bacause it is may be
+  } else if (IsLinearized() && FPDF_GetPageCount(doc()) == 1) {
+    // If we have only one page we should load form first, because it may be an
     // XFA document. And after loading form the page count and its contents may
     // be changed.
     LoadForm();
@@ -2690,7 +2907,8 @@ void PDFiumEngine::LoadPages() {
       // the document is available, the first page is available as well.
       CheckPageAvailable(FPDFAvail_GetFirstPageNum(doc()), &pending_pages_);
     }
-    LoadPageInfo(false);
+    DCHECK(!document_loaded_);
+    LoadPageInfo();
   }
 }
 
@@ -2702,29 +2920,51 @@ void PDFiumEngine::LoadForm() {
   document_->SetFormStatus();
   if (document_->form_status() != PDF_FORM_NOTAVAIL ||
       doc_loader_->IsDocumentComplete()) {
-    document_->InitializeForm(&form_filler_);
-#if defined(PDF_ENABLE_XFA)
-    FPDF_LoadXFA(doc());
-#endif
+    {
+      ScopedUnsupportedFeature scoped_unsupported_feature(this);
+      document_->InitializeForm(&form_filler_);
+    }
 
+    if (form_filler_.script_option() ==
+        PDFiumFormFiller::ScriptOption::kJavaScriptAndXFA) {
+      FPDF_LoadXFA(doc());
+    }
     FPDF_SetFormFieldHighlightColor(form(), FPDF_FORMFIELD_UNKNOWN,
                                     kFormHighlightColor);
     FPDF_SetFormFieldHighlightAlpha(form(), kFormHighlightAlpha);
+
+    if (base::FeatureList::IsEnabled(features::kTabAcrossPDFAnnotations) &&
+        !client_->IsPrintPreview()) {
+      static constexpr FPDF_ANNOTATION_SUBTYPE kFocusableAnnotSubtypes[] = {
+          FPDF_ANNOT_LINK, FPDF_ANNOT_HIGHLIGHT, FPDF_ANNOT_WIDGET};
+      FPDF_BOOL ret = FPDFAnnot_SetFocusableSubtypes(
+          form(), kFocusableAnnotSubtypes, base::size(kFocusableAnnotSubtypes));
+      DCHECK(ret);
+    }
   }
 }
 
+bool PDFiumEngine::IsLinearized() {
+  DCHECK(fpdf_availability());
+  return FPDFAvail_IsLinearized(fpdf_availability()) == PDF_LINEARIZED;
+}
+
 void PDFiumEngine::CalculateVisiblePages() {
-  if (!doc_loader_)
+  // Early return if the PDF isn't being loaded or if we don't have the document
+  // info yet. The latter is important because otherwise as the PDF is being
+  // initialized by the renderer there could be races that call this method
+  // before we get the initial network responses. The document loader depends on
+  // the list of pending requests to be valid for progressive loading to
+  // function.
+  if (!doc_loader_ || pages_.empty())
     return;
   // Clear pending requests queue, since it may contain requests to the pages
   // that are already invisible (after scrolling for example).
   pending_pages_.clear();
   doc_loader_->ClearPendingRequests();
 
-  std::vector<int> formerly_visible_pages;
-  std::swap(visible_pages_, formerly_visible_pages);
-
-  pp::Rect visible_rect(plugin_size_);
+  visible_pages_.clear();
+  gfx::Rect visible_rect(plugin_size_);
   for (int i = 0; i < static_cast<int>(pages_.size()); ++i) {
     // Check an entire PageScreenRect, since we might need to repaint side
     // borders and shadows even if the page itself is not visible.
@@ -2732,12 +2972,7 @@ void PDFiumEngine::CalculateVisiblePages() {
     // outside page area.
     if (visible_rect.Intersects(GetPageScreenRect(i))) {
       visible_pages_.push_back(i);
-      if (CheckPageAvailable(i, &pending_pages_)) {
-        auto it = std::find(formerly_visible_pages.begin(),
-                            formerly_visible_pages.end(), i);
-        if (it == formerly_visible_pages.end())
-          client_->NotifyPageBecameVisible(pages_[i]->GetPageFeatures());
-      }
+      CheckPageAvailable(i, &pending_pages_);
     } else {
       // Need to unload pages when we're not using them, since some PDFs use a
       // lot of memory.  See http://crbug.com/48791
@@ -2746,12 +2981,6 @@ void PDFiumEngine::CalculateVisiblePages() {
       } else {
         pages_[i]->Unload();
       }
-
-      // If the last mouse down was on a page that's no longer visible, reset
-      // that variable so that we don't send keyboard events to it (the focus
-      // will be lost when the page is first closed anyways).
-      if (static_cast<int>(i) == last_page_mouse_down_)
-        last_page_mouse_down_ = -1;
     }
   }
 
@@ -2759,23 +2988,20 @@ void PDFiumEngine::CalculateVisiblePages() {
   // screen coordinates.
   form_highlights_.clear();
 
-  int most_visible_page = visible_pages_.empty() ? -1 : visible_pages_.front();
-  // Check if the next page is more visible than the first one.
-  if (most_visible_page != -1 && !pages_.empty() &&
-      most_visible_page < static_cast<int>(pages_.size()) - 1) {
-    pp::Rect rc_first =
-        visible_rect.Intersect(GetPageScreenRect(most_visible_page));
-    pp::Rect rc_next =
-        visible_rect.Intersect(GetPageScreenRect(most_visible_page + 1));
-    if (rc_next.height() > rc_first.height())
-      most_visible_page++;
+  std::vector<draw_utils::IndexedPage> visible_pages_rects;
+  visible_pages_rects.reserve(visible_pages_.size());
+  for (int visible_page_index : visible_pages_) {
+    visible_pages_rects.emplace_back(visible_page_index,
+                                     pages_[visible_page_index]->rect());
   }
 
+  int most_visible_page =
+      draw_utils::GetMostVisiblePage(visible_pages_rects, GetVisibleRect());
   SetCurrentPage(most_visible_page);
 }
 
 bool PDFiumEngine::IsPageVisible(int index) const {
-  return base::ContainsValue(visible_pages_, index);
+  return base::Contains(visible_pages_, index);
 }
 
 void PDFiumEngine::ScrollToPage(int page) {
@@ -2796,38 +3022,104 @@ bool PDFiumEngine::CheckPageAvailable(int index, std::vector<int>* pending) {
 
   FX_DOWNLOADHINTS& download_hints = document_->download_hints();
   if (!FPDFAvail_IsPageAvail(fpdf_availability(), index, &download_hints)) {
-    if (!base::ContainsValue(*pending, index))
+    if (!base::Contains(*pending, index))
       pending->push_back(index);
     return false;
   }
 
   if (index < num_pages)
-    pages_[index]->set_available(true);
+    pages_[index]->MarkAvailable();
   if (default_page_size_.IsEmpty())
     default_page_size_ = GetPageSize(index);
   return true;
 }
 
-pp::Size PDFiumEngine::GetPageSize(int index) {
-  pp::Size size;
-  double width_in_points = 0;
-  double height_in_points = 0;
-  int rv = FPDF_GetPageSizeByIndex(doc(), index, &width_in_points,
-                                   &height_in_points);
-
-  if (rv) {
-    int width_in_pixels = static_cast<int>(
-        ConvertUnitDouble(width_in_points, kPointsPerInch, kPixelsPerInch));
-    int height_in_pixels = static_cast<int>(
-        ConvertUnitDouble(height_in_points, kPointsPerInch, kPixelsPerInch));
-    if (current_rotation_ % 2 == 1)
-      std::swap(width_in_pixels, height_in_pixels);
-    size = pp::Size(width_in_pixels, height_in_pixels);
-  }
-  return size;
+gfx::Size PDFiumEngine::GetPageSize(int index) {
+  return GetPageSizeForLayout(index, layout_.options());
 }
 
-int PDFiumEngine::StartPaint(int page_index, const pp::Rect& dirty) {
+gfx::Size PDFiumEngine::GetPageSizeForLayout(
+    int index,
+    const DocumentLayout::Options& layout_options) {
+  FS_SIZEF size_in_points;
+  if (!FPDF_GetPageSizeByIndexF(doc(), index, &size_in_points))
+    return gfx::Size();
+
+  int width_in_pixels = static_cast<int>(
+      ConvertUnitDouble(size_in_points.width, kPointsPerInch, kPixelsPerInch));
+  int height_in_pixels = static_cast<int>(
+      ConvertUnitDouble(size_in_points.height, kPointsPerInch, kPixelsPerInch));
+
+  switch (layout_options.default_page_orientation()) {
+    case PageOrientation::kOriginal:
+    case PageOrientation::kClockwise180:
+      // No axis swap needed.
+      break;
+    case PageOrientation::kClockwise90:
+    case PageOrientation::kClockwise270:
+      // Rotated 90 degrees: swap axes.
+      std::swap(width_in_pixels, height_in_pixels);
+      break;
+  }
+
+  return gfx::Size(width_in_pixels, height_in_pixels);
+}
+
+draw_utils::PageInsetSizes PDFiumEngine::GetInsetSizes(
+    const DocumentLayout::Options& layout_options,
+    size_t page_index,
+    size_t num_of_pages) const {
+  DCHECK_LT(page_index, num_of_pages);
+
+  if (layout_options.two_up_view_enabled()) {
+    return draw_utils::GetPageInsetsForTwoUpView(
+        page_index, num_of_pages, DocumentLayout::kSingleViewInsets,
+        DocumentLayout::kHorizontalSeparator);
+  }
+
+  return DocumentLayout::kSingleViewInsets;
+}
+
+void PDFiumEngine::EnlargePage(const DocumentLayout::Options& layout_options,
+                               size_t page_index,
+                               size_t num_of_pages,
+                               gfx::Size* page_size) const {
+  draw_utils::PageInsetSizes inset_sizes =
+      GetInsetSizes(layout_options, page_index, num_of_pages);
+  page_size->Enlarge(inset_sizes.left + inset_sizes.right,
+                     inset_sizes.top + inset_sizes.bottom);
+}
+
+void PDFiumEngine::InsetPage(const DocumentLayout::Options& layout_options,
+                             size_t page_index,
+                             size_t num_of_pages,
+                             double multiplier,
+                             gfx::Rect& rect) const {
+  draw_utils::PageInsetSizes inset_sizes =
+      GetInsetSizes(layout_options, page_index, num_of_pages);
+  rect.Inset(static_cast<int>(ceil(inset_sizes.left * multiplier)),
+             static_cast<int>(ceil(inset_sizes.top * multiplier)),
+             static_cast<int>(ceil(inset_sizes.right * multiplier)),
+             static_cast<int>(ceil(inset_sizes.bottom * multiplier)));
+}
+
+base::Optional<size_t> PDFiumEngine::GetAdjacentPageIndexForTwoUpView(
+    size_t page_index,
+    size_t num_of_pages) const {
+  DCHECK_LT(page_index, num_of_pages);
+
+  if (!layout_.options().two_up_view_enabled())
+    return base::nullopt;
+
+  int adjacent_page_offset = page_index % 2 ? -1 : 1;
+  size_t adjacent_page_index = page_index + adjacent_page_offset;
+  if (adjacent_page_index >= num_of_pages)
+    return base::nullopt;
+
+  return adjacent_page_index;
+}
+
+int PDFiumEngine::StartPaint(int page_index, const gfx::Rect& dirty) {
   // For the first time we hit paint, do nothing and just record the paint for
   // the next callback.  This keeps the UI responsive in case the user is doing
   // a lot of scrolling.
@@ -2835,15 +3127,13 @@ int PDFiumEngine::StartPaint(int page_index, const pp::Rect& dirty) {
   return progressive_paints_.size() - 1;
 }
 
-bool PDFiumEngine::ContinuePaint(int progressive_index,
-                                 pp::ImageData* image_data) {
+bool PDFiumEngine::ContinuePaint(int progressive_index, SkBitmap& image_data) {
   DCHECK_GE(progressive_index, 0);
   DCHECK_LT(static_cast<size_t>(progressive_index), progressive_paints_.size());
-  DCHECK(image_data);
 
   last_progressive_start_time_ = base::Time::Now();
-#if defined(OS_LINUX)
-  g_last_instance_id = client_->GetPluginInstance()->pp_instance();
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+  SetLastInstance(client_->GetPluginInstance());
 #endif
 
   int page_index = progressive_paints_[progressive_index].page_index();
@@ -2852,37 +3142,34 @@ bool PDFiumEngine::ContinuePaint(int progressive_index,
   int rv;
   FPDF_PAGE page = pages_[page_index]->GetPage();
   if (progressive_paints_[progressive_index].bitmap()) {
-    rv = FPDF_RenderPage_Continue(page, static_cast<IFSDK_PAUSE*>(this));
+    rv = FPDF_RenderPage_Continue(page, this);
   } else {
     int start_x;
     int start_y;
     int size_x;
     int size_y;
-    pp::Rect dirty = progressive_paints_[progressive_index].rect();
+    gfx::Rect dirty = progressive_paints_[progressive_index].rect();
     GetPDFiumRect(page_index, dirty, &start_x, &start_y, &size_x, &size_y);
 
     ScopedFPDFBitmap new_bitmap = CreateBitmap(dirty, image_data);
     FPDFBitmap_FillRect(new_bitmap.get(), start_x, start_y, size_x, size_y,
                         0xFFFFFFFF);
-    rv = FPDF_RenderPageBitmap_Start(new_bitmap.get(), page, start_x, start_y,
-                                     size_x, size_y, current_rotation_,
-                                     GetRenderingFlags(),
-                                     static_cast<IFSDK_PAUSE*>(this));
+    rv = FPDF_RenderPageBitmap_Start(
+        new_bitmap.get(), page, start_x, start_y, size_x, size_y,
+        ToPDFiumRotation(layout_.options().default_page_orientation()),
+        GetRenderingFlags(), this);
     progressive_paints_[progressive_index].SetBitmapAndImageData(
-        std::move(new_bitmap), *image_data);
+        std::move(new_bitmap), image_data);
   }
-  return rv != FPDF_RENDER_TOBECOUNTINUED;
+  return rv != FPDF_RENDER_TOBECONTINUED;
 }
 
-void PDFiumEngine::FinishPaint(int progressive_index,
-                               pp::ImageData* image_data) {
+void PDFiumEngine::FinishPaint(int progressive_index, SkBitmap& image_data) {
   DCHECK_GE(progressive_index, 0);
   DCHECK_LT(static_cast<size_t>(progressive_index), progressive_paints_.size());
-  DCHECK(image_data);
 
   int page_index = progressive_paints_[progressive_index].page_index();
-  const pp::Rect& dirty_in_screen =
-      progressive_paints_[progressive_index].rect();
+  gfx::Rect dirty_in_screen = progressive_paints_[progressive_index].rect();
 
   int start_x;
   int start_y;
@@ -2894,7 +3181,9 @@ void PDFiumEngine::FinishPaint(int progressive_index,
 
   // Draw the forms.
   FPDF_FFLDraw(form(), bitmap, pages_[page_index]->GetPage(), start_x, start_y,
-               size_x, size_y, current_rotation_, GetRenderingFlags());
+               size_x, size_y,
+               ToPDFiumRotation(layout_.options().default_page_orientation()),
+               GetRenderingFlags());
 
   FillPageSides(progressive_index);
 
@@ -2902,11 +3191,10 @@ void PDFiumEngine::FinishPaint(int progressive_index,
   PaintPageShadow(progressive_index, image_data);
 
   DrawSelections(progressive_index, image_data);
+  form_highlights_.clear();
 
   FPDF_RenderPage_Close(pages_[page_index]->GetPage());
   progressive_paints_.erase(progressive_paints_.begin() + progressive_index);
-
-  client_->DocumentPaintOccurred();
 }
 
 void PDFiumEngine::CancelPaints() {
@@ -2921,61 +3209,74 @@ void PDFiumEngine::FillPageSides(int progressive_index) {
   DCHECK_LT(static_cast<size_t>(progressive_index), progressive_paints_.size());
 
   int page_index = progressive_paints_[progressive_index].page_index();
-  const pp::Rect& dirty_in_screen =
-      progressive_paints_[progressive_index].rect();
+  gfx::Rect dirty_in_screen = progressive_paints_[progressive_index].rect();
   FPDF_BITMAP bitmap = progressive_paints_[progressive_index].bitmap();
+  draw_utils::PageInsetSizes inset_sizes =
+      GetInsetSizes(layout_.options(), page_index, pages_.size());
 
-  pp::Rect page_rect = pages_[page_index]->rect();
-  if (page_rect.x() > 0) {
-    pp::Rect left(0, page_rect.y() - kPageShadowTop,
-                  page_rect.x() - kPageShadowLeft,
-                  page_rect.height() + kPageShadowTop + kPageShadowBottom +
-                      kPageSeparatorThickness);
-    left = GetScreenRect(left).Intersect(dirty_in_screen);
+  gfx::Rect page_rect = pages_[page_index]->rect();
+  const bool is_two_up_view = layout_.options().two_up_view_enabled();
+  if (page_rect.x() > 0 && (!is_two_up_view || page_index % 2 == 0)) {
+    // If in two-up view, only need to draw the left empty space for left pages
+    // since the gap between the left and right page will be drawn by the left
+    // page.
+    gfx::Rect left_in_screen = GetScreenRect(draw_utils::GetLeftFillRect(
+        page_rect, inset_sizes, DocumentLayout::kBottomSeparator));
+    left_in_screen.Intersect(dirty_in_screen);
 
-    FPDFBitmap_FillRect(bitmap, left.x() - dirty_in_screen.x(),
-                        left.y() - dirty_in_screen.y(), left.width(),
-                        left.height(), client_->GetBackgroundColor());
+    FPDFBitmap_FillRect(bitmap, left_in_screen.x() - dirty_in_screen.x(),
+                        left_in_screen.y() - dirty_in_screen.y(),
+                        left_in_screen.width(), left_in_screen.height(),
+                        client_->GetBackgroundColor());
   }
 
-  if (page_rect.right() < document_size_.width()) {
-    pp::Rect right(
-        page_rect.right() + kPageShadowRight, page_rect.y() - kPageShadowTop,
-        document_size_.width() - page_rect.right() - kPageShadowRight,
-        page_rect.height() + kPageShadowTop + kPageShadowBottom +
-            kPageSeparatorThickness);
-    right = GetScreenRect(right).Intersect(dirty_in_screen);
+  if (page_rect.right() < layout_.size().width()) {
+    gfx::Rect right_in_screen = GetScreenRect(draw_utils::GetRightFillRect(
+        page_rect, inset_sizes, layout_.size().width(),
+        DocumentLayout::kBottomSeparator));
+    right_in_screen.Intersect(dirty_in_screen);
 
-    FPDFBitmap_FillRect(bitmap, right.x() - dirty_in_screen.x(),
-                        right.y() - dirty_in_screen.y(), right.width(),
-                        right.height(), client_->GetBackgroundColor());
+    FPDFBitmap_FillRect(bitmap, right_in_screen.x() - dirty_in_screen.x(),
+                        right_in_screen.y() - dirty_in_screen.y(),
+                        right_in_screen.width(), right_in_screen.height(),
+                        client_->GetBackgroundColor());
   }
 
-  // Paint separator.
-  pp::Rect bottom(page_rect.x() - kPageShadowLeft,
-                  page_rect.bottom() + kPageShadowBottom,
-                  page_rect.width() + kPageShadowLeft + kPageShadowRight,
-                  kPageSeparatorThickness);
-  bottom = GetScreenRect(bottom).Intersect(dirty_in_screen);
+  gfx::Rect bottom_in_screen;
+  if (is_two_up_view) {
+    gfx::Rect page_in_screen = GetScreenRect(page_rect);
+    bottom_in_screen = draw_utils::GetBottomGapBetweenRects(
+        page_in_screen.bottom(), dirty_in_screen);
 
-  FPDFBitmap_FillRect(bitmap, bottom.x() - dirty_in_screen.x(),
-                      bottom.y() - dirty_in_screen.y(), bottom.width(),
-                      bottom.height(), client_->GetBackgroundColor());
+    if (page_index % 2 == 1) {
+      draw_utils::AdjustBottomGapForRightSidePage(page_in_screen.x(),
+                                                  &bottom_in_screen);
+    }
+
+    bottom_in_screen.Intersect(dirty_in_screen);
+  } else {
+    bottom_in_screen = GetScreenRect(draw_utils::GetBottomFillRect(
+        page_rect, inset_sizes, DocumentLayout::kBottomSeparator));
+    bottom_in_screen.Intersect(dirty_in_screen);
+  }
+
+  FPDFBitmap_FillRect(bitmap, bottom_in_screen.x() - dirty_in_screen.x(),
+                      bottom_in_screen.y() - dirty_in_screen.y(),
+                      bottom_in_screen.width(), bottom_in_screen.height(),
+                      client_->GetBackgroundColor());
 }
 
 void PDFiumEngine::PaintPageShadow(int progressive_index,
-                                   pp::ImageData* image_data) {
+                                   SkBitmap& image_data) {
   DCHECK_GE(progressive_index, 0);
   DCHECK_LT(static_cast<size_t>(progressive_index), progressive_paints_.size());
-  DCHECK(image_data);
 
   int page_index = progressive_paints_[progressive_index].page_index();
-  const pp::Rect& dirty_in_screen =
-      progressive_paints_[progressive_index].rect();
-  pp::Rect page_rect = pages_[page_index]->rect();
-  pp::Rect shadow_rect(page_rect);
-  shadow_rect.Inset(-kPageShadowLeft, -kPageShadowTop, -kPageShadowRight,
-                    -kPageShadowBottom);
+  gfx::Rect dirty_in_screen = progressive_paints_[progressive_index].rect();
+  gfx::Rect page_rect = pages_[page_index]->rect();
+  gfx::Rect shadow_rect(page_rect);
+  InsetPage(layout_.options(), page_index, pages_.size(), /*multiplier=*/-1,
+            shadow_rect);
 
   // Due to the rounding errors of the GetScreenRect it is possible to get
   // different size shadows on the left and right sides even they are defined
@@ -2983,63 +3284,59 @@ void PDFiumEngine::PaintPageShadow(int progressive_index,
   // it by the size of the shadows.
   shadow_rect = GetScreenRect(shadow_rect);
   page_rect = shadow_rect;
-
-  page_rect.Inset(static_cast<int>(ceil(kPageShadowLeft * current_zoom_)),
-                  static_cast<int>(ceil(kPageShadowTop * current_zoom_)),
-                  static_cast<int>(ceil(kPageShadowRight * current_zoom_)),
-                  static_cast<int>(ceil(kPageShadowBottom * current_zoom_)));
+  InsetPage(layout_.options(), page_index, pages_.size(),
+            /*multiplier=*/current_zoom_, page_rect);
 
   DrawPageShadow(page_rect, shadow_rect, dirty_in_screen, image_data);
 }
 
 void PDFiumEngine::DrawSelections(int progressive_index,
-                                  pp::ImageData* image_data) {
+                                  SkBitmap& image_data) const {
   DCHECK_GE(progressive_index, 0);
   DCHECK_LT(static_cast<size_t>(progressive_index), progressive_paints_.size());
-  DCHECK(image_data);
 
   int page_index = progressive_paints_[progressive_index].page_index();
-  const pp::Rect& dirty_in_screen =
-      progressive_paints_[progressive_index].rect();
+  gfx::Rect dirty_in_screen = progressive_paints_[progressive_index].rect();
 
   void* region = nullptr;
   int stride;
-  GetRegion(dirty_in_screen.point(), image_data, &region, &stride);
+  GetRegion(dirty_in_screen.origin(), image_data, region, stride);
 
-  std::vector<pp::Rect> highlighted_rects;
-  pp::Rect visible_rect = GetVisibleRect();
-  for (auto& range : selection_) {
+  std::vector<gfx::Rect> highlighted_rects;
+  gfx::Rect visible_rect = GetVisibleRect();
+  for (const auto& range : selection_) {
     if (range.page_index() != page_index)
       continue;
 
-    const std::vector<pp::Rect>& rects = range.GetScreenRects(
-        visible_rect.point(), current_zoom_, current_rotation_);
+    const std::vector<gfx::Rect>& rects =
+        range.GetScreenRects(visible_rect.origin(), current_zoom_,
+                             layout_.options().default_page_orientation());
     for (const auto& rect : rects) {
-      pp::Rect visible_selection = rect.Intersect(dirty_in_screen);
+      gfx::Rect visible_selection = gfx::IntersectRects(rect, dirty_in_screen);
       if (visible_selection.IsEmpty())
         continue;
 
-      visible_selection.Offset(-dirty_in_screen.point().x(),
-                               -dirty_in_screen.point().y());
-      Highlight(region, stride, visible_selection, &highlighted_rects);
+      visible_selection.Offset(-dirty_in_screen.OffsetFromOrigin());
+      Highlight(region, stride, visible_selection, kHighlightColorR,
+                kHighlightColorG, kHighlightColorB, highlighted_rects);
     }
   }
 
   for (const auto& highlight : form_highlights_) {
-    pp::Rect visible_selection = highlight.Intersect(dirty_in_screen);
+    gfx::Rect visible_selection =
+        gfx::IntersectRects(highlight, dirty_in_screen);
     if (visible_selection.IsEmpty())
       continue;
 
-    visible_selection.Offset(-dirty_in_screen.point().x(),
-                             -dirty_in_screen.point().y());
-    Highlight(region, stride, visible_selection, &highlighted_rects);
+    visible_selection.Offset(-dirty_in_screen.OffsetFromOrigin());
+    Highlight(region, stride, visible_selection, kHighlightColorR,
+              kHighlightColorG, kHighlightColorB, highlighted_rects);
   }
-  form_highlights_.clear();
 }
 
 void PDFiumEngine::PaintUnavailablePage(int page_index,
-                                        const pp::Rect& dirty,
-                                        pp::ImageData* image_data) {
+                                        const gfx::Rect& dirty,
+                                        SkBitmap& image_data) {
   int start_x;
   int start_y;
   int size_x;
@@ -3049,7 +3346,7 @@ void PDFiumEngine::PaintUnavailablePage(int page_index,
   FPDFBitmap_FillRect(bitmap.get(), start_x, start_y, size_x, size_y,
                       kPendingPageColor);
 
-  pp::Rect loading_text_in_screen(
+  gfx::Rect loading_text_in_screen(
       pages_[page_index]->rect().width() / 2,
       pages_[page_index]->rect().y() + kLoadingTextVerticalOffset, 0, 0);
   loading_text_in_screen = GetScreenRect(loading_text_in_screen);
@@ -3063,11 +3360,11 @@ int PDFiumEngine::GetProgressiveIndex(int page_index) const {
   return -1;
 }
 
-ScopedFPDFBitmap PDFiumEngine::CreateBitmap(const pp::Rect& rect,
-                                            pp::ImageData* image_data) const {
+ScopedFPDFBitmap PDFiumEngine::CreateBitmap(const gfx::Rect& rect,
+                                            SkBitmap& image_data) const {
   void* region;
   int stride;
-  GetRegion(rect.point(), image_data, &region, &stride);
+  GetRegion(rect.origin(), image_data, region, stride);
   if (!region)
     return nullptr;
   return ScopedFPDFBitmap(FPDFBitmap_CreateEx(rect.width(), rect.height(),
@@ -3075,12 +3372,12 @@ ScopedFPDFBitmap PDFiumEngine::CreateBitmap(const pp::Rect& rect,
 }
 
 void PDFiumEngine::GetPDFiumRect(int page_index,
-                                 const pp::Rect& rect,
+                                 const gfx::Rect& rect,
                                  int* start_x,
                                  int* start_y,
                                  int* size_x,
                                  int* size_y) const {
-  pp::Rect page_rect = GetScreenRect(pages_[page_index]->rect());
+  gfx::Rect page_rect = GetScreenRect(pages_[page_index]->rect());
   page_rect.Offset(-rect.x(), -rect.y());
 
   *start_x = page_rect.x();
@@ -3090,7 +3387,7 @@ void PDFiumEngine::GetPDFiumRect(int page_index,
 }
 
 int PDFiumEngine::GetRenderingFlags() const {
-  int flags = FPDF_LCD_TEXT | FPDF_NO_CATCH;
+  int flags = FPDF_LCD_TEXT;
   if (render_grayscale_)
     flags |= FPDF_GRAYSCALE;
   if (client_->IsPrintPreview())
@@ -3100,8 +3397,8 @@ int PDFiumEngine::GetRenderingFlags() const {
   return flags;
 }
 
-pp::Rect PDFiumEngine::GetVisibleRect() const {
-  pp::Rect rv;
+gfx::Rect PDFiumEngine::GetVisibleRect() const {
+  gfx::Rect rv;
   rv.set_x(static_cast<int>(position_.x() / current_zoom_));
   rv.set_y(static_cast<int>(position_.y() / current_zoom_));
   rv.set_width(static_cast<int>(ceil(plugin_size_.width() / current_zoom_)));
@@ -3109,51 +3406,51 @@ pp::Rect PDFiumEngine::GetVisibleRect() const {
   return rv;
 }
 
-pp::Rect PDFiumEngine::GetPageScreenRect(int page_index) const {
-  // Since we use this rect for creating the PDFium bitmap, also include other
-  // areas around the page that we might need to update such as the page
-  // separator and the sides if the page is narrower than the document.
-  return GetScreenRect(
-      pp::Rect(0, pages_[page_index]->rect().y() - kPageShadowTop,
-               document_size_.width(),
-               pages_[page_index]->rect().height() + kPageShadowTop +
-                   kPageShadowBottom + kPageSeparatorThickness));
+gfx::Rect PDFiumEngine::GetPageScreenRect(int page_index) const {
+  gfx::Rect page_rect = pages_[page_index]->rect();
+  draw_utils::PageInsetSizes inset_sizes =
+      GetInsetSizes(layout_.options(), page_index, pages_.size());
+
+  int max_page_height = page_rect.height();
+  base::Optional<size_t> adjacent_page_index =
+      GetAdjacentPageIndexForTwoUpView(page_index, pages_.size());
+  if (adjacent_page_index.has_value()) {
+    max_page_height = std::max(
+        max_page_height, pages_[adjacent_page_index.value()]->rect().height());
+  }
+
+  return GetScreenRect(draw_utils::GetSurroundingRect(
+      page_rect.y(), max_page_height, inset_sizes, layout_.size().width(),
+      DocumentLayout::kBottomSeparator));
 }
 
-pp::Rect PDFiumEngine::GetScreenRect(const pp::Rect& rect) const {
-  pp::Rect rv;
-  int right =
-      static_cast<int>(ceil(rect.right() * current_zoom_ - position_.x()));
-  int bottom =
-      static_cast<int>(ceil(rect.bottom() * current_zoom_ - position_.y()));
-
-  rv.set_x(static_cast<int>(rect.x() * current_zoom_ - position_.x()));
-  rv.set_y(static_cast<int>(rect.y() * current_zoom_ - position_.y()));
-  rv.set_width(right - rv.x());
-  rv.set_height(bottom - rv.y());
-  return rv;
+gfx::Rect PDFiumEngine::GetScreenRect(const gfx::Rect& rect) const {
+  return draw_utils::GetScreenRect(rect, position_, current_zoom_);
 }
 
 void PDFiumEngine::Highlight(void* buffer,
                              int stride,
-                             const pp::Rect& rect,
-                             std::vector<pp::Rect>* highlighted_rects) {
+                             const gfx::Rect& rect,
+                             int color_red,
+                             int color_green,
+                             int color_blue,
+                             std::vector<gfx::Rect>& highlighted_rects) const {
   if (!buffer)
     return;
 
-  pp::Rect new_rect = rect;
-  for (const auto& highlighted : *highlighted_rects)
-    new_rect = new_rect.Subtract(highlighted);
+  gfx::Rect new_rect = rect;
+  for (const auto& highlighted : highlighted_rects)
+    new_rect.Subtract(highlighted);
   if (new_rect.IsEmpty())
     return;
 
   std::vector<size_t> overlapping_rect_indices;
-  for (size_t i = 0; i < highlighted_rects->size(); ++i) {
-    if (new_rect.Intersects((*highlighted_rects)[i]))
+  for (size_t i = 0; i < highlighted_rects.size(); ++i) {
+    if (new_rect.Intersects((highlighted_rects)[i]))
       overlapping_rect_indices.push_back(i);
   }
 
-  highlighted_rects->push_back(new_rect);
+  highlighted_rects.push_back(new_rect);
   int l = new_rect.x();
   int t = new_rect.y();
   int w = new_rect.width();
@@ -3163,7 +3460,7 @@ void PDFiumEngine::Highlight(void* buffer,
     for (int x = l; x < l + w; ++x) {
       bool overlaps = false;
       for (size_t i : overlapping_rect_indices) {
-        const auto& highlighted = (*highlighted_rects)[i];
+        const auto& highlighted = (highlighted_rects)[i];
         if (highlighted.Contains(x, y)) {
           overlaps = true;
           break;
@@ -3173,9 +3470,9 @@ void PDFiumEngine::Highlight(void* buffer,
         continue;
 
       uint8_t* pixel = static_cast<uint8_t*>(buffer) + y * stride + x * 4;
-      pixel[0] = static_cast<uint8_t>(pixel[0] * (kHighlightColorB / 255.0));
-      pixel[1] = static_cast<uint8_t>(pixel[1] * (kHighlightColorG / 255.0));
-      pixel[2] = static_cast<uint8_t>(pixel[2] * (kHighlightColorR / 255.0));
+      pixel[0] = static_cast<uint8_t>(pixel[0] * (color_blue / 255.0));
+      pixel[1] = static_cast<uint8_t>(pixel[1] * (color_green / 255.0));
+      pixel[2] = static_cast<uint8_t>(pixel[2] * (color_red / 255.0));
     }
   }
 }
@@ -3183,22 +3480,22 @@ void PDFiumEngine::Highlight(void* buffer,
 PDFiumEngine::SelectionChangeInvalidator::SelectionChangeInvalidator(
     PDFiumEngine* engine)
     : engine_(engine),
-      previous_origin_(engine_->GetVisibleRect().point()),
+      previous_origin_(engine_->GetVisibleRect().origin()),
       old_selections_(GetVisibleSelections()) {}
 
 PDFiumEngine::SelectionChangeInvalidator::~SelectionChangeInvalidator() {
   // Offset the old selections if the document scrolled since we recorded them.
-  pp::Point offset = previous_origin_ - engine_->GetVisibleRect().point();
+  gfx::Vector2d offset = previous_origin_ - engine_->GetVisibleRect().origin();
   for (auto& old_selection : old_selections_)
     old_selection.Offset(offset);
 
-  std::vector<pp::Rect> new_selections = GetVisibleSelections();
+  std::vector<gfx::Rect> new_selections = GetVisibleSelections();
   for (auto& new_selection : new_selections) {
     for (auto& old_selection : old_selections_) {
       if (!old_selection.IsEmpty() && new_selection == old_selection) {
         // Rectangle was selected before and after, so no need to invalidate it.
         // Mark the rectangles by setting them to empty.
-        new_selection = old_selection = pp::Rect();
+        new_selection = old_selection = gfx::Rect();
         break;
       }
     }
@@ -3224,25 +3521,26 @@ PDFiumEngine::SelectionChangeInvalidator::~SelectionChangeInvalidator() {
   }
 }
 
-std::vector<pp::Rect>
+std::vector<gfx::Rect>
 PDFiumEngine::SelectionChangeInvalidator::GetVisibleSelections() const {
-  std::vector<pp::Rect> rects;
-  pp::Point visible_point = engine_->GetVisibleRect().point();
-  for (auto& range : engine_->selection_) {
+  std::vector<gfx::Rect> rects;
+  gfx::Point visible_point = engine_->GetVisibleRect().origin();
+  for (const auto& range : engine_->selection_) {
     // Exclude selections on pages that's not currently visible.
     if (!engine_->IsPageVisible(range.page_index()))
       continue;
 
-    const std::vector<pp::Rect>& selection_rects = range.GetScreenRects(
-        visible_point, engine_->current_zoom_, engine_->current_rotation_);
+    const std::vector<gfx::Rect>& selection_rects = range.GetScreenRects(
+        visible_point, engine_->current_zoom_,
+        engine_->layout_.options().default_page_orientation());
     rects.insert(rects.end(), selection_rects.begin(), selection_rects.end());
   }
   return rects;
 }
 
 void PDFiumEngine::SelectionChangeInvalidator::Invalidate(
-    const pp::Rect& selection) {
-  pp::Rect expanded_selection = selection;
+    const gfx::Rect& selection) {
+  gfx::Rect expanded_selection = selection;
   expanded_selection.Inset(-1, -1);
   engine_->client_->Invalidate(expanded_selection);
 }
@@ -3281,10 +3579,11 @@ bool PDFiumEngine::MouseDownState::Matches(
 }
 
 void PDFiumEngine::DeviceToPage(int page_index,
-                                const pp::Point& device_point,
+                                const gfx::Point& device_point,
                                 double* page_x,
                                 double* page_y) {
-  *page_x = *page_y = 0;
+  *page_x = 0;
+  *page_y = 0;
   float device_x = device_point.x();
   float device_y = device_point.y();
   int temp_x = static_cast<int>((device_x + position_.x()) / current_zoom_ -
@@ -3293,8 +3592,9 @@ void PDFiumEngine::DeviceToPage(int page_index,
                                 pages_[page_index]->rect().y());
   FPDF_BOOL ret = FPDF_DeviceToPage(
       pages_[page_index]->GetPage(), 0, 0, pages_[page_index]->rect().width(),
-      pages_[page_index]->rect().height(), current_rotation_, temp_x, temp_y,
-      page_x, page_y);
+      pages_[page_index]->rect().height(),
+      ToPDFiumRotation(layout_.options().default_page_orientation()), temp_x,
+      temp_y, page_x, page_y);
   DCHECK(ret);
 }
 
@@ -3320,8 +3620,8 @@ void PDFiumEngine::SetCurrentPage(int index) {
     FORM_DoPageAAction(old_page, form(), FPDFPAGE_AACTION_CLOSE);
   }
   most_visible_page_ = index;
-#if defined(OS_LINUX)
-  g_last_instance_id = client_->GetPluginInstance()->pp_instance();
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+  SetLastInstance(client_->GetPluginInstance());
 #endif
   if (most_visible_page_ != -1 && called_do_document_action_) {
     FPDF_PAGE new_page = pages_[most_visible_page_]->GetPage();
@@ -3329,79 +3629,80 @@ void PDFiumEngine::SetCurrentPage(int index) {
   }
 }
 
-void PDFiumEngine::DrawPageShadow(const pp::Rect& page_rc,
-                                  const pp::Rect& shadow_rc,
-                                  const pp::Rect& clip_rc,
-                                  pp::ImageData* image_data) {
-  pp::Rect page_rect(page_rc);
+void PDFiumEngine::DrawPageShadow(const gfx::Rect& page_rc,
+                                  const gfx::Rect& shadow_rc,
+                                  const gfx::Rect& clip_rc,
+                                  SkBitmap& image_data) {
+  gfx::Rect page_rect(page_rc);
   page_rect.Offset(page_offset_);
 
-  pp::Rect shadow_rect(shadow_rc);
+  gfx::Rect shadow_rect(shadow_rc);
   shadow_rect.Offset(page_offset_);
 
-  pp::Rect clip_rect(clip_rc);
+  gfx::Rect clip_rect(clip_rc);
   clip_rect.Offset(page_offset_);
 
   // Page drop shadow parameters.
-  const double factor = 0.5;
-  uint32_t depth =
-      std::max(std::max(page_rect.x() - shadow_rect.x(),
-                        page_rect.y() - shadow_rect.y()),
-               std::max(shadow_rect.right() - page_rect.right(),
-                        shadow_rect.bottom() - page_rect.bottom()));
+  constexpr double factor = 0.5;
+  uint32_t depth = std::max({page_rect.x() - shadow_rect.x(),
+                             page_rect.y() - shadow_rect.y(),
+                             shadow_rect.right() - page_rect.right(),
+                             shadow_rect.bottom() - page_rect.bottom()});
   depth = static_cast<uint32_t>(depth * 1.5) + 1;
 
   // We need to check depth only to verify our copy of shadow matrix is correct.
-  if (!page_shadow_.get() || page_shadow_->depth() != depth) {
-    page_shadow_ = std::make_unique<ShadowMatrix>(
+  if (!page_shadow_ || page_shadow_->depth() != depth) {
+    page_shadow_ = std::make_unique<draw_utils::ShadowMatrix>(
         depth, factor, client_->GetBackgroundColor());
   }
 
-  DCHECK(!image_data->is_null());
+  DCHECK(!image_data.isNull());
   DrawShadow(image_data, shadow_rect, page_rect, clip_rect, *page_shadow_);
 }
 
-void PDFiumEngine::GetRegion(const pp::Point& location,
-                             pp::ImageData* image_data,
-                             void** region,
-                             int* stride) const {
-  if (image_data->is_null()) {
+void PDFiumEngine::GetRegion(const gfx::Point& location,
+                             SkBitmap& image_data,
+                             void*& region,
+                             int& stride) const {
+  if (image_data.isNull()) {
     DCHECK(plugin_size_.IsEmpty());
-    *stride = 0;
-    *region = nullptr;
+    stride = 0;
+    region = nullptr;
     return;
   }
-  char* buffer = static_cast<char*>(image_data->data());
-  *stride = image_data->stride();
+  char* buffer = static_cast<char*>(image_data.getPixels());
+  stride = image_data.rowBytes();
 
-  pp::Point offset_location = location + page_offset_;
+  gfx::Point offset_location = location + page_offset_;
   // TODO: update this when we support BIDI and scrollbars can be on the left.
   if (!buffer ||
-      !pp::Rect(page_offset_, plugin_size_).Contains(offset_location)) {
-    *region = nullptr;
+      !gfx::Rect(gfx::PointAtOffsetFromOrigin(page_offset_), plugin_size_)
+           .Contains(offset_location)) {
+    region = nullptr;
     return;
   }
 
-  buffer += location.y() * (*stride);
+  buffer += location.y() * stride;
   buffer += (location.x() + page_offset_.x()) * 4;
-  *region = buffer;
+  region = buffer;
 }
 
 void PDFiumEngine::OnSelectionTextChanged() {
   DCHECK(!in_form_text_area_);
-  pp::PDF::SetSelectedText(GetPluginInstance(), GetSelectedText().c_str());
+  client_->SetSelectedText(GetSelectedText());
 }
 
 void PDFiumEngine::OnSelectionPositionChanged() {
   // We need to determine the top-left and bottom-right points of the selection
   // in order to report those to the embedder. This code assumes that the
   // selection list is out of order.
-  pp::Rect left(std::numeric_limits<int32_t>::max(),
-                std::numeric_limits<int32_t>::max(), 0, 0);
-  pp::Rect right;
-  for (auto& sel : selection_) {
-    const std::vector<pp::Rect>& screen_rects = sel.GetScreenRects(
-        GetVisibleRect().point(), current_zoom_, current_rotation_);
+  gfx::Rect left(std::numeric_limits<int32_t>::max(),
+                 std::numeric_limits<int32_t>::max(), 0, 0);
+  gfx::Rect right;
+  for (const auto& sel : selection_) {
+    const std::vector<gfx::Rect>& screen_rects =
+        sel.GetScreenRects(GetVisibleRect().origin(), current_zoom_,
+                           layout_.options().default_page_orientation());
     for (const auto& rect : screen_rects) {
       if (IsAboveOrDirectlyLeftOf(rect, left))
         left = rect;
@@ -3417,7 +3718,20 @@ void PDFiumEngine::OnSelectionPositionChanged() {
   client_->SelectionChanged(left, right);
 }
 
-void PDFiumEngine::RotateInternal() {
+gfx::Size PDFiumEngine::ApplyDocumentLayout(
+    const DocumentLayout::Options& options) {
+  // We need to return early if the layout would not change, otherwise calling
+  // client_->ScrollToPage() would send another "viewport" message, triggering
+  // an infinite loop.
+  //
+  // TODO(crbug.com/1013800): The current implementation computes layout twice
+  // (here, and in InvalidateAllPages()). This shouldn't be too expensive at
+  // realistic page counts, but could be avoided.
+  layout_.SetOptions(options);
+  UpdateDocumentLayout(&layout_);
+  if (!layout_.dirty())
+    return layout_.size();
+
   // Store the current find index so that we can resume finding at that
   // particular index after we have recomputed the find results.
   std::string current_find_text = current_find_text_;
@@ -3439,21 +3753,23 @@ void PDFiumEngine::RotateInternal() {
   // the scroll position has not. Re-adjust.
   // TODO(thestig): It would be better to also restore the position on the page.
   client_->ScrollToPage(most_visible_page);
+
+  return layout_.size();
 }
 
 void PDFiumEngine::SetSelecting(bool selecting) {
   bool was_selecting = selecting_;
   selecting_ = selecting;
   if (selecting_ != was_selecting)
-    client_->IsSelectingChanged(selecting);
+    client_->SetIsSelecting(selecting);
 }
 
-void PDFiumEngine::SetEditMode(bool edit_mode) {
-  if (!kIsEditModeTracked || edit_mode_ == edit_mode)
+void PDFiumEngine::EnteredEditMode() {
+  if (edit_mode_)
     return;
 
-  edit_mode_ = edit_mode;
-  client_->IsEditModeChanged(edit_mode_);
+  edit_mode_ = true;
+  client_->EnteredEditMode();
 }
 
 void PDFiumEngine::SetInFormTextArea(bool in_form_text_area) {
@@ -3461,8 +3777,9 @@ void PDFiumEngine::SetInFormTextArea(bool in_form_text_area) {
   // Clearing needs to be done before changing focus to ensure the correct
   // observer is notified of the change in selection. When |in_form_text_area_|
   // is true, this is the Renderer. After it flips, the MimeHandler is notified.
-  if (in_form_text_area_)
-    pp::PDF::SetSelectedText(GetPluginInstance(), "");
+  if (in_form_text_area_) {
+    client_->SetSelectedText("");
+  }
 
   client_->FormTextFieldFocusChange(in_form_text_area);
   in_form_text_area_ = in_form_text_area;
@@ -3476,29 +3793,26 @@ void PDFiumEngine::SetMouseLeftButtonDown(bool is_mouse_left_button_down) {
   mouse_left_button_down_ = is_mouse_left_button_down;
 }
 
-bool PDFiumEngine::IsPointInEditableFormTextArea(FPDF_PAGE page,
-                                                 double page_x,
-                                                 double page_y,
-                                                 int form_type) {
+bool PDFiumEngine::IsAnnotationAnEditableFormTextArea(FPDF_ANNOTATION annot,
+                                                      int form_type) const {
 #if defined(PDF_ENABLE_XFA)
-  if (IS_XFA_FORMFIELD(form_type))
+  if (IS_XFA_FORMFIELD(form_type)) {
     return form_type == FPDF_FORMFIELD_XFA_TEXTFIELD ||
            form_type == FPDF_FORMFIELD_XFA_COMBOBOX;
+  }
 #endif  // defined(PDF_ENABLE_XFA)
 
-  ScopedFPDFAnnotation annot(
-      FPDFAnnot_GetFormFieldAtPoint(form(), page, page_x, page_y));
   if (!annot)
     return false;
 
-  int flags = FPDFAnnot_GetFormFieldFlags(page, annot.get());
+  int flags = FPDFAnnot_GetFormFieldFlags(form(), annot);
   return CheckIfEditableFormTextArea(flags, form_type);
 }
 
-void PDFiumEngine::ScheduleTouchTimer(const pp::TouchInputEvent& evt) {
+void PDFiumEngine::ScheduleTouchTimer(const TouchInputEvent& evt) {
   touch_timer_.Start(FROM_HERE, kTouchLongPressTimeout,
-                     base::BindRepeating(&PDFiumEngine::HandleLongPress,
-                                         base::Unretained(this), evt));
+                     base::BindOnce(&PDFiumEngine::HandleLongPress,
+                                    base::Unretained(this), evt));
 }
 
 void PDFiumEngine::KillTouchTimer() {
@@ -3509,8 +3823,10 @@ bool PDFiumEngine::PageIndexInBounds(int index) const {
   return index >= 0 && index < static_cast<int>(pages_.size());
 }
 
-float PDFiumEngine::GetToolbarHeightInScreenCoords() {
-  return client_->GetToolbarHeightInScreenCoords();
+bool PDFiumEngine::IsPageCharacterIndexInBounds(
+    const PageCharacterIndex& index) const {
+  return PageIndexInBounds(index.page_index) &&
+         pages_[index.page_index]->IsCharIndexInBounds(index.char_index);
 }
 
 FPDF_BOOL PDFiumEngine::Pause_NeedToPauseNow(IFSDK_PAUSE* param) {
@@ -3519,11 +3835,104 @@ FPDF_BOOL PDFiumEngine::Pause_NeedToPauseNow(IFSDK_PAUSE* param) {
          engine->progressive_paint_timeout_;
 }
 
-void PDFiumEngine::SetCaretPosition(const pp::Point& position) {
+void PDFiumEngine::SetSelection(const PageCharacterIndex& selection_start_index,
+                                const PageCharacterIndex& selection_end_index) {
+  SelectionChangeInvalidator selection_invalidator(this);
+  selection_.clear();
+
+  PageCharacterIndex sel_start_index = selection_start_index;
+  PageCharacterIndex sel_end_index = selection_end_index;
+  if (sel_end_index.page_index < sel_start_index.page_index) {
+    std::swap(sel_end_index.page_index, sel_start_index.page_index);
+    std::swap(sel_end_index.char_index, sel_start_index.char_index);
+  }
+
+  if (sel_end_index.page_index == sel_start_index.page_index &&
+      sel_end_index.char_index < sel_start_index.char_index) {
+    std::swap(sel_end_index.char_index, sel_start_index.char_index);
+  }
+
+  for (uint32_t i = sel_start_index.page_index; i <= sel_end_index.page_index;
+       ++i) {
+    int32_t char_count = pages_[i]->GetCharCount();
+    if (char_count <= 0)
+      continue;
+    int32_t start_char_index = 0;
+    int32_t end_char_index = char_count;
+    if (i == sel_start_index.page_index)
+      start_char_index = sel_start_index.char_index;
+    if (i == sel_end_index.page_index)
+      end_char_index = sel_end_index.char_index;
+    selection_.push_back(PDFiumRange(pages_[i].get(), start_char_index,
+                                     end_char_index - start_char_index));
+  }
+}
+
+void PDFiumEngine::ScrollFocusedAnnotationIntoView() {
+  FPDF_ANNOTATION annot;
+  int page_index;
+  if (!FORM_GetFocusedAnnot(form(), &page_index, &annot))
+    return;
+
+  ScrollAnnotationIntoView(annot, page_index);
+  FPDFPage_CloseAnnot(annot);
+}
+
+void PDFiumEngine::ScrollAnnotationIntoView(FPDF_ANNOTATION annot,
+                                            int page_index) {
+  if (!PageIndexInBounds(page_index))
+    return;
+
+  FS_RECTF annot_rect;
+  if (!FPDFAnnot_GetRect(annot, &annot_rect))
+    return;
+
+  gfx::Rect rect = pages_[page_index]->PageToScreen(
+      gfx::Point(), /*zoom=*/1.0, annot_rect.left, annot_rect.top,
+      annot_rect.right, annot_rect.bottom,
+      layout_.options().default_page_orientation());
+
+  gfx::Rect visible_rect = GetVisibleRect();
+  if (visible_rect.Contains(rect))
+    return;
+  // Since the focus rect is not already in the visible area, scrolling
+  // horizontally and/or vertically is required.
+  if (rect.y() < visible_rect.y() || rect.bottom() > visible_rect.bottom()) {
+    // Scroll the viewport vertically to align the top of focus rect to
+    // centre.
+    client_->ScrollToY(rect.y() * current_zoom_ - plugin_size_.height() / 2);
+  }
+  if (rect.x() < visible_rect.x() || rect.right() > visible_rect.right()) {
+    // Scroll the viewport horizontally to align the left of focus rect to
+    // centre.
+    client_->ScrollToX(rect.x() * current_zoom_ - plugin_size_.width() / 2);
+  }
+}
+
+void PDFiumEngine::OnFocusedAnnotationUpdated(FPDF_ANNOTATION annot,
+                                              int page_index) {
+  SetLinkUnderCursorForAnnotation(annot, page_index);
+  int form_type = FPDFAnnot_GetFormFieldType(form(), annot);
+  if (form_type <= FPDF_FORMFIELD_UNKNOWN) {
+    SetInFormTextArea(false);
+    return;
+  }
+  bool is_form_text_area =
+      PDFiumPage::FormTypeToArea(form_type) == PDFiumPage::FORM_TEXT_AREA;
+  if (is_form_text_area) {
+    SelectionChangeInvalidator selection_invalidator(this);
+    selection_.clear();
+  }
+  SetInFormTextArea(is_form_text_area);
+  editable_form_text_area_ =
+      is_form_text_area && IsAnnotationAnEditableFormTextArea(annot, form_type);
+}
+
+void PDFiumEngine::SetCaretPosition(const gfx::Point& position) {
   // TODO(dsinclair): Handle caret position ...
 }
 
-void PDFiumEngine::MoveRangeSelectionExtent(const pp::Point& extent) {
+void PDFiumEngine::MoveRangeSelectionExtent(const gfx::Point& extent) {
   int page_index = -1;
   int char_index = -1;
   int form_type = FPDF_FORMFIELD_UNKNOWN;
@@ -3551,8 +3960,8 @@ void PDFiumEngine::MoveRangeSelectionExtent(const pp::Point& extent) {
   ExtendSelection(page_index, char_index);
 }
 
-void PDFiumEngine::SetSelectionBounds(const pp::Point& base,
-                                      const pp::Point& extent) {
+void PDFiumEngine::SetSelectionBounds(const gfx::Point& base,
+                                      const gfx::Point& extent) {
   range_selection_base_ = base;
   range_selection_direction_ = IsAboveOrDirectlyLeftOf(base, extent)
                                    ? RangeSelectionDirection::Left
@@ -3588,8 +3997,252 @@ void PDFiumEngine::GetSelection(uint32_t* selection_start_page_index,
   }
 }
 
+void PDFiumEngine::LoadDocumentAttachmentInfoList() {
+  DCHECK(document_loaded_);
+
+  int attachment_count = FPDFDoc_GetAttachmentCount(doc());
+  if (attachment_count <= 0)
+    return;
+
+  doc_attachment_info_list_.resize(attachment_count);
+  for (int i = 0; i < attachment_count; ++i) {
+    FPDF_ATTACHMENT attachment = FPDFDoc_GetAttachment(doc(), i);
+
+    if (!attachment) {
+      doc_attachment_info_list_[i].is_readable = false;
+      continue;
+    }
+
+    doc_attachment_info_list_[i].name = GetAttachmentName(attachment);
+    doc_attachment_info_list_[i].creation_date =
+        GetAttachmentAttribute(attachment, "CreationDate");
+    doc_attachment_info_list_[i].modified_date =
+        GetAttachmentAttribute(attachment, "ModDate");
+
+    unsigned long actual_length_bytes;
+    doc_attachment_info_list_[i].is_readable =
+        FPDFAttachment_GetFile(attachment, /*buffer=*/nullptr,
+                               /*buflen=*/0, &actual_length_bytes);
+    if (doc_attachment_info_list_[i].is_readable)
+      doc_attachment_info_list_[i].size_bytes = actual_length_bytes;
+  }
+}
+
+void PDFiumEngine::LoadDocumentMetadata() {
+  DCHECK(document_loaded_);
+
+  doc_metadata_.version = GetDocumentVersion();
+  doc_metadata_.size_bytes = GetLoadedByteSize();
+  doc_metadata_.page_count = pages_.size();
+  doc_metadata_.linearized = IsLinearized();
+  doc_metadata_.has_attachments = !doc_attachment_info_list_.empty();
+  doc_metadata_.tagged = FPDFCatalog_IsTagged(doc());
+  doc_metadata_.form_type = static_cast<FormType>(FPDF_GetFormType(doc()));
+
+  // Document information dictionary entries
+  doc_metadata_.title = GetTrimmedMetadataByField("Title");
+  doc_metadata_.author = GetTrimmedMetadataByField("Author");
+  doc_metadata_.subject = GetTrimmedMetadataByField("Subject");
+  doc_metadata_.keywords = GetTrimmedMetadataByField("Keywords");
+  doc_metadata_.creator = GetTrimmedMetadataByField("Creator");
+  doc_metadata_.producer = GetTrimmedMetadataByField("Producer");
+  doc_metadata_.creation_date =
+      ParsePdfDate(GetTrimmedMetadataByField("CreationDate"));
+  doc_metadata_.mod_date = ParsePdfDate(GetTrimmedMetadataByField("ModDate"));
+}
+
+std::string PDFiumEngine::GetTrimmedMetadataByField(
+    FPDF_BYTESTRING field) const {
+  DCHECK(doc());
+
+  std::u16string metadata = CallPDFiumWideStringBufferApi(
+      base::BindRepeating(&FPDF_GetMetaText, doc(), field),
+      /*check_expected_size=*/false);
+
+  return base::UTF16ToUTF8(base::TrimWhitespace(metadata, base::TRIM_ALL));
+}
+
+PdfVersion PDFiumEngine::GetDocumentVersion() const {
+  DCHECK(doc());
+
+  int version;
+  if (!FPDF_GetFileVersion(doc(), &version))
+    return PdfVersion::kUnknown;
+
+  switch (version) {
+    case 10:
+      return PdfVersion::k1_0;
+    case 11:
+      return PdfVersion::k1_1;
+    case 12:
+      return PdfVersion::k1_2;
+    case 13:
+      return PdfVersion::k1_3;
+    case 14:
+      return PdfVersion::k1_4;
+    case 15:
+      return PdfVersion::k1_5;
+    case 16:
+      return PdfVersion::k1_6;
+    case 17:
+      return PdfVersion::k1_7;
+    case 18:
+      return PdfVersion::k1_8;
+    case 20:
+      return PdfVersion::k2_0;
+    default:
+      return PdfVersion::kUnknown;
+  }
+}
+
+bool PDFiumEngine::HandleTabEvent(uint32_t modifiers) {
+  bool alt_key = !!(modifiers & kInputEventModifierAltKey);
+  bool ctrl_key = !!(modifiers & kInputEventModifierControlKey);
+  if (alt_key || ctrl_key)
+    return HandleTabEventWithModifiers(modifiers);
+
+  return modifiers & kInputEventModifierShiftKey ? HandleTabBackward(modifiers)
+                                                 : HandleTabForward(modifiers);
+}
+
+bool PDFiumEngine::HandleTabEventWithModifiers(uint32_t modifiers) {
+  // Only handle cases when a page is focused, else return false.
+  switch (focus_item_type_) {
+    case FocusElementType::kNone:
+    case FocusElementType::kDocument:
+      return false;
+    case FocusElementType::kPage:
+      if (last_focused_page_ == -1)
+        return false;
+      return !!FORM_OnKeyDown(form(), pages_[last_focused_page_]->GetPage(),
+                              FWL_VKEY_Tab, modifiers);
+    default:
+      NOTREACHED();
+      return false;
+  }
+}
+
+bool PDFiumEngine::HandleTabForward(uint32_t modifiers) {
+  if (focus_item_type_ == FocusElementType::kNone) {
+    UpdateFocusItemType(FocusElementType::kDocument);
+    return true;
+  }
+
+  int page_index = last_focused_page_;
+  if (page_index == -1)
+    page_index = 0;
+
+  bool did_tab_forward = false;
+  while (!did_tab_forward && PageIndexInBounds(page_index)) {
+    did_tab_forward = !!FORM_OnKeyDown(form(), pages_[page_index]->GetPage(),
+                                       FWL_VKEY_Tab, modifiers);
+    if (!did_tab_forward)
+      ++page_index;
+  }
+
+  if (did_tab_forward) {
+    last_focused_page_ = page_index;
+    UpdateFocusItemType(FocusElementType::kPage);
+  } else {
+    last_focused_page_ = -1;
+    UpdateFocusItemType(FocusElementType::kNone);
+  }
+  return did_tab_forward;
+}
+
+bool PDFiumEngine::HandleTabBackward(uint32_t modifiers) {
+  if (focus_item_type_ == FocusElementType::kDocument) {
+    UpdateFocusItemType(FocusElementType::kNone);
+    return false;
+  }
+
+  int page_index = last_focused_page_;
+  if (page_index == -1)
+    page_index = GetNumberOfPages() - 1;
+
+  bool did_tab_backward = false;
+  while (!did_tab_backward && PageIndexInBounds(page_index)) {
+    did_tab_backward = !!FORM_OnKeyDown(form(), pages_[page_index]->GetPage(),
+                                        FWL_VKEY_Tab, modifiers);
+    if (!did_tab_backward)
+      --page_index;
+  }
+
+  if (did_tab_backward) {
+    last_focused_page_ = page_index;
+    UpdateFocusItemType(FocusElementType::kPage);
+  } else {
+    // No focusable annotation found in pages. Possible scenarios:
+    // Case 1: |focus_item_type_| is None. Since no object in any page can take
+    // the focus, the document should take focus.
+    // Case 2: |focus_item_type_| is Page. Since there aren't any objects that
+    // could take focus, the document should take focus.
+    // Case 3: |focus_item_type_| is Document. Move focus_item_type_ to None.
+    switch (focus_item_type_) {
+      case FocusElementType::kPage:
+      case FocusElementType::kNone:
+        did_tab_backward = true;
+        last_focused_page_ = -1;
+        UpdateFocusItemType(FocusElementType::kDocument);
+        KillFormFocus();
+        break;
+      case FocusElementType::kDocument:
+        UpdateFocusItemType(FocusElementType::kNone);
+        break;
+      default:
+        NOTREACHED();
+        break;
+    }
+  }
+  return did_tab_backward;
+}
+
+void PDFiumEngine::UpdateFocusItemType(FocusElementType focus_item_type) {
+  if (focus_item_type_ == focus_item_type)
+    return;
+  if (focus_item_type_ == FocusElementType::kDocument)
+    client_->DocumentFocusChanged(false);
+  focus_item_type_ = focus_item_type;
+  if (focus_item_type_ == FocusElementType::kDocument)
+    client_->DocumentFocusChanged(true);
+}
+
+#if defined(PDF_ENABLE_XFA)
+void PDFiumEngine::UpdatePageCount() {
+  InvalidateAllPages();
+}
+#endif  // defined(PDF_ENABLE_XFA)
+
+void PDFiumEngine::UpdateLinkUnderCursor(const std::string& target_url) {
+  if (link_under_cursor_ == target_url)
+    return;
+
+  link_under_cursor_ = target_url;
+  client_->SetLinkUnderCursor(link_under_cursor_);
+}
+
+void PDFiumEngine::SetLinkUnderCursorForAnnotation(FPDF_ANNOTATION annot,
+                                                   int page_index) {
+  if (!PageIndexInBounds(page_index)) {
+    UpdateLinkUnderCursor("");
+    return;
+  }
+
+  PDFiumPage::LinkTarget target;
+  pages_[page_index]->GetLinkTarget(FPDFAnnot_GetLink(annot), &target);
+  UpdateLinkUnderCursor(target.url);
+}
+
+void PDFiumEngine::RequestThumbnail(int page_index,
+                                    float device_pixel_ratio,
+                                    SendThumbnailCallback send_callback) {
+  DCHECK(PageIndexInBounds(page_index));
+  pages_[page_index]->RequestThumbnail(device_pixel_ratio,
+                                       std::move(send_callback));
+}
+
 PDFiumEngine::ProgressivePaint::ProgressivePaint(int index,
-                                                 const pp::Rect& rect)
+                                                 const gfx::Rect& rect)
     : page_index_(index), rect_(rect) {}
 
 PDFiumEngine::ProgressivePaint::ProgressivePaint(ProgressivePaint&& that) =
@@ -3602,18 +4255,9 @@ PDFiumEngine::ProgressivePaint& PDFiumEngine::ProgressivePaint::operator=(
 
 void PDFiumEngine::ProgressivePaint::SetBitmapAndImageData(
     ScopedFPDFBitmap bitmap,
-    pp::ImageData image_data) {
+    SkBitmap image_data) {
   bitmap_ = std::move(bitmap);
   image_data_ = std::move(image_data);
 }
 
-ScopedSubstFont::ScopedSubstFont(PDFiumEngine* engine)
-    : old_engine_(g_engine_for_fontmapper) {
-  g_engine_for_fontmapper = engine;
-}
-
-ScopedSubstFont::~ScopedSubstFont() {
-  g_engine_for_fontmapper = old_engine_;
-}
-
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_engine.h b/pdf/pdfium/pdfium_engine.h
index 5e0c878be58e..f72980d7d81f 100644
--- a/pdf/pdfium/pdfium_engine.h
+++ b/pdf/pdfium/pdfium_engine.h
@@ -13,59 +13,84 @@
 #include <string>
 #include <vector>
 
-#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
 #include "base/optional.h"
 #include "base/time/time.h"
 #include "base/timer/timer.h"
+#include "base/values.h"
+#include "pdf/document_attachment_info.h"
+#include "pdf/document_layout.h"
 #include "pdf/document_loader.h"
+#include "pdf/document_metadata.h"
 #include "pdf/pdf_engine.h"
 #include "pdf/pdfium/pdfium_form_filler.h"
 #include "pdf/pdfium/pdfium_page.h"
 #include "pdf/pdfium/pdfium_print.h"
 #include "pdf/pdfium/pdfium_range.h"
-#include "ppapi/cpp/completion_callback.h"
+#include "ppapi/c/private/ppp_pdf.h"
 #include "ppapi/cpp/dev/buffer_dev.h"
-#include "ppapi/cpp/image_data.h"
-#include "ppapi/cpp/input_event.h"
-#include "ppapi/cpp/point.h"
-#include "ppapi/cpp/var_array.h"
-#include "ppapi/utility/completion_callback_factory.h"
 #include "third_party/pdfium/public/cpp/fpdf_scopers.h"
 #include "third_party/pdfium/public/fpdf_formfill.h"
 #include "third_party/pdfium/public/fpdf_progressive.h"
 #include "third_party/pdfium/public/fpdfview.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/geometry/vector2d.h"
 
 namespace chrome_pdf {
 
+enum class AccessibilityScrollAlignment;
+class KeyboardInputEvent;
+class MouseInputEvent;
 class PDFiumDocument;
+class PDFiumPermissions;
+class TouchInputEvent;
+struct AccessibilityActionData;
+struct AccessibilityTextRunInfo;
+struct PageCharacterIndex;
+
+namespace draw_utils {
 class ShadowMatrix;
+struct PageInsetSizes;
+}  // namespace draw_utils
 
 class PDFiumEngine : public PDFEngine,
                      public DocumentLoader::Client,
                      public IFSDK_PAUSE {
  public:
-  PDFiumEngine(PDFEngine::Client* client, bool enable_javascript);
+  // State transition when tabbing forward:
+  // None -> Document -> Page -> None (when focusable annotations on all pages
+  // are done).
+  // Exposed for testing.
+  enum class FocusElementType { kNone, kDocument, kPage };
+
+  // NOTE: |script_option| is ignored when PDF_ENABLE_V8 is not defined.
+  PDFiumEngine(PDFEngine::Client* client,
+               PDFiumFormFiller::ScriptOption script_option);
+  PDFiumEngine(const PDFiumEngine&) = delete;
+  PDFiumEngine& operator=(const PDFiumEngine&) = delete;
   ~PDFiumEngine() override;
 
-  using CreateDocumentLoaderFunction =
-      std::unique_ptr<DocumentLoader> (*)(DocumentLoader::Client* client);
-  static void SetCreateDocumentLoaderFunctionForTesting(
-      CreateDocumentLoaderFunction function);
+  // Replaces the normal DocumentLoader for testing. Must be called before
+  // HandleDocumentLoad().
+  void SetDocumentLoaderForTesting(std::unique_ptr<DocumentLoader> loader);
 
-  // PDFEngine implementation.
+  // PDFEngine:
   bool New(const char* url, const char* headers) override;
-  void PageOffsetUpdated(const pp::Point& page_offset) override;
-  void PluginSizeUpdated(const pp::Size& size) override;
+  void PageOffsetUpdated(const gfx::Vector2d& page_offset) override;
+  void PluginSizeUpdated(const gfx::Size& size) override;
   void ScrolledToXPosition(int position) override;
   void ScrolledToYPosition(int position) override;
   void PrePaint() override;
-  void Paint(const pp::Rect& rect,
-             pp::ImageData* image_data,
-             std::vector<pp::Rect>* ready,
-             std::vector<pp::Rect>* pending) override;
+  void Paint(const gfx::Rect& rect,
+             SkBitmap& image_data,
+             std::vector<gfx::Rect>& ready,
+             std::vector<gfx::Rect>& pending) override;
   void PostPaint() override;
-  bool HandleDocumentLoad(const pp::URLLoader& loader) override;
-  bool HandleEvent(const pp::InputEvent& event) override;
+  bool HandleDocumentLoad(std::unique_ptr<UrlLoader> loader) override;
+  bool HandleEvent(const InputEvent& event) override;
   uint32_t QuerySupportedPrintOutputFormats() override;
   void PrintBegin() override;
   pp::Resource PrintPages(
@@ -80,6 +105,12 @@ class PDFiumEngine : public PDFEngine,
   void ZoomUpdated(double new_zoom_level) override;
   void RotateClockwise() override;
   void RotateCounterclockwise() override;
+  bool IsReadOnly() const override;
+  void SetReadOnly(bool enable) override;
+  void SetTwoUpView(bool enable) override;
+  void DisplayAnnotations(bool display) override;
+  gfx::Size ApplyDocumentLayout(
+      const DocumentLayout::Options& options) override;
   std::string GetSelectedText() override;
   bool CanEditText() override;
   bool HasEditableText() override;
@@ -88,63 +119,87 @@ class PDFiumEngine : public PDFEngine,
   bool CanRedo() override;
   void Undo() override;
   void Redo() override;
-  std::string GetLinkAtPosition(const pp::Point& point) override;
+  void HandleAccessibilityAction(
+      const AccessibilityActionData& action_data) override;
+  std::string GetLinkAtPosition(const gfx::Point& point) override;
   bool HasPermission(DocumentPermission permission) const override;
   void SelectAll() override;
-  int GetNumberOfPages() override;
-  pp::VarArray GetBookmarks() override;
+  const std::vector<DocumentAttachmentInfo>& GetDocumentAttachmentInfoList()
+      const override;
+  std::vector<uint8_t> GetAttachmentData(size_t index) override;
+  const DocumentMetadata& GetDocumentMetadata() const override;
+  int GetNumberOfPages() const override;
+  base::Value GetBookmarks() override;
   base::Optional<PDFEngine::NamedDestination> GetNamedDestination(
       const std::string& destination) override;
-  gfx::PointF TransformPagePoint(int page_index,
-                                 const gfx::PointF& page_xy) override;
   int GetMostVisiblePage() override;
-  pp::Rect GetPageRect(int index) override;
-  pp::Rect GetPageBoundsRect(int index) override;
-  pp::Rect GetPageContentsRect(int index) override;
-  pp::Rect GetPageScreenRect(int page_index) const override;
+  gfx::Rect GetPageBoundsRect(int index) override;
+  gfx::Rect GetPageContentsRect(int index) override;
+  gfx::Rect GetPageScreenRect(int page_index) const override;
   int GetVerticalScrollbarYPosition() override;
   void SetGrayscale(bool grayscale) override;
   int GetCharCount(int page_index) override;
-  pp::FloatRect GetCharBounds(int page_index, int char_index) override;
+  gfx::RectF GetCharBounds(int page_index, int char_index) override;
   uint32_t GetCharUnicode(int page_index, int char_index) override;
-  void GetTextRunInfo(int page_index,
-                      int start_char_index,
-                      uint32_t* out_len,
-                      double* out_font_size,
-                      pp::FloatRect* out_bounds) override;
+  base::Optional<AccessibilityTextRunInfo> GetTextRunInfo(
+      int page_index,
+      int start_char_index) override;
+  std::vector<AccessibilityLinkInfo> GetLinkInfo(
+      int page_index,
+      const std::vector<AccessibilityTextRunInfo>& text_runs) override;
+  std::vector<AccessibilityImageInfo> GetImageInfo(
+      int page_index,
+      uint32_t text_run_count) override;
+  std::vector<AccessibilityHighlightInfo> GetHighlightInfo(
+      int page_index,
+      const std::vector<AccessibilityTextRunInfo>& text_runs) override;
+  std::vector<AccessibilityTextFieldInfo> GetTextFieldInfo(
+      int page_index,
+      uint32_t text_run_count) override;
   bool GetPrintScaling() override;
   int GetCopiesToPrint() override;
   int GetDuplexType() override;
-  bool GetPageSizeAndUniformity(pp::Size* size) override;
-  void AppendBlankPages(int num_pages) override;
+  base::Optional<gfx::Size> GetUniformPageSizePoints() override;
+  void AppendBlankPages(size_t num_pages) override;
   void AppendPage(PDFEngine* engine, int index) override;
-  std::string GetMetadata(const std::string& key) override;
-  void SetCaretPosition(const pp::Point& position) override;
-  void MoveRangeSelectionExtent(const pp::Point& extent) override;
-  void SetSelectionBounds(const pp::Point& base,
-                          const pp::Point& extent) override;
+  std::vector<uint8_t> GetSaveData() override;
+  void SetCaretPosition(const gfx::Point& position) override;
+  void MoveRangeSelectionExtent(const gfx::Point& extent) override;
+  void SetSelectionBounds(const gfx::Point& base,
+                          const gfx::Point& extent) override;
   void GetSelection(uint32_t* selection_start_page_index,
                     uint32_t* selection_start_char_index,
                     uint32_t* selection_end_page_index,
                     uint32_t* selection_end_char_index) override;
+  void KillFormFocus() override;
+  void UpdateFocus(bool has_focus) override;
+  PP_PrivateAccessibilityFocusInfo GetFocusInfo() override;
+  uint32_t GetLoadedByteSize() override;
+  bool ReadLoadedBytes(uint32_t length, void* buffer) override;
+  void RequestThumbnail(int page_index,
+                        float device_pixel_ratio,
+                        SendThumbnailCallback send_callback) override;
 
-  // DocumentLoader::Client implementation.
+  // DocumentLoader::Client:
   pp::Instance* GetPluginInstance() override;
   std::unique_ptr<URLLoaderWrapper> CreateURLLoader() override;
   void OnPendingRequestComplete() override;
   void OnNewDataReceived() override;
   void OnDocumentComplete() override;
   void OnDocumentCanceled() override;
-  void CancelBrowserDownload() override;
-  void KillFormFocus() override;
+
+#if defined(PDF_ENABLE_XFA)
+  void UpdatePageCount();
+#endif  // defined(PDF_ENABLE_XFA)
 
   void UnsupportedFeature(const std::string& feature);
-  void FontSubstituted();
 
   FPDF_AVAIL fpdf_availability() const;
   FPDF_DOCUMENT doc() const;
   FPDF_FORMHANDLE form() const;
 
+  bool IsValidLink(const std::string& url);
+
  private:
   // This helper class is used to detect the difference in selection between
   // construction and destruction.  At destruction, it invalidates all the
@@ -158,17 +213,17 @@ class PDFiumEngine : public PDFEngine,
    private:
     // Returns all the currently visible selection rectangles, in screen
     // coordinates.
-    std::vector<pp::Rect> GetVisibleSelections() const;
+    std::vector<gfx::Rect> GetVisibleSelections() const;
 
     // Invalidates |selection|, but with |selection| slightly expanded to
     // compensate for any rounding errors.
-    void Invalidate(const pp::Rect& selection);
+    void Invalidate(const gfx::Rect& selection);
 
     PDFiumEngine* const engine_;
     // The origin at the time this object was constructed.
-    const pp::Point previous_origin_;
+    const gfx::Point previous_origin_;
     // Screen rectangles that were selected on construction.
-    std::vector<pp::Rect> old_selections_;
+    std::vector<gfx::Rect> old_selections_;
   };
 
   // Used to store mouse down state to handle it in other mouse event handlers.
@@ -176,6 +231,8 @@ class PDFiumEngine : public PDFEngine,
    public:
     MouseDownState(const PDFiumPage::Area& area,
                    const PDFiumPage::LinkTarget& target);
+    MouseDownState(const MouseDownState&) = delete;
+    MouseDownState& operator=(const MouseDownState&) = delete;
     ~MouseDownState();
 
     void Set(const PDFiumPage::Area& area,
@@ -187,11 +244,12 @@ class PDFiumEngine : public PDFEngine,
    private:
     PDFiumPage::Area area_;
     PDFiumPage::LinkTarget target_;
-
-    DISALLOW_COPY_AND_ASSIGN(MouseDownState);
   };
 
+  friend class FormFillerTest;
+  friend class PDFiumEngineTabbingTest;
   friend class PDFiumFormFiller;
+  friend class PDFiumTestBase;
   friend class SelectionChangeInvalidator;
 
   // We finished getting the pdf file, so load it. This will complete
@@ -209,7 +267,7 @@ class PDFiumEngine : public PDFEngine,
   void GetPasswordAndLoad();
 
   // Called when the password has been retrieved.
-  void OnGetPasswordComplete(int32_t result, const pp::Var& password);
+  void OnGetPasswordComplete(const std::string& password);
 
   // Continues loading the document when the password has been retrieved, or if
   // there is no password. If there is no password, then |password| is empty.
@@ -223,9 +281,29 @@ class PDFiumEngine : public PDFEngine,
   // If this has been run once, it will not notify the client again.
   void FinishLoadingDocument();
 
-  // Loads information about the pages in the document and calculate the
-  // document size.
-  void LoadPageInfo(bool reload);
+  // Loads information about the pages in the document and performs layout.
+  void LoadPageInfo();
+
+  // Refreshes the document layout using the current pages and layout options.
+  void RefreshCurrentDocumentLayout();
+
+  // Proposes the next document layout using the current pages and
+  // |desired_layout_options_|.
+  void ProposeNextDocumentLayout();
+
+  // Updates |layout| using the current page sizes.
+  void UpdateDocumentLayout(DocumentLayout* layout);
+
+  // Loads information about the pages in the document, calculating and
+  // returning the individual page sizes.
+  //
+  // Note that the page rects of any new pages will be left uninitialized, so
+  // layout must be performed immediately after calling this method.
+  //
+  // TODO(kmoon): LoadPageSizes() is a bit misnomer, but LoadPageInfo() is
+  // taken right now...
+  std::vector<gfx::Size> LoadPageSizes(
+      const DocumentLayout::Options& layout_options);
 
   void LoadBody();
 
@@ -233,6 +311,9 @@ class PDFiumEngine : public PDFEngine,
 
   void LoadForm();
 
+  // Checks whether the document is optimized by linearization.
+  bool IsLinearized();
+
   // Calculates which pages should be displayed right now.
   void CalculateVisiblePages();
 
@@ -252,11 +333,45 @@ class PDFiumEngine : public PDFEngine,
 
   // Helper function to get a given page's size in pixels.  This is not part of
   // PDFiumPage because we might not have that structure when we need this.
-  pp::Size GetPageSize(int index);
+  gfx::Size GetPageSize(int index);
+  gfx::Size GetPageSizeForLayout(int index,
+                                 const DocumentLayout::Options& layout_options);
 
-  void GetAllScreenRectsUnion(std::vector<PDFiumRange>* rect_range,
-                              const pp::Point& offset_point,
-                              std::vector<pp::Rect>* rect_vector);
+  // Helper function for getting the inset sizes for the current layout. If
+  // two-up view is enabled, the configuration of inset sizes depends on
+  // the position of the page, specified by |page_index| and |num_of_pages|.
+  draw_utils::PageInsetSizes GetInsetSizes(
+      const DocumentLayout::Options& layout_options,
+      size_t page_index,
+      size_t num_of_pages) const;
+
+  // If two-up view is disabled, enlarges |page_size| with inset sizes for
+  // single-view. If two-up view is enabled, calls GetInsetSizes() with
+  // |page_index| and |num_of_pages|, and uses the returned inset sizes to
+  // enlarge |page_size|.
+  void EnlargePage(const DocumentLayout::Options& layout_options,
+                   size_t page_index,
+                   size_t num_of_pages,
+                   gfx::Size* page_size) const;
+
+  // Similar to EnlargePage(), but insets a |rect|. Also multiplies the inset
+  // sizes by |multiplier|, using the ceiling of the result.
+  void InsetPage(const DocumentLayout::Options& layout_options,
+                 size_t page_index,
+                 size_t num_of_pages,
+                 double multiplier,
+                 gfx::Rect& rect) const;
+
+  // If two-up view is enabled, returns the index of the page beside
+  // |page_index| page. Returns base::nullopt if there is no adjacent page or
+  // if two-up view is disabled.
+  base::Optional<size_t> GetAdjacentPageIndexForTwoUpView(
+      size_t page_index,
+      size_t num_of_pages) const;
+
+  std::vector<gfx::Rect> GetAllScreenRectsUnion(
+      const std::vector<PDFiumRange>& rect_range,
+      const gfx::Point& point) const;
 
   void UpdateTickMarks();
 
@@ -268,27 +383,27 @@ class PDFiumEngine : public PDFEngine,
 
   // Search a page using PDFium's methods.  Doesn't work with unicode.  This
   // function is just kept arount in case PDFium code is fixed.
-  void SearchUsingPDFium(const base::string16& term,
+  void SearchUsingPDFium(const std::u16string& term,
                          bool case_sensitive,
                          bool first_search,
                          int character_to_start_searching_from,
                          int current_page);
 
   // Search a page ourself using ICU.
-  void SearchUsingICU(const base::string16& term,
+  void SearchUsingICU(const std::u16string& term,
                       bool case_sensitive,
                       bool first_search,
                       int character_to_start_searching_from,
                       int current_page);
 
   // Input event handlers.
-  bool OnMouseDown(const pp::MouseInputEvent& event);
-  bool OnMouseUp(const pp::MouseInputEvent& event);
-  bool OnMouseMove(const pp::MouseInputEvent& event);
-  void OnMouseEnter(const pp::MouseInputEvent& event);
-  bool OnKeyDown(const pp::KeyboardInputEvent& event);
-  bool OnKeyUp(const pp::KeyboardInputEvent& event);
-  bool OnChar(const pp::KeyboardInputEvent& event);
+  bool OnMouseDown(const MouseInputEvent& event);
+  bool OnMouseUp(const MouseInputEvent& event);
+  bool OnMouseMove(const MouseInputEvent& event);
+  void OnMouseEnter(const MouseInputEvent& event);
+  bool OnKeyDown(const KeyboardInputEvent& event);
+  bool OnKeyUp(const KeyboardInputEvent& event);
+  bool OnChar(const KeyboardInputEvent& event);
 
   // Decide what cursor should be displayed.
   PP_CursorType_Dev DetermineCursorType(PDFiumPage::Area area,
@@ -296,25 +411,27 @@ class PDFiumEngine : public PDFEngine,
 
   bool ExtendSelection(int page_index, int char_index);
 
-  pp::Buffer_Dev PrintPagesAsRasterPDF(
+  pp::Buffer_Dev PrintPagesAsRasterPdf(
       const PP_PrintPageNumberRange_Dev* page_ranges,
       uint32_t page_range_count,
       const PP_PrintSettings_Dev& print_settings,
       const PP_PdfPrintSettings_Dev& pdf_print_settings);
 
-  pp::Buffer_Dev PrintPagesAsPDF(
+  pp::Buffer_Dev PrintPagesAsPdf(
       const PP_PrintPageNumberRange_Dev* page_ranges,
       uint32_t page_range_count,
       const PP_PrintSettings_Dev& print_settings,
       const PP_PdfPrintSettings_Dev& pdf_print_settings);
 
+  pp::Buffer_Dev ConvertPdfToBufferDev(const std::vector<uint8_t>& pdf_data);
+
   // Checks if |page| has selected text in a form element. If so, sets that as
   // the plugin's text selection.
   void SetFormSelectedText(FPDF_FORMHANDLE form_handle, FPDF_PAGE page);
 
   // Given |point|, returns which page and character location it's closest to,
   // as well as extra information about objects at that point.
-  PDFiumPage::Area GetCharIndex(const pp::Point& point,
+  PDFiumPage::Area GetCharIndex(const gfx::Point& point,
                                 int* page_index,
                                 int* char_index,
                                 int* form_type,
@@ -322,21 +439,21 @@ class PDFiumEngine : public PDFEngine,
 
   void OnSingleClick(int page_index, int char_index);
   void OnMultipleClick(int click_count, int page_index, int char_index);
-  bool OnLeftMouseDown(const pp::MouseInputEvent& event);
-  bool OnMiddleMouseDown(const pp::MouseInputEvent& event);
-  bool OnRightMouseDown(const pp::MouseInputEvent& event);
+  bool OnLeftMouseDown(const MouseInputEvent& event);
+  bool OnMiddleMouseDown(const MouseInputEvent& event);
+  bool OnRightMouseDown(const MouseInputEvent& event);
 
   // Starts a progressive paint operation given a rectangle in screen
   // coordinates. Returns the index in progressive_rects_.
-  int StartPaint(int page_index, const pp::Rect& dirty);
+  int StartPaint(int page_index, const gfx::Rect& dirty);
 
   // Continues a paint operation that was started earlier.  Returns true if the
   // paint is done, or false if it needs to be continued.
-  bool ContinuePaint(int progressive_index, pp::ImageData* image_data);
+  bool ContinuePaint(int progressive_index, SkBitmap& image_data);
 
   // Called once PDFium is finished rendering a page so that we draw our
   // borders, highlighting etc.
-  void FinishPaint(int progressive_index, pp::ImageData* image_data);
+  void FinishPaint(int progressive_index, SkBitmap& image_data);
 
   // Stops any paints that are in progress.
   void CancelPaints();
@@ -349,28 +466,28 @@ class PDFiumEngine : public PDFEngine,
   // with the page background.
   void FillPageSides(int progressive_index);
 
-  void PaintPageShadow(int progressive_index, pp::ImageData* image_data);
+  void PaintPageShadow(int progressive_index, SkBitmap& image_data);
 
   // Highlight visible find results and selections.
-  void DrawSelections(int progressive_index, pp::ImageData* image_data);
+  void DrawSelections(int progressive_index, SkBitmap& image_data) const;
 
   // Paints an page that hasn't finished downloading.
   void PaintUnavailablePage(int page_index,
-                            const pp::Rect& dirty,
-                            pp::ImageData* image_data);
+                            const gfx::Rect& dirty,
+                            SkBitmap& image_data);
 
   // Given a page index, returns the corresponding index in progressive_rects_,
   // or -1 if it doesn't exist.
   int GetProgressiveIndex(int page_index) const;
 
   // Creates a FPDF_BITMAP from a rectangle in screen coordinates.
-  ScopedFPDFBitmap CreateBitmap(const pp::Rect& rect,
-                                pp::ImageData* image_data) const;
+  ScopedFPDFBitmap CreateBitmap(const gfx::Rect& rect,
+                                SkBitmap& image_data) const;
 
   // Given a rectangle in screen coordinates, returns the coordinates in the
   // units that PDFium rendering functions expect.
   void GetPDFiumRect(int page_index,
-                     const pp::Rect& rect,
+                     const gfx::Rect& rect,
                      int* start_x,
                      int* start_y,
                      int* size_x,
@@ -380,25 +497,27 @@ class PDFiumEngine : public PDFEngine,
   int GetRenderingFlags() const;
 
   // Returns the currently visible rectangle in document coordinates.
-  pp::Rect GetVisibleRect() const;
+  gfx::Rect GetVisibleRect() const;
 
-  // Given a rectangle in document coordinates, returns the rectange into screen
-  // coordinates (i.e. 0,0 is top left corner of plugin area).  If it's not
-  // visible, an empty rectangle is returned.
-  pp::Rect GetScreenRect(const pp::Rect& rect) const;
+  // Given |rect| in document coordinates, returns the rectangle in screen
+  // coordinates. (i.e. 0,0 is top left corner of plugin area)
+  gfx::Rect GetScreenRect(const gfx::Rect& rect) const;
 
   // Given an image |buffer| with |stride|, highlights |rect|.
   // |highlighted_rects| contains the already highlighted rectangles and will be
   // updated to include |rect| if |rect| has not already been highlighted.
   void Highlight(void* buffer,
                  int stride,
-                 const pp::Rect& rect,
-                 std::vector<pp::Rect>* highlighted_rects);
+                 const gfx::Rect& rect,
+                 int color_red,
+                 int color_green,
+                 int color_blue,
+                 std::vector<gfx::Rect>& highlighted_rects) const;
 
   // Helper function to convert a device to page coordinates.  If the page is
   // not yet loaded, |page_x| and |page_y| will be set to 0.
   void DeviceToPage(int page_index,
-                    const pp::Point& device_point,
+                    const gfx::Point& device_point,
                     double* page_x,
                     double* page_y);
 
@@ -410,23 +529,20 @@ class PDFiumEngine : public PDFEngine,
   // triggers as necessary.
   void SetCurrentPage(int index);
 
-  void DrawPageShadow(const pp::Rect& page_rect,
-                      const pp::Rect& shadow_rect,
-                      const pp::Rect& clip_rect,
-                      pp::ImageData* image_data);
+  void DrawPageShadow(const gfx::Rect& page_rect,
+                      const gfx::Rect& shadow_rect,
+                      const gfx::Rect& clip_rect,
+                      SkBitmap& image_data);
 
-  void GetRegion(const pp::Point& location,
-                 pp::ImageData* image_data,
-                 void** region,
-                 int* stride) const;
+  void GetRegion(const gfx::Point& location,
+                 SkBitmap& image_data,
+                 void*& region,
+                 int& stride) const;
 
   // Called when the selection changes.
   void OnSelectionTextChanged();
   void OnSelectionPositionChanged();
 
-  // Common code shared by RotateClockwise() and RotateCounterclockwise().
-  void RotateInternal();
-
   // Sets text selection status of document. This does not include text
   // within form text fields.
   void SetSelecting(bool selecting);
@@ -438,53 +554,110 @@ class PDFiumEngine : public PDFEngine,
   // Sets whether or not left mouse button is currently being held down.
   void SetMouseLeftButtonDown(bool is_mouse_left_button_down);
 
-  // Given coordinates on |page| has a form of |form_type| which is known to be
-  // a form text area, check if it is an editable form text area.
-  bool IsPointInEditableFormTextArea(FPDF_PAGE page,
-                                     double page_x,
-                                     double page_y,
-                                     int form_type);
+  // Given an annotation which is a form of |form_type| which is known to be a
+  // form text area, check if it is an editable form text area.
+  bool IsAnnotationAnEditableFormTextArea(FPDF_ANNOTATION annot,
+                                          int form_type) const;
 
   bool PageIndexInBounds(int index) const;
+  bool IsPageCharacterIndexInBounds(const PageCharacterIndex& index) const;
 
-  // Gets the height of the top toolbar in screen coordinates. This is
-  // independent of whether it is hidden or not at the moment.
-  float GetToolbarHeightInScreenCoords();
-
-  void ScheduleTouchTimer(const pp::TouchInputEvent& event);
+  void ScheduleTouchTimer(const TouchInputEvent& event);
   void KillTouchTimer();
-  void HandleLongPress(const pp::TouchInputEvent& event);
+  void HandleLongPress(const TouchInputEvent& event);
 
-  // Returns a VarDictionary (representing a bookmark), which in turn contains
-  // child VarDictionaries (representing the child bookmarks).
+  // Returns a base::Value (representing a bookmark), which in turn contains
+  // child base::Value dictionaries (representing the child bookmarks).
   // If nullptr is passed in as the bookmark then we traverse from the "root".
   // Note that the "root" bookmark contains no useful information.
-  pp::VarDictionary TraverseBookmarks(FPDF_BOOKMARK bookmark,
-                                      unsigned int depth);
+  base::Value TraverseBookmarks(FPDF_BOOKMARK bookmark, unsigned int depth);
+
+  void ScrollBasedOnScrollAlignment(
+      const gfx::Rect& scroll_rect,
+      const AccessibilityScrollAlignment& horizontal_scroll_alignment,
+      const AccessibilityScrollAlignment& vertical_scroll_alignment);
+
+  // Scrolls top left of a rect in page |target_rect| to |global_point|.
+  // Global point is point relative to viewport in screen.
+  void ScrollToGlobalPoint(const gfx::Rect& target_rect,
+                           const gfx::Point& global_point);
 
   // Set if the document has any local edits.
-  void SetEditMode(bool edit_mode);
+  void EnteredEditMode();
+
+  // Navigates to a link destination depending on the type of destination.
+  // Returns false if |area| is not a link.
+  bool NavigateToLinkDestination(PDFiumPage::Area area,
+                                 const PDFiumPage::LinkTarget& target,
+                                 WindowOpenDisposition disposition);
 
   // IFSDK_PAUSE callbacks
   static FPDF_BOOL Pause_NeedToPauseNow(IFSDK_PAUSE* param);
 
+  // Used for text selection. Given the start and end of selection, sets the
+  // text range in |selection_|.
+  void SetSelection(const PageCharacterIndex& selection_start_index,
+                    const PageCharacterIndex& selection_end_index);
+
+  // Scroll the current focused annotation into view if not already in view.
+  void ScrollFocusedAnnotationIntoView();
+
+  // Given |annot|, scroll the |annot| into view if not already in view.
+  void ScrollAnnotationIntoView(FPDF_ANNOTATION annot, int page_index);
+
+  void OnFocusedAnnotationUpdated(FPDF_ANNOTATION annot, int page_index);
+
+  // Read the attachments' information inside the PDF document, and set
+  // |doc_attachment_info_list_|. To be called after the document is loaded.
+  void LoadDocumentAttachmentInfoList();
+
+  // Fetches and populates the fields of |doc_metadata_|. To be called after the
+  // document is loaded.
+  void LoadDocumentMetadata();
+
+  // Retrieves the value of |field| in the document information dictionary.
+  // Trims whitespace characters from the retrieved value.
+  std::string GetTrimmedMetadataByField(FPDF_BYTESTRING field) const;
+
+  // Retrieves the version of the PDF (e.g. 1.4 or 2.0) as an enum.
+  PdfVersion GetDocumentVersion() const;
+
+  // This is a layer between OnKeyDown() and actual tab handling to facilitate
+  // testing.
+  bool HandleTabEvent(uint32_t modifiers);
+
+  // Helper functions to handle tab events.
+  bool HandleTabEventWithModifiers(uint32_t modifiers);
+  bool HandleTabForward(uint32_t modifiers);
+  bool HandleTabBackward(uint32_t modifiers);
+
+  // Updates the currently focused object stored in |focus_item_type_|. Notifies
+  // |client_| about document focus change, if any.
+  void UpdateFocusItemType(FocusElementType focus_item_type);
+
+  void UpdateLinkUnderCursor(const std::string& target_url);
+  void SetLinkUnderCursorForAnnotation(FPDF_ANNOTATION annot, int page_index);
+
   PDFEngine::Client* const client_;
-  pp::Size document_size_;  // Size of document in pixels.
+
+  // The current document layout.
+  DocumentLayout layout_;
+
+  // The options for the desired document layout.
+  DocumentLayout::Options desired_layout_options_;
 
   // The scroll position in screen coordinates.
-  pp::Point position_;
+  gfx::Point position_;
   // The offset of the page into the viewport.
-  pp::Point page_offset_;
+  gfx::Vector2d page_offset_;
   // The plugin size in screen coordinates.
-  pp::Size plugin_size_;
+  gfx::Size plugin_size_;
   double current_zoom_ = 1.0;
-  unsigned int current_rotation_ = 0;
 
   std::unique_ptr<DocumentLoader> doc_loader_;  // Main document's loader.
+  bool doc_loader_set_for_testing_ = false;
   std::string url_;
   std::string headers_;
-  pp::CompletionCallbackFactory<PDFiumEngine> find_factory_;
-  pp::CompletionCallbackFactory<PDFiumEngine> password_factory_;
 
   // Set to true if the user is being prompted for their password. Will be set
   // to false after the user finishes getting their password.
@@ -496,6 +669,7 @@ class PDFiumEngine : public PDFEngine,
   PDFiumFormFiller form_filler_;
 
   std::unique_ptr<PDFiumDocument> document_;
+  bool document_loaded_ = false;
 
   // The page(s) of the document.
   std::vector<std::unique_ptr<PDFiumPage>> pages_;
@@ -538,7 +712,7 @@ class PDFiumEngine : public PDFEngine,
   bool mouse_middle_button_down_ = false;
 
   // Last known position while performing middle mouse button pan.
-  pp::Point mouse_middle_button_last_position_;
+  gfx::Point mouse_middle_button_last_position_;
 
   // The current text used for searching.
   std::string current_find_text_;
@@ -556,19 +730,31 @@ class PDFiumEngine : public PDFEngine,
   // Where to resume searching. (0-based)
   base::Optional<size_t> resume_find_index_;
 
-  // Permissions bitfield.
-  unsigned long permissions_ = 0;
+  std::unique_ptr<PDFiumPermissions> permissions_;
 
-  // Permissions security handler revision number. -1 for unknown.
-  int permissions_handler_revision_ = -1;
-
-  pp::Size default_page_size_;
+  gfx::Size default_page_size_;
 
   // Timer for touch long press detection.
   base::OneShotTimer touch_timer_;
 
-  // Holds the zero-based page index of the last page that the mouse clicked on.
-  int last_page_mouse_down_ = -1;
+  // Set to true when handling long touch press.
+  bool handling_long_press_ = false;
+
+  // Set to true when updating plugin focus.
+  bool updating_focus_ = false;
+
+  // The focus item type for the currently focused object.
+  FocusElementType focus_item_type_ = FocusElementType::kNone;
+
+  // Stores the last focused object's focus item type before PDF loses focus.
+  FocusElementType last_focused_item_type_ = FocusElementType::kNone;
+
+  // Stores the last focused annotation's index before PDF loses focus.
+  int last_focused_annot_index_ = -1;
+
+  // Holds the zero-based page index of the last page that had the focused
+  // object.
+  int last_focused_page_ = -1;
 
   // Holds the zero-based page index of the most visible page; refreshed by
   // calling CalculateVisiblePages()
@@ -584,7 +770,7 @@ class PDFiumEngine : public PDFEngine,
 
   // Records parts of form fields that need to be highlighted at next paint, in
   // screen coordinates.
-  std::vector<pp::Rect> form_highlights_;
+  std::vector<gfx::Rect> form_highlights_;
 
   // Whether to render in grayscale or in color.
   bool render_grayscale_ = false;
@@ -598,31 +784,27 @@ class PDFiumEngine : public PDFEngine,
   // Pending progressive paints.
   class ProgressivePaint {
    public:
-    ProgressivePaint(int page_index, const pp::Rect& rect);
+    ProgressivePaint(int page_index, const gfx::Rect& rect);
     ProgressivePaint(ProgressivePaint&& that);
+    ProgressivePaint& operator=(ProgressivePaint&& that);
     ~ProgressivePaint();
 
-    ProgressivePaint& operator=(ProgressivePaint&& that);
-
     int page_index() const { return page_index_; }
-    const pp::Rect& rect() const { return rect_; }
+    const gfx::Rect& rect() const { return rect_; }
     FPDF_BITMAP bitmap() const { return bitmap_.get(); }
     bool painted() const { return painted_; }
 
     void set_painted(bool enable) { painted_ = enable; }
-    void SetBitmapAndImageData(ScopedFPDFBitmap bitmap,
-                               pp::ImageData image_data);
+    void SetBitmapAndImageData(ScopedFPDFBitmap bitmap, SkBitmap image_data);
 
    private:
     int page_index_;
-    pp::Rect rect_;             // In screen coordinates.
-    pp::ImageData image_data_;  // Maintains reference while |bitmap_| exists.
+    gfx::Rect rect_;            // In screen coordinates.
+    SkBitmap image_data_;       // Maintains reference while |bitmap_| exists.
     ScopedFPDFBitmap bitmap_;   // Must come after |image_data_|.
     // Temporary used to figure out if in a series of Paint() calls whether this
     // pending paint was updated or not.
     bool painted_ = false;
-
-    DISALLOW_COPY_AND_ASSIGN(ProgressivePaint);
   };
   std::vector<ProgressivePaint> progressive_paints_;
 
@@ -634,7 +816,13 @@ class PDFiumEngine : public PDFEngine,
   base::TimeDelta progressive_paint_timeout_;
 
   // Shadow matrix for generating the page shadow bitmap.
-  std::unique_ptr<ShadowMatrix> page_shadow_;
+  std::unique_ptr<draw_utils::ShadowMatrix> page_shadow_;
+
+  // A list of information of document attachments.
+  std::vector<DocumentAttachmentInfo> doc_attachment_info_list_;
+
+  // Stores parsed document metadata.
+  DocumentMetadata doc_metadata_;
 
   // While true, the document try to be opened and parsed after download each
   // part. Else the document will be opened and parsed only on finish of
@@ -645,26 +833,22 @@ class PDFiumEngine : public PDFEngine,
   RangeSelectionDirection range_selection_direction_ =
       RangeSelectionDirection::Right;
 
-  pp::Point range_selection_base_;
+  gfx::Point range_selection_base_;
 
   bool edit_mode_ = false;
 
+  // When true, interactive portions of the content, such as forms and links,
+  // are restricted.
+  bool read_only_ = false;
+
   PDFiumPrint print_;
 
-  DISALLOW_COPY_AND_ASSIGN(PDFiumEngine);
-};
+  base::WeakPtrFactory<PDFiumEngine> weak_factory_{this};
 
-// Create a local variable of this when calling PDFium functions which can call
-// our global callback when a substitute font is mapped.
-class ScopedSubstFont {
- public:
-  explicit ScopedSubstFont(PDFiumEngine* engine);
-  ~ScopedSubstFont();
-
- private:
-  PDFiumEngine* const old_engine_;
-
-  DISALLOW_COPY_AND_ASSIGN(ScopedSubstFont);
+  // Weak pointers from this factory are used to bind the ContinueFind()
+  // function. This allows those weak pointers to be invalidated during
+  // StopFind(), and keeps the invalidation separated from |weak_factory_|.
+  base::WeakPtrFactory<PDFiumEngine> find_weak_factory_{this};
 };
 
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_engine_exports.cc b/pdf/pdfium/pdfium_engine_exports.cc
index e6c94fb3adf8..780361bab26b 100644
--- a/pdf/pdfium/pdfium_engine_exports.cc
+++ b/pdf/pdfium/pdfium_engine_exports.cc
@@ -7,10 +7,25 @@
 #include <algorithm>
 #include <utility>
 
+#include "base/bind.h"
 #include "base/no_destructor.h"
+#include "base/numerics/safe_conversions.h"
+#include "base/optional.h"
+#include "build/chromeos_buildflags.h"
+#include "pdf/pdfium/pdfium_api_string_buffer_adapter.h"
+#include "pdf/pdfium/pdfium_mem_buffer_file_write.h"
+#include "pdf/pdfium/pdfium_print.h"
+#include "printing/nup_parameters.h"
 #include "printing/units.h"
 #include "third_party/pdfium/public/cpp/fpdf_scopers.h"
+#include "third_party/pdfium/public/fpdf_catalog.h"
+#include "third_party/pdfium/public/fpdf_ppo.h"
+#include "third_party/pdfium/public/fpdf_structtree.h"
 #include "third_party/pdfium/public/fpdfview.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/geometry/size_f.h"
+#include "ui/gfx/geometry/vector2d.h"
 
 using printing::ConvertUnitDouble;
 using printing::kPointsPerInch;
@@ -21,13 +36,15 @@ namespace {
 
 int CalculatePosition(FPDF_PAGE page,
                       const PDFiumEngineExports::RenderingSettings& settings,
-                      pp::Rect* dest) {
+                      gfx::Rect* dest) {
   // settings.bounds is in terms of the max DPI. Convert page sizes to match.
-  int dpi = std::max(settings.dpi_x, settings.dpi_y);
+  const int dpi_x = settings.dpi.width();
+  const int dpi_y = settings.dpi.height();
+  const int dpi = std::max(dpi_x, dpi_y);
   int page_width = static_cast<int>(
-      ConvertUnitDouble(FPDF_GetPageWidth(page), kPointsPerInch, dpi));
+      ConvertUnitDouble(FPDF_GetPageWidthF(page), kPointsPerInch, dpi));
   int page_height = static_cast<int>(
-      ConvertUnitDouble(FPDF_GetPageHeight(page), kPointsPerInch, dpi));
+      ConvertUnitDouble(FPDF_GetPageHeightF(page), kPointsPerInch, dpi));
 
   // Start by assuming that we will draw exactly to the bounds rect
   // specified.
@@ -75,40 +92,128 @@ int CalculatePosition(FPDF_PAGE page,
   }
 
   // Scale the bounds to device units if DPI is rectangular.
-  if (settings.dpi_x != settings.dpi_y) {
-    dest->set_width(dest->width() * settings.dpi_x / dpi);
-    dest->set_height(dest->height() * settings.dpi_y / dpi);
+  if (dpi_x != dpi_y) {
+    dest->set_width(dest->width() * dpi_x / dpi);
+    dest->set_height(dest->height() * dpi_y / dpi);
   }
 
   if (settings.center_in_bounds) {
-    pp::Point offset(
-        (settings.bounds.width() * settings.dpi_x / dpi - dest->width()) / 2,
-        (settings.bounds.height() * settings.dpi_y / dpi - dest->height()) / 2);
+    gfx::Vector2d offset(
+        (settings.bounds.width() * dpi_x / dpi - dest->width()) / 2,
+        (settings.bounds.height() * dpi_y / dpi - dest->height()) / 2);
     dest->Offset(offset);
   }
   return rotate;
 }
 
+ScopedFPDFDocument LoadPdfData(base::span<const uint8_t> pdf_buffer) {
+  if (!base::IsValueInRangeForNumericType<int>(pdf_buffer.size()))
+    return nullptr;
+  return ScopedFPDFDocument(
+      FPDF_LoadMemDocument(pdf_buffer.data(), pdf_buffer.size(), nullptr));
+}
+
+ScopedFPDFDocument CreatePdfDoc(
+    std::vector<base::span<const uint8_t>> input_buffers) {
+  if (input_buffers.empty())
+    return nullptr;
+
+  ScopedFPDFDocument doc(FPDF_CreateNewDocument());
+  size_t index = 0;
+  for (auto input_buffer : input_buffers) {
+    ScopedFPDFDocument single_page_doc = LoadPdfData(input_buffer);
+    if (!FPDF_ImportPages(doc.get(), single_page_doc.get(), "1", index++)) {
+      return nullptr;
+    }
+  }
+
+  return doc;
+}
+
+bool IsValidPrintableArea(const gfx::Size& page_size,
+                          const gfx::Rect& printable_area) {
+  return !printable_area.IsEmpty() && printable_area.x() >= 0 &&
+         printable_area.y() >= 0 &&
+         printable_area.right() <= page_size.width() &&
+         printable_area.bottom() <= page_size.height();
+}
+
+int GetRenderFlagsFromSettings(
+    const PDFiumEngineExports::RenderingSettings& settings) {
+  int flags = FPDF_ANNOT;
+  if (!settings.use_color)
+    flags |= FPDF_GRAYSCALE;
+  if (settings.render_for_printing)
+    flags |= FPDF_PRINTING;
+  return flags;
+}
+
+base::Value RecursiveGetStructTree(FPDF_STRUCTELEMENT struct_elem) {
+  int children_count = FPDF_StructElement_CountChildren(struct_elem);
+  if (children_count <= 0)
+    return base::Value(base::Value::Type::NONE);
+
+  base::Optional<std::u16string> opt_type =
+      CallPDFiumWideStringBufferApiAndReturnOptional(
+          base::BindRepeating(FPDF_StructElement_GetType, struct_elem), true);
+  if (!opt_type)
+    return base::Value(base::Value::Type::NONE);
+
+  base::Value result(base::Value::Type::DICTIONARY);
+  result.SetStringKey("type", *opt_type);
+
+  base::Optional<std::u16string> opt_alt =
+      CallPDFiumWideStringBufferApiAndReturnOptional(
+          base::BindRepeating(FPDF_StructElement_GetAltText, struct_elem),
+          true);
+  if (opt_alt)
+    result.SetStringKey("alt", *opt_alt);
+
+  base::Optional<std::u16string> opt_lang =
+      CallPDFiumWideStringBufferApiAndReturnOptional(
+          base::BindRepeating(FPDF_StructElement_GetLang, struct_elem), true);
+  if (opt_lang)
+    result.SetStringKey("lang", *opt_lang);
+
+  base::Value children(base::Value::Type::LIST);
+  for (int i = 0; i < children_count; i++) {
+    FPDF_STRUCTELEMENT child_elem =
+        FPDF_StructElement_GetChildAtIndex(struct_elem, i);
+
+    base::Value child = RecursiveGetStructTree(child_elem);
+    if (child.is_dict())
+      children.Append(std::move(child));
+  }
+
+  // use "~children" instead of "children" because we pretty-print the
+  // result of this as JSON and the keys are sorted; it's much easier to
+  // understand when the children are the last key.
+  if (!children.GetList().empty())
+    result.SetKey("~children", std::move(children));
+
+  return result;
+}
+
 }  // namespace
 
-PDFEngineExports::RenderingSettings::RenderingSettings(int dpi_x,
-                                                       int dpi_y,
-                                                       const pp::Rect& bounds,
+PDFEngineExports::RenderingSettings::RenderingSettings(const gfx::Size& dpi,
+                                                       const gfx::Rect& bounds,
                                                        bool fit_to_bounds,
                                                        bool stretch_to_bounds,
                                                        bool keep_aspect_ratio,
                                                        bool center_in_bounds,
                                                        bool autorotate,
-                                                       bool use_color)
-    : dpi_x(dpi_x),
-      dpi_y(dpi_y),
+                                                       bool use_color,
+                                                       bool render_for_printing)
+    : dpi(dpi),
       bounds(bounds),
       fit_to_bounds(fit_to_bounds),
       stretch_to_bounds(stretch_to_bounds),
       keep_aspect_ratio(keep_aspect_ratio),
       center_in_bounds(center_in_bounds),
       autorotate(autorotate),
-      use_color(use_color) {}
+      use_color(use_color),
+      render_for_printing(render_for_printing) {}
 
 PDFEngineExports::RenderingSettings::RenderingSettings(
     const RenderingSettings& that) = default;
@@ -122,14 +227,23 @@ PDFiumEngineExports::PDFiumEngineExports() {}
 
 PDFiumEngineExports::~PDFiumEngineExports() {}
 
+#if BUILDFLAG(IS_CHROMEOS_ASH)
+std::vector<uint8_t> PDFiumEngineExports::CreateFlattenedPdf(
+    base::span<const uint8_t> input_buffer) {
+  ScopedFPDFDocument doc = LoadPdfData(input_buffer);
+  if (!doc)
+    return std::vector<uint8_t>();
+  return PDFiumPrint::CreateFlattenedPdf(std::move(doc));
+}
+#endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+
 #if defined(OS_WIN)
-bool PDFiumEngineExports::RenderPDFPageToDC(const void* pdf_buffer,
-                                            int buffer_size,
-                                            int page_number,
-                                            const RenderingSettings& settings,
-                                            HDC dc) {
-  ScopedFPDFDocument doc(
-      FPDF_LoadMemDocument(pdf_buffer, buffer_size, nullptr));
+bool PDFiumEngineExports::RenderPDFPageToDC(
+    base::span<const uint8_t> pdf_buffer,
+    int page_number,
+    const RenderingSettings& settings,
+    HDC dc) {
+  ScopedFPDFDocument doc = LoadPdfData(pdf_buffer);
   if (!doc)
     return false;
   ScopedFPDFPage page(FPDF_LoadPage(doc.get(), page_number));
@@ -138,12 +252,12 @@ bool PDFiumEngineExports::RenderPDFPageToDC(const void* pdf_buffer,
 
   RenderingSettings new_settings = settings;
   // calculate the page size
-  if (new_settings.dpi_x == -1)
-    new_settings.dpi_x = GetDeviceCaps(dc, LOGPIXELSX);
-  if (new_settings.dpi_y == -1)
-    new_settings.dpi_y = GetDeviceCaps(dc, LOGPIXELSY);
+  if (new_settings.dpi.width() == -1)
+    new_settings.dpi.set_width(GetDeviceCaps(dc, LOGPIXELSX));
+  if (new_settings.dpi.height() == -1)
+    new_settings.dpi.set_height(GetDeviceCaps(dc, LOGPIXELSY));
 
-  pp::Rect dest;
+  gfx::Rect dest;
   int rotate = CalculatePosition(page.get(), new_settings, &dest);
 
   int save_state = SaveDC(dc);
@@ -154,9 +268,7 @@ bool PDFiumEngineExports::RenderPDFPageToDC(const void* pdf_buffer,
                     settings.bounds.x() + settings.bounds.width(),
                     settings.bounds.y() + settings.bounds.height());
 
-  int flags = FPDF_ANNOT | FPDF_PRINTING | FPDF_NO_CATCH;
-  if (!settings.use_color)
-    flags |= FPDF_GRAYSCALE;
+  int flags = GetRenderFlagsFromSettings(settings);
 
   // A "temporary" hack. Some PDFs seems to render very slowly if
   // FPDF_RenderPage() is directly used on a printer DC. I suspect it is
@@ -211,20 +323,18 @@ void PDFiumEngineExports::SetPDFUsePrintMode(int mode) {
 #endif  // defined(OS_WIN)
 
 bool PDFiumEngineExports::RenderPDFPageToBitmap(
-    const void* pdf_buffer,
-    int pdf_buffer_size,
+    base::span<const uint8_t> pdf_buffer,
     int page_number,
     const RenderingSettings& settings,
     void* bitmap_buffer) {
-  ScopedFPDFDocument doc(
-      FPDF_LoadMemDocument(pdf_buffer, pdf_buffer_size, nullptr));
+  ScopedFPDFDocument doc = LoadPdfData(pdf_buffer);
   if (!doc)
     return false;
   ScopedFPDFPage page(FPDF_LoadPage(doc.get(), page_number));
   if (!page)
     return false;
 
-  pp::Rect dest;
+  gfx::Rect dest;
   int rotate = CalculatePosition(page.get(), settings, &dest);
 
   ScopedFPDFBitmap bitmap(FPDFBitmap_CreateEx(
@@ -234,23 +344,50 @@ bool PDFiumEngineExports::RenderPDFPageToBitmap(
   FPDFBitmap_FillRect(bitmap.get(), 0, 0, settings.bounds.width(),
                       settings.bounds.height(), 0xFFFFFFFF);
   // Shift top-left corner of bounds to (0, 0) if it's not there.
-  dest.set_point(dest.point() - settings.bounds.point());
-
-  int flags = FPDF_ANNOT | FPDF_PRINTING | FPDF_NO_CATCH;
-  if (!settings.use_color)
-    flags |= FPDF_GRAYSCALE;
+  dest.set_origin(dest.origin() - settings.bounds.OffsetFromOrigin());
 
   FPDF_RenderPageBitmap(bitmap.get(), page.get(), dest.x(), dest.y(),
-                        dest.width(), dest.height(), rotate, flags);
+                        dest.width(), dest.height(), rotate,
+                        GetRenderFlagsFromSettings(settings));
   return true;
 }
 
-bool PDFiumEngineExports::GetPDFDocInfo(const void* pdf_buffer,
-                                        int buffer_size,
+std::vector<uint8_t> PDFiumEngineExports::ConvertPdfPagesToNupPdf(
+    std::vector<base::span<const uint8_t>> input_buffers,
+    size_t pages_per_sheet,
+    const gfx::Size& page_size,
+    const gfx::Rect& printable_area) {
+  if (!IsValidPrintableArea(page_size, printable_area))
+    return std::vector<uint8_t>();
+
+  ScopedFPDFDocument doc = CreatePdfDoc(std::move(input_buffers));
+  if (!doc)
+    return std::vector<uint8_t>();
+
+  return PDFiumPrint::CreateNupPdf(std::move(doc), pages_per_sheet, page_size,
+                                   printable_area);
+}
+
+std::vector<uint8_t> PDFiumEngineExports::ConvertPdfDocumentToNupPdf(
+    base::span<const uint8_t> input_buffer,
+    size_t pages_per_sheet,
+    const gfx::Size& page_size,
+    const gfx::Rect& printable_area) {
+  if (!IsValidPrintableArea(page_size, printable_area))
+    return std::vector<uint8_t>();
+
+  ScopedFPDFDocument doc = LoadPdfData(input_buffer);
+  if (!doc)
+    return std::vector<uint8_t>();
+
+  return PDFiumPrint::CreateNupPdf(std::move(doc), pages_per_sheet, page_size,
+                                   printable_area);
+}
+
+bool PDFiumEngineExports::GetPDFDocInfo(base::span<const uint8_t> pdf_buffer,
                                         int* page_count,
-                                        double* max_page_width) {
-  ScopedFPDFDocument doc(
-      FPDF_LoadMemDocument(pdf_buffer, buffer_size, nullptr));
+                                        float* max_page_width) {
+  ScopedFPDFDocument doc = LoadPdfData(pdf_buffer);
   if (!doc)
     return false;
 
@@ -264,28 +401,65 @@ bool PDFiumEngineExports::GetPDFDocInfo(const void* pdf_buffer,
   if (max_page_width) {
     *max_page_width = 0;
     for (int page_number = 0; page_number < page_count_local; page_number++) {
-      double page_width = 0;
-      double page_height = 0;
-      FPDF_GetPageSizeByIndex(doc.get(), page_number, &page_width,
-                              &page_height);
-      if (page_width > *max_page_width) {
-        *max_page_width = page_width;
+      FS_SIZEF page_size;
+      if (FPDF_GetPageSizeByIndexF(doc.get(), page_number, &page_size) &&
+          page_size.width > *max_page_width) {
+        *max_page_width = page_size.width;
       }
     }
   }
   return true;
 }
 
-bool PDFiumEngineExports::GetPDFPageSizeByIndex(const void* pdf_buffer,
-                                                int pdf_buffer_size,
-                                                int page_number,
-                                                double* width,
-                                                double* height) {
-  ScopedFPDFDocument doc(
-      FPDF_LoadMemDocument(pdf_buffer, pdf_buffer_size, nullptr));
+base::Optional<bool> PDFiumEngineExports::IsPDFDocTagged(
+    base::span<const uint8_t> pdf_buffer) {
+  ScopedFPDFDocument doc = LoadPdfData(pdf_buffer);
   if (!doc)
-    return false;
-  return FPDF_GetPageSizeByIndex(doc.get(), page_number, width, height) != 0;
+    return base::nullopt;
+
+  return FPDFCatalog_IsTagged(doc.get());
+}
+
+base::Value PDFiumEngineExports::GetPDFStructTreeForPage(
+    base::span<const uint8_t> pdf_buffer,
+    int page_index) {
+  ScopedFPDFDocument doc = LoadPdfData(pdf_buffer);
+  if (!doc)
+    return base::Value(base::Value::Type::NONE);
+
+  ScopedFPDFPage page(FPDF_LoadPage(doc.get(), page_index));
+  if (!page)
+    return base::Value(base::Value::Type::NONE);
+
+  ScopedFPDFStructTree struct_tree(FPDF_StructTree_GetForPage(page.get()));
+  if (!struct_tree)
+    return base::Value(base::Value::Type::NONE);
+
+  // We only expect one child of the struct tree - i.e. a single root node.
+  int children = FPDF_StructTree_CountChildren(struct_tree.get());
+  if (children != 1)
+    return base::Value(base::Value::Type::NONE);
+
+  FPDF_STRUCTELEMENT struct_root_elem =
+      FPDF_StructTree_GetChildAtIndex(struct_tree.get(), 0);
+  if (!struct_root_elem)
+    return base::Value(base::Value::Type::NONE);
+
+  return RecursiveGetStructTree(struct_root_elem);
+}
+
+base::Optional<gfx::SizeF> PDFiumEngineExports::GetPDFPageSizeByIndex(
+    base::span<const uint8_t> pdf_buffer,
+    int page_number) {
+  ScopedFPDFDocument doc = LoadPdfData(pdf_buffer);
+  if (!doc)
+    return base::nullopt;
+
+  FS_SIZEF size;
+  if (!FPDF_GetPageSizeByIndexF(doc.get(), page_number, &size))
+    return base::nullopt;
+
+  return gfx::SizeF(size.width, size.height);
 }
 
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_engine_exports.h b/pdf/pdfium/pdfium_engine_exports.h
index b37de82875a4..39d11fb6aa09 100644
--- a/pdf/pdfium/pdfium_engine_exports.h
+++ b/pdf/pdfium/pdfium_engine_exports.h
@@ -9,6 +9,7 @@
 #include <stdint.h>
 
 #include "build/build_config.h"
+#include "build/chromeos_buildflags.h"
 #include "pdf/pdf_engine.h"
 
 namespace chrome_pdf {
@@ -16,12 +17,17 @@ namespace chrome_pdf {
 class PDFiumEngineExports : public PDFEngineExports {
  public:
   PDFiumEngineExports();
+  PDFiumEngineExports(const PDFiumEngineExports&) = delete;
+  PDFiumEngineExports& operator=(const PDFiumEngineExports&) = delete;
   ~PDFiumEngineExports() override;
 
 // PDFEngineExports:
+#if BUILDFLAG(IS_CHROMEOS_ASH)
+  std::vector<uint8_t> CreateFlattenedPdf(
+      base::span<const uint8_t> input_buffer) override;
+#endif  // BUILDFLAG(IS_CHROMEOS_ASH)
 #if defined(OS_WIN)
-  bool RenderPDFPageToDC(const void* pdf_buffer,
-                         int buffer_size,
+  bool RenderPDFPageToDC(base::span<const uint8_t> pdf_buffer,
                          int page_number,
                          const RenderingSettings& settings,
                          HDC dc) override;
@@ -31,23 +37,30 @@ class PDFiumEngineExports : public PDFEngineExports {
   void SetPDFUseGDIPrinting(bool enable) override;
   void SetPDFUsePrintMode(int mode) override;
 #endif  // defined(OS_WIN)
-  bool RenderPDFPageToBitmap(const void* pdf_buffer,
-                             int pdf_buffer_size,
+  bool RenderPDFPageToBitmap(base::span<const uint8_t> pdf_buffer,
                              int page_number,
                              const RenderingSettings& settings,
                              void* bitmap_buffer) override;
-  bool GetPDFDocInfo(const void* pdf_buffer,
-                     int buffer_size,
+  std::vector<uint8_t> ConvertPdfPagesToNupPdf(
+      std::vector<base::span<const uint8_t>> input_buffers,
+      size_t pages_per_sheet,
+      const gfx::Size& page_size,
+      const gfx::Rect& printable_area) override;
+  std::vector<uint8_t> ConvertPdfDocumentToNupPdf(
+      base::span<const uint8_t> input_buffer,
+      size_t pages_per_sheet,
+      const gfx::Size& page_size,
+      const gfx::Rect& printable_area) override;
+  bool GetPDFDocInfo(base::span<const uint8_t> pdf_buffer,
                      int* page_count,
-                     double* max_page_width) override;
-  bool GetPDFPageSizeByIndex(const void* pdf_buffer,
-                             int pdf_buffer_size,
-                             int page_number,
-                             double* width,
-                             double* height) override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(PDFiumEngineExports);
+                     float* max_page_width) override;
+  base::Optional<bool> IsPDFDocTagged(
+      base::span<const uint8_t> pdf_buffer) override;
+  base::Value GetPDFStructTreeForPage(base::span<const uint8_t> pdf_buffer,
+                                      int page_index) override;
+  base::Optional<gfx::SizeF> GetPDFPageSizeByIndex(
+      base::span<const uint8_t> pdf_buffer,
+      int page_number) override;
 };
 
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_engine_exports_unittest.cc b/pdf/pdfium/pdfium_engine_exports_unittest.cc
index fe83add7857f..189504a58b41 100644
--- a/pdf/pdfium/pdfium_engine_exports_unittest.cc
+++ b/pdf/pdfium/pdfium_engine_exports_unittest.cc
@@ -3,13 +3,16 @@
 // found in the LICENSE file.
 
 #include "base/files/file_util.h"
+#include "base/optional.h"
 #include "base/path_service.h"
 #include "base/test/test_simple_task_runner.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "gin/v8_initializer.h"
 #include "pdf/pdf.h"
-#include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/geometry/size_f.h"
 
 namespace chrome_pdf {
 
@@ -21,7 +24,6 @@ void LoadV8SnapshotData() {
   if (!loaded) {
     loaded = true;
     gin::V8Initializer::LoadV8Snapshot();
-    gin::V8Initializer::LoadV8Natives();
   }
 #endif
 }
@@ -29,6 +31,8 @@ void LoadV8SnapshotData() {
 class PDFiumEngineExportsTest : public testing::Test {
  public:
   PDFiumEngineExportsTest() = default;
+  PDFiumEngineExportsTest(const PDFiumEngineExportsTest&) = delete;
+  PDFiumEngineExportsTest& operator=(const PDFiumEngineExportsTest&) = delete;
   ~PDFiumEngineExportsTest() override = default;
 
  protected:
@@ -49,8 +53,6 @@ class PDFiumEngineExportsTest : public testing::Test {
  private:
   std::unique_ptr<base::ThreadTaskRunnerHandle> handle_;
   base::FilePath pdf_data_dir_;
-
-  DISALLOW_COPY_AND_ASSIGN(PDFiumEngineExportsTest);
 };
 
 }  // namespace
@@ -61,15 +63,12 @@ TEST_F(PDFiumEngineExportsTest, GetPDFDocInfo) {
   std::string pdf_data;
   ASSERT_TRUE(base::ReadFileToString(pdf_path, &pdf_data));
 
-  EXPECT_FALSE(GetPDFDocInfo(nullptr, 0, nullptr, nullptr));
-
-  ASSERT_TRUE(
-      GetPDFDocInfo(pdf_data.data(), pdf_data.size(), nullptr, nullptr));
+  auto pdf_span = base::as_bytes(base::make_span(pdf_data));
+  ASSERT_TRUE(GetPDFDocInfo(pdf_span, nullptr, nullptr));
 
   int page_count;
-  double max_page_width;
-  ASSERT_TRUE(GetPDFDocInfo(pdf_data.data(), pdf_data.size(), &page_count,
-                            &max_page_width));
+  float max_page_width;
+  ASSERT_TRUE(GetPDFDocInfo(pdf_span, &page_count, &max_page_width));
   EXPECT_EQ(2, page_count);
   EXPECT_DOUBLE_EQ(200.0, max_page_width);
 }
@@ -82,19 +81,85 @@ TEST_F(PDFiumEngineExportsTest, GetPDFPageSizeByIndex) {
   std::string pdf_data;
   ASSERT_TRUE(base::ReadFileToString(pdf_path, &pdf_data));
 
-  EXPECT_FALSE(GetPDFPageSizeByIndex(nullptr, 0, 0, nullptr, nullptr));
-
+  auto pdf_span = base::as_bytes(base::make_span(pdf_data));
   int page_count;
-  ASSERT_TRUE(
-      GetPDFDocInfo(pdf_data.data(), pdf_data.size(), &page_count, nullptr));
+  ASSERT_TRUE(GetPDFDocInfo(pdf_span, &page_count, nullptr));
   ASSERT_EQ(2, page_count);
   for (int page_number = 0; page_number < page_count; ++page_number) {
-    double width;
-    double height;
-    ASSERT_TRUE(GetPDFPageSizeByIndex(pdf_data.data(), pdf_data.size(),
-                                      page_number, &width, &height));
-    EXPECT_DOUBLE_EQ(200.0, width);
-    EXPECT_DOUBLE_EQ(200.0, height);
+    base::Optional<gfx::SizeF> page_size =
+        GetPDFPageSizeByIndex(pdf_span, page_number);
+    ASSERT_TRUE(page_size.has_value());
+    EXPECT_EQ(gfx::SizeF(200, 200), page_size.value());
+  }
+}
+
+TEST_F(PDFiumEngineExportsTest, ConvertPdfPagesToNupPdf) {
+  base::FilePath pdf_path =
+      pdf_data_dir().Append(FILE_PATH_LITERAL("rectangles.pdf"));
+  std::string pdf_data;
+  ASSERT_TRUE(base::ReadFileToString(pdf_path, &pdf_data));
+
+  std::vector<base::span<const uint8_t>> pdf_buffers;
+  std::vector<uint8_t> output_pdf_buffer = ConvertPdfPagesToNupPdf(
+      pdf_buffers, 1, gfx::Size(612, 792), gfx::Rect(22, 20, 570, 750));
+  EXPECT_TRUE(output_pdf_buffer.empty());
+
+  pdf_buffers.push_back(base::as_bytes(base::make_span(pdf_data)));
+  pdf_buffers.push_back(base::as_bytes(base::make_span(pdf_data)));
+  output_pdf_buffer = ConvertPdfPagesToNupPdf(
+      pdf_buffers, 2, gfx::Size(612, 792), gfx::Rect(22, 20, 0, 750));
+  EXPECT_TRUE(output_pdf_buffer.empty());
+  output_pdf_buffer = ConvertPdfPagesToNupPdf(
+      pdf_buffers, 2, gfx::Size(612, 792), gfx::Rect(22, 20, 570, 0));
+  EXPECT_TRUE(output_pdf_buffer.empty());
+  output_pdf_buffer = ConvertPdfPagesToNupPdf(
+      pdf_buffers, 2, gfx::Size(612, 792), gfx::Rect(300, 20, 570, 750));
+  EXPECT_TRUE(output_pdf_buffer.empty());
+  output_pdf_buffer = ConvertPdfPagesToNupPdf(
+      pdf_buffers, 2, gfx::Size(612, 792), gfx::Rect(22, 400, 570, 750));
+  EXPECT_TRUE(output_pdf_buffer.empty());
+  output_pdf_buffer = ConvertPdfPagesToNupPdf(
+      pdf_buffers, 2, gfx::Size(612, 792), gfx::Rect(22, 20, 570, 750));
+  ASSERT_GT(output_pdf_buffer.size(), 0U);
+
+  base::span<const uint8_t> output_pdf_span =
+      base::make_span(output_pdf_buffer);
+  int page_count;
+  ASSERT_TRUE(GetPDFDocInfo(output_pdf_span, &page_count, nullptr));
+  ASSERT_EQ(1, page_count);
+
+  base::Optional<gfx::SizeF> page_size =
+      GetPDFPageSizeByIndex(output_pdf_span, 0);
+  ASSERT_TRUE(page_size.has_value());
+  EXPECT_EQ(gfx::SizeF(792, 612), page_size.value());
+}
+
+TEST_F(PDFiumEngineExportsTest, ConvertPdfDocumentToNupPdf) {
+  base::FilePath pdf_path =
+      pdf_data_dir().Append(FILE_PATH_LITERAL("rectangles_multi_pages.pdf"));
+  std::string pdf_data;
+  ASSERT_TRUE(base::ReadFileToString(pdf_path, &pdf_data));
+
+  base::span<const uint8_t> pdf_buffer;
+  std::vector<uint8_t> output_pdf_buffer = ConvertPdfDocumentToNupPdf(
+      pdf_buffer, 1, gfx::Size(612, 792), gfx::Rect(32, 20, 570, 750));
+  EXPECT_TRUE(output_pdf_buffer.empty());
+
+  pdf_buffer = base::as_bytes(base::make_span(pdf_data));
+  output_pdf_buffer = ConvertPdfDocumentToNupPdf(
+      pdf_buffer, 4, gfx::Size(612, 792), gfx::Rect(22, 20, 570, 750));
+  ASSERT_GT(output_pdf_buffer.size(), 0U);
+
+  base::span<const uint8_t> output_pdf_span =
+      base::make_span(output_pdf_buffer);
+  int page_count;
+  ASSERT_TRUE(GetPDFDocInfo(output_pdf_span, &page_count, nullptr));
+  ASSERT_EQ(2, page_count);
+  for (int page_number = 0; page_number < page_count; ++page_number) {
+    base::Optional<gfx::SizeF> page_size =
+        GetPDFPageSizeByIndex(output_pdf_span, page_number);
+    ASSERT_TRUE(page_size.has_value());
+    EXPECT_EQ(gfx::SizeF(612, 792), page_size.value());
   }
 }
 
diff --git a/pdf/pdfium/pdfium_engine_unittest.cc b/pdf/pdfium/pdfium_engine_unittest.cc
new file mode 100644
index 000000000000..cf976dc13748
--- /dev/null
+++ b/pdf/pdfium/pdfium_engine_unittest.cc
@@ -0,0 +1,1229 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "pdf/pdfium/pdfium_engine.h"
+
+#include <stdint.h>
+
+#include "base/hash/md5.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/test/gtest_util.h"
+#include "base/test/mock_callback.h"
+#include "base/test/scoped_feature_list.h"
+#include "base/test/task_environment.h"
+#include "base/time/time.h"
+#include "pdf/document_attachment_info.h"
+#include "pdf/document_layout.h"
+#include "pdf/document_metadata.h"
+#include "pdf/pdf_features.h"
+#include "pdf/pdfium/pdfium_page.h"
+#include "pdf/pdfium/pdfium_test_base.h"
+#include "pdf/ppapi_migration/input_event_conversions.h"
+#include "pdf/test/test_client.h"
+#include "pdf/test/test_document_loader.h"
+#include "pdf/ui/thumbnail.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/size.h"
+
+namespace chrome_pdf {
+
+namespace {
+
+using ::testing::InSequence;
+using ::testing::Invoke;
+using ::testing::IsEmpty;
+using ::testing::NiceMock;
+using ::testing::Not;
+using ::testing::Return;
+using ::testing::StrictMock;
+
+MATCHER_P2(LayoutWithSize, width, height, "") {
+  return arg.size() == gfx::Size(width, height);
+}
+
+MATCHER_P(LayoutWithOptions, options, "") {
+  return arg.options() == options;
+}
+
+class MockTestClient : public TestClient {
+ public:
+  MockTestClient() {
+    ON_CALL(*this, ProposeDocumentLayout)
+        .WillByDefault([this](const DocumentLayout& layout) {
+          TestClient::ProposeDocumentLayout(layout);
+        });
+  }
+
+  MOCK_METHOD(void,
+              ProposeDocumentLayout,
+              (const DocumentLayout& layout),
+              (override));
+  MOCK_METHOD(void, ScrollToPage, (int page), (override));
+};
+
+}  // namespace
+
+class PDFiumEngineTest : public PDFiumTestBase {
+ protected:
+  void ExpectPageRect(const PDFiumEngine& engine,
+                      size_t page_index,
+                      const gfx::Rect& expected_rect) {
+    const PDFiumPage& page = GetPDFiumPageForTest(engine, page_index);
+    EXPECT_EQ(expected_rect, page.rect());
+  }
+
+  // Tries to load a PDF incrementally, returning `true` if the PDF actually was
+  // loaded incrementally. Note that this function will return `false` if
+  // incremental loading fails, but also if incremental loading is disabled.
+  bool TryLoadIncrementally() {
+    NiceMock<MockTestClient> client;
+    InitializeEngineResult initialize_result = InitializeEngineWithoutLoading(
+        &client, FILE_PATH_LITERAL("linearized.pdf"));
+    if (!initialize_result.engine) {
+      ADD_FAILURE();
+      return false;
+    }
+    PDFiumEngine& engine = *initialize_result.engine;
+
+    // Load enough for the document to become partially available.
+    initialize_result.document_loader->SimulateLoadData(8192);
+
+    bool loaded_incrementally;
+    if (engine.GetNumberOfPages() == 0) {
+      // This is not necessarily a test failure; it just indicates incremental
+      // loading is not occurring.
+      loaded_incrementally = false;
+    } else {
+      // Note: Plugin size chosen so all pages of the document are visible. The
+      // engine only updates availability incrementally for visible pages.
+      EXPECT_EQ(0, CountAvailablePages(engine));
+      engine.PluginSizeUpdated({1024, 4096});
+      int available_pages = CountAvailablePages(engine);
+      loaded_incrementally =
+          0 < available_pages && available_pages < engine.GetNumberOfPages();
+    }
+
+    // Verify that loading can finish.
+    while (initialize_result.document_loader->SimulateLoadData(UINT32_MAX))
+      continue;
+
+    EXPECT_EQ(engine.GetNumberOfPages(), CountAvailablePages(engine));
+
+    return loaded_incrementally;
+  }
+
+  // Counts the number of available pages. Returns `int` instead of `size_t` for
+  // consistency with `PDFiumEngine::GetNumberOfPages()`.
+  int CountAvailablePages(const PDFiumEngine& engine) {
+    int available_pages = 0;
+    for (int i = 0; i < engine.GetNumberOfPages(); ++i) {
+      if (GetPDFiumPageForTest(engine, i).available())
+        ++available_pages;
+    }
+    return available_pages;
+  }
+};
+
+TEST_F(PDFiumEngineTest, InitializeWithRectanglesMultiPagesPdf) {
+  NiceMock<MockTestClient> client;
+
+  // ProposeDocumentLayout() gets called twice during loading because
+  // PDFiumEngine::ContinueLoadingDocument() calls LoadBody() (which eventually
+  // triggers a layout proposal), and then calls FinishLoadingDocument() (since
+  // the document is complete), which calls LoadBody() again. Coalescing these
+  // proposals is not correct unless we address the issue covered by
+  // PDFiumEngineTest.ProposeDocumentLayoutWithOverlap.
+  EXPECT_CALL(client, ProposeDocumentLayout(LayoutWithSize(343, 1664)))
+      .Times(2);
+
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("rectangles_multi_pages.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(5, engine->GetNumberOfPages());
+
+  ExpectPageRect(*engine, 0, {38, 3, 266, 333});
+  ExpectPageRect(*engine, 1, {5, 350, 333, 266});
+  ExpectPageRect(*engine, 2, {38, 630, 266, 333});
+  ExpectPageRect(*engine, 3, {38, 977, 266, 333});
+  ExpectPageRect(*engine, 4, {38, 1324, 266, 333});
+}
+
+TEST_F(PDFiumEngineTest, InitializeWithRectanglesMultiPagesPdfInTwoUpView) {
+  NiceMock<MockTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("rectangles_multi_pages.pdf"));
+  ASSERT_TRUE(engine);
+
+  DocumentLayout::Options options;
+  options.set_two_up_view_enabled(true);
+  EXPECT_CALL(client, ProposeDocumentLayout(LayoutWithOptions(options)))
+      .WillOnce(Return());
+  engine->SetTwoUpView(true);
+
+  engine->ApplyDocumentLayout(options);
+
+  ASSERT_EQ(5, engine->GetNumberOfPages());
+
+  ExpectPageRect(*engine, 0, {72, 3, 266, 333});
+  ExpectPageRect(*engine, 1, {340, 3, 333, 266});
+  ExpectPageRect(*engine, 2, {72, 346, 266, 333});
+  ExpectPageRect(*engine, 3, {340, 346, 266, 333});
+  ExpectPageRect(*engine, 4, {68, 689, 266, 333});
+}
+
+TEST_F(PDFiumEngineTest, AppendBlankPagesWithFewerPages) {
+  NiceMock<MockTestClient> client;
+  {
+    InSequence normal_then_append;
+    EXPECT_CALL(client, ProposeDocumentLayout(LayoutWithSize(343, 1664)))
+        .Times(2);
+    EXPECT_CALL(client, ProposeDocumentLayout(LayoutWithSize(276, 1037)));
+  }
+
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("rectangles_multi_pages.pdf"));
+  ASSERT_TRUE(engine);
+
+  engine->AppendBlankPages(3);
+  ASSERT_EQ(3, engine->GetNumberOfPages());
+
+  ExpectPageRect(*engine, 0, {5, 3, 266, 333});
+  ExpectPageRect(*engine, 1, {5, 350, 266, 333});
+  ExpectPageRect(*engine, 2, {5, 697, 266, 333});
+}
+
+TEST_F(PDFiumEngineTest, AppendBlankPagesWithMorePages) {
+  NiceMock<MockTestClient> client;
+  {
+    InSequence normal_then_append;
+    EXPECT_CALL(client, ProposeDocumentLayout(LayoutWithSize(343, 1664)))
+        .Times(2);
+    EXPECT_CALL(client, ProposeDocumentLayout(LayoutWithSize(276, 2425)));
+  }
+
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("rectangles_multi_pages.pdf"));
+  ASSERT_TRUE(engine);
+
+  engine->AppendBlankPages(7);
+  ASSERT_EQ(7, engine->GetNumberOfPages());
+
+  ExpectPageRect(*engine, 0, {5, 3, 266, 333});
+  ExpectPageRect(*engine, 1, {5, 350, 266, 333});
+  ExpectPageRect(*engine, 2, {5, 697, 266, 333});
+  ExpectPageRect(*engine, 3, {5, 1044, 266, 333});
+  ExpectPageRect(*engine, 4, {5, 1391, 266, 333});
+  ExpectPageRect(*engine, 5, {5, 1738, 266, 333});
+  ExpectPageRect(*engine, 6, {5, 2085, 266, 333});
+}
+
+TEST_F(PDFiumEngineTest, ProposeDocumentLayoutWithOverlap) {
+  NiceMock<MockTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("rectangles_multi_pages.pdf"));
+  ASSERT_TRUE(engine);
+
+  EXPECT_CALL(client, ProposeDocumentLayout(LayoutWithSize(343, 1463)))
+      .WillOnce(Return());
+  engine->RotateClockwise();
+
+  EXPECT_CALL(client, ProposeDocumentLayout(LayoutWithSize(343, 1664)))
+      .WillOnce(Return());
+  engine->RotateCounterclockwise();
+}
+
+TEST_F(PDFiumEngineTest, ApplyDocumentLayoutAvoidsInfiniteLoop) {
+  NiceMock<MockTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("rectangles_multi_pages.pdf"));
+  ASSERT_TRUE(engine);
+
+  DocumentLayout::Options options;
+  EXPECT_CALL(client, ScrollToPage(-1)).Times(0);
+  EXPECT_EQ(gfx::Size(343, 1664), engine->ApplyDocumentLayout(options));
+
+  options.RotatePagesClockwise();
+  EXPECT_CALL(client, ScrollToPage(-1)).Times(1);
+  EXPECT_EQ(gfx::Size(343, 1463), engine->ApplyDocumentLayout(options));
+  EXPECT_EQ(gfx::Size(343, 1463), engine->ApplyDocumentLayout(options));
+}
+
+TEST_F(PDFiumEngineTest, GetDocumentAttachments) {
+  NiceMock<MockTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("embedded_attachments.pdf"));
+  ASSERT_TRUE(engine);
+
+  const std::vector<DocumentAttachmentInfo>& attachments =
+      engine->GetDocumentAttachmentInfoList();
+  ASSERT_EQ(3u, attachments.size());
+
+  {
+    const DocumentAttachmentInfo& attachment = attachments[0];
+    EXPECT_EQ("1.txt", base::UTF16ToUTF8(attachment.name));
+    EXPECT_TRUE(attachment.is_readable);
+    EXPECT_EQ(4u, attachment.size_bytes);
+    EXPECT_EQ("D:20170712214438-07'00'",
+              base::UTF16ToUTF8(attachment.creation_date));
+    EXPECT_EQ("D:20160115091400", base::UTF16ToUTF8(attachment.modified_date));
+
+    std::vector<uint8_t> content = engine->GetAttachmentData(0);
+    ASSERT_EQ(attachment.size_bytes, content.size());
+    std::string content_str(content.begin(), content.end());
+    EXPECT_EQ("test", content_str);
+  }
+
+  {
+    static constexpr char kCheckSum[] = "72afcddedf554dda63c0c88e06f1ce18";
+    const DocumentAttachmentInfo& attachment = attachments[1];
+    EXPECT_EQ("attached.pdf", base::UTF16ToUTF8(attachment.name));
+    EXPECT_TRUE(attachment.is_readable);
+    EXPECT_EQ(5869u, attachment.size_bytes);
+    EXPECT_EQ("D:20170712214443-07'00'",
+              base::UTF16ToUTF8(attachment.creation_date));
+    EXPECT_EQ("D:20170712214410", base::UTF16ToUTF8(attachment.modified_date));
+
+    std::vector<uint8_t> content = engine->GetAttachmentData(1);
+    ASSERT_EQ(attachment.size_bytes, content.size());
+    // The whole attachment content is too long to do string comparison.
+    // Instead, we only verify the checksum value here.
+    base::MD5Digest hash;
+    base::MD5Sum(content.data(), content.size(), &hash);
+    EXPECT_EQ(kCheckSum, base::MD5DigestToBase16(hash));
+  }
+
+  {
+    // Test attachments with no creation date or last modified date.
+    const DocumentAttachmentInfo& attachment = attachments[2];
+    EXPECT_EQ(".txt", base::UTF16ToUTF8(attachment.name));
+    EXPECT_TRUE(attachment.is_readable);
+    EXPECT_EQ(5u, attachment.size_bytes);
+    EXPECT_THAT(attachment.creation_date, IsEmpty());
+    EXPECT_THAT(attachment.modified_date, IsEmpty());
+
+    std::vector<uint8_t> content = engine->GetAttachmentData(2);
+    ASSERT_EQ(attachment.size_bytes, content.size());
+    std::string content_str(content.begin(), content.end());
+    EXPECT_EQ("test\n", content_str);
+  }
+}
+
+TEST_F(PDFiumEngineTest, GetInvalidDocumentAttachment) {
+  NiceMock<MockTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("invalid_attachment.pdf"));
+  ASSERT_TRUE(engine);
+
+  // Test on a document with one invalid attachment, which can make
+  // FPDFDoc_GetAttachment() fail. This particular attachment is invalid due
+  // to its key value violating the `Limits` entry.
+  const std::vector<DocumentAttachmentInfo>& attachments =
+      engine->GetDocumentAttachmentInfoList();
+  ASSERT_EQ(1u, attachments.size());
+
+  const DocumentAttachmentInfo& attachment = attachments[0];
+  EXPECT_THAT(attachment.name, IsEmpty());
+  EXPECT_FALSE(attachment.is_readable);
+  EXPECT_EQ(0u, attachment.size_bytes);
+  EXPECT_THAT(attachment.creation_date, IsEmpty());
+  EXPECT_THAT(attachment.modified_date, IsEmpty());
+}
+
+TEST_F(PDFiumEngineTest, GetDocumentAttachmentWithInvalidData) {
+  NiceMock<MockTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("embedded_attachments_invalid_data.pdf"));
+  ASSERT_TRUE(engine);
+
+  const std::vector<DocumentAttachmentInfo>& attachments =
+      engine->GetDocumentAttachmentInfoList();
+  ASSERT_EQ(1u, attachments.size());
+
+  // Test on an attachment which FPDFAttachment_GetFile() fails to retrieve data
+  // from.
+  const DocumentAttachmentInfo& attachment = attachments[0];
+  EXPECT_EQ("1.txt", base::UTF16ToUTF8(attachment.name));
+  EXPECT_FALSE(attachment.is_readable);
+  EXPECT_EQ(0u, attachment.size_bytes);
+  EXPECT_THAT(attachment.creation_date, IsEmpty());
+  EXPECT_THAT(attachment.modified_date, IsEmpty());
+}
+
+TEST_F(PDFiumEngineTest, NoDocumentAttachmentInfo) {
+  NiceMock<MockTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("hello_world2.pdf"));
+  ASSERT_TRUE(engine);
+
+  EXPECT_EQ(0u, engine->GetDocumentAttachmentInfoList().size());
+}
+
+TEST_F(PDFiumEngineTest, GetDocumentMetadata) {
+  NiceMock<MockTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("document_info.pdf"));
+  ASSERT_TRUE(engine);
+
+  const DocumentMetadata& doc_metadata = engine->GetDocumentMetadata();
+
+  EXPECT_EQ(PdfVersion::k1_7, doc_metadata.version);
+  EXPECT_EQ(714u, doc_metadata.size_bytes);
+  EXPECT_FALSE(doc_metadata.linearized);
+  EXPECT_EQ("Sample PDF Document Info", doc_metadata.title);
+  EXPECT_EQ("Chromium Authors", doc_metadata.author);
+  EXPECT_EQ("Testing", doc_metadata.subject);
+  EXPECT_EQ("testing,chromium,pdfium,document,info", doc_metadata.keywords);
+  EXPECT_EQ("Your Preferred Text Editor", doc_metadata.creator);
+  EXPECT_EQ("fixup_pdf_template.py", doc_metadata.producer);
+
+  base::Time expected_creation_date;
+  ASSERT_TRUE(base::Time::FromUTCString("2020-02-05 15:39:12",
+                                        &expected_creation_date));
+  EXPECT_EQ(expected_creation_date, doc_metadata.creation_date);
+
+  base::Time expected_mod_date;
+  ASSERT_TRUE(
+      base::Time::FromUTCString("2020-02-06 09:42:34", &expected_mod_date));
+  EXPECT_EQ(expected_mod_date, doc_metadata.mod_date);
+}
+
+TEST_F(PDFiumEngineTest, GetEmptyDocumentMetadata) {
+  NiceMock<MockTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("hello_world2.pdf"));
+  ASSERT_TRUE(engine);
+
+  const DocumentMetadata& doc_metadata = engine->GetDocumentMetadata();
+
+  EXPECT_EQ(PdfVersion::k1_7, doc_metadata.version);
+  EXPECT_EQ(786u, doc_metadata.size_bytes);
+  EXPECT_FALSE(doc_metadata.linearized);
+  EXPECT_THAT(doc_metadata.title, IsEmpty());
+  EXPECT_THAT(doc_metadata.author, IsEmpty());
+  EXPECT_THAT(doc_metadata.subject, IsEmpty());
+  EXPECT_THAT(doc_metadata.keywords, IsEmpty());
+  EXPECT_THAT(doc_metadata.creator, IsEmpty());
+  EXPECT_THAT(doc_metadata.producer, IsEmpty());
+  EXPECT_TRUE(doc_metadata.creation_date.is_null());
+  EXPECT_TRUE(doc_metadata.mod_date.is_null());
+}
+
+TEST_F(PDFiumEngineTest, GetLinearizedDocumentMetadata) {
+  NiceMock<MockTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("linearized.pdf"));
+  ASSERT_TRUE(engine);
+  EXPECT_TRUE(engine->GetDocumentMetadata().linearized);
+}
+
+TEST_F(PDFiumEngineTest, GetBadPdfVersion) {
+  NiceMock<MockTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("bad_version.pdf"));
+  ASSERT_TRUE(engine);
+
+  const DocumentMetadata& doc_metadata = engine->GetDocumentMetadata();
+  EXPECT_EQ(PdfVersion::kUnknown, doc_metadata.version);
+}
+
+TEST_F(PDFiumEngineTest, IncrementalLoadingFeatureDefault) {
+  EXPECT_FALSE(TryLoadIncrementally());
+}
+
+TEST_F(PDFiumEngineTest, IncrementalLoadingFeatureEnabled) {
+  base::test::ScopedFeatureList scoped_feature_list;
+  scoped_feature_list.InitAndEnableFeature(features::kPdfIncrementalLoading);
+  EXPECT_TRUE(TryLoadIncrementally());
+}
+
+TEST_F(PDFiumEngineTest, IncrementalLoadingFeatureDisabled) {
+  base::test::ScopedFeatureList scoped_feature_list;
+  scoped_feature_list.InitAndDisableFeature(features::kPdfIncrementalLoading);
+  EXPECT_FALSE(TryLoadIncrementally());
+}
+
+TEST_F(PDFiumEngineTest, RequestThumbnail) {
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("rectangles_multi_pages.pdf"));
+  ASSERT_TRUE(engine);
+
+  const int num_pages = engine->GetNumberOfPages();
+  ASSERT_EQ(5, num_pages);
+  ASSERT_EQ(num_pages, CountAvailablePages(*engine));
+
+  // Each page should immediately return a thumbnail.
+  for (int i = 0; i < num_pages; ++i) {
+    base::MockCallback<SendThumbnailCallback> send_callback;
+    EXPECT_CALL(send_callback, Run);
+    engine->RequestThumbnail(/*page_index=*/i, /*device_pixel_ratio=*/1,
+                             send_callback.Get());
+  }
+}
+
+TEST_F(PDFiumEngineTest, RequestThumbnailLinearized) {
+  base::test::ScopedFeatureList scoped_feature_list;
+  scoped_feature_list.InitAndEnableFeature(features::kPdfIncrementalLoading);
+
+  NiceMock<MockTestClient> client;
+  InitializeEngineResult initialize_result = InitializeEngineWithoutLoading(
+      &client, FILE_PATH_LITERAL("linearized.pdf"));
+  ASSERT_TRUE(initialize_result.engine);
+  PDFiumEngine& engine = *initialize_result.engine;
+
+  // Load only some pages.
+  initialize_result.document_loader->SimulateLoadData(8192);
+
+  // Note: Plugin size chosen so all pages of the document are visible. The
+  // engine only updates availability incrementally for visible pages.
+  engine.PluginSizeUpdated({1024, 4096});
+
+  const int num_pages = engine.GetNumberOfPages();
+  ASSERT_EQ(3, num_pages);
+  const int available_pages = CountAvailablePages(engine);
+  ASSERT_LT(0, available_pages);
+  ASSERT_GT(num_pages, available_pages);
+
+  // Initialize callbacks for first and last pages.
+  base::MockCallback<SendThumbnailCallback> first_loaded;
+  base::MockCallback<SendThumbnailCallback> last_loaded;
+
+  // When the document is partially loaded, `SendThumbnailCallback` is only run
+  // for the loaded page even though `RequestThumbnail()` gets called for both
+  // pages.
+  EXPECT_CALL(first_loaded, Run);
+  engine.RequestThumbnail(/*page_index=*/0, /*device_pixel_ratio=*/1,
+                          first_loaded.Get());
+  engine.RequestThumbnail(/*page_index=*/num_pages - 1,
+                          /*device_pixel_ratio=*/1, last_loaded.Get());
+
+  // Finish loading the document. `SendThumbnailCallback` should be run for the
+  // last page.
+  EXPECT_CALL(last_loaded, Run);
+  while (initialize_result.document_loader->SimulateLoadData(UINT32_MAX))
+    continue;
+}
+
+using PDFiumEngineDeathTest = PDFiumEngineTest;
+
+TEST_F(PDFiumEngineDeathTest, RequestThumbnailRedundant) {
+  ::testing::FLAGS_gtest_death_test_style = "threadsafe";
+  base::test::ScopedFeatureList scoped_feature_list;
+  scoped_feature_list.InitAndEnableFeature(features::kPdfIncrementalLoading);
+
+  NiceMock<MockTestClient> client;
+  InitializeEngineResult initialize_result = InitializeEngineWithoutLoading(
+      &client, FILE_PATH_LITERAL("linearized.pdf"));
+  ASSERT_TRUE(initialize_result.engine);
+  PDFiumEngine& engine = *initialize_result.engine;
+
+  // Load only some pages.
+  initialize_result.document_loader->SimulateLoadData(8192);
+
+  // Twice request a thumbnail for the second page, which is not loaded. The
+  // second call should crash.
+  base::MockCallback<SendThumbnailCallback> mock_callback;
+  engine.RequestThumbnail(/*page_index=*/1, /*device_pixel_ratio=*/1,
+                          mock_callback.Get());
+  EXPECT_DCHECK_DEATH(engine.RequestThumbnail(
+      /*page_index=*/1, /*device_pixel_ratio=*/1, mock_callback.Get()));
+}
+
+class TabbingTestClient : public TestClient {
+ public:
+  TabbingTestClient() = default;
+  ~TabbingTestClient() override = default;
+  TabbingTestClient(const TabbingTestClient&) = delete;
+  TabbingTestClient& operator=(const TabbingTestClient&) = delete;
+
+  // Mock PDFEngine::Client methods.
+  MOCK_METHOD(void, DocumentFocusChanged, (bool), (override));
+};
+
+class PDFiumEngineTabbingTest : public PDFiumTestBase {
+ public:
+  PDFiumEngineTabbingTest() = default;
+  ~PDFiumEngineTabbingTest() override = default;
+  PDFiumEngineTabbingTest(const PDFiumEngineTabbingTest&) = delete;
+  PDFiumEngineTabbingTest& operator=(const PDFiumEngineTabbingTest&) = delete;
+
+  bool HandleTabEvent(PDFiumEngine* engine, uint32_t modifiers) {
+    return engine->HandleTabEvent(modifiers);
+  }
+
+  PDFiumEngine::FocusElementType GetFocusedElementType(PDFiumEngine* engine) {
+    return engine->focus_item_type_;
+  }
+
+  int GetLastFocusedPage(PDFiumEngine* engine) {
+    return engine->last_focused_page_;
+  }
+
+  PDFiumEngine::FocusElementType GetLastFocusedElementType(
+      PDFiumEngine* engine) {
+    return engine->last_focused_item_type_;
+  }
+
+  int GetLastFocusedAnnotationIndex(PDFiumEngine* engine) {
+    return engine->last_focused_annot_index_;
+  }
+
+  bool IsInFormTextArea(PDFiumEngine* engine) {
+    return engine->in_form_text_area_;
+  }
+
+  size_t GetSelectionSize(PDFiumEngine* engine) {
+    return engine->selection_.size();
+  }
+
+  const std::string& GetLinkUnderCursor(PDFiumEngine* engine) {
+    return engine->link_under_cursor_;
+  }
+
+  void ScrollFocusedAnnotationIntoView(PDFiumEngine* engine) {
+    engine->ScrollFocusedAnnotationIntoView();
+  }
+
+ protected:
+  base::test::TaskEnvironment task_environment_{
+      base::test::TaskEnvironment::TimeSource::MOCK_TIME};
+};
+
+TEST_F(PDFiumEngineTabbingTest, LinkUnderCursorTest) {
+  /*
+   * Document structure
+   * Document
+   * ++ Page 1
+   * ++++ Widget annotation
+   * ++++ Widget annotation
+   * ++++ Highlight annotation
+   * ++++ Link annotation
+   */
+  // Enable feature flag.
+  base::test::ScopedFeatureList scoped_feature_list;
+  scoped_feature_list.InitAndEnableFeature(
+      chrome_pdf::features::kTabAcrossPDFAnnotations);
+
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("annots.pdf"));
+  ASSERT_TRUE(engine);
+
+  // Initial value of link under cursor.
+  EXPECT_EQ("", GetLinkUnderCursor(engine.get()));
+
+  // Tab through non-link annotations and validate link under cursor.
+  for (int i = 0; i < 4; i++) {
+    ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+    EXPECT_EQ("", GetLinkUnderCursor(engine.get()));
+  }
+
+  // Tab to Link annotation.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ("https://www.google.com/", GetLinkUnderCursor(engine.get()));
+
+  // Tab to previous annotation.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), kInputEventModifierShiftKey));
+  EXPECT_EQ("", GetLinkUnderCursor(engine.get()));
+}
+
+TEST_F(PDFiumEngineTabbingTest, TabbingSupportedAnnots) {
+  /*
+   * Document structure
+   * Document
+   * ++ Page 1
+   * ++++ Widget annotation
+   * ++++ Widget annotation
+   * ++++ Highlight annotation
+   * ++++ Link annotation
+   */
+
+  // Enable feature flag.
+  base::test::ScopedFeatureList scoped_feature_list;
+  scoped_feature_list.InitAndEnableFeature(
+      chrome_pdf::features::kTabAcrossPDFAnnotations);
+
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("annots.pdf"));
+  ASSERT_TRUE(engine);
+
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  ASSERT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(-1, GetLastFocusedPage(engine.get()));
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kDocument,
+            GetFocusedElementType(engine.get()));
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+
+  ASSERT_FALSE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+}
+
+TEST_F(PDFiumEngineTabbingTest, TabbingForwardTest) {
+  /*
+   * Document structure
+   * Document
+   * ++ Page 1
+   * ++++ Annotation
+   * ++++ Annotation
+   * ++ Page 2
+   * ++++ Annotation
+   */
+  TabbingTestClient client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("annotation_form_fields.pdf"));
+  ASSERT_TRUE(engine);
+
+  ASSERT_EQ(2, engine->GetNumberOfPages());
+
+  static constexpr bool kExpectedFocusState[] = {true, false};
+  {
+    InSequence sequence;
+    for (auto focused : kExpectedFocusState)
+      EXPECT_CALL(client, DocumentFocusChanged(focused));
+  }
+
+  ASSERT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(-1, GetLastFocusedPage(engine.get()));
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kDocument,
+            GetFocusedElementType(engine.get()));
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(1, GetLastFocusedPage(engine.get()));
+
+  ASSERT_FALSE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+}
+
+TEST_F(PDFiumEngineTabbingTest, TabbingBackwardTest) {
+  /*
+   * Document structure
+   * Document
+   * ++ Page 1
+   * ++++ Annotation
+   * ++++ Annotation
+   * ++ Page 2
+   * ++++ Annotation
+   */
+  TabbingTestClient client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("annotation_form_fields.pdf"));
+  ASSERT_TRUE(engine);
+
+  ASSERT_EQ(2, engine->GetNumberOfPages());
+
+  static constexpr bool kExpectedFocusState[] = {true, false};
+  {
+    InSequence sequence;
+    for (auto focused : kExpectedFocusState)
+      EXPECT_CALL(client, DocumentFocusChanged(focused));
+  }
+
+  ASSERT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(-1, GetLastFocusedPage(engine.get()));
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), kInputEventModifierShiftKey));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(1, GetLastFocusedPage(engine.get()));
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), kInputEventModifierShiftKey));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), kInputEventModifierShiftKey));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), kInputEventModifierShiftKey));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kDocument,
+            GetFocusedElementType(engine.get()));
+
+  ASSERT_FALSE(HandleTabEvent(engine.get(), kInputEventModifierShiftKey));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+}
+
+TEST_F(PDFiumEngineTabbingTest, TabbingWithModifiers) {
+  /*
+   * Document structure
+   * Document
+   * ++ Page 1
+   * ++++ Annotation
+   * ++++ Annotation
+   * ++ Page 2
+   * ++++ Annotation
+   */
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("annotation_form_fields.pdf"));
+  ASSERT_TRUE(engine);
+
+  ASSERT_EQ(2, engine->GetNumberOfPages());
+
+  ASSERT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(-1, GetLastFocusedPage(engine.get()));
+
+  // Tabbing with ctrl modifier.
+  ASSERT_FALSE(HandleTabEvent(engine.get(), kInputEventModifierControlKey));
+  // Tabbing with alt modifier.
+  ASSERT_FALSE(HandleTabEvent(engine.get(), kInputEventModifierAltKey));
+
+  // Tab to bring document into focus.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kDocument,
+            GetFocusedElementType(engine.get()));
+
+  // Tabbing with ctrl modifier.
+  ASSERT_FALSE(HandleTabEvent(engine.get(), kInputEventModifierControlKey));
+  // Tabbing with alt modifier.
+  ASSERT_FALSE(HandleTabEvent(engine.get(), kInputEventModifierAltKey));
+
+  // Tab to bring first page into focus.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+
+  // Tabbing with ctrl modifier.
+  ASSERT_FALSE(HandleTabEvent(engine.get(), kInputEventModifierControlKey));
+  // Tabbing with alt modifier.
+  ASSERT_FALSE(HandleTabEvent(engine.get(), kInputEventModifierAltKey));
+}
+
+TEST_F(PDFiumEngineTabbingTest, NoFocusableItemTabbingTest) {
+  /*
+   * Document structure
+   * Document
+   * ++ Page 1
+   * ++ Page 2
+   */
+  TabbingTestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("hello_world2.pdf"));
+  ASSERT_TRUE(engine);
+
+  ASSERT_EQ(2, engine->GetNumberOfPages());
+
+  static constexpr bool kExpectedFocusState[] = {true, false, true, false};
+  {
+    InSequence sequence;
+    for (auto focused : kExpectedFocusState)
+      EXPECT_CALL(client, DocumentFocusChanged(focused));
+  }
+
+  ASSERT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(-1, GetLastFocusedPage(engine.get()));
+
+  // Tabbing forward.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kDocument,
+            GetFocusedElementType(engine.get()));
+
+  ASSERT_FALSE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+
+  // Tabbing backward.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), kInputEventModifierShiftKey));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kDocument,
+            GetFocusedElementType(engine.get()));
+
+  ASSERT_FALSE(HandleTabEvent(engine.get(), kInputEventModifierShiftKey));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+}
+
+TEST_F(PDFiumEngineTabbingTest, RestoringDocumentFocusTest) {
+  /*
+   * Document structure
+   * Document
+   * ++ Page 1
+   * ++++ Annotation
+   * ++++ Annotation
+   * ++ Page 2
+   * ++++ Annotation
+   */
+  TabbingTestClient client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("annotation_form_fields.pdf"));
+  ASSERT_TRUE(engine);
+
+  ASSERT_EQ(2, engine->GetNumberOfPages());
+
+  static constexpr bool kExpectedFocusState[] = {true, false, true};
+  {
+    InSequence sequence;
+    for (auto focused : kExpectedFocusState)
+      EXPECT_CALL(client, DocumentFocusChanged(focused));
+  }
+
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(-1, GetLastFocusedPage(engine.get()));
+
+  // Tabbing to bring the document into focus.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kDocument,
+            GetFocusedElementType(engine.get()));
+
+  engine->UpdateFocus(/*has_focus=*/false);
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kDocument,
+            GetLastFocusedElementType(engine.get()));
+  EXPECT_EQ(-1, GetLastFocusedAnnotationIndex(engine.get()));
+
+  engine->UpdateFocus(/*has_focus=*/true);
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kDocument,
+            GetFocusedElementType(engine.get()));
+}
+
+TEST_F(PDFiumEngineTabbingTest, RestoringAnnotFocusTest) {
+  /*
+   * Document structure
+   * Document
+   * ++ Page 1
+   * ++++ Annotation
+   * ++++ Annotation
+   * ++ Page 2
+   * ++++ Annotation
+   */
+  TabbingTestClient client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("annotation_form_fields.pdf"));
+  ASSERT_TRUE(engine);
+
+  ASSERT_EQ(2, engine->GetNumberOfPages());
+
+  static constexpr bool kExpectedFocusState[] = {true, false};
+  {
+    InSequence sequence;
+    for (auto focused : kExpectedFocusState)
+      EXPECT_CALL(client, DocumentFocusChanged(focused));
+  }
+
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(-1, GetLastFocusedPage(engine.get()));
+
+  // Tabbing to bring last annotation of page 0 into focus.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+
+  engine->UpdateFocus(/*has_focus=*/false);
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetLastFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedAnnotationIndex(engine.get()));
+
+  engine->UpdateFocus(/*has_focus=*/true);
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+
+  // Tabbing now should bring the second page's annotation to focus.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(1, GetLastFocusedPage(engine.get()));
+}
+
+TEST_F(PDFiumEngineTabbingTest, VerifyFormFieldStatesOnTabbing) {
+  /*
+   * Document structure
+   * Document
+   * ++ Page 1
+   * ++++ Annotation (Text Field)
+   * ++++ Annotation (Radio Button)
+   */
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("annots.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kDocument,
+            GetFocusedElementType(engine.get()));
+
+  // Bring focus to the text field.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+  EXPECT_TRUE(IsInFormTextArea(engine.get()));
+  EXPECT_TRUE(engine->CanEditText());
+
+  // Bring focus to the button.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+  EXPECT_FALSE(IsInFormTextArea(engine.get()));
+  EXPECT_FALSE(engine->CanEditText());
+}
+
+TEST_F(PDFiumEngineTabbingTest, ClearSelectionOnFocusInFormTextArea) {
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("form_text_fields.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(-1, GetLastFocusedPage(engine.get()));
+
+  // Select all text.
+  engine->SelectAll();
+  EXPECT_EQ(1u, GetSelectionSize(engine.get()));
+
+  // Tab to bring focus to a form text area annotation.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+  EXPECT_EQ(0u, GetSelectionSize(engine.get()));
+}
+
+TEST_F(PDFiumEngineTabbingTest, RetainSelectionOnFocusNotInFormTextArea) {
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("annots.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(-1, GetLastFocusedPage(engine.get()));
+
+  // Select all text.
+  engine->SelectAll();
+  EXPECT_EQ(1u, GetSelectionSize(engine.get()));
+
+  // Tab to bring focus to a non form text area annotation (Button).
+  ASSERT_TRUE(HandleTabEvent(engine.get(), kInputEventModifierShiftKey));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+  EXPECT_EQ(1u, GetSelectionSize(engine.get()));
+}
+
+class ScrollingTestClient : public TestClient {
+ public:
+  ScrollingTestClient() = default;
+  ~ScrollingTestClient() override = default;
+  ScrollingTestClient(const ScrollingTestClient&) = delete;
+  ScrollingTestClient& operator=(const ScrollingTestClient&) = delete;
+
+  // Mock PDFEngine::Client methods.
+  MOCK_METHOD(void, ScrollToX, (int), (override));
+  MOCK_METHOD(void, ScrollToY, (int), (override));
+};
+
+TEST_F(PDFiumEngineTabbingTest, MaintainViewportWhenFocusIsUpdated) {
+  StrictMock<ScrollingTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("annotation_form_fields.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(2, engine->GetNumberOfPages());
+  engine->PluginSizeUpdated(gfx::Size(60, 40));
+
+  {
+    InSequence sequence;
+    static constexpr gfx::Point kScrollValue = {510, 478};
+    EXPECT_CALL(client, ScrollToY(kScrollValue.y()))
+        .WillOnce(Invoke(
+            [&engine]() { engine->ScrolledToYPosition(kScrollValue.y()); }));
+    EXPECT_CALL(client, ScrollToX(kScrollValue.x()))
+        .WillOnce(Invoke(
+            [&engine]() { engine->ScrolledToXPosition(kScrollValue.x()); }));
+  }
+
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(-1, GetLastFocusedPage(engine.get()));
+
+  // Tabbing to bring the document into focus.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kDocument,
+            GetFocusedElementType(engine.get()));
+
+  // Tab to an annotation.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+
+  // Scroll focused annotation out of viewport.
+  static constexpr gfx::Point kScrollPosition = {242, 746};
+  engine->ScrolledToXPosition(kScrollPosition.x());
+  engine->ScrolledToYPosition(kScrollPosition.y());
+
+  engine->UpdateFocus(/*has_focus=*/false);
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetLastFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(1, GetLastFocusedAnnotationIndex(engine.get()));
+
+  // Restore focus, we shouldn't have any calls to scroll viewport.
+  engine->UpdateFocus(/*has_focus=*/true);
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(0, GetLastFocusedPage(engine.get()));
+}
+
+TEST_F(PDFiumEngineTabbingTest, ScrollFocusedAnnotationIntoView) {
+  StrictMock<ScrollingTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("annotation_form_fields.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(2, engine->GetNumberOfPages());
+  engine->PluginSizeUpdated(gfx::Size(60, 40));
+
+  {
+    InSequence sequence;
+    static constexpr gfx::Point kScrollValues[] = {{510, 478}, {510, 478}};
+
+    for (const auto& scroll_value : kScrollValues) {
+      EXPECT_CALL(client, ScrollToY(scroll_value.y()))
+          .WillOnce(Invoke([&engine, &scroll_value]() {
+            engine->ScrolledToYPosition(scroll_value.y());
+          }));
+      EXPECT_CALL(client, ScrollToX(scroll_value.x()))
+          .WillOnce(Invoke([&engine, &scroll_value]() {
+            engine->ScrolledToXPosition(scroll_value.x());
+          }));
+    }
+  }
+
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kNone,
+            GetFocusedElementType(engine.get()));
+  EXPECT_EQ(-1, GetLastFocusedPage(engine.get()));
+
+  // Tabbing to bring the document into focus.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kDocument,
+            GetFocusedElementType(engine.get()));
+
+  // Tab to an annotation.
+  ASSERT_TRUE(HandleTabEvent(engine.get(), 0));
+  EXPECT_EQ(PDFiumEngine::FocusElementType::kPage,
+            GetFocusedElementType(engine.get()));
+
+  // Scroll focused annotation out of viewport.
+  static constexpr gfx::Point kScrollPosition = {242, 746};
+  engine->ScrolledToXPosition(kScrollPosition.x());
+  engine->ScrolledToYPosition(kScrollPosition.y());
+
+  // Scroll the focused annotation into view.
+  ScrollFocusedAnnotationIntoView(engine.get());
+}
+
+class ReadOnlyTestClient : public TestClient {
+ public:
+  ReadOnlyTestClient() = default;
+  ~ReadOnlyTestClient() override = default;
+  ReadOnlyTestClient(const ReadOnlyTestClient&) = delete;
+  ReadOnlyTestClient& operator=(const ReadOnlyTestClient&) = delete;
+
+  // Mock PDFEngine::Client methods.
+  MOCK_METHOD(void, FormTextFieldFocusChange, (bool), (override));
+  MOCK_METHOD(void, SetSelectedText, (const std::string&), (override));
+};
+
+using PDFiumEngineReadOnlyTest = PDFiumTestBase;
+
+TEST_F(PDFiumEngineReadOnlyTest, KillFormFocus) {
+  NiceMock<ReadOnlyTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("annotation_form_fields.pdf"));
+  ASSERT_TRUE(engine);
+
+  // Setting read-only mode should kill form focus.
+  EXPECT_FALSE(engine->IsReadOnly());
+  EXPECT_CALL(client, FormTextFieldFocusChange(false));
+  engine->SetReadOnly(true);
+
+  // Attempting to focus during read-only mode should once more trigger a
+  // killing of form focus.
+  EXPECT_TRUE(engine->IsReadOnly());
+  EXPECT_CALL(client, FormTextFieldFocusChange(false));
+  engine->UpdateFocus(true);
+}
+
+TEST_F(PDFiumEngineReadOnlyTest, UnselectText) {
+  NiceMock<ReadOnlyTestClient> client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("hello_world2.pdf"));
+  ASSERT_TRUE(engine);
+
+  // Update the plugin size so that all the text is visible by
+  // `SelectionChangeInvalidator`.
+  engine->PluginSizeUpdated({500, 500});
+
+  // Select text before going into read-only mode.
+  EXPECT_FALSE(engine->IsReadOnly());
+  EXPECT_CALL(client, SetSelectedText(Not(IsEmpty())));
+  engine->SelectAll();
+
+  // Setting read-only mode should unselect the text.
+  EXPECT_CALL(client, SetSelectedText(IsEmpty()));
+  engine->SetReadOnly(true);
+}
+
+}  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_font_linux.cc b/pdf/pdfium/pdfium_font_linux.cc
new file mode 100644
index 000000000000..dd7f4f48c64d
--- /dev/null
+++ b/pdf/pdfium/pdfium_font_linux.cc
@@ -0,0 +1,207 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "pdf/pdfium/pdfium_font_linux.h"
+
+#include <algorithm>
+#include <string>
+
+#include "base/i18n/encoding_detection.h"
+#include "base/i18n/icu_string_conversions.h"
+#include "base/notreached.h"
+#include "base/numerics/ranges.h"
+#include "base/stl_util.h"
+#include "base/strings/string_util.h"
+#include "ppapi/cpp/instance.h"
+#include "ppapi/cpp/module.h"
+#include "ppapi/cpp/private/pdf.h"
+#include "ppapi/cpp/trusted/browser_font_trusted.h"
+#include "third_party/pdfium/public/fpdf_sysfontinfo.h"
+
+namespace chrome_pdf {
+
+namespace {
+
+PP_Instance g_last_instance_id;
+
+PP_BrowserFont_Trusted_Weight WeightToBrowserFontTrustedWeight(int weight) {
+  static_assert(PP_BROWSERFONT_TRUSTED_WEIGHT_100 == 0,
+                "PP_BrowserFont_Trusted_Weight min");
+  static_assert(PP_BROWSERFONT_TRUSTED_WEIGHT_900 == 8,
+                "PP_BrowserFont_Trusted_Weight max");
+  constexpr int kMinimumWeight = 100;
+  constexpr int kMaximumWeight = 900;
+  int normalized_weight =
+      base::ClampToRange(weight, kMinimumWeight, kMaximumWeight);
+  normalized_weight = (normalized_weight / 100) - 1;
+  return static_cast<PP_BrowserFont_Trusted_Weight>(normalized_weight);
+}
+
+// This list is for CPWL_FontMap::GetDefaultFontByCharset().
+// We pretend to have these font natively and let the browser (or underlying
+// fontconfig) pick the proper font on the system.
+void EnumFonts(FPDF_SYSFONTINFO* sysfontinfo, void* mapper) {
+  FPDF_AddInstalledFont(mapper, "Arial", FXFONT_DEFAULT_CHARSET);
+
+  const FPDF_CharsetFontMap* font_map = FPDF_GetDefaultTTFMap();
+  for (; font_map->charset != -1; ++font_map) {
+    FPDF_AddInstalledFont(mapper, font_map->fontname, font_map->charset);
+  }
+}
+
+void* MapFont(FPDF_SYSFONTINFO*,
+              int weight,
+              int italic,
+              int charset,
+              int pitch_family,
+              const char* face,
+              int* exact) {
+  // Do not attempt to map fonts if PPAPI is not initialized (for Privet local
+  // printing).
+  // TODO(noamsml): Real font substitution (http://crbug.com/391978)
+  if (!pp::Module::Get())
+    return nullptr;
+
+  pp::BrowserFontDescription description;
+
+  // Pretend the system does not have the Symbol font to force a fallback to
+  // the built in Symbol font in CFX_FontMapper::FindSubstFont().
+  if (strcmp(face, "Symbol") == 0)
+    return nullptr;
+
+  if (pitch_family & FXFONT_FF_FIXEDPITCH) {
+    description.set_family(PP_BROWSERFONT_TRUSTED_FAMILY_MONOSPACE);
+  } else if (pitch_family & FXFONT_FF_ROMAN) {
+    description.set_family(PP_BROWSERFONT_TRUSTED_FAMILY_SERIF);
+  }
+
+  static const struct {
+    const char* pdf_name;
+    const char* face;
+    bool bold;
+    bool italic;
+  } kPdfFontSubstitutions[] = {
+      {"Courier", "Courier New", false, false},
+      {"Courier-Bold", "Courier New", true, false},
+      {"Courier-BoldOblique", "Courier New", true, true},
+      {"Courier-Oblique", "Courier New", false, true},
+      {"Helvetica", "Arial", false, false},
+      {"Helvetica-Bold", "Arial", true, false},
+      {"Helvetica-BoldOblique", "Arial", true, true},
+      {"Helvetica-Oblique", "Arial", false, true},
+      {"Times-Roman", "Times New Roman", false, false},
+      {"Times-Bold", "Times New Roman", true, false},
+      {"Times-BoldItalic", "Times New Roman", true, true},
+      {"Times-Italic", "Times New Roman", false, true},
+
+      // MS P?(Mincho|Gothic) are the most notable fonts in Japanese PDF files
+      // without embedding the glyphs. Sometimes the font names are encoded
+      // in Japanese Windows's locale (CP932/Shift_JIS) without space.
+      // Most Linux systems don't have the exact font, but for outsourcing
+      // fontconfig to find substitutable font in the system, we pass ASCII
+      // font names to it.
+      {"MS-PGothic", "MS PGothic", false, false},
+      {"MS-Gothic", "MS Gothic", false, false},
+      {"MS-PMincho", "MS PMincho", false, false},
+      {"MS-Mincho", "MS Mincho", false, false},
+      // MS PGothic in Shift_JIS encoding.
+      {"\x82\x6C\x82\x72\x82\x6F\x83\x53\x83\x56\x83\x62\x83\x4E", "MS PGothic",
+       false, false},
+      // MS Gothic in Shift_JIS encoding.
+      {"\x82\x6C\x82\x72\x83\x53\x83\x56\x83\x62\x83\x4E", "MS Gothic", false,
+       false},
+      // MS PMincho in Shift_JIS encoding.
+      {"\x82\x6C\x82\x72\x82\x6F\x96\xBE\x92\xA9", "MS PMincho", false, false},
+      // MS Mincho in Shift_JIS encoding.
+      {"\x82\x6C\x82\x72\x96\xBE\x92\xA9", "MS Mincho", false, false},
+  };
+
+  // Similar logic exists in PDFium's CFX_FolderFontInfo::FindFont().
+  if (charset == FXFONT_ANSI_CHARSET && (pitch_family & FXFONT_FF_FIXEDPITCH))
+    face = "Courier New";
+
+  // Map from the standard PDF fonts to TrueType font names.
+  size_t i;
+  for (i = 0; i < base::size(kPdfFontSubstitutions); ++i) {
+    if (strcmp(face, kPdfFontSubstitutions[i].pdf_name) == 0) {
+      description.set_face(kPdfFontSubstitutions[i].face);
+      if (kPdfFontSubstitutions[i].bold)
+        description.set_weight(PP_BROWSERFONT_TRUSTED_WEIGHT_BOLD);
+      if (kPdfFontSubstitutions[i].italic)
+        description.set_italic(true);
+      break;
+    }
+  }
+
+  if (i == base::size(kPdfFontSubstitutions)) {
+    // Convert to UTF-8 before calling set_face().
+    std::string face_utf8;
+    if (base::IsStringUTF8(face)) {
+      face_utf8 = face;
+    } else {
+      std::string encoding;
+      if (base::DetectEncoding(face, &encoding)) {
+        // ConvertToUtf8AndNormalize() clears |face_utf8| on failure.
+        base::ConvertToUtf8AndNormalize(face, encoding, &face_utf8);
+      }
+    }
+
+    if (face_utf8.empty())
+      return nullptr;
+
+    description.set_face(face_utf8);
+    description.set_weight(WeightToBrowserFontTrustedWeight(weight));
+    description.set_italic(italic > 0);
+  }
+
+  if (!pp::PDF::IsAvailable()) {
+    NOTREACHED();
+    return nullptr;
+  }
+
+  PP_Resource font_resource = pp::PDF::GetFontFileWithFallback(
+      pp::InstanceHandle(g_last_instance_id),
+      &description.pp_font_description(),
+      static_cast<PP_PrivateFontCharset>(charset));
+  long res_id = font_resource;
+  return reinterpret_cast<void*>(res_id);
+}
+
+unsigned long GetFontData(FPDF_SYSFONTINFO*,
+                          void* font_id,
+                          unsigned int table,
+                          unsigned char* buffer,
+                          unsigned long buf_size) {
+  if (!pp::PDF::IsAvailable()) {
+    NOTREACHED();
+    return 0;
+  }
+
+  uint32_t size = buf_size;
+  long res_id = reinterpret_cast<long>(font_id);
+  if (!pp::PDF::GetFontTableForPrivateFontFile(res_id, table, buffer, &size))
+    return 0;
+  return size;
+}
+
+void DeleteFont(FPDF_SYSFONTINFO*, void* font_id) {
+  long res_id = reinterpret_cast<long>(font_id);
+  pp::Module::Get()->core()->ReleaseResource(res_id);
+}
+
+FPDF_SYSFONTINFO g_font_info = {1,           0, EnumFonts, MapFont,   0,
+                                GetFontData, 0, 0,         DeleteFont};
+
+}  // namespace
+
+void InitializeLinuxFontMapper() {
+  FPDF_SetSystemFontInfo(&g_font_info);
+}
+
+void SetLastInstance(pp::Instance* last_instance) {
+  if (last_instance)
+    g_last_instance_id = last_instance->pp_instance();
+}
+
+}  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_font_linux.h b/pdf/pdfium/pdfium_font_linux.h
new file mode 100644
index 000000000000..4caa79135500
--- /dev/null
+++ b/pdf/pdfium/pdfium_font_linux.h
@@ -0,0 +1,25 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef PDF_PDFIUM_PDFIUM_FONT_LINUX_H_
+#define PDF_PDFIUM_PDFIUM_FONT_LINUX_H_
+
+namespace pp {
+class Instance;
+}
+
+namespace chrome_pdf {
+
+// Initializes a Linux-specific font mapper that proxies font requests via
+// PPAPI. This is necessary because font loading does not work in the sandbox on
+// Linux.
+void InitializeLinuxFontMapper();
+
+// Keeps track of the most recently used plugin instance. This is a no-op of
+// |last_instance| is null.
+void SetLastInstance(pp::Instance* last_instance);
+
+}  // namespace chrome_pdf
+
+#endif  // PDF_PDFIUM_PDFIUM_FONT_LINUX_H_
diff --git a/pdf/pdfium/pdfium_form_filler.cc b/pdf/pdfium/pdfium_form_filler.cc
index c64ccafcf450..205cfb2cd8e5 100644
--- a/pdf/pdfium/pdfium_form_filler.cc
+++ b/pdf/pdfium/pdfium_form_filler.cc
@@ -8,27 +8,45 @@
 #include <string>
 #include <utility>
 
+#include "base/bind.h"
+#include "base/feature_list.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/utf_string_conversions.h"
+#include "pdf/pdf_features.h"
 #include "pdf/pdfium/pdfium_engine.h"
+#include "pdf/ppapi_migration/input_event_conversions.h"
+#include "third_party/pdfium/public/fpdf_annot.h"
+#include "ui/gfx/geometry/rect.h"
 
 namespace chrome_pdf {
 
 namespace {
 
+int g_last_timer_id = 0;
+
 std::string WideStringToString(FPDF_WIDESTRING wide_string) {
-  return base::UTF16ToUTF8(reinterpret_cast<const base::char16*>(wide_string));
+  return base::UTF16ToUTF8(reinterpret_cast<const char16_t*>(wide_string));
 }
 
 }  // namespace
 
-PDFiumFormFiller::PDFiumFormFiller(PDFiumEngine* engine, bool enable_javascript)
-    : engine_(engine) {
+// static
+PDFiumFormFiller::ScriptOption PDFiumFormFiller::DefaultScriptOption() {
+#if defined(PDF_ENABLE_XFA)
+  if (base::FeatureList::IsEnabled(features::kPdfXfaSupport))
+    return PDFiumFormFiller::ScriptOption::kJavaScriptAndXFA;
+#endif  // defined(PDF_ENABLE_XFA)
+  return PDFiumFormFiller::ScriptOption::kJavaScript;
+}
+
+PDFiumFormFiller::PDFiumFormFiller(PDFiumEngine* engine,
+                                   ScriptOption script_option)
+    : engine_(engine), script_option_(script_option) {
   // Initialize FPDF_FORMFILLINFO member variables.  Deriving from this struct
   // allows the static callbacks to be able to cast the FPDF_FORMFILLINFO in
   // callbacks to ourself instead of maintaining a map of them to
   // PDFiumEngine.
-  FPDF_FORMFILLINFO::version = 1;
+  FPDF_FORMFILLINFO::version = 2;
   FPDF_FORMFILLINFO::Release = nullptr;
   FPDF_FORMFILLINFO::FFI_Invalidate = Form_Invalidate;
   FPDF_FORMFILLINFO::FFI_OutputSelectedRect = Form_OutputSelectedRect;
@@ -44,26 +62,29 @@ PDFiumFormFiller::PDFiumFormFiller(PDFiumEngine* engine, bool enable_javascript)
   FPDF_FORMFILLINFO::FFI_SetTextFieldFocus = Form_SetTextFieldFocus;
   FPDF_FORMFILLINFO::FFI_DoURIAction = Form_DoURIAction;
   FPDF_FORMFILLINFO::FFI_DoGoToAction = Form_DoGoToAction;
-#if defined(PDF_ENABLE_XFA)
-  FPDF_FORMFILLINFO::version = 2;
-  FPDF_FORMFILLINFO::FFI_EmailTo = Form_EmailTo;
-  FPDF_FORMFILLINFO::FFI_DisplayCaret = Form_DisplayCaret;
-  FPDF_FORMFILLINFO::FFI_SetCurrentPage = Form_SetCurrentPage;
-  FPDF_FORMFILLINFO::FFI_GetCurrentPageIndex = Form_GetCurrentPageIndex;
-  FPDF_FORMFILLINFO::FFI_GetPageViewRect = Form_GetPageViewRect;
-  FPDF_FORMFILLINFO::FFI_GetPlatform = Form_GetPlatform;
+  FPDF_FORMFILLINFO::FFI_OnFocusChange = Form_OnFocusChange;
+  FPDF_FORMFILLINFO::FFI_DoURIActionWithKeyboardModifier =
+      Form_DoURIActionWithKeyboardModifier;
+  FPDF_FORMFILLINFO::xfa_disabled = true;
+  FPDF_FORMFILLINFO::FFI_EmailTo = nullptr;
+  FPDF_FORMFILLINFO::FFI_DisplayCaret = nullptr;
+  FPDF_FORMFILLINFO::FFI_SetCurrentPage = nullptr;
+  FPDF_FORMFILLINFO::FFI_GetCurrentPageIndex = nullptr;
+  FPDF_FORMFILLINFO::FFI_GetPageViewRect = nullptr;
+  FPDF_FORMFILLINFO::FFI_GetPlatform = nullptr;
   FPDF_FORMFILLINFO::FFI_PageEvent = nullptr;
-  FPDF_FORMFILLINFO::FFI_PopupMenu = Form_PopupMenu;
-  FPDF_FORMFILLINFO::FFI_PostRequestURL = Form_PostRequestURL;
-  FPDF_FORMFILLINFO::FFI_PutRequestURL = Form_PutRequestURL;
-  FPDF_FORMFILLINFO::FFI_UploadTo = Form_UploadTo;
-  FPDF_FORMFILLINFO::FFI_DownloadFromURL = Form_DownloadFromURL;
-  FPDF_FORMFILLINFO::FFI_OpenFile = Form_OpenFile;
-  FPDF_FORMFILLINFO::FFI_GotoURL = Form_GotoURL;
-  FPDF_FORMFILLINFO::FFI_GetLanguage = Form_GetLanguage;
-#endif  // defined(PDF_ENABLE_XFA)
+  FPDF_FORMFILLINFO::FFI_PopupMenu = nullptr;
+  FPDF_FORMFILLINFO::FFI_PostRequestURL = nullptr;
+  FPDF_FORMFILLINFO::FFI_PutRequestURL = nullptr;
+  FPDF_FORMFILLINFO::FFI_UploadTo = nullptr;
+  FPDF_FORMFILLINFO::FFI_DownloadFromURL = nullptr;
+  FPDF_FORMFILLINFO::FFI_OpenFile = nullptr;
+  FPDF_FORMFILLINFO::FFI_GotoURL = nullptr;
+  FPDF_FORMFILLINFO::FFI_GetLanguage = nullptr;
+  FPDF_FORMFILLINFO::m_pJsPlatform = nullptr;
 
-  if (enable_javascript) {
+#if defined(PDF_ENABLE_V8)
+  if (script_option != ScriptOption::kNoJavaScript) {
     FPDF_FORMFILLINFO::m_pJsPlatform = this;
     IPDF_JSPLATFORM::version = 3;
     IPDF_JSPLATFORM::app_alert = Form_Alert;
@@ -75,9 +96,28 @@ PDFiumFormFiller::PDFiumFormFiller(PDFiumEngine* engine, bool enable_javascript)
     IPDF_JSPLATFORM::Doc_submitForm = Form_SubmitForm;
     IPDF_JSPLATFORM::Doc_gotoPage = Form_GotoPage;
     IPDF_JSPLATFORM::Field_browse = nullptr;
-  } else {
-    FPDF_FORMFILLINFO::m_pJsPlatform = nullptr;
   }
+#if defined(PDF_ENABLE_XFA)
+  if (script_option == ScriptOption::kJavaScriptAndXFA) {
+    FPDF_FORMFILLINFO::xfa_disabled = false;
+    FPDF_FORMFILLINFO::FFI_EmailTo = Form_EmailTo;
+    FPDF_FORMFILLINFO::FFI_DisplayCaret = Form_DisplayCaret;
+    FPDF_FORMFILLINFO::FFI_SetCurrentPage = Form_SetCurrentPage;
+    FPDF_FORMFILLINFO::FFI_GetCurrentPageIndex = Form_GetCurrentPageIndex;
+    FPDF_FORMFILLINFO::FFI_GetPageViewRect = Form_GetPageViewRect;
+    FPDF_FORMFILLINFO::FFI_GetPlatform = Form_GetPlatform;
+    FPDF_FORMFILLINFO::FFI_PageEvent = Form_PageEvent;
+    FPDF_FORMFILLINFO::FFI_PopupMenu = Form_PopupMenu;
+    FPDF_FORMFILLINFO::FFI_PostRequestURL = Form_PostRequestURL;
+    FPDF_FORMFILLINFO::FFI_PutRequestURL = Form_PutRequestURL;
+    FPDF_FORMFILLINFO::FFI_UploadTo = Form_UploadTo;
+    FPDF_FORMFILLINFO::FFI_DownloadFromURL = Form_DownloadFromURL;
+    FPDF_FORMFILLINFO::FFI_OpenFile = Form_OpenFile;
+    FPDF_FORMFILLINFO::FFI_GotoURL = Form_GotoURL;
+    FPDF_FORMFILLINFO::FFI_GetLanguage = Form_GetLanguage;
+  }
+#endif  // defined(PDF_ENABLE_XFA)
+#endif  // defined(PDF_ENABLE_V8)
 }
 
 PDFiumFormFiller::~PDFiumFormFiller() = default;
@@ -97,9 +137,9 @@ void PDFiumFormFiller::Form_Invalidate(FPDF_FORMFILLINFO* param,
     return;
   }
 
-  pp::Rect rect = engine->pages_[page_index]->PageToScreen(
-      engine->GetVisibleRect().point(), engine->current_zoom_, left, top, right,
-      bottom, engine->current_rotation_);
+  gfx::Rect rect = engine->pages_[page_index]->PageToScreen(
+      engine->GetVisibleRect().origin(), engine->current_zoom_, left, top,
+      right, bottom, engine->layout_.options().default_page_orientation());
   engine->client_->Invalidate(rect);
 }
 
@@ -116,9 +156,9 @@ void PDFiumFormFiller::Form_OutputSelectedRect(FPDF_FORMFILLINFO* param,
     NOTREACHED();
     return;
   }
-  pp::Rect rect = engine->pages_[page_index]->PageToScreen(
-      engine->GetVisibleRect().point(), engine->current_zoom_, left, top, right,
-      bottom, engine->current_rotation_);
+  gfx::Rect rect = engine->pages_[page_index]->PageToScreen(
+      engine->GetVisibleRect().origin(), engine->current_zoom_, left, top,
+      right, bottom, engine->layout_.options().default_page_orientation());
   if (rect.IsEmpty())
     return;
 
@@ -168,7 +208,7 @@ FPDF_SYSTEMTIME PDFiumFormFiller::Form_GetLocalTime(FPDF_FORMFILLINFO* param) {
 // static
 void PDFiumFormFiller::Form_OnChange(FPDF_FORMFILLINFO* param) {
   PDFiumEngine* engine = GetEngine(param);
-  engine->SetEditMode(true);
+  engine->EnteredEditMode();
 }
 
 // static
@@ -185,7 +225,7 @@ FPDF_PAGE PDFiumFormFiller::Form_GetPage(FPDF_FORMFILLINFO* param,
 FPDF_PAGE PDFiumFormFiller::Form_GetCurrentPage(FPDF_FORMFILLINFO* param,
                                                 FPDF_DOCUMENT document) {
   PDFiumEngine* engine = GetEngine(param);
-  int index = engine->last_page_mouse_down_;
+  int index = engine->last_focused_page_;
   if (index == -1) {
     index = engine->GetMostVisiblePage();
     if (index == -1) {
@@ -213,7 +253,7 @@ void PDFiumFormFiller::Form_ExecuteNamedAction(FPDF_FORMFILLINFO* param,
     return;
   }
 
-  int index = engine->last_page_mouse_down_;
+  int index = engine->last_focused_page_;
   /* Don't try to calculate the most visible page if we don't have a left click
      before this event (this code originally copied Form_GetCurrentPage which of
      course needs to do that and which doesn't have recursion). This can end up
@@ -249,6 +289,22 @@ void PDFiumFormFiller::Form_SetTextFieldFocus(FPDF_FORMFILLINFO* param,
   // TODO(gene): use this signal to trigger OSK.
 }
 
+// static
+void PDFiumFormFiller::Form_OnFocusChange(FPDF_FORMFILLINFO* param,
+                                          FPDF_ANNOTATION annot,
+                                          int page_index) {
+  PDFiumEngine* engine = GetEngine(param);
+  if (!engine->PageIndexInBounds(page_index))
+    return;
+
+  // Maintain viewport if we are updating focus. This is to ensure that we don't
+  // scroll the focused annotation into view when focus is regained.
+  if (!engine->updating_focus_)
+    engine->ScrollAnnotationIntoView(annot, page_index);
+
+  engine->OnFocusedAnnotationUpdated(annot, page_index);
+}
+
 // static
 void PDFiumFormFiller::Form_DoURIAction(FPDF_FORMFILLINFO* param,
                                         FPDF_BYTESTRING uri) {
@@ -267,6 +323,25 @@ void PDFiumFormFiller::Form_DoGoToAction(FPDF_FORMFILLINFO* param,
   engine->ScrollToPage(page_index);
 }
 
+// static
+void PDFiumFormFiller::Form_DoURIActionWithKeyboardModifier(
+    FPDF_FORMFILLINFO* param,
+    FPDF_BYTESTRING uri,
+    int modifiers) {
+  PDFiumEngine* engine = GetEngine(param);
+  bool middle_button = !!(modifiers & kInputEventModifierMiddleButtonDown);
+  bool alt_key = !!(modifiers & kInputEventModifierAltKey);
+  bool ctrl_key = !!(modifiers & kInputEventModifierControlKey);
+  bool meta_key = !!(modifiers & kInputEventModifierMetaKey);
+  bool shift_key = !!(modifiers & kInputEventModifierShiftKey);
+
+  WindowOpenDisposition disposition = ui::DispositionFromClick(
+      middle_button, alt_key, ctrl_key, meta_key, shift_key);
+
+  engine->client_->NavigateTo(std::string(uri), disposition);
+}
+
+#if defined(PDF_ENABLE_V8)
 #if defined(PDF_ENABLE_XFA)
 
 // static
@@ -328,10 +403,7 @@ void PDFiumFormFiller::Form_GetPageViewRect(FPDF_FORMFILLINFO* param,
     return;
   }
 
-  pp::Rect page_view_rect = engine->GetPageContentsRect(page_index);
-
-  float toolbar_height_in_screen_coords =
-      engine->GetToolbarHeightInScreenCoords();
+  gfx::Rect page_view_rect = engine->GetPageContentsRect(page_index);
 
   float page_width = FPDF_GetPageWidth(page);
   float page_height = FPDF_GetPageHeight(page);
@@ -345,11 +417,10 @@ void PDFiumFormFiller::Form_GetPageViewRect(FPDF_FORMFILLINFO* param,
   // coords, we use (page_width * (x - base_x) / page_view_rect.width()).
   // For y positions, (page_height * (y - base_y) / page_view_rect.height()).
 
-  // The top-most y position that can be relied to be visible on the screen is
-  // the bottom of the toolbar, which is y = toolbar_height_in_screen_coords.
+  // The top-most x position that is visible on the screen is the top of the
+  // plugin area, which is y = 0.
   float screen_top_in_page_coords =
-      page_height * (toolbar_height_in_screen_coords - page_view_rect.y()) /
-      page_view_rect.height();
+      page_height * (0 - page_view_rect.y()) / page_view_rect.height();
   // The bottom-most y position that is visible on the screen is the bottom of
   // the plugin area, which is y = engine->plugin_size_.height().
   float screen_bottom_in_page_coords =
@@ -393,6 +464,18 @@ int PDFiumFormFiller::Form_GetPlatform(FPDF_FORMFILLINFO* param,
   return platform_flag;
 }
 
+// static
+void PDFiumFormFiller::Form_PageEvent(FPDF_FORMFILLINFO* param,
+                                      int page_count,
+                                      unsigned long event_type) {
+  DCHECK(page_count != 0);
+  DCHECK(event_type == FXFA_PAGEVIEWEVENT_POSTADDED ||
+         event_type == FXFA_PAGEVIEWEVENT_POSTREMOVED);
+
+  PDFiumEngine* engine = GetEngine(param);
+  engine->UpdatePageCount();
+}
+
 // static
 FPDF_BOOL PDFiumFormFiller::Form_PopupMenu(FPDF_FORMFILLINFO* param,
                                            FPDF_PAGE page,
@@ -411,15 +494,8 @@ FPDF_BOOL PDFiumFormFiller::Form_PostRequestURL(FPDF_FORMFILLINFO* param,
                                                 FPDF_WIDESTRING encode,
                                                 FPDF_WIDESTRING header,
                                                 FPDF_BSTR* response) {
-  std::string url_str = WideStringToString(url);
-  std::string data_str = WideStringToString(data);
-  std::string content_type_str = WideStringToString(content_type);
-  std::string encode_str = WideStringToString(encode);
-  std::string header_str = WideStringToString(header);
-
-  std::string javascript = "alert(\"Post:" + url_str + "," + data_str + "," +
-                           content_type_str + "," + encode_str + "," +
-                           header_str + "\")";
+  // NOTE: Think hard about the privacy implications before allowing
+  // a PDF file to perform this action, as it might be used for beaconing.
   return true;
 }
 
@@ -428,13 +504,8 @@ FPDF_BOOL PDFiumFormFiller::Form_PutRequestURL(FPDF_FORMFILLINFO* param,
                                                FPDF_WIDESTRING url,
                                                FPDF_WIDESTRING data,
                                                FPDF_WIDESTRING encode) {
-  std::string url_str = WideStringToString(url);
-  std::string data_str = WideStringToString(data);
-  std::string encode_str = WideStringToString(encode);
-
-  std::string javascript =
-      "alert(\"Put:" + url_str + "," + data_str + "," + encode_str + "\")";
-
+  // NOTE: Think hard about the privacy implications before allowing
+  // a PDF file to perform this action, as it might be used for beaconing.
   return true;
 }
 
@@ -443,16 +514,17 @@ void PDFiumFormFiller::Form_UploadTo(FPDF_FORMFILLINFO* param,
                                      FPDF_FILEHANDLER* file_handle,
                                      int file_flag,
                                      FPDF_WIDESTRING to) {
-  std::string to_str = WideStringToString(to);
-  // TODO: needs the full implementation of form uploading
+  // NOTE: Think hard about the privacy implications before allowing
+  // a PDF file to perform this action, as it might be used for beaconing.
 }
 
 // static
-FPDF_LPFILEHANDLER PDFiumFormFiller::Form_DownloadFromURL(
+FPDF_FILEHANDLER* PDFiumFormFiller::Form_DownloadFromURL(
     FPDF_FORMFILLINFO* param,
     FPDF_WIDESTRING url) {
   // NOTE: Think hard about the security implications before allowing
-  // a PDF file to perform this action.
+  // a PDF file to perform this action. Also think hard about the privacy
+  // implications, as it might be used for beaconing.
   return nullptr;
 }
 
@@ -470,8 +542,9 @@ FPDF_FILEHANDLER* PDFiumFormFiller::Form_OpenFile(FPDF_FORMFILLINFO* param,
 void PDFiumFormFiller::Form_GotoURL(FPDF_FORMFILLINFO* param,
                                     FPDF_DOCUMENT document,
                                     FPDF_WIDESTRING url) {
-  std::string url_str = WideStringToString(url);
-  // TODO: needs to implement GOTO URL action
+  // NOTE: Think hard about the security implications before allowing
+  // a PDF file to perform this action. Also think hard about the privacy
+  // implications, as it might be used for beaconing.
 }
 
 // static
@@ -537,8 +610,8 @@ int PDFiumFormFiller::Form_Response(IPDF_JSPLATFORM* param,
 
   PDFiumEngine* engine = GetEngine(param);
   std::string rv = engine->client_->Prompt(question_str, default_str);
-  base::string16 rv_16 = base::UTF8ToUTF16(rv);
-  int rv_bytes = rv_16.size() * sizeof(base::char16);
+  std::u16string rv_16 = base::UTF8ToUTF16(rv);
+  int rv_bytes = rv_16.size() * sizeof(char16_t);
   if (response) {
     int bytes_to_copy = rv_bytes < length ? rv_bytes : length;
     memcpy(response, rv_16.c_str(), bytes_to_copy);
@@ -611,6 +684,8 @@ void PDFiumFormFiller::Form_GotoPage(IPDF_JSPLATFORM* param, int page_number) {
   engine->ScrollToPage(page_number);
 }
 
+#endif  // defined(PDF_ENABLE_V8)
+
 // static
 PDFiumEngine* PDFiumFormFiller::GetEngine(FPDF_FORMFILLINFO* info) {
   auto* form_filler = static_cast<PDFiumFormFiller*>(info);
@@ -625,7 +700,9 @@ PDFiumEngine* PDFiumFormFiller::GetEngine(IPDF_JSPLATFORM* platform) {
 
 int PDFiumFormFiller::SetTimer(const base::TimeDelta& delay,
                                TimerCallback timer_func) {
-  const int timer_id = ++last_timer_id_;
+  const int timer_id = ++g_last_timer_id;
+  DCHECK(!base::Contains(timers_, timer_id));
+
   auto timer = std::make_unique<base::RepeatingTimer>();
   timer->Start(FROM_HERE, delay, base::BindRepeating(timer_func, timer_id));
   timers_[timer_id] = std::move(timer);
@@ -633,7 +710,8 @@ int PDFiumFormFiller::SetTimer(const base::TimeDelta& delay,
 }
 
 void PDFiumFormFiller::KillTimer(int timer_id) {
-  timers_.erase(timer_id);
+  size_t erased = timers_.erase(timer_id);
+  DCHECK_EQ(1u, erased);
 }
 
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_form_filler.h b/pdf/pdfium/pdfium_form_filler.h
index df4c7fb3d474..3408a8114ff2 100644
--- a/pdf/pdfium/pdfium_form_filler.h
+++ b/pdf/pdfium/pdfium_form_filler.h
@@ -8,10 +8,10 @@
 #include <map>
 #include <memory>
 
-#include "base/macros.h"
 #include "base/time/time.h"
 #include "base/timer/timer.h"
 #include "third_party/pdfium/public/fpdf_formfill.h"
+#include "third_party/pdfium/public/fpdfview.h"
 
 namespace chrome_pdf {
 
@@ -19,10 +19,20 @@ class PDFiumEngine;
 
 class PDFiumFormFiller : public FPDF_FORMFILLINFO, public IPDF_JSPLATFORM {
  public:
-  PDFiumFormFiller(PDFiumEngine* engine, bool enable_javascript);
+  enum class ScriptOption { kNoJavaScript, kJavaScript, kJavaScriptAndXFA };
+  static PDFiumFormFiller::ScriptOption DefaultScriptOption();
+
+  // NOTE: |script_option| is ignored when PDF_ENABLE_V8 is not defined.
+  PDFiumFormFiller(PDFiumEngine* engine, ScriptOption script_option);
+  PDFiumFormFiller(const PDFiumFormFiller&) = delete;
+  PDFiumFormFiller& operator=(const PDFiumFormFiller&) = delete;
   ~PDFiumFormFiller();
 
+  ScriptOption script_option() const { return script_option_; }
+
  private:
+  friend class FormFillerTest;
+
   // FPDF_FORMFILLINFO callbacks.
   static void Form_Invalidate(FPDF_FORMFILLINFO* param,
                               FPDF_PAGE page,
@@ -55,13 +65,20 @@ class PDFiumFormFiller : public FPDF_FORMFILLINFO, public IPDF_JSPLATFORM {
                                      FPDF_WIDESTRING value,
                                      FPDF_DWORD valueLen,
                                      FPDF_BOOL is_focus);
+  static void Form_OnFocusChange(FPDF_FORMFILLINFO* param,
+                                 FPDF_ANNOTATION annot,
+                                 int page_index);
   static void Form_DoURIAction(FPDF_FORMFILLINFO* param, FPDF_BYTESTRING uri);
   static void Form_DoGoToAction(FPDF_FORMFILLINFO* param,
                                 int page_index,
                                 int zoom_mode,
                                 float* position_array,
                                 int size_of_array);
+  static void Form_DoURIActionWithKeyboardModifier(FPDF_FORMFILLINFO* param,
+                                                   FPDF_BYTESTRING uri,
+                                                   int modifiers);
 
+#if defined(PDF_ENABLE_V8)
 #if defined(PDF_ENABLE_XFA)
   static void Form_EmailTo(FPDF_FORMFILLINFO* param,
                            FPDF_FILEHANDLER* file_handler,
@@ -91,6 +108,9 @@ class PDFiumFormFiller : public FPDF_FORMFILLINFO, public IPDF_JSPLATFORM {
   static int Form_GetPlatform(FPDF_FORMFILLINFO* param,
                               void* platform,
                               int length);
+  static void Form_PageEvent(FPDF_FORMFILLINFO* param,
+                             int page_count,
+                             unsigned long event_type);
   static FPDF_BOOL Form_PopupMenu(FPDF_FORMFILLINFO* param,
                                   FPDF_PAGE page,
                                   FPDF_WIDGET widget,
@@ -112,8 +132,8 @@ class PDFiumFormFiller : public FPDF_FORMFILLINFO, public IPDF_JSPLATFORM {
                             FPDF_FILEHANDLER* file_handler,
                             int file_flag,
                             FPDF_WIDESTRING dest);
-  static FPDF_LPFILEHANDLER Form_DownloadFromURL(FPDF_FORMFILLINFO* param,
-                                                 FPDF_WIDESTRING url);
+  static FPDF_FILEHANDLER* Form_DownloadFromURL(FPDF_FORMFILLINFO* param,
+                                                FPDF_WIDESTRING url);
   static FPDF_FILEHANDLER* Form_OpenFile(FPDF_FORMFILLINFO* param,
                                          int file_flag,
                                          FPDF_WIDESTRING url,
@@ -167,6 +187,7 @@ class PDFiumFormFiller : public FPDF_FORMFILLINFO, public IPDF_JSPLATFORM {
                               int length,
                               FPDF_WIDESTRING url);
   static void Form_GotoPage(IPDF_JSPLATFORM* param, int page_number);
+#endif  // defined(PDF_ENABLE_V8)
 
   static PDFiumEngine* GetEngine(FPDF_FORMFILLINFO* info);
   static PDFiumEngine* GetEngine(IPDF_JSPLATFORM* platform);
@@ -175,11 +196,8 @@ class PDFiumFormFiller : public FPDF_FORMFILLINFO, public IPDF_JSPLATFORM {
   void KillTimer(int timer_id);
 
   PDFiumEngine* const engine_;
-
+  const ScriptOption script_option_;
   std::map<int, std::unique_ptr<base::RepeatingTimer>> timers_;
-  int last_timer_id_ = 0;
-
-  DISALLOW_COPY_AND_ASSIGN(PDFiumFormFiller);
 };
 
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_form_filler_unittest.cc b/pdf/pdfium/pdfium_form_filler_unittest.cc
new file mode 100644
index 000000000000..031bff08a33a
--- /dev/null
+++ b/pdf/pdfium/pdfium_form_filler_unittest.cc
@@ -0,0 +1,163 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "build/build_config.h"
+#include "pdf/pdfium/pdfium_engine.h"
+#include "pdf/pdfium/pdfium_test_base.h"
+#include "pdf/ppapi_migration/input_event_conversions.h"
+#include "pdf/test/test_client.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "third_party/pdfium/public/fpdf_annot.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/size.h"
+
+using testing::InSequence;
+
+namespace chrome_pdf {
+
+namespace {
+
+class FormFillerTestClient : public TestClient {
+ public:
+  FormFillerTestClient() = default;
+  ~FormFillerTestClient() override = default;
+  FormFillerTestClient(const FormFillerTestClient&) = delete;
+  FormFillerTestClient& operator=(const FormFillerTestClient&) = delete;
+
+  // Mock PDFEngine::Client methods.
+  MOCK_METHOD(void, ScrollToX, (int), (override));
+  MOCK_METHOD(void, ScrollToY, (int), (override));
+  MOCK_METHOD(void,
+              NavigateTo,
+              (const std::string&, WindowOpenDisposition),
+              (override));
+};
+
+}  // namespace
+
+class FormFillerTest : public PDFiumTestBase {
+ public:
+  FormFillerTest() = default;
+  ~FormFillerTest() override = default;
+  FormFillerTest(const FormFillerTest&) = delete;
+  FormFillerTest& operator=(const FormFillerTest&) = delete;
+
+  void TriggerFormFocusChange(PDFiumEngine* engine,
+                              FPDF_ANNOTATION annot,
+                              int page_index) {
+    ASSERT_TRUE(engine);
+    engine->form_filler_.Form_OnFocusChange(&engine->form_filler_, annot,
+                                            page_index);
+  }
+
+  void TriggerDoURIActionWithKeyboardModifier(PDFiumEngine* engine,
+                                              FPDF_BYTESTRING uri,
+                                              int modifiers) {
+    ASSERT_TRUE(engine);
+    engine->form_filler_.Form_DoURIActionWithKeyboardModifier(
+        &engine->form_filler_, uri, modifiers);
+  }
+};
+
+TEST_F(FormFillerTest, DoURIActionWithKeyboardModifier) {
+  FormFillerTestClient client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("annotation_form_fields.pdf"));
+  ASSERT_TRUE(engine);
+
+  const char kUri[] = "https://www.google.com/";
+  {
+    InSequence sequence;
+    EXPECT_CALL(client, NavigateTo(kUri, WindowOpenDisposition::CURRENT_TAB))
+        .Times(1);
+    EXPECT_CALL(client, NavigateTo(kUri, WindowOpenDisposition::SAVE_TO_DISK))
+        .Times(1);
+    EXPECT_CALL(client,
+                NavigateTo(kUri, WindowOpenDisposition::NEW_BACKGROUND_TAB))
+        .Times(1);
+    EXPECT_CALL(client, NavigateTo(kUri, WindowOpenDisposition::NEW_WINDOW))
+        .Times(1);
+    EXPECT_CALL(client,
+                NavigateTo(kUri, WindowOpenDisposition::NEW_FOREGROUND_TAB))
+        .Times(1);
+    EXPECT_CALL(client,
+                NavigateTo(kUri, WindowOpenDisposition::NEW_BACKGROUND_TAB))
+        .Times(1);
+    EXPECT_CALL(client,
+                NavigateTo(kUri, WindowOpenDisposition::NEW_FOREGROUND_TAB))
+        .Times(1);
+  }
+
+#if defined(OS_MAC)
+#define modifier_key kInputEventModifierMetaKey;
+#else
+#define modifier_key kInputEventModifierControlKey
+#endif
+
+  int modifiers = 0;
+  TriggerDoURIActionWithKeyboardModifier(engine.get(), kUri, modifiers);
+  modifiers = kInputEventModifierAltKey;
+  TriggerDoURIActionWithKeyboardModifier(engine.get(), kUri, modifiers);
+  modifiers = modifier_key;
+  TriggerDoURIActionWithKeyboardModifier(engine.get(), kUri, modifiers);
+  modifiers = kInputEventModifierShiftKey;
+  TriggerDoURIActionWithKeyboardModifier(engine.get(), kUri, modifiers);
+  modifiers |= modifier_key;
+  TriggerDoURIActionWithKeyboardModifier(engine.get(), kUri, modifiers);
+  modifiers = kInputEventModifierMiddleButtonDown;
+  TriggerDoURIActionWithKeyboardModifier(engine.get(), kUri, modifiers);
+  modifiers |= kInputEventModifierShiftKey;
+  TriggerDoURIActionWithKeyboardModifier(engine.get(), kUri, modifiers);
+}
+
+TEST_F(FormFillerTest, FormOnFocusChange) {
+  struct {
+    // Initial scroll position of the document.
+    gfx::Point initial_position;
+    // Page number on which the annotation is present.
+    int page_index;
+    // The index of test annotation on page_index.
+    int annot_index;
+    // The scroll position to bring the annotation into view. (0,0) if the
+    // annotation is already in view.
+    gfx::Point final_scroll_position;
+  } static constexpr test_cases[] = {
+      {{0, 0}, 0, 0, {242, 746}},   {{0, 0}, 0, 1, {510, 478}},
+      {{242, 40}, 0, 0, {0, 746}},  {{60, 758}, 0, 0, {242, 0}},
+      {{242, 758}, 0, 0, {0, 0}},   {{242, 768}, 0, 0, {0, 746}},
+      {{274, 758}, 0, 0, {242, 0}}, {{60, 40}, 1, 0, {242, 1816}}};
+
+  FormFillerTestClient client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("annotation_form_fields.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(2, engine->GetNumberOfPages());
+  engine->PluginSizeUpdated(gfx::Size(60, 40));
+
+  {
+    InSequence sequence;
+
+    for (const auto& test_case : test_cases) {
+      if (test_case.final_scroll_position.y() != 0) {
+        EXPECT_CALL(client, ScrollToY(test_case.final_scroll_position.y()));
+      }
+      if (test_case.final_scroll_position.x() != 0)
+        EXPECT_CALL(client, ScrollToX(test_case.final_scroll_position.x()));
+    }
+  }
+
+  for (const auto& test_case : test_cases) {
+    // Setting up the initial scroll positions.
+    engine->ScrolledToXPosition(test_case.initial_position.x());
+    engine->ScrolledToYPosition(test_case.initial_position.y());
+
+    PDFiumPage& page = GetPDFiumPageForTest(*engine, test_case.page_index);
+    ScopedFPDFAnnotation annot(
+        FPDFPage_GetAnnot(page.GetPage(), test_case.annot_index));
+    ASSERT_TRUE(annot);
+    TriggerFormFocusChange(engine.get(), annot.get(), test_case.page_index);
+  }
+}
+
+}  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_mem_buffer_file_write.cc b/pdf/pdfium/pdfium_mem_buffer_file_write.cc
index cd851b4e35b4..df9ae2e4987c 100644
--- a/pdf/pdfium/pdfium_mem_buffer_file_write.cc
+++ b/pdf/pdfium/pdfium_mem_buffer_file_write.cc
@@ -13,17 +13,21 @@ PDFiumMemBufferFileWrite::PDFiumMemBufferFileWrite() {
 
 PDFiumMemBufferFileWrite::~PDFiumMemBufferFileWrite() = default;
 
+std::vector<uint8_t> PDFiumMemBufferFileWrite::TakeBuffer() {
+  return std::move(buffer_);
+}
+
+// static
 int PDFiumMemBufferFileWrite::WriteBlockImpl(FPDF_FILEWRITE* this_file_write,
                                              const void* data,
                                              unsigned long size) {
-  PDFiumMemBufferFileWrite* mem_buffer_file_write =
-      static_cast<PDFiumMemBufferFileWrite*>(this_file_write);
-  return mem_buffer_file_write->DoWriteBlock(data, size);
+  auto* buffer = static_cast<PDFiumMemBufferFileWrite*>(this_file_write);
+  return buffer->DoWriteBlock(static_cast<const uint8_t*>(data), size);
 }
 
-int PDFiumMemBufferFileWrite::DoWriteBlock(const void* data,
+int PDFiumMemBufferFileWrite::DoWriteBlock(const uint8_t* data,
                                            unsigned long size) {
-  buffer_.append(static_cast<const unsigned char*>(data), size);
+  buffer_.insert(buffer_.end(), data, data + size);
   return 1;
 }
 
diff --git a/pdf/pdfium/pdfium_mem_buffer_file_write.h b/pdf/pdfium/pdfium_mem_buffer_file_write.h
index 7b40466e5d4f..82e82d23684d 100644
--- a/pdf/pdfium/pdfium_mem_buffer_file_write.h
+++ b/pdf/pdfium/pdfium_mem_buffer_file_write.h
@@ -6,8 +6,9 @@
 #define PDF_PDFIUM_PDFIUM_MEM_BUFFER_FILE_WRITE_H_
 
 #include <stddef.h>
+#include <stdint.h>
 
-#include <string>
+#include <vector>
 
 #include "third_party/pdfium/public/fpdf_save.h"
 
@@ -19,16 +20,19 @@ class PDFiumMemBufferFileWrite : public FPDF_FILEWRITE {
   PDFiumMemBufferFileWrite();
   ~PDFiumMemBufferFileWrite();
 
-  const std::basic_string<unsigned char>& buffer() { return buffer_; }
-  size_t size() { return buffer_.size(); }
+  const std::vector<uint8_t>& buffer() const { return buffer_; }
+  size_t size() const { return buffer_.size(); }
+
+  std::vector<uint8_t> TakeBuffer();
 
  private:
-  int DoWriteBlock(const void* data, unsigned long size);
   static int WriteBlockImpl(FPDF_FILEWRITE* this_file_write,
                             const void* data,
                             unsigned long size);
 
-  std::basic_string<unsigned char> buffer_;
+  int DoWriteBlock(const uint8_t* data, unsigned long size);
+
+  std::vector<uint8_t> buffer_;
 };
 
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_page.cc b/pdf/pdfium/pdfium_page.cc
index 37b4db3dfe7c..fee0bc580338 100644
--- a/pdf/pdfium/pdfium_page.cc
+++ b/pdf/pdfium/pdfium_page.cc
@@ -11,92 +11,267 @@
 #include <memory>
 #include <utility>
 
-#include "base/logging.h"
+#include "base/bind.h"
+#include "base/callback.h"
+#include "base/check_op.h"
+#include "base/metrics/histogram_functions.h"
+#include "base/notreached.h"
+#include "base/numerics/math_constants.h"
 #include "base/numerics/safe_math.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
+#include "pdf/accessibility_helper.h"
+#include "pdf/accessibility_structs.h"
 #include "pdf/pdfium/pdfium_api_string_buffer_adapter.h"
 #include "pdf/pdfium/pdfium_engine.h"
 #include "pdf/pdfium/pdfium_unsupported_features.h"
+#include "pdf/ppapi_migration/geometry_conversions.h"
+#include "pdf/ui/thumbnail.h"
+#include "ppapi/c/private/ppb_pdf.h"
 #include "printing/units.h"
 #include "third_party/pdfium/public/cpp/fpdf_scopers.h"
 #include "third_party/pdfium/public/fpdf_annot.h"
+#include "third_party/pdfium/public/fpdf_catalog.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/point_f.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/rect_f.h"
+#include "ui/gfx/geometry/size_f.h"
+#include "ui/gfx/geometry/vector2d.h"
+#include "ui/gfx/geometry/vector2d_f.h"
+#include "ui/gfx/range/range.h"
 
 using printing::ConvertUnitDouble;
-using printing::kPointsPerInch;
 using printing::kPixelsPerInch;
+using printing::kPointsPerInch;
+
+namespace chrome_pdf {
 
 namespace {
 
-pp::FloatRect FloatPageRectToPixelRect(FPDF_PAGE page,
-                                       const pp::FloatRect& input) {
-  int output_width = FPDF_GetPageWidth(page);
-  int output_height = FPDF_GetPageHeight(page);
+constexpr float k45DegreesInRadians = base::kPiFloat / 4;
+constexpr float k90DegreesInRadians = base::kPiFloat / 2;
+constexpr float k180DegreesInRadians = base::kPiFloat;
+constexpr float k270DegreesInRadians = 3 * base::kPiFloat / 2;
+constexpr float k360DegreesInRadians = 2 * base::kPiFloat;
+
+gfx::RectF FloatPageRectToPixelRect(FPDF_PAGE page, const gfx::RectF& input) {
+  int output_width = FPDF_GetPageWidthF(page);
+  int output_height = FPDF_GetPageHeightF(page);
 
   int min_x;
   int min_y;
   int max_x;
   int max_y;
-  FPDF_BOOL ret = FPDF_PageToDevice(page, 0, 0, output_width, output_height, 0,
-                                    input.x(), input.y(), &min_x, &min_y);
-  DCHECK(ret);
-  ret = FPDF_PageToDevice(page, 0, 0, output_width, output_height, 0,
-                          input.right(), input.bottom(), &max_x, &max_y);
-  DCHECK(ret);
-
+  if (!FPDF_PageToDevice(page, 0, 0, output_width, output_height, 0, input.x(),
+                         input.y(), &min_x, &min_y)) {
+    return gfx::RectF();
+  }
+  if (!FPDF_PageToDevice(page, 0, 0, output_width, output_height, 0,
+                         input.right(), input.bottom(), &max_x, &max_y)) {
+    return gfx::RectF();
+  }
   if (max_x < min_x)
     std::swap(min_x, max_x);
   if (max_y < min_y)
     std::swap(min_y, max_y);
 
-  pp::FloatRect output_rect(
+  // Make sure small but non-zero dimensions for |input| does not get rounded
+  // down to 0.
+  int width = max_x - min_x;
+  int height = max_y - min_y;
+  if (width == 0 && input.width())
+    width = 1;
+  if (height == 0 && input.height())
+    height = 1;
+
+  gfx::RectF output_rect(
       ConvertUnitDouble(min_x, kPointsPerInch, kPixelsPerInch),
       ConvertUnitDouble(min_y, kPointsPerInch, kPixelsPerInch),
-      ConvertUnitDouble(max_x - min_x, kPointsPerInch, kPixelsPerInch),
-      ConvertUnitDouble(max_y - min_y, kPointsPerInch, kPixelsPerInch));
+      ConvertUnitDouble(width, kPointsPerInch, kPixelsPerInch),
+      ConvertUnitDouble(height, kPointsPerInch, kPixelsPerInch));
   return output_rect;
 }
 
-pp::FloatRect GetFloatCharRectInPixels(FPDF_PAGE page,
-                                       FPDF_TEXTPAGE text_page,
-                                       int index) {
+gfx::RectF GetFloatCharRectInPixels(FPDF_PAGE page,
+                                    FPDF_TEXTPAGE text_page,
+                                    int index) {
   double left;
   double right;
   double bottom;
   double top;
-  FPDFText_GetCharBox(text_page, index, &left, &right, &bottom, &top);
+  if (!FPDFText_GetCharBox(text_page, index, &left, &right, &bottom, &top))
+    return gfx::RectF();
+
   if (right < left)
     std::swap(left, right);
   if (bottom < top)
     std::swap(top, bottom);
-  pp::FloatRect page_coords(left, top, right - left, bottom - top);
+  gfx::RectF page_coords(left, top, right - left, bottom - top);
   return FloatPageRectToPixelRect(page, page_coords);
 }
 
-bool OverlapsOnYAxis(const pp::FloatRect& a, const pp::FloatRect& b) {
-  return !(a.IsEmpty() || b.IsEmpty() || a.bottom() < b.y() ||
-           b.bottom() < a.y());
+int GetFirstNonUnicodeWhiteSpaceCharIndex(FPDF_TEXTPAGE text_page,
+                                          int start_char_index,
+                                          int chars_count) {
+  int i = start_char_index;
+  while (i < chars_count &&
+         base::IsUnicodeWhitespace(FPDFText_GetUnicode(text_page, i))) {
+    i++;
+  }
+  return i;
+}
+
+AccessibilityTextDirection GetDirectionFromAngle(float angle) {
+  // Rotating the angle by 45 degrees to simplify the conditions statements.
+  // It's like if we rotated the whole cartesian coordinate system like below.
+  //   X                   X
+  //     X      IV       X
+  //       X           X
+  //         X       X
+  //           X   X
+  //   III       X       I
+  //           X   X
+  //         X       X
+  //       X           X
+  //     X      II       X
+  //   X                   X
+
+  angle = fmodf(angle + k45DegreesInRadians, k360DegreesInRadians);
+  // Quadrant I.
+  if (angle >= 0 && angle <= k90DegreesInRadians)
+    return AccessibilityTextDirection::kLeftToRight;
+  // Quadrant II.
+  if (angle > k90DegreesInRadians && angle <= k180DegreesInRadians)
+    return AccessibilityTextDirection::kTopToBottom;
+  // Quadrant III.
+  if (angle > k180DegreesInRadians && angle <= k270DegreesInRadians)
+    return AccessibilityTextDirection::kRightToLeft;
+  // Quadrant IV.
+  return AccessibilityTextDirection::kBottomToTop;
+}
+
+void AddCharSizeToAverageCharSize(gfx::SizeF new_size,
+                                  gfx::SizeF* avg_size,
+                                  int* count) {
+  // Some characters sometimes have a bogus empty bounding box. We don't want
+  // them to impact the average.
+  if (!new_size.IsEmpty()) {
+    avg_size->set_width((avg_size->width() * *count + new_size.width()) /
+                        (*count + 1));
+    avg_size->set_height((avg_size->height() * *count + new_size.height()) /
+                         (*count + 1));
+    (*count)++;
+  }
+}
+
+float GetRotatedCharWidth(float angle, const gfx::SizeF& size) {
+  return fabsf(cosf(angle) * size.width()) + fabsf(sinf(angle) * size.height());
+}
+
+float GetAngleOfVector(const gfx::Vector2dF& v) {
+  float angle = atan2f(v.y(), v.x());
+  if (angle < 0)
+    angle += k360DegreesInRadians;
+  return angle;
+}
+
+float GetAngleDifference(float a, float b) {
+  // This is either the difference or (360 - difference).
+  float x = fmodf(fabsf(b - a), k360DegreesInRadians);
+  return x > k180DegreesInRadians ? k360DegreesInRadians - x : x;
+}
+
+bool FloatEquals(float f1, float f2) {
+  // The idea behind this is to use this fraction of the larger of the
+  // two numbers as the limit of the difference.  This breaks down near
+  // zero, so we reuse this as the minimum absolute size we will use
+  // for the base of the scale too.
+  static constexpr float kEpsilonScale = 0.00001f;
+  return fabsf(f1 - f2) <
+         kEpsilonScale * fmaxf(fmaxf(fabsf(f1), fabsf(f2)), kEpsilonScale);
+}
+
+// Count overlaps across text annotations.
+template <typename T, typename U>
+uint32_t CountOverlaps(const std::vector<T>& first_set,
+                       const std::vector<U>& second_set) {
+  // This method assumes vectors passed are sorted by |start_char_index|.
+  uint32_t overlaps = 0;
+  // Count overlaps between |first_set| and |second_set|.
+  for (const auto& first_set_object : first_set) {
+    gfx::Range first_range(
+        first_set_object.start_char_index,
+        first_set_object.start_char_index + first_set_object.char_count);
+    for (const auto& second_set_object : second_set) {
+      gfx::Range second_range(
+          second_set_object.start_char_index,
+          second_set_object.start_char_index + second_set_object.char_count);
+      if (first_range.Intersects(second_range)) {
+        overlaps++;
+      } else if (first_range.start() < second_range.start()) {
+        // Both range vectors are sorted by |start_char_index|. In case they
+        // don't overlap, and the |second_range| starts after the |first_range|,
+        // then all successive |second_set_object| will not overlap with
+        // |first_range|.
+        break;
+      }
+    }
+  }
+  return overlaps;
+}
+
+// Count overlaps within text annotations.
+template <typename T>
+uint32_t CountInternalTextOverlaps(const std::vector<T>& text_objects) {
+  // This method assumes text_objects is sorted by |start_char_index|.
+  uint32_t overlaps = 0;
+  for (size_t i = 0; i < text_objects.size(); ++i) {
+    gfx::Range range1(
+        text_objects[i].start_char_index,
+        text_objects[i].start_char_index + text_objects[i].char_count);
+    for (size_t j = i + 1; j < text_objects.size(); ++j) {
+      DCHECK_GE(text_objects[j].start_char_index,
+                text_objects[i].start_char_index);
+      gfx::Range range2(
+          text_objects[j].start_char_index,
+          text_objects[j].start_char_index + text_objects[j].char_count);
+      if (range1.Intersects(range2)) {
+        overlaps++;
+      } else {
+        // The input is sorted by |start_char_index|. In case |range1| and
+        // |range2| do not overlap, and |range2| starts after |range1|, then
+        // successive ranges in the inner loop will also not overlap with
+        // |range1|.
+        break;
+      }
+    }
+  }
+  return overlaps;
+}
+
+bool IsRadioButtonOrCheckBox(int button_type) {
+  return button_type == FPDF_FORMFIELD_CHECKBOX ||
+         button_type == FPDF_FORMFIELD_RADIOBUTTON;
+}
+
+template <typename T>
+bool CompareTextRuns(const T& a, const T& b) {
+  return a.text_range.index < b.text_range.index;
 }
 
 }  // namespace
 
-namespace chrome_pdf {
-
 PDFiumPage::LinkTarget::LinkTarget() : page(-1) {}
 
 PDFiumPage::LinkTarget::LinkTarget(const LinkTarget& other) = default;
 
 PDFiumPage::LinkTarget::~LinkTarget() = default;
 
-PDFiumPage::PDFiumPage(PDFiumEngine* engine,
-                       int i,
-                       const pp::Rect& r,
-                       bool available)
-    : engine_(engine),
-      index_(i),
-      rect_(r),
-      available_(available) {}
+PDFiumPage::PDFiumPage(PDFiumEngine* engine, int i)
+    : engine_(engine), index_(i), available_(false) {}
 
 PDFiumPage::PDFiumPage(PDFiumPage&& that) = default;
 
@@ -121,7 +296,6 @@ void PDFiumPage::Unload() {
 
 FPDF_PAGE PDFiumPage::GetPage() {
   ScopedUnsupportedFeature scoped_unsupported_feature(engine_);
-  ScopedSubstFont scoped_subst_font(engine_);
   if (!available_)
     return nullptr;
   if (!page_) {
@@ -134,26 +308,6 @@ FPDF_PAGE PDFiumPage::GetPage() {
   return page();
 }
 
-FPDF_PAGE PDFiumPage::GetPrintPage() {
-  ScopedUnsupportedFeature scoped_unsupported_feature(engine_);
-  ScopedSubstFont scoped_subst_font(engine_);
-  if (!available_)
-    return nullptr;
-  if (!page_) {
-    ScopedUnloadPreventer scoped_unload_preventer(this);
-    page_.reset(FPDF_LoadPage(engine_->doc(), index_));
-  }
-  return page();
-}
-
-void PDFiumPage::ClosePrintPage() {
-  // Do not close |page_| while in the middle of a load.
-  if (preventing_unload_count_)
-    return;
-
-  page_.reset();
-}
-
 FPDF_TEXTPAGE PDFiumPage::GetTextPage() {
   if (!available_)
     return nullptr;
@@ -164,63 +318,292 @@ FPDF_TEXTPAGE PDFiumPage::GetTextPage() {
   return text_page();
 }
 
-void PDFiumPage::GetTextRunInfo(int start_char_index,
-                                uint32_t* out_len,
-                                double* out_font_size,
-                                pp::FloatRect* out_bounds) {
+void PDFiumPage::CalculatePageObjectTextRunBreaks() {
+  if (calculated_page_object_text_run_breaks_)
+    return;
+
+  calculated_page_object_text_run_breaks_ = true;
+  int chars_count = FPDFText_CountChars(GetTextPage());
+  if (chars_count == 0)
+    return;
+
+  CalculateLinks();
+  for (const auto& link : links_) {
+    if (link.start_char_index >= 0 && link.start_char_index < chars_count) {
+      page_object_text_run_breaks_.insert(link.start_char_index);
+      int next_text_run_break_index = link.start_char_index + link.char_count;
+      // Don't insert a break if the link is at the end of the page text.
+      if (next_text_run_break_index < chars_count) {
+        page_object_text_run_breaks_.insert(next_text_run_break_index);
+      }
+    }
+  }
+
+  PopulateAnnotations();
+  for (const auto& highlight : highlights_) {
+    if (highlight.start_char_index >= 0 &&
+        highlight.start_char_index < chars_count) {
+      page_object_text_run_breaks_.insert(highlight.start_char_index);
+      int next_text_run_break_index =
+          highlight.start_char_index + highlight.char_count;
+      // Don't insert a break if the highlight is at the end of the page text.
+      if (next_text_run_break_index < chars_count) {
+        page_object_text_run_breaks_.insert(next_text_run_break_index);
+      }
+    }
+  }
+}
+
+void PDFiumPage::CalculateTextRunStyleInfo(
+    int char_index,
+    AccessibilityTextStyleInfo& style_info) {
+  FPDF_TEXTPAGE text_page = GetTextPage();
+  style_info.font_size = FPDFText_GetFontSize(text_page, char_index);
+
+  int flags = 0;
+  size_t buffer_size =
+      FPDFText_GetFontInfo(text_page, char_index, nullptr, 0, &flags);
+  if (buffer_size > 0) {
+    PDFiumAPIStringBufferAdapter<std::string> api_string_adapter(
+        &style_info.font_name, buffer_size, true);
+    void* data = api_string_adapter.GetData();
+    size_t bytes_written =
+        FPDFText_GetFontInfo(text_page, char_index, data, buffer_size, nullptr);
+    // Trim the null character.
+    api_string_adapter.Close(bytes_written);
+  }
+
+  style_info.font_weight = FPDFText_GetFontWeight(text_page, char_index);
+  // As defined in PDF 1.7 table 5.20.
+  constexpr int kFlagItalic = (1 << 6);
+  // Bold text is considered bold when greater than or equal to 700.
+  constexpr int kStandardBoldValue = 700;
+  style_info.is_italic = (flags & kFlagItalic);
+  style_info.is_bold = style_info.font_weight >= kStandardBoldValue;
+  unsigned int fill_r;
+  unsigned int fill_g;
+  unsigned int fill_b;
+  unsigned int fill_a;
+  if (FPDFText_GetFillColor(text_page, char_index, &fill_r, &fill_g, &fill_b,
+                            &fill_a)) {
+    style_info.fill_color = MakeARGB(fill_a, fill_r, fill_g, fill_b);
+  } else {
+    style_info.fill_color = MakeARGB(0xff, 0, 0, 0);
+  }
+
+  unsigned int stroke_r;
+  unsigned int stroke_g;
+  unsigned int stroke_b;
+  unsigned int stroke_a;
+  if (FPDFText_GetStrokeColor(text_page, char_index, &stroke_r, &stroke_g,
+                              &stroke_b, &stroke_a)) {
+    style_info.stroke_color = MakeARGB(stroke_a, stroke_r, stroke_g, stroke_b);
+  } else {
+    style_info.stroke_color = MakeARGB(0xff, 0, 0, 0);
+  }
+
+  int render_mode = FPDFText_GetTextRenderMode(text_page, char_index);
+  DCHECK_GE(render_mode,
+            static_cast<int>(AccessibilityTextRenderMode::kUnknown));
+  DCHECK_LE(render_mode,
+            static_cast<int>(AccessibilityTextRenderMode::kMaxValue));
+  style_info.render_mode =
+      static_cast<AccessibilityTextRenderMode>(render_mode);
+}
+
+bool PDFiumPage::AreTextStyleEqual(int char_index,
+                                   const AccessibilityTextStyleInfo& style) {
+  AccessibilityTextStyleInfo char_style;
+  CalculateTextRunStyleInfo(char_index, char_style);
+  return char_style.font_name == style.font_name &&
+         char_style.font_weight == style.font_weight &&
+         char_style.render_mode == style.render_mode &&
+         FloatEquals(char_style.font_size, style.font_size) &&
+         char_style.fill_color == style.fill_color &&
+         char_style.stroke_color == style.stroke_color &&
+         char_style.is_italic == style.is_italic &&
+         char_style.is_bold == style.is_bold;
+}
+
+void PDFiumPage::LogOverlappingAnnotations() {
+  if (logged_overlapping_annotations_)
+    return;
+  logged_overlapping_annotations_ = true;
+
+  DCHECK(calculated_page_object_text_run_breaks_);
+
+  std::vector<Link> links = links_;
+  std::sort(links.begin(), links.end(), [](const Link& a, const Link& b) {
+    return a.start_char_index < b.start_char_index;
+  });
+  uint32_t overlap_count = CountLinkHighlightOverlaps(links, highlights_);
+  // We log this overlap count per page of the PDF. Typically we expect only a
+  // few overlaps because intersecting links/highlights are not that common.
+  base::UmaHistogramCustomCounts("PDF.LinkHighlightOverlapsInPage",
+                                 overlap_count, 1, 100, 50);
+}
+
+base::Optional<AccessibilityTextRunInfo> PDFiumPage::GetTextRunInfo(
+    int start_char_index) {
   FPDF_PAGE page = GetPage();
   FPDF_TEXTPAGE text_page = GetTextPage();
   int chars_count = FPDFText_CountChars(text_page);
-  int char_index = start_char_index;
-  while (
-      char_index < chars_count &&
-      base::IsUnicodeWhitespace(FPDFText_GetUnicode(text_page, char_index))) {
-    char_index++;
+  // Check to make sure |start_char_index| is within bounds.
+  if (start_char_index < 0 || start_char_index >= chars_count)
+    return base::nullopt;
+
+  int actual_start_char_index = GetFirstNonUnicodeWhiteSpaceCharIndex(
+      text_page, start_char_index, chars_count);
+  // Check to see if GetFirstNonUnicodeWhiteSpaceCharIndex() iterated through
+  // all the characters.
+  if (actual_start_char_index >= chars_count) {
+    // If so, |info.len| needs to take the number of characters
+    // iterated into account.
+    DCHECK_GT(actual_start_char_index, start_char_index);
+    AccessibilityTextRunInfo info;
+    info.len = chars_count - start_char_index;
+    return info;
   }
-  int text_run_font_size = FPDFText_GetFontSize(text_page, char_index);
-  pp::FloatRect text_run_bounds =
+
+  // If the first character in a text run is a space, we need to start
+  // |text_run_bounds| from the space character instead of the first
+  // non-space unicode character.
+  gfx::RectF text_run_bounds =
+      actual_start_char_index > start_char_index
+          ? GetFloatCharRectInPixels(page, text_page, start_char_index)
+          : gfx::RectF();
+
+  // Pdfium trims more than 1 consecutive spaces to 1 space.
+  DCHECK_LE(actual_start_char_index - start_char_index, 1);
+
+  int char_index = actual_start_char_index;
+
+  // Set text run's style info from the first character of the text run.
+  AccessibilityTextRunInfo info;
+  CalculateTextRunStyleInfo(char_index, info.style);
+
+  gfx::RectF start_char_rect =
       GetFloatCharRectInPixels(page, text_page, char_index);
+  float text_run_font_size = info.style.font_size;
+
+  // Heuristic: Initialize the average character size to one-third of the font
+  // size to avoid having the first few characters misrepresent the average.
+  // Without it, if a text run starts with a '.', its small bounding box could
+  // lead to a break in the text run after only one space. Ex: ". Hello World"
+  // would be split in two runs: "." and "Hello World".
+  double font_size_minimum = FPDFText_GetFontSize(text_page, char_index) / 3.0;
+  gfx::SizeF avg_char_size(font_size_minimum, font_size_minimum);
+  int non_whitespace_chars_count = 1;
+  AddCharSizeToAverageCharSize(start_char_rect.size(), &avg_char_size,
+                               &non_whitespace_chars_count);
+
+  // Add first non-space char to text run.
+  text_run_bounds.Union(start_char_rect);
+  AccessibilityTextDirection char_direction =
+      GetDirectionFromAngle(FPDFText_GetCharAngle(text_page, char_index));
   if (char_index < chars_count)
     char_index++;
+
+  gfx::RectF prev_char_rect = start_char_rect;
+  float estimated_font_size =
+      std::max(start_char_rect.width(), start_char_rect.height());
+
+  // The angle of the vector starting at the first character center-point and
+  // ending at the current last character center-point.
+  float text_run_angle = 0;
+
+  CalculatePageObjectTextRunBreaks();
+  const auto breakpoint_iter =
+      std::lower_bound(page_object_text_run_breaks_.begin(),
+                       page_object_text_run_breaks_.end(), char_index);
+  int breakpoint_index = breakpoint_iter != page_object_text_run_breaks_.end()
+                             ? *breakpoint_iter
+                             : -1;
+
+  // Continue adding characters until heuristics indicate we should end the text
+  // run.
   while (char_index < chars_count) {
+    // Split a text run when it encounters a page object like links or images.
+    if (char_index == breakpoint_index)
+      break;
+
     unsigned int character = FPDFText_GetUnicode(text_page, char_index);
+    gfx::RectF char_rect =
+        GetFloatCharRectInPixels(page, text_page, char_index);
 
     if (!base::IsUnicodeWhitespace(character)) {
-      // TODO(dmazzoni): this assumes horizontal text.
-      // https://crbug.com/580311
-      pp::FloatRect char_rect =
-          GetFloatCharRectInPixels(page, text_page, char_index);
-      if (!char_rect.IsEmpty() && !OverlapsOnYAxis(text_run_bounds, char_rect))
+      // Heuristic: End the text run if the text style of the current character
+      // is different from the text run's style.
+      if (!AreTextStyleEqual(char_index, info.style))
         break;
 
-      int font_size = FPDFText_GetFontSize(text_page, char_index);
-      if (font_size != text_run_font_size)
+      // Heuristic: End text run if character isn't going in the same direction.
+      if (char_direction !=
+          GetDirectionFromAngle(FPDFText_GetCharAngle(text_page, char_index)))
         break;
 
-      // Heuristic: split a text run after a space longer than 3 average
-      // characters.
-      double avg_char_width =
-          text_run_bounds.width() / (char_index - start_char_index);
-      if (char_rect.x() - text_run_bounds.right() > avg_char_width * 3)
+      // Heuristic: End the text run if the difference between the text run
+      // angle and the angle between the center-points of the previous and
+      // current characters is greater than 90 degrees.
+      float current_angle = GetAngleOfVector(char_rect.CenterPoint() -
+                                             prev_char_rect.CenterPoint());
+      if (start_char_rect != prev_char_rect) {
+        text_run_angle = GetAngleOfVector(prev_char_rect.CenterPoint() -
+                                          start_char_rect.CenterPoint());
+
+        if (GetAngleDifference(text_run_angle, current_angle) >
+            k90DegreesInRadians) {
+          break;
+        }
+      }
+
+      // Heuristic: End the text run if the center-point distance to the
+      // previous character is less than 2.5x the average character size.
+      AddCharSizeToAverageCharSize(char_rect.size(), &avg_char_size,
+                                   &non_whitespace_chars_count);
+
+      float avg_char_width = GetRotatedCharWidth(current_angle, avg_char_size);
+
+      float distance =
+          (char_rect.CenterPoint() - prev_char_rect.CenterPoint()).Length() -
+          GetRotatedCharWidth(current_angle, char_rect.size()) / 2 -
+          GetRotatedCharWidth(current_angle, prev_char_rect.size()) / 2;
+
+      if (distance > 2.5f * avg_char_width)
         break;
 
-      text_run_bounds = text_run_bounds.Union(char_rect);
+      text_run_bounds.Union(char_rect);
+      prev_char_rect = char_rect;
+    }
+
+    if (!char_rect.IsEmpty()) {
+      // Update the estimated font size if needed.
+      float char_largest_side = std::max(char_rect.height(), char_rect.width());
+      estimated_font_size = std::max(char_largest_side, estimated_font_size);
     }
 
     char_index++;
   }
 
   // Some PDFs have missing or obviously bogus font sizes; substitute the
-  // height of the bounding box in those cases.
-  if (text_run_font_size <= 1 ||
-      text_run_font_size < text_run_bounds.height() / 2 ||
-      text_run_font_size > text_run_bounds.height() * 2) {
-    text_run_font_size = text_run_bounds.height();
+  // font size by the width or height (whichever's the largest) of the bigger
+  // character in the current text run.
+  if (text_run_font_size <= 1 || text_run_font_size < estimated_font_size / 2 ||
+      text_run_font_size > estimated_font_size * 2) {
+    text_run_font_size = estimated_font_size;
   }
 
-  *out_len = char_index - start_char_index;
-  *out_font_size = text_run_font_size;
-  *out_bounds = text_run_bounds;
+  info.len = char_index - start_char_index;
+  info.style.font_size = text_run_font_size;
+  info.bounds = text_run_bounds;
+  // Infer text direction from first and last character of the text run. We
+  // can't base our decision on the character direction, since a character of a
+  // RTL language will have an angle of 0 when not rotated, just like a
+  // character in a LTR language.
+  info.direction = char_index - actual_start_char_index > 1
+                       ? GetDirectionFromAngle(text_run_angle)
+                       : AccessibilityTextDirection::kNone;
+  return info;
 }
 
 uint32_t PDFiumPage::GetCharUnicode(int char_index) {
@@ -228,26 +611,178 @@ uint32_t PDFiumPage::GetCharUnicode(int char_index) {
   return FPDFText_GetUnicode(text_page, char_index);
 }
 
-pp::FloatRect PDFiumPage::GetCharBounds(int char_index) {
+gfx::RectF PDFiumPage::GetCharBounds(int char_index) {
   FPDF_PAGE page = GetPage();
   FPDF_TEXTPAGE text_page = GetTextPage();
   return GetFloatCharRectInPixels(page, text_page, char_index);
 }
 
-PDFiumPage::Area PDFiumPage::GetCharIndex(const pp::Point& point,
-                                          int rotation,
+std::vector<AccessibilityLinkInfo> PDFiumPage::GetLinkInfo(
+    const std::vector<AccessibilityTextRunInfo>& text_runs) {
+  std::vector<AccessibilityLinkInfo> link_info;
+  if (!available_)
+    return link_info;
+
+  CalculateLinks();
+
+  link_info.reserve(links_.size());
+  for (size_t i = 0; i < links_.size(); ++i) {
+    const Link& link = links_[i];
+    AccessibilityLinkInfo cur_info;
+    cur_info.url = link.target.url;
+    cur_info.index_in_page = i;
+    cur_info.text_range = GetEnclosingTextRunRangeForCharRange(
+        text_runs, link.start_char_index, link.char_count);
+
+    gfx::Rect link_rect;
+    for (const auto& rect : link.bounding_rects)
+      link_rect.Union(rect);
+    cur_info.bounds = gfx::RectF(link_rect.x(), link_rect.y(),
+                                 link_rect.width(), link_rect.height());
+
+    link_info.push_back(std::move(cur_info));
+  }
+
+  std::sort(link_info.begin(), link_info.end(),
+            CompareTextRuns<AccessibilityLinkInfo>);
+  return link_info;
+}
+
+std::vector<AccessibilityImageInfo> PDFiumPage::GetImageInfo(
+    uint32_t text_run_count) {
+  std::vector<AccessibilityImageInfo> image_info;
+  if (!available_)
+    return image_info;
+
+  CalculateImages();
+
+  image_info.reserve(images_.size());
+  for (const Image& image : images_) {
+    AccessibilityImageInfo cur_info;
+    cur_info.alt_text = image.alt_text;
+    // TODO(mohitb): Update text run index to nearest text run to image bounds.
+    cur_info.text_run_index = text_run_count;
+    cur_info.bounds =
+        gfx::RectF(image.bounding_rect.x(), image.bounding_rect.y(),
+                   image.bounding_rect.width(), image.bounding_rect.height());
+    image_info.push_back(std::move(cur_info));
+  }
+  return image_info;
+}
+
+std::vector<AccessibilityHighlightInfo> PDFiumPage::GetHighlightInfo(
+    const std::vector<AccessibilityTextRunInfo>& text_runs) {
+  std::vector<AccessibilityHighlightInfo> highlight_info;
+  if (!available_)
+    return highlight_info;
+
+  PopulateAnnotations();
+
+  highlight_info.reserve(highlights_.size());
+  for (size_t i = 0; i < highlights_.size(); ++i) {
+    const Highlight& highlight = highlights_[i];
+    AccessibilityHighlightInfo cur_info;
+    cur_info.index_in_page = i;
+    cur_info.text_range = GetEnclosingTextRunRangeForCharRange(
+        text_runs, highlight.start_char_index, highlight.char_count);
+    cur_info.bounds = gfx::RectF(
+        highlight.bounding_rect.x(), highlight.bounding_rect.y(),
+        highlight.bounding_rect.width(), highlight.bounding_rect.height());
+    cur_info.color = highlight.color;
+    cur_info.note_text = highlight.note_text;
+    highlight_info.push_back(std::move(cur_info));
+  }
+
+  std::sort(highlight_info.begin(), highlight_info.end(),
+            CompareTextRuns<AccessibilityHighlightInfo>);
+  return highlight_info;
+}
+
+std::vector<AccessibilityTextFieldInfo> PDFiumPage::GetTextFieldInfo(
+    uint32_t text_run_count) {
+  std::vector<AccessibilityTextFieldInfo> text_field_info;
+  if (!available_)
+    return text_field_info;
+
+  PopulateAnnotations();
+
+  text_field_info.reserve(text_fields_.size());
+  for (size_t i = 0; i < text_fields_.size(); ++i) {
+    const TextField& text_field = text_fields_[i];
+    AccessibilityTextFieldInfo cur_info;
+    cur_info.name = text_field.name;
+    cur_info.value = text_field.value;
+    cur_info.index_in_page = i;
+    cur_info.is_read_only = !!(text_field.flags & FPDF_FORMFLAG_READONLY);
+    cur_info.is_required = !!(text_field.flags & FPDF_FORMFLAG_REQUIRED);
+    cur_info.is_password = !!(text_field.flags & FPDF_FORMFLAG_TEXT_PASSWORD);
+    // TODO(crbug.com/1030242): Update text run index to nearest text run to
+    // text field bounds.
+    cur_info.text_run_index = text_run_count;
+    cur_info.bounds = gfx::RectF(
+        text_field.bounding_rect.x(), text_field.bounding_rect.y(),
+        text_field.bounding_rect.width(), text_field.bounding_rect.height());
+    text_field_info.push_back(std::move(cur_info));
+  }
+  return text_field_info;
+}
+
+PDFiumPage::Area PDFiumPage::GetLinkTargetAtIndex(int link_index,
+                                                  LinkTarget* target) {
+  if (!available_ || link_index < 0)
+    return NONSELECTABLE_AREA;
+  CalculateLinks();
+  if (link_index >= static_cast<int>(links_.size()))
+    return NONSELECTABLE_AREA;
+  *target = links_[link_index].target;
+  return target->url.empty() ? DOCLINK_AREA : WEBLINK_AREA;
+}
+
+PDFiumPage::Area PDFiumPage::GetLinkTarget(FPDF_LINK link, LinkTarget* target) {
+  FPDF_DEST dest_link = FPDFLink_GetDest(engine_->doc(), link);
+  if (dest_link)
+    return GetDestinationTarget(dest_link, target);
+
+  FPDF_ACTION action = FPDFLink_GetAction(link);
+  if (!action)
+    return NONSELECTABLE_AREA;
+
+  switch (FPDFAction_GetType(action)) {
+    case PDFACTION_GOTO: {
+      FPDF_DEST dest_action = FPDFAction_GetDest(engine_->doc(), action);
+      if (dest_action)
+        return GetDestinationTarget(dest_action, target);
+      // TODO(crbug.com/55776): We don't fully support all types of the
+      // in-document links.
+      return NONSELECTABLE_AREA;
+    }
+    case PDFACTION_URI:
+      return GetURITarget(action, target);
+      // TODO(crbug.com/767191): Support PDFACTION_LAUNCH.
+      // TODO(crbug.com/142344): Support PDFACTION_REMOTEGOTO.
+    case PDFACTION_LAUNCH:
+    case PDFACTION_REMOTEGOTO:
+    default:
+      return NONSELECTABLE_AREA;
+  }
+}
+
+PDFiumPage::Area PDFiumPage::GetCharIndex(const gfx::Point& point,
+                                          PageOrientation orientation,
                                           int* char_index,
                                           int* form_type,
                                           LinkTarget* target) {
   if (!available_)
     return NONSELECTABLE_AREA;
-  pp::Point point2 = point - rect_.point();
+
+  gfx::Point device_point = point - rect_.OffsetFromOrigin();
   double new_x;
   double new_y;
-  FPDF_BOOL ret =
-      FPDF_DeviceToPage(GetPage(), 0, 0, rect_.width(), rect_.height(),
-                        rotation, point2.x(), point2.y(), &new_x, &new_y);
-  DCHECK(ret);
+  if (!FPDF_DeviceToPage(GetPage(), 0, 0, rect_.width(), rect_.height(),
+                         ToPDFiumRotation(orientation), device_point.x(),
+                         device_point.y(), &new_x, &new_y)) {
+    return NONSELECTABLE_AREA;
+  }
 
   // hit detection tolerance, in points.
   constexpr double kTolerance = 20.0;
@@ -312,10 +847,10 @@ PDFiumPage::Area PDFiumPage::FormTypeToArea(int form_type) {
   }
 }
 
-base::char16 PDFiumPage::GetCharAtIndex(int index) {
+char16_t PDFiumPage::GetCharAtIndex(int index) {
   if (!available_)
     return L'\0';
-  return static_cast<base::char16>(FPDFText_GetUnicode(GetTextPage(), index));
+  return char16_t{FPDFText_GetUnicode(GetTextPage(), index)};
 }
 
 int PDFiumPage::GetCharCount() {
@@ -324,33 +859,8 @@ int PDFiumPage::GetCharCount() {
   return FPDFText_CountChars(GetTextPage());
 }
 
-PDFiumPage::Area PDFiumPage::GetLinkTarget(FPDF_LINK link, LinkTarget* target) {
-  FPDF_DEST dest = FPDFLink_GetDest(engine_->doc(), link);
-  if (dest)
-    return GetDestinationTarget(dest, target);
-
-  FPDF_ACTION action = FPDFLink_GetAction(link);
-  if (!action)
-    return NONSELECTABLE_AREA;
-
-  switch (FPDFAction_GetType(action)) {
-    case PDFACTION_GOTO: {
-      FPDF_DEST dest = FPDFAction_GetDest(engine_->doc(), action);
-      if (dest)
-        return GetDestinationTarget(dest, target);
-      // TODO(crbug.com/55776): We don't fully support all types of the
-      // in-document links.
-      return NONSELECTABLE_AREA;
-    }
-    case PDFACTION_URI:
-      return GetURITarget(action, target);
-    // TODO(crbug.com/767191): Support PDFACTION_LAUNCH.
-    // TODO(crbug.com/142344): Support PDFACTION_REMOTEGOTO.
-    case PDFACTION_LAUNCH:
-    case PDFACTION_REMOTEGOTO:
-    default:
-      return NONSELECTABLE_AREA;
-  }
+bool PDFiumPage::IsCharIndexInBounds(int index) {
+  return index >= 0 && index < GetCharCount();
 }
 
 PDFiumPage::Area PDFiumPage::GetDestinationTarget(FPDF_DEST destination,
@@ -364,16 +874,31 @@ PDFiumPage::Area PDFiumPage::GetDestinationTarget(FPDF_DEST destination,
 
   target->page = page_index;
 
-  base::Optional<gfx::PointF> xy = GetPageXYTarget(destination);
-  if (xy)
-    target->y_in_pixels = TransformPageToScreenXY(xy.value()).y();
+  base::Optional<float> x;
+  base::Optional<float> y;
+  GetPageDestinationTarget(destination, &x, &y, &target->zoom);
+
+  if (x) {
+    target->x_in_pixels =
+        TransformPageToScreenX(PreProcessInPageCoordX(x.value()));
+  }
+  if (y) {
+    target->y_in_pixels =
+        TransformPageToScreenY(PreProcessInPageCoordY(y.value()));
+  }
 
   return DOCLINK_AREA;
 }
 
-base::Optional<gfx::PointF> PDFiumPage::GetPageXYTarget(FPDF_DEST destination) {
+void PDFiumPage::GetPageDestinationTarget(FPDF_DEST destination,
+                                          base::Optional<float>* dest_x,
+                                          base::Optional<float>* dest_y,
+                                          base::Optional<float>* zoom_value) {
+  *dest_x = base::nullopt;
+  *dest_y = base::nullopt;
+  *zoom_value = base::nullopt;
   if (!available_)
-    return {};
+    return;
 
   FPDF_BOOL has_x_coord;
   FPDF_BOOL has_y_coord;
@@ -384,34 +909,54 @@ base::Optional<gfx::PointF> PDFiumPage::GetPageXYTarget(FPDF_DEST destination) {
   FPDF_BOOL success = FPDFDest_GetLocationInPage(
       destination, &has_x_coord, &has_y_coord, &has_zoom, &x, &y, &zoom);
 
-  if (!success || !has_x_coord || !has_y_coord)
-    return {};
+  if (!success)
+    return;
 
-  return {gfx::PointF(x, y)};
+  if (has_x_coord)
+    *dest_x = x;
+  if (has_y_coord)
+    *dest_y = y;
+  if (has_zoom)
+    *zoom_value = zoom;
+}
+
+float PDFiumPage::PreProcessInPageCoordX(float x) {
+  // If `x` < 0, scroll to the left side of the page.
+  // If `x` > width, scroll to the right side of the page.
+  return std::max<float>(std::min<float>(x, FPDF_GetPageWidthF(GetPage())), 0);
+}
+
+float PDFiumPage::PreProcessInPageCoordY(float y) {
+  // If `y` < 0, it is a valid input, no extra handling is needed.
+  // If `y` > height, scroll to the top of the page.
+  return std::min<float>(y, FPDF_GetPageHeightF(GetPage()));
 }
 
 gfx::PointF PDFiumPage::TransformPageToScreenXY(const gfx::PointF& xy) {
   if (!available_)
     return gfx::PointF();
 
-  pp::FloatRect page_rect(xy.x(), xy.y(), 0, 0);
-  pp::FloatRect pixel_rect(FloatPageRectToPixelRect(GetPage(), page_rect));
+  gfx::RectF page_rect(xy.x(), xy.y(), 0, 0);
+  gfx::RectF pixel_rect(FloatPageRectToPixelRect(GetPage(), page_rect));
   return gfx::PointF(pixel_rect.x(), pixel_rect.y());
 }
 
+float PDFiumPage::TransformPageToScreenX(float x) {
+  return TransformPageToScreenXY(gfx::PointF(x, 0)).x();
+}
+
+float PDFiumPage::TransformPageToScreenY(float y) {
+  return TransformPageToScreenXY(gfx::PointF(0, y)).y();
+}
+
 PDFiumPage::Area PDFiumPage::GetURITarget(FPDF_ACTION uri_action,
                                           LinkTarget* target) const {
   if (target) {
-    size_t buffer_size =
-        FPDFAction_GetURIPath(engine_->doc(), uri_action, nullptr, 0);
-    if (buffer_size > 0) {
-      PDFiumAPIStringBufferAdapter<std::string> api_string_adapter(
-          &target->url, buffer_size, true);
-      void* data = api_string_adapter.GetData();
-      size_t bytes_written =
-          FPDFAction_GetURIPath(engine_->doc(), uri_action, data, buffer_size);
-      api_string_adapter.Close(bytes_written);
-    }
+    std::string url = CallPDFiumStringBufferApi(
+        base::BindRepeating(&FPDFAction_GetURIPath, engine_->doc(), uri_action),
+        /*check_expected_size=*/true);
+    if (!url.empty())
+      target->url = url;
   }
   return WEBLINK_AREA;
 }
@@ -428,15 +973,19 @@ int PDFiumPage::GetLink(int char_index, LinkTarget* target) {
   double right;
   double bottom;
   double top;
-  FPDFText_GetCharBox(GetTextPage(), char_index, &left, &right, &bottom, &top);
+  if (!FPDFText_GetCharBox(GetTextPage(), char_index, &left, &right, &bottom,
+                           &top)) {
+    return -1;
+  }
 
-  pp::Point origin(
-      PageToScreen(pp::Point(), 1.0, left, top, right, bottom, 0).point());
+  gfx::Point origin = PageToScreen(gfx::Point(), 1.0, left, top, right, bottom,
+                                   PageOrientation::kOriginal)
+                          .origin();
   for (size_t i = 0; i < links_.size(); ++i) {
-    for (const auto& rect : links_[i].rects) {
+    for (const auto& rect : links_[i].bounding_rects) {
       if (rect.Contains(origin)) {
         if (target)
-          target->url = links_[i].url;
+          target->url = links_[i].target.url;
         return i;
       }
     }
@@ -444,66 +993,46 @@ int PDFiumPage::GetLink(int char_index, LinkTarget* target) {
   return -1;
 }
 
-std::vector<int> PDFiumPage::GetLinks(pp::Rect text_area,
-                                      std::vector<LinkTarget>* targets) {
-  std::vector<int> links;
-  if (!available_)
-    return links;
-
-  CalculateLinks();
-
-  for (size_t i = 0; i < links_.size(); ++i) {
-    for (const auto& rect : links_[i].rects) {
-      if (rect.Intersects(text_area)) {
-        if (targets) {
-          LinkTarget target;
-          target.url = links_[i].url;
-          targets->push_back(target);
-        }
-        links.push_back(i);
-      }
-    }
-  }
-  return links;
-}
-
 void PDFiumPage::CalculateLinks() {
   if (calculated_links_)
     return;
 
   calculated_links_ = true;
-  FPDF_PAGELINK links = FPDFLink_LoadWebLinks(GetTextPage());
-  int count = FPDFLink_CountWebLinks(links);
+  PopulateWebLinks();
+  PopulateAnnotationLinks();
+}
+
+void PDFiumPage::PopulateWebLinks() {
+  ScopedFPDFPageLink links(FPDFLink_LoadWebLinks(GetTextPage()));
+  int count = FPDFLink_CountWebLinks(links.get());
   for (int i = 0; i < count; ++i) {
-    base::string16 url;
-    int url_length = FPDFLink_GetURL(links, i, nullptr, 0);
+    // WARNING: FPDFLink_GetURL() is not compatible with
+    // CallPDFiumWideStringBufferApi().
+    std::u16string url;
+    int url_length = FPDFLink_GetURL(links.get(), i, nullptr, 0);
     if (url_length > 0) {
-      PDFiumAPIStringBufferAdapter<base::string16> api_string_adapter(
+      PDFiumAPIStringBufferAdapter<std::u16string> api_string_adapter(
           &url, url_length, true);
       unsigned short* data =
           reinterpret_cast<unsigned short*>(api_string_adapter.GetData());
-      int actual_length = FPDFLink_GetURL(links, i, data, url_length);
+      int actual_length = FPDFLink_GetURL(links.get(), i, data, url_length);
       api_string_adapter.Close(actual_length);
     }
     Link link;
-    link.url = base::UTF16ToUTF8(url);
+    link.target.url = base::UTF16ToUTF8(url);
 
-    // If the link cannot be converted to a pp::Var, then it is not possible to
-    // pass it to JS. In this case, ignore the link like other PDF viewers.
-    // See http://crbug.com/312882 for an example.
-    pp::Var link_var(link.url);
-    if (!link_var.is_string())
+    if (!engine_->IsValidLink(link.target.url))
       continue;
 
     // Make sure all the characters in the URL are valid per RFC 1738.
     // http://crbug.com/340326 has a sample bad PDF.
     // GURL does not work correctly, e.g. it just strips \t \r \n.
     bool is_invalid_url = false;
-    for (size_t j = 0; j < link.url.length(); ++j) {
+    for (size_t j = 0; j < link.target.url.length(); ++j) {
       // Control characters are not allowed.
       // 0x7F is also a control character.
       // 0x80 and above are not in US-ASCII.
-      if (link.url[j] < ' ' || link.url[j] >= '\x7F') {
+      if (link.target.url[j] < ' ' || link.target.url[j] >= '\x7F') {
         is_invalid_url = true;
         break;
       }
@@ -511,59 +1040,448 @@ void PDFiumPage::CalculateLinks() {
     if (is_invalid_url)
       continue;
 
-    int rect_count = FPDFLink_CountRects(links, i);
+    int rect_count = FPDFLink_CountRects(links.get(), i);
     for (int j = 0; j < rect_count; ++j) {
       double left;
       double top;
       double right;
       double bottom;
-      FPDFLink_GetRect(links, i, j, &left, &top, &right, &bottom);
-      pp::Rect rect =
-          PageToScreen(pp::Point(), 1.0, left, top, right, bottom, 0);
+      if (!FPDFLink_GetRect(links.get(), i, j, &left, &top, &right, &bottom))
+        continue;
+      gfx::Rect rect = PageToScreen(gfx::Point(), 1.0, left, top, right, bottom,
+                                    PageOrientation::kOriginal);
       if (rect.IsEmpty())
         continue;
-      link.rects.push_back(rect);
+      link.bounding_rects.push_back(rect);
     }
+    FPDF_BOOL is_link_over_text = FPDFLink_GetTextRange(
+        links.get(), i, &link.start_char_index, &link.char_count);
+    DCHECK(is_link_over_text);
     links_.push_back(link);
   }
-  FPDFLink_CloseWebLinks(links);
 }
 
-pp::Rect PDFiumPage::PageToScreen(const pp::Point& offset,
-                                  double zoom,
-                                  double left,
-                                  double top,
-                                  double right,
-                                  double bottom,
-                                  int rotation) const {
-  if (!available_)
-    return pp::Rect();
+void PDFiumPage::PopulateAnnotationLinks() {
+  int start_pos = 0;
+  FPDF_LINK link_annot;
+  FPDF_PAGE page = GetPage();
+  while (FPDFLink_Enumerate(page, &start_pos, &link_annot)) {
+    Link link;
+    Area area = GetLinkTarget(link_annot, &link.target);
+    if (area == NONSELECTABLE_AREA)
+      continue;
 
-  double start_x = (rect_.x() - offset.x()) * zoom;
-  double start_y = (rect_.y() - offset.y()) * zoom;
+    FS_RECTF link_rect;
+    if (!FPDFLink_GetAnnotRect(link_annot, &link_rect))
+      continue;
+
+    // The horizontal/vertical coordinates in PDF Links could be
+    // flipped. Swap the coordinates before further processing.
+    if (link_rect.right < link_rect.left)
+      std::swap(link_rect.right, link_rect.left);
+    if (link_rect.bottom > link_rect.top)
+      std::swap(link_rect.bottom, link_rect.top);
+
+    int quad_point_count = FPDFLink_CountQuadPoints(link_annot);
+    // Calculate the bounds of link using the quad points data.
+    // If quad points for link is not present then use
+    // |link_rect| to calculate the bounds instead.
+    if (quad_point_count > 0) {
+      for (int i = 0; i < quad_point_count; ++i) {
+        FS_QUADPOINTSF point;
+        if (FPDFLink_GetQuadPoints(link_annot, i, &point)) {
+          // PDF Specifications: Quadpoints start from bottom left (x1, y1) and
+          // runs counter clockwise.
+          link.bounding_rects.push_back(
+              PageToScreen(gfx::Point(), 1.0, point.x4, point.y4, point.x2,
+                           point.y2, PageOrientation::kOriginal));
+        }
+      }
+    } else {
+      link.bounding_rects.push_back(PageToScreen(
+          gfx::Point(), 1.0, link_rect.left, link_rect.top, link_rect.right,
+          link_rect.bottom, PageOrientation::kOriginal));
+    }
+
+    // Calculate underlying text range of link.
+    GetUnderlyingTextRangeForRect(
+        gfx::RectF(link_rect.left, link_rect.bottom,
+                   std::abs(link_rect.right - link_rect.left),
+                   std::abs(link_rect.bottom - link_rect.top)),
+        &link.start_char_index, &link.char_count);
+    links_.emplace_back(link);
+  }
+}
+
+void PDFiumPage::CalculateImages() {
+  if (calculated_images_)
+    return;
+
+  calculated_images_ = true;
+  FPDF_PAGE page = GetPage();
+  int page_object_count = FPDFPage_CountObjects(page);
+  MarkedContentIdToImageMap marked_content_id_image_map;
+  bool is_tagged = FPDFCatalog_IsTagged(engine_->doc());
+  for (int i = 0; i < page_object_count; ++i) {
+    FPDF_PAGEOBJECT page_object = FPDFPage_GetObject(page, i);
+    if (FPDFPageObj_GetType(page_object) != FPDF_PAGEOBJ_IMAGE)
+      continue;
+    float left;
+    float top;
+    float right;
+    float bottom;
+    if (!FPDFPageObj_GetBounds(page_object, &left, &bottom, &right, &top))
+      continue;
+
+    Image image;
+    image.bounding_rect = PageToScreen(gfx::Point(), 1.0, left, top, right,
+                                       bottom, PageOrientation::kOriginal);
+
+    if (is_tagged) {
+      // Collect all marked content IDs for image objects so that they can
+      // later be used to retrieve alt text from struct tree for the page.
+      FPDF_IMAGEOBJ_METADATA image_metadata;
+      if (FPDFImageObj_GetImageMetadata(page_object, page, &image_metadata)) {
+        int marked_content_id = image_metadata.marked_content_id;
+        if (marked_content_id >= 0) {
+          // If |marked_content_id| is already present, ignore the one being
+          // inserted.
+          marked_content_id_image_map.insert(
+              {marked_content_id, images_.size()});
+        }
+      }
+    }
+    images_.push_back(image);
+  }
+
+  if (!marked_content_id_image_map.empty())
+    PopulateImageAltText(marked_content_id_image_map);
+}
+
+void PDFiumPage::PopulateImageAltText(
+    const MarkedContentIdToImageMap& marked_content_id_image_map) {
+  ScopedFPDFStructTree struct_tree(FPDF_StructTree_GetForPage(GetPage()));
+  if (!struct_tree)
+    return;
+
+  std::set<FPDF_STRUCTELEMENT> visited_elements;
+  int tree_children_count = FPDF_StructTree_CountChildren(struct_tree.get());
+  for (int i = 0; i < tree_children_count; ++i) {
+    FPDF_STRUCTELEMENT current_element =
+        FPDF_StructTree_GetChildAtIndex(struct_tree.get(), i);
+    PopulateImageAltTextForStructElement(marked_content_id_image_map,
+                                         current_element, &visited_elements);
+  }
+}
+
+void PDFiumPage::PopulateImageAltTextForStructElement(
+    const MarkedContentIdToImageMap& marked_content_id_image_map,
+    FPDF_STRUCTELEMENT current_element,
+    std::set<FPDF_STRUCTELEMENT>* visited_elements) {
+  if (!current_element)
+    return;
+
+  bool inserted = visited_elements->insert(current_element).second;
+  if (!inserted)
+    return;
+
+  int marked_content_id =
+      FPDF_StructElement_GetMarkedContentID(current_element);
+  if (marked_content_id >= 0) {
+    auto it = marked_content_id_image_map.find(marked_content_id);
+    if (it != marked_content_id_image_map.end() &&
+        images_[it->second].alt_text.empty()) {
+      images_[it->second].alt_text =
+          base::UTF16ToUTF8(CallPDFiumWideStringBufferApi(
+              base::BindRepeating(&FPDF_StructElement_GetAltText,
+                                  current_element),
+              /*check_expected_size=*/true));
+    }
+  }
+  int children_count = FPDF_StructElement_CountChildren(current_element);
+  for (int i = 0; i < children_count; ++i) {
+    FPDF_STRUCTELEMENT child =
+        FPDF_StructElement_GetChildAtIndex(current_element, i);
+    PopulateImageAltTextForStructElement(marked_content_id_image_map, child,
+                                         visited_elements);
+  }
+}
+
+void PDFiumPage::PopulateAnnotations() {
+  if (calculated_annotations_)
+    return;
+
+  FPDF_PAGE page = GetPage();
+  if (!page)
+    return;
+
+  int annotation_count = FPDFPage_GetAnnotCount(page);
+  for (int i = 0; i < annotation_count; ++i) {
+    ScopedFPDFAnnotation annot(FPDFPage_GetAnnot(page, i));
+    DCHECK(annot);
+    FPDF_ANNOTATION_SUBTYPE subtype = FPDFAnnot_GetSubtype(annot.get());
+
+    switch (subtype) {
+      case FPDF_ANNOT_HIGHLIGHT: {
+        PopulateHighlight(annot.get());
+        break;
+      }
+      case FPDF_ANNOT_WIDGET: {
+        PopulateFormField(annot.get());
+        break;
+      }
+      default:
+        break;
+    }
+  }
+  calculated_annotations_ = true;
+}
+
+void PDFiumPage::PopulateHighlight(FPDF_ANNOTATION annot) {
+  DCHECK(annot);
+  DCHECK_EQ(FPDFAnnot_GetSubtype(annot), FPDF_ANNOT_HIGHLIGHT);
+
+  FS_RECTF rect;
+  if (!FPDFAnnot_GetRect(annot, &rect))
+    return;
+
+  Highlight highlight;
+  // We use the bounding box of the highlight as the bounding rect.
+  highlight.bounding_rect =
+      PageToScreen(gfx::Point(), 1.0, rect.left, rect.top, rect.right,
+                   rect.bottom, PageOrientation::kOriginal);
+  GetUnderlyingTextRangeForRect(
+      gfx::RectF(rect.left, rect.bottom, std::abs(rect.right - rect.left),
+                 std::abs(rect.bottom - rect.top)),
+      &highlight.start_char_index, &highlight.char_count);
+
+  // Retrieve the color of the highlight.
+  unsigned int color_r;
+  unsigned int color_g;
+  unsigned int color_b;
+  unsigned int color_a;
+  FPDF_PAGEOBJECT page_object = FPDFAnnot_GetObject(annot, 0);
+  if (FPDFPageObj_GetFillColor(page_object, &color_r, &color_g, &color_b,
+                               &color_a)) {
+    highlight.color = MakeARGB(color_a, color_r, color_g, color_b);
+  } else {
+    // Set the same default color as in pdfium. See calls to
+    // GetColorStringWithDefault() in CPVT_GenerateAP::Generate*AP() in
+    // pdfium.
+    highlight.color = MakeARGB(255, 255, 255, 0);
+  }
+
+  // Retrieve the contents of the popup note associated with highlight.
+  // See table 164 in ISO 32000-1 standard for more details around "Contents"
+  // key in a highlight annotation.
+  static constexpr char kContents[] = "Contents";
+  highlight.note_text = base::UTF16ToUTF8(CallPDFiumWideStringBufferApi(
+      base::BindRepeating(&FPDFAnnot_GetStringValue, annot, kContents),
+      /*check_expected_size=*/true));
+
+  highlights_.push_back(std::move(highlight));
+}
+
+void PDFiumPage::PopulateTextField(FPDF_ANNOTATION annot) {
+  DCHECK(annot);
+  FPDF_FORMHANDLE form_handle = engine_->form();
+  DCHECK_EQ(FPDFAnnot_GetFormFieldType(form_handle, annot),
+            FPDF_FORMFIELD_TEXTFIELD);
+
+  TextField text_field;
+  if (!PopulateFormFieldProperties(annot, &text_field))
+    return;
+
+  text_field.value = base::UTF16ToUTF8(CallPDFiumWideStringBufferApi(
+      base::BindRepeating(&FPDFAnnot_GetFormFieldValue, form_handle, annot),
+      /*check_expected_size=*/true));
+  text_fields_.push_back(std::move(text_field));
+}
+
+void PDFiumPage::PopulateChoiceField(FPDF_ANNOTATION annot) {
+  DCHECK(annot);
+  FPDF_FORMHANDLE form_handle = engine_->form();
+  int form_field_type = FPDFAnnot_GetFormFieldType(form_handle, annot);
+  DCHECK(form_field_type == FPDF_FORMFIELD_LISTBOX ||
+         form_field_type == FPDF_FORMFIELD_COMBOBOX);
+
+  ChoiceField choice_field;
+  if (!PopulateFormFieldProperties(annot, &choice_field))
+    return;
+
+  int options_count = FPDFAnnot_GetOptionCount(form_handle, annot);
+  if (options_count < 0)
+    return;
+
+  choice_field.options.resize(options_count);
+  for (int i = 0; i < options_count; ++i) {
+    choice_field.options[i].name =
+        base::UTF16ToUTF8(CallPDFiumWideStringBufferApi(
+            base::BindRepeating(&FPDFAnnot_GetOptionLabel, form_handle, annot,
+                                i),
+            /*check_expected_size=*/true));
+    choice_field.options[i].is_selected =
+        FPDFAnnot_IsOptionSelected(form_handle, annot, i);
+  }
+  choice_fields_.push_back(std::move(choice_field));
+}
+
+void PDFiumPage::PopulateButton(FPDF_ANNOTATION annot) {
+  DCHECK(annot);
+  FPDF_FORMHANDLE form_handle = engine_->form();
+  int button_type = FPDFAnnot_GetFormFieldType(form_handle, annot);
+  DCHECK(button_type == FPDF_FORMFIELD_PUSHBUTTON ||
+         IsRadioButtonOrCheckBox(button_type));
+
+  Button button;
+  if (!PopulateFormFieldProperties(annot, &button))
+    return;
+
+  button.type = button_type;
+  if (IsRadioButtonOrCheckBox(button_type)) {
+    button.control_count = FPDFAnnot_GetFormControlCount(form_handle, annot);
+    if (button.control_count <= 0)
+      return;
+
+    button.control_index = FPDFAnnot_GetFormControlIndex(form_handle, annot);
+    button.value = base::UTF16ToUTF8(CallPDFiumWideStringBufferApi(
+        base::BindRepeating(&FPDFAnnot_GetFormFieldExportValue, form_handle,
+                            annot),
+        /*check_expected_size=*/true));
+    button.is_checked = FPDFAnnot_IsChecked(form_handle, annot);
+  }
+  buttons_.push_back(std::move(button));
+}
+
+void PDFiumPage::PopulateFormField(FPDF_ANNOTATION annot) {
+  DCHECK_EQ(FPDFAnnot_GetSubtype(annot), FPDF_ANNOT_WIDGET);
+  int form_field_type = FPDFAnnot_GetFormFieldType(engine_->form(), annot);
+
+  // TODO(crbug.com/1030242): Populate other types of form fields too.
+  switch (form_field_type) {
+    case FPDF_FORMFIELD_PUSHBUTTON:
+    case FPDF_FORMFIELD_CHECKBOX:
+    case FPDF_FORMFIELD_RADIOBUTTON: {
+      PopulateButton(annot);
+      break;
+    }
+    case FPDF_FORMFIELD_COMBOBOX:
+    case FPDF_FORMFIELD_LISTBOX: {
+      PopulateChoiceField(annot);
+      break;
+    }
+    case FPDF_FORMFIELD_TEXTFIELD: {
+      PopulateTextField(annot);
+      break;
+    }
+    default:
+      break;
+  }
+}
+
+bool PDFiumPage::PopulateFormFieldProperties(FPDF_ANNOTATION annot,
+                                             FormField* form_field) {
+  DCHECK(annot);
+  FS_RECTF rect;
+  if (!FPDFAnnot_GetRect(annot, &rect))
+    return false;
+
+  // We use the bounding box of the form field as the bounding rect.
+  form_field->bounding_rect =
+      PageToScreen(gfx::Point(), 1.0, rect.left, rect.top, rect.right,
+                   rect.bottom, PageOrientation::kOriginal);
+  FPDF_FORMHANDLE form_handle = engine_->form();
+  form_field->name = base::UTF16ToUTF8(CallPDFiumWideStringBufferApi(
+      base::BindRepeating(&FPDFAnnot_GetFormFieldName, form_handle, annot),
+      /*check_expected_size=*/true));
+  form_field->flags = FPDFAnnot_GetFormFieldFlags(form_handle, annot);
+  return true;
+}
+
+bool PDFiumPage::GetUnderlyingTextRangeForRect(const gfx::RectF& rect,
+                                               int* start_index,
+                                               int* char_len) {
+  if (!available_)
+    return false;
+
+  FPDF_TEXTPAGE text_page = GetTextPage();
+  int char_count = FPDFText_CountChars(text_page);
+  if (char_count <= 0)
+    return false;
+
+  int start_char_index = -1;
+  int cur_char_count = 0;
+
+  // Iterate over page text to find such continuous characters whose mid-points
+  // lie inside the rectangle.
+  for (int i = 0; i < char_count; ++i) {
+    double char_left;
+    double char_right;
+    double char_bottom;
+    double char_top;
+    if (!FPDFText_GetCharBox(text_page, i, &char_left, &char_right,
+                             &char_bottom, &char_top)) {
+      break;
+    }
+
+    float xmid = (char_left + char_right) / 2;
+    float ymid = (char_top + char_bottom) / 2;
+    if (rect.Contains(xmid, ymid)) {
+      if (start_char_index == -1)
+        start_char_index = i;
+      ++cur_char_count;
+    } else if (start_char_index != -1) {
+      break;
+    }
+  }
+
+  if (cur_char_count == 0)
+    return false;
+
+  *char_len = cur_char_count;
+  *start_index = start_char_index;
+  return true;
+}
+
+gfx::Rect PDFiumPage::PageToScreen(const gfx::Point& page_point,
+                                   double zoom,
+                                   double left,
+                                   double top,
+                                   double right,
+                                   double bottom,
+                                   PageOrientation orientation) const {
+  if (!available_)
+    return gfx::Rect();
+
+  double start_x = (rect_.x() - page_point.x()) * zoom;
+  double start_y = (rect_.y() - page_point.y()) * zoom;
   double size_x = rect_.width() * zoom;
   double size_y = rect_.height() * zoom;
   if (!base::IsValueInRangeForNumericType<int>(start_x) ||
       !base::IsValueInRangeForNumericType<int>(start_y) ||
       !base::IsValueInRangeForNumericType<int>(size_x) ||
       !base::IsValueInRangeForNumericType<int>(size_y)) {
-    return pp::Rect();
+    return gfx::Rect();
   }
 
   int new_left;
   int new_top;
+  if (!FPDF_PageToDevice(
+          page(), static_cast<int>(start_x), static_cast<int>(start_y),
+          static_cast<int>(ceil(size_x)), static_cast<int>(ceil(size_y)),
+          ToPDFiumRotation(orientation), left, top, &new_left, &new_top)) {
+    return gfx::Rect();
+  }
+
   int new_right;
   int new_bottom;
-  FPDF_BOOL ret = FPDF_PageToDevice(
-      page(), static_cast<int>(start_x), static_cast<int>(start_y),
-      static_cast<int>(ceil(size_x)), static_cast<int>(ceil(size_y)), rotation,
-      left, top, &new_left, &new_top);
-  DCHECK(ret);
-  ret = FPDF_PageToDevice(
-      page(), static_cast<int>(start_x), static_cast<int>(start_y),
-      static_cast<int>(ceil(size_x)), static_cast<int>(ceil(size_y)), rotation,
-      right, bottom, &new_right, &new_bottom);
-  DCHECK(ret);
+  if (!FPDF_PageToDevice(
+          page(), static_cast<int>(start_x), static_cast<int>(start_y),
+          static_cast<int>(ceil(size_x)), static_cast<int>(ceil(size_y)),
+          ToPDFiumRotation(orientation), right, bottom, &new_right,
+          &new_bottom)) {
+    return gfx::Rect();
+  }
 
   // If the PDF is rotated, the horizontal/vertical coordinates could be
   // flipped.  See
@@ -580,31 +1498,67 @@ pp::Rect PDFiumPage::PageToScreen(const pp::Point& offset,
   new_size_y -= new_top;
   new_size_y += 1;
   if (!new_size_x.IsValid() || !new_size_y.IsValid())
-    return pp::Rect();
+    return gfx::Rect();
 
-  return pp::Rect(new_left, new_top, new_size_x.ValueOrDie(),
-                  new_size_y.ValueOrDie());
+  return gfx::Rect(new_left, new_top, new_size_x.ValueOrDie(),
+                   new_size_y.ValueOrDie());
 }
 
-const PDFEngine::PageFeatures* PDFiumPage::GetPageFeatures() {
-  // If page_features_ is cached, return the cached features.
-  if (page_features_.IsInitialized())
-    return &page_features_;
+void PDFiumPage::RequestThumbnail(float device_pixel_ratio,
+                                  SendThumbnailCallback send_callback) {
+  DCHECK(!thumbnail_callback_);
 
-  FPDF_PAGE page = GetPage();
-  if (!page)
-    return nullptr;
-
-  // Initialize and cache page_features_.
-  page_features_.index = index_;
-  int annotation_count = FPDFPage_GetAnnotCount(page);
-  for (int i = 0; i < annotation_count; ++i) {
-    ScopedFPDFAnnotation annotation(FPDFPage_GetAnnot(page, i));
-    FPDF_ANNOTATION_SUBTYPE subtype = FPDFAnnot_GetSubtype(annotation.get());
-    page_features_.annotation_types.insert(subtype);
+  if (available()) {
+    GenerateAndSendThumbnail(device_pixel_ratio, std::move(send_callback));
+    return;
   }
 
-  return &page_features_;
+  // It is safe to use base::Unretained(this) because the callback is only used
+  // by |this|.
+  thumbnail_callback_ = base::BindOnce(
+      &PDFiumPage::GenerateAndSendThumbnail, base::Unretained(this),
+      device_pixel_ratio, std::move(send_callback));
+}
+
+Thumbnail PDFiumPage::GenerateThumbnail(float device_pixel_ratio) {
+  DCHECK(available());
+
+  FPDF_PAGE page = GetPage();
+  gfx::Size page_size(base::saturated_cast<int>(FPDF_GetPageWidthF(page)),
+                      base::saturated_cast<int>(FPDF_GetPageHeightF(page)));
+  Thumbnail thumbnail(page_size, device_pixel_ratio);
+
+  SkBitmap& sk_bitmap = thumbnail.bitmap();
+  ScopedFPDFBitmap fpdf_bitmap(FPDFBitmap_CreateEx(
+      sk_bitmap.width(), sk_bitmap.height(), FPDFBitmap_BGRA,
+      sk_bitmap.getPixels(), sk_bitmap.rowBytes()));
+
+  // Clear the bitmap.
+  FPDFBitmap_FillRect(fpdf_bitmap.get(), /*left=*/0, /*top=*/0,
+                      sk_bitmap.width(), sk_bitmap.height(),
+                      /*color=*/0xFFFFFFFF);
+
+  // The combination of the |FPDF_REVERSE_BYTE_ORDER| rendering flag and the
+  // |FPDFBitmap_BGRA| format when initializing |fpdf_bitmap| results in an RGBA
+  // rendering, which is the format required by HTML <canvas>.
+  FPDF_RenderPageBitmap(fpdf_bitmap.get(), GetPage(), /*start_x=*/0,
+                        /*start_y=*/0, sk_bitmap.width(), sk_bitmap.height(),
+                        /*rotate=*/0, FPDF_ANNOT | FPDF_REVERSE_BYTE_ORDER);
+
+  return thumbnail;
+}
+
+void PDFiumPage::GenerateAndSendThumbnail(float device_pixel_ratio,
+                                          SendThumbnailCallback send_callback) {
+  std::move(send_callback).Run(GenerateThumbnail(device_pixel_ratio));
+}
+
+void PDFiumPage::MarkAvailable() {
+  available_ = true;
+
+  // Fulfill pending thumbnail request.
+  if (thumbnail_callback_)
+    std::move(thumbnail_callback_).Run();
 }
 
 PDFiumPage::ScopedUnloadPreventer::ScopedUnloadPreventer(PDFiumPage* page)
@@ -622,4 +1576,72 @@ PDFiumPage::Link::Link(const Link& that) = default;
 
 PDFiumPage::Link::~Link() = default;
 
+PDFiumPage::Image::Image() = default;
+
+PDFiumPage::Image::Image(const Image& that) = default;
+
+PDFiumPage::Image::~Image() = default;
+
+PDFiumPage::Highlight::Highlight() = default;
+
+PDFiumPage::Highlight::Highlight(const Highlight& that) = default;
+
+PDFiumPage::Highlight::~Highlight() = default;
+
+PDFiumPage::FormField::FormField() = default;
+
+PDFiumPage::FormField::FormField(const FormField& that) = default;
+
+PDFiumPage::FormField::~FormField() = default;
+
+PDFiumPage::TextField::TextField() = default;
+
+PDFiumPage::TextField::TextField(const TextField& that) = default;
+
+PDFiumPage::TextField::~TextField() = default;
+
+PDFiumPage::ChoiceFieldOption::ChoiceFieldOption() = default;
+
+PDFiumPage::ChoiceFieldOption::ChoiceFieldOption(
+    const ChoiceFieldOption& that) = default;
+
+PDFiumPage::ChoiceFieldOption::~ChoiceFieldOption() = default;
+
+PDFiumPage::ChoiceField::ChoiceField() = default;
+
+PDFiumPage::ChoiceField::ChoiceField(const ChoiceField& that) = default;
+
+PDFiumPage::ChoiceField::~ChoiceField() = default;
+
+PDFiumPage::Button::Button() = default;
+
+PDFiumPage::Button::Button(const Button& that) = default;
+
+PDFiumPage::Button::~Button() = default;
+
+// static
+uint32_t PDFiumPage::CountLinkHighlightOverlaps(
+    const std::vector<Link>& links,
+    const std::vector<Highlight>& highlights) {
+  return CountOverlaps(links, highlights) + CountInternalTextOverlaps(links) +
+         CountInternalTextOverlaps(highlights);
+}
+
+int ToPDFiumRotation(PageOrientation orientation) {
+  // Could static_cast<int>(orientation), but using an exhaustive switch will
+  // trigger an error if we ever change the definition of PageOrientation.
+  switch (orientation) {
+    case PageOrientation::kOriginal:
+      return 0;
+    case PageOrientation::kClockwise90:
+      return 1;
+    case PageOrientation::kClockwise180:
+      return 2;
+    case PageOrientation::kClockwise270:
+      return 3;
+  }
+  NOTREACHED();
+  return 0;
+}
+
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_page.h b/pdf/pdfium/pdfium_page.h
index 86daadc0ed53..c1315dd4c537 100644
--- a/pdf/pdfium/pdfium_page.h
+++ b/pdf/pdfium/pdfium_page.h
@@ -5,27 +5,47 @@
 #ifndef PDF_PDFIUM_PDFIUM_PAGE_H_
 #define PDF_PDFIUM_PDFIUM_PAGE_H_
 
+#include <map>
+#include <set>
 #include <string>
 #include <vector>
 
+#include "base/callback.h"
+#include "base/callback_forward.h"
+#include "base/gtest_prod_util.h"
 #include "base/optional.h"
-#include "base/strings/string16.h"
+#include "pdf/page_orientation.h"
 #include "pdf/pdf_engine.h"
-#include "ppapi/cpp/rect.h"
+#include "ppapi/cpp/private/pdf.h"
 #include "third_party/pdfium/public/cpp/fpdf_scopers.h"
 #include "third_party/pdfium/public/fpdf_doc.h"
 #include "third_party/pdfium/public/fpdf_formfill.h"
 #include "third_party/pdfium/public/fpdf_text.h"
 #include "ui/gfx/geometry/point_f.h"
+#include "ui/gfx/geometry/rect.h"
+
+namespace gfx {
+class Point;
+class RectF;
+}  // namespace gfx
 
 namespace chrome_pdf {
 
 class PDFiumEngine;
+class Thumbnail;
+struct AccessibilityLinkInfo;
+struct AccessibilityHighlightInfo;
+struct AccessibilityImageInfo;
+struct AccessibilityTextFieldInfo;
+struct AccessibilityTextRunInfo;
+struct AccessibilityTextStyleInfo;
 
 // Wrapper around a page from the document.
 class PDFiumPage {
  public:
-  PDFiumPage(PDFiumEngine* engine, int i, const pp::Rect& r, bool available);
+  PDFiumPage(PDFiumEngine* engine, int i);
+  PDFiumPage(const PDFiumPage&) = delete;
+  PDFiumPage& operator=(const PDFiumPage&) = delete;
   PDFiumPage(PDFiumPage&& that);
   ~PDFiumPage();
 
@@ -33,25 +53,32 @@ class PDFiumPage {
   void Unload();
   // Gets the FPDF_PAGE for this page, loading and parsing it if necessary.
   FPDF_PAGE GetPage();
-  // Get the FPDF_PAGE for printing.
-  FPDF_PAGE GetPrintPage();
-  // Close the printing page.
-  void ClosePrintPage();
 
   // Returns FPDF_TEXTPAGE for the page, loading and parsing it if necessary.
   FPDF_TEXTPAGE GetTextPage();
 
-  // Given a start char index, find the longest continuous run of text that's
-  // in a single direction and with the same style and font size. Return the
-  // length of that sequence and its font size and bounding box.
-  void GetTextRunInfo(int start_char_index,
-                      uint32_t* out_len,
-                      double* out_font_size,
-                      pp::FloatRect* out_bounds);
+  // Log overlaps between annotations in the page.
+  void LogOverlappingAnnotations();
+  // See definition of PDFEngine::GetTextRunInfo().
+  base::Optional<AccessibilityTextRunInfo> GetTextRunInfo(int start_char_index);
   // Get a unicode character from the page.
   uint32_t GetCharUnicode(int char_index);
   // Get the bounds of a character in page pixels.
-  pp::FloatRect GetCharBounds(int char_index);
+  gfx::RectF GetCharBounds(int char_index);
+  // For all the links on the page, get their urls, underlying text ranges and
+  // bounding boxes.
+  std::vector<AccessibilityLinkInfo> GetLinkInfo(
+      const std::vector<AccessibilityTextRunInfo>& text_runs);
+  // For all the images on the page, get their alt texts and bounding boxes.
+  std::vector<AccessibilityImageInfo> GetImageInfo(uint32_t text_run_count);
+  // For all the highlights on the page, get their underlying text ranges and
+  // bounding boxes.
+  std::vector<AccessibilityHighlightInfo> GetHighlightInfo(
+      const std::vector<AccessibilityTextRunInfo>& text_runs);
+  // For all the text fields on the page, get their properties like name,
+  // value, bounding boxes, etc.
+  std::vector<AccessibilityTextFieldInfo> GetTextFieldInfo(
+      uint32_t text_run_count);
 
   enum Area {
     NONSELECTABLE_AREA,
@@ -74,22 +101,49 @@ class PDFiumPage {
 
     // Valid for DOCLINK_AREA only.
     int page;
-    // Valid for DOCLINK_AREA only. From the top of the page.
+    // Valid for DOCLINK_AREA only. From the top-left of the page.
+    base::Optional<float> x_in_pixels;
     base::Optional<float> y_in_pixels;
+    // Valid for DOCLINK_AREA only.
+    base::Optional<float> zoom;
   };
 
-  // Returns the (x, y) position of a destination in page coordinates.
-  base::Optional<gfx::PointF> GetPageXYTarget(FPDF_DEST destination);
+  // Given a |link_index|, returns the type of underlying area and the link
+  // target. |target| must be valid. Returns NONSELECTABLE_AREA if
+  // |link_index| is invalid.
+  Area GetLinkTargetAtIndex(int link_index, LinkTarget* target);
+
+  // Returns link type and fills target associated with a link. Returns
+  // NONSELECTABLE_AREA if link detection failed.
+  Area GetLinkTarget(FPDF_LINK link, LinkTarget* target);
+
+  // Fills the output params with the in-page coordinates and the zoom value of
+  // the destination.
+  void GetPageDestinationTarget(FPDF_DEST destination,
+                                base::Optional<float>* dest_x,
+                                base::Optional<float>* dest_y,
+                                base::Optional<float>* zoom_value);
+
+  // For a named destination with "XYZ" view fit type, pre-processes the in-page
+  // x/y coordinate in case it's out of the range of the page dimension.
+  float PreProcessInPageCoordX(float x);
+  float PreProcessInPageCoordY(float y);
 
   // Transforms an (x, y) position in page coordinates to screen coordinates.
   gfx::PointF TransformPageToScreenXY(const gfx::PointF& xy);
 
+  // Transforms an in-page x coordinate to its value in screen coordinates.
+  float TransformPageToScreenX(float x);
+
+  // Transforms an in-page y coordinate to its value in screen coordinates.
+  float TransformPageToScreenY(float y);
+
   // Given a point in the document that's in this page, returns its character
   // index if it's near a character, and also the type of text.
   // Target is optional. It will be filled in for WEBLINK_AREA or
   // DOCLINK_AREA only.
-  Area GetCharIndex(const pp::Point& point,
-                    int rotation,
+  Area GetCharIndex(const gfx::Point& point,
+                    PageOrientation orientation,
                     int* char_index,
                     int* form_type,
                     LinkTarget* target);
@@ -98,27 +152,48 @@ class PDFiumPage {
   static Area FormTypeToArea(int form_type);
 
   // Gets the character at the given index.
-  base::char16 GetCharAtIndex(int index);
+  char16_t GetCharAtIndex(int index);
 
   // Gets the number of characters in the page.
   int GetCharCount();
 
-  // Converts from page coordinates to screen coordinates.
-  pp::Rect PageToScreen(const pp::Point& offset,
-                        double zoom,
-                        double left,
-                        double top,
-                        double right,
-                        double bottom,
-                        int rotation) const;
+  // Returns true if the given |char_index| lies within the character range
+  // of the page.
+  bool IsCharIndexInBounds(int char_index);
 
-  const PDFEngine::PageFeatures* GetPageFeatures();
+  // Given a rectangle in page coordinates, computes the range of continuous
+  // characters which lie inside that rectangle. Returns false without
+  // modifying the out parameters if no character lies inside the rectangle.
+  bool GetUnderlyingTextRangeForRect(const gfx::RectF& rect,
+                                     int* start_index,
+                                     int* char_len);
+
+  // Converts from page coordinates to screen coordinates.
+  gfx::Rect PageToScreen(const gfx::Point& page_point,
+                         double zoom,
+                         double left,
+                         double top,
+                         double right,
+                         double bottom,
+                         PageOrientation orientation) const;
+
+  // Sets the callbacks for sending the thumbnail.
+  void RequestThumbnail(float device_pixel_ratio,
+                        SendThumbnailCallback send_callback);
+
+  // Generates a page thumbnail accommodating a specific |device_pixel_ratio|.
+  Thumbnail GenerateThumbnail(float device_pixel_ratio);
 
   int index() const { return index_; }
-  pp::Rect rect() const { return rect_; }
-  void set_rect(const pp::Rect& r) { rect_ = r; }
+
+  const gfx::Rect& rect() const { return rect_; }
+  void set_rect(const gfx::Rect& r) { rect_ = r; }
+
+  // Availability is a one-way transition: A page can become available, but it
+  // cannot become unavailable (unless deleted entirely).
   bool available() const { return available_; }
-  void set_available(bool available) { available_ = available; }
+  void MarkAvailable();
+
   void set_calculated_links(bool calculated_links) {
     calculated_links_ = calculated_links;
   }
@@ -127,24 +202,19 @@ class PDFiumPage {
   FPDF_TEXTPAGE text_page() const { return text_page_.get(); }
 
  private:
-  // Returns a link index if the given character index is over a link, or -1
-  // otherwise.
-  int GetLink(int char_index, LinkTarget* target);
-  // Returns the link indices if the given rect intersects a link rect, or an
-  // empty vector otherwise.
-  std::vector<int> GetLinks(pp::Rect text_area,
-                            std::vector<LinkTarget>* targets);
-  // Calculate the locations of any links on the page.
-  void CalculateLinks();
-  // Returns link type and fills target associated with a link. Returns
-  // NONSELECTABLE_AREA if link detection failed.
-  Area GetLinkTarget(FPDF_LINK link, LinkTarget* target);
-  // Returns link type and fills target associated with a destination. Returns
-  // NONSELECTABLE_AREA if detection failed.
-  Area GetDestinationTarget(FPDF_DEST destination, LinkTarget* target);
-  // Returns link type and fills target associated with a URI action. Returns
-  // NONSELECTABLE_AREA if detection failed.
-  Area GetURITarget(FPDF_ACTION uri_action, LinkTarget* target) const;
+  friend class PDFiumPageLinkTest;
+  friend class PDFiumTestBase;
+
+  FRIEND_TEST_ALL_PREFIXES(PDFiumPageImageTest, TestCalculateImages);
+  FRIEND_TEST_ALL_PREFIXES(PDFiumPageLinkTest, TestAnnotLinkGeneration);
+  FRIEND_TEST_ALL_PREFIXES(PDFiumPageImageTest, TestImageAltText);
+  FRIEND_TEST_ALL_PREFIXES(PDFiumPageLinkTest, TestLinkGeneration);
+  FRIEND_TEST_ALL_PREFIXES(PDFiumPageHighlightTest, TestPopulateHighlights);
+  FRIEND_TEST_ALL_PREFIXES(PDFiumPageTextFieldTest, TestPopulateTextFields);
+  FRIEND_TEST_ALL_PREFIXES(PDFiumPageChoiceFieldTest, TestPopulateChoiceFields);
+  FRIEND_TEST_ALL_PREFIXES(PDFiumPageButtonTest, TestPopulateButtons);
+  FRIEND_TEST_ALL_PREFIXES(PDFiumPageOverlappingTest, CountPartialOverlaps);
+  FRIEND_TEST_ALL_PREFIXES(PDFiumPageOverlappingTest, CountCompleteOverlaps);
 
   class ScopedUnloadPreventer {
    public:
@@ -160,25 +230,211 @@ class PDFiumPage {
     Link(const Link& that);
     ~Link();
 
-    std::string url;
-    // Bounding rectangles of characters.
-    std::vector<pp::Rect> rects;
+    // Represents start index of underlying text range. Should be -1 if the link
+    // is not over text.
+    int32_t start_char_index = -1;
+    // Represents the number of characters that the link overlaps with.
+    int32_t char_count = 0;
+    std::vector<gfx::Rect> bounding_rects;
+    LinkTarget target;
   };
 
+  // Represents an Image inside the page.
+  struct Image {
+    Image();
+    Image(const Image& other);
+    ~Image();
+
+    gfx::Rect bounding_rect;
+    // Alt text is available only for tagged PDFs.
+    std::string alt_text;
+  };
+
+  // Represents a highlight within the page.
+  struct Highlight {
+    Highlight();
+    Highlight(const Highlight& other);
+    ~Highlight();
+
+    // Start index of underlying text range. -1 indicates invalid value.
+    int32_t start_char_index = -1;
+    // Number of characters encompassed by this highlight.
+    int32_t char_count = 0;
+    gfx::Rect bounding_rect;
+
+    // Color of the highlight in ARGB. Alpha is stored in the first 8 MSBs. RGB
+    // follows after it with each using 8 bytes.
+    uint32_t color;
+
+    // Text of the popup note associated with highlight.
+    std::string note_text;
+  };
+
+  // Represents a form field within the page.
+  struct FormField {
+    FormField();
+    FormField(const FormField& other);
+    ~FormField();
+
+    gfx::Rect bounding_rect;
+    // Represents the name of form field as defined in the field dictionary.
+    std::string name;
+    // Represents the flags of form field as defined in the field dictionary.
+    int flags;
+  };
+
+  // Represents a text field within the page.
+  struct TextField : FormField {
+    TextField();
+    TextField(const TextField& other);
+    ~TextField();
+
+    std::string value;
+  };
+
+  // Represents a choice field option.
+  struct ChoiceFieldOption {
+    ChoiceFieldOption();
+    ChoiceFieldOption(const ChoiceFieldOption& other);
+    ~ChoiceFieldOption();
+
+    std::string name;
+    bool is_selected;
+  };
+
+  // Represents a choice field within the page.
+  struct ChoiceField : FormField {
+    ChoiceField();
+    ChoiceField(const ChoiceField& other);
+    ~ChoiceField();
+
+    std::vector<ChoiceFieldOption> options;
+  };
+
+  // Represents a button within the page.
+  struct Button : FormField {
+    Button();
+    Button(const Button& other);
+    ~Button();
+
+    std::string value;
+    // A button can be of type radio, checkbox or push button.
+    int type;
+    // Represents if the radio button or checkbox is checked.
+    bool is_checked = false;
+    // Represents count of controls in the control group. A group of
+    // interactive form annotations is collectively called a form control
+    // group. Here an interactive form annotation should be either a radio
+    // button or a checkbox.
+    uint32_t control_count = 0;
+    // Represents index of the control in the control group. A group of
+    // interactive form annotations is collectively called a form control
+    // group. Here an interactive form annotation should be either a radio
+    // button or a checkbox. Value of |control_index| is -1 for push button.
+    int control_index = -1;
+  };
+
+  // Returns a link index if the given character index is over a link, or -1
+  // otherwise.
+  int GetLink(int char_index, LinkTarget* target);
+  // Calculate the locations of any links on the page.
+  void CalculateLinks();
+  // Populates weblinks on the page.
+  void PopulateWebLinks();
+  // Populates annotation links on the page.
+  void PopulateAnnotationLinks();
+  // Calculate the locations of images on the page.
+  void CalculateImages();
+  // Populate annotations like highlight and text field on the page.
+  void PopulateAnnotations();
+  // Populate |highlights_| with |annot|.
+  void PopulateHighlight(FPDF_ANNOTATION annot);
+  // Populate |text_fields_| with |annot|.
+  void PopulateTextField(FPDF_ANNOTATION annot);
+  // Populate |choice_fields_| with |annot|.
+  void PopulateChoiceField(FPDF_ANNOTATION annot);
+  // Populate |buttons_| with |annot|.
+  void PopulateButton(FPDF_ANNOTATION annot);
+  // Populate form fields like text field, choice field and button on the page.
+  void PopulateFormField(FPDF_ANNOTATION annot);
+  // Returns link type and fills target associated with a destination. Returns
+  // NONSELECTABLE_AREA if detection failed.
+  Area GetDestinationTarget(FPDF_DEST destination, LinkTarget* target);
+  // Returns link type and fills target associated with a URI action. Returns
+  // NONSELECTABLE_AREA if detection failed.
+  Area GetURITarget(FPDF_ACTION uri_action, LinkTarget* target) const;
+  // Calculates the set of character indices on which text runs need to be
+  // broken for page objects such as links and images.
+  void CalculatePageObjectTextRunBreaks();
+  // Set text run style information based on a character of the text run.
+  void CalculateTextRunStyleInfo(int char_index,
+                                 AccessibilityTextStyleInfo& style_info);
+  // Returns a boolean indicating if the character at index |char_index| has the
+  // same text style as the text run.
+  bool AreTextStyleEqual(int char_index,
+                         const AccessibilityTextStyleInfo& style);
+
+  // Key    :  Marked content id for the image element as specified in the
+  //           struct tree.
+  // Value  :  Index of image in the |images_| vector.
+  using MarkedContentIdToImageMap = std::map<int, size_t>;
+  // Traverses the entire struct tree of the page recursively and extracts the
+  // alt text from struct tree elements corresponding to the marked content IDs
+  // present in |marked_content_id_image_map|.
+  void PopulateImageAltText(
+      const MarkedContentIdToImageMap& marked_content_id_image_map);
+  // Traverses a struct element and its sub-tree recursively and extracts the
+  // alt text from struct elements corresponding to the marked content IDs
+  // present in |marked_content_id_image_map|. Uses |visited_elements| to guard
+  // against malformed struct trees.
+  void PopulateImageAltTextForStructElement(
+      const MarkedContentIdToImageMap& marked_content_id_image_map,
+      FPDF_STRUCTELEMENT current_element,
+      std::set<FPDF_STRUCTELEMENT>* visited_elements);
+  static uint32_t CountLinkHighlightOverlaps(
+      const std::vector<Link>& links,
+      const std::vector<Highlight>& highlights);
+  bool PopulateFormFieldProperties(FPDF_ANNOTATION annot,
+                                   FormField* form_field);
+  // Generates and sends the thumbnail using |send_callback|.
+  void GenerateAndSendThumbnail(float device_pixel_ratio,
+                                SendThumbnailCallback send_callback);
+
   PDFiumEngine* engine_;
   ScopedFPDFPage page_;
   ScopedFPDFTextPage text_page_;
   int index_;
   int preventing_unload_count_ = 0;
-  pp::Rect rect_;
+  gfx::Rect rect_;
   bool calculated_links_ = false;
   std::vector<Link> links_;
+  bool calculated_images_ = false;
+  std::vector<Image> images_;
+  bool calculated_annotations_ = false;
+  std::vector<Highlight> highlights_;
+  std::vector<TextField> text_fields_;
+  std::vector<ChoiceField> choice_fields_;
+  std::vector<Button> buttons_;
+  bool logged_overlapping_annotations_ = false;
+  bool calculated_page_object_text_run_breaks_ = false;
+  // The set of character indices on which text runs need to be broken for page
+  // objects.
+  std::set<int> page_object_text_run_breaks_;
+  base::OnceClosure thumbnail_callback_;
   bool available_;
-  PDFEngine::PageFeatures page_features_;
-
-  DISALLOW_COPY_AND_ASSIGN(PDFiumPage);
 };
 
+// Converts page orientations to the PDFium equivalents, as defined by
+// FPDF_RenderPage().
+int ToPDFiumRotation(PageOrientation orientation);
+
+constexpr uint32_t MakeARGB(unsigned int a,
+                            unsigned int r,
+                            unsigned int g,
+                            unsigned int b) {
+  return (a << 24) | (r << 16) | (g << 8) | b;
+}
+
 }  // namespace chrome_pdf
 
 #endif  // PDF_PDFIUM_PDFIUM_PAGE_H_
diff --git a/pdf/pdfium/pdfium_page_unittest.cc b/pdf/pdfium/pdfium_page_unittest.cc
new file mode 100644
index 000000000000..98a329d71e58
--- /dev/null
+++ b/pdf/pdfium/pdfium_page_unittest.cc
@@ -0,0 +1,785 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "pdf/pdfium/pdfium_page.h"
+
+#include <utility>
+#include <vector>
+
+#include "base/check.h"
+#include "base/files/file_path.h"
+#include "base/optional.h"
+#include "base/path_service.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/test/gtest_util.h"
+#include "cc/test/pixel_comparator.h"
+#include "cc/test/pixel_test_utils.h"
+#include "pdf/accessibility_structs.h"
+#include "pdf/pdfium/pdfium_engine.h"
+#include "pdf/pdfium/pdfium_test_base.h"
+#include "pdf/ppapi_migration/geometry_conversions.h"
+#include "pdf/test/test_client.h"
+#include "pdf/ui/thumbnail.h"
+#include "ppapi/c/private/ppb_pdf.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/pdfium/public/fpdf_formfill.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/rect_f.h"
+#include "ui/gfx/range/range.h"
+#include "ui/gfx/test/gfx_util.h"
+
+namespace chrome_pdf {
+
+namespace {
+
+TEST(PDFiumPageHelperTest, ToPDFiumRotation) {
+  EXPECT_EQ(ToPDFiumRotation(PageOrientation::kOriginal), 0);
+  EXPECT_EQ(ToPDFiumRotation(PageOrientation::kClockwise90), 1);
+  EXPECT_EQ(ToPDFiumRotation(PageOrientation::kClockwise180), 2);
+  EXPECT_EQ(ToPDFiumRotation(PageOrientation::kClockwise270), 3);
+}
+
+TEST(PDFiumPageHelperDeathTest, ToPDFiumRotation) {
+  PageOrientation invalid_orientation = static_cast<PageOrientation>(-1);
+#if DCHECK_IS_ON()
+  EXPECT_DCHECK_DEATH(ToPDFiumRotation(invalid_orientation));
+#else
+  EXPECT_EQ(ToPDFiumRotation(invalid_orientation), 0);
+#endif
+}
+
+void CompareTextRuns(const AccessibilityTextRunInfo& expected_text_run,
+                     const AccessibilityTextRunInfo& actual_text_run) {
+  EXPECT_EQ(expected_text_run.len, actual_text_run.len);
+  EXPECT_RECTF_EQ(expected_text_run.bounds, actual_text_run.bounds);
+  EXPECT_EQ(expected_text_run.direction, actual_text_run.direction);
+
+  const AccessibilityTextStyleInfo& expected_style = expected_text_run.style;
+  const AccessibilityTextStyleInfo& actual_style = actual_text_run.style;
+
+  EXPECT_EQ(expected_style.font_name, actual_style.font_name);
+  EXPECT_EQ(expected_style.font_weight, actual_style.font_weight);
+  EXPECT_EQ(expected_style.render_mode, actual_style.render_mode);
+  EXPECT_FLOAT_EQ(expected_style.font_size, actual_style.font_size);
+  EXPECT_EQ(expected_style.fill_color, actual_style.fill_color);
+  EXPECT_EQ(expected_style.stroke_color, actual_style.stroke_color);
+  EXPECT_EQ(expected_style.is_italic, actual_style.is_italic);
+  EXPECT_EQ(expected_style.is_bold, actual_style.is_bold);
+}
+
+template <typename T>
+void PopulateTextObjects(const std::vector<gfx::Range>& ranges,
+                         std::vector<T>* text_objects) {
+  text_objects->resize(ranges.size());
+  for (size_t i = 0; i < ranges.size(); ++i) {
+    (*text_objects)[i].start_char_index = ranges[i].start();
+    (*text_objects)[i].char_count = ranges[i].end() - ranges[i].start();
+  }
+}
+
+base::FilePath GetThumbnailTestData(const std::string& expectation_file_prefix,
+                                    size_t page_index,
+                                    float device_pixel_ratio) {
+  std::string file_dir = base::StringPrintf("%.1fx", device_pixel_ratio);
+  std::string file_name = base::StringPrintf(
+      "%s_expected.pdf.%zu.png", expectation_file_prefix.c_str(), page_index);
+  base::FilePath root_path;
+  if (!base::PathService::Get(base::DIR_SOURCE_ROOT, &root_path))
+    return base::FilePath();
+  return root_path.Append(FILE_PATH_LITERAL("pdf"))
+      .Append(FILE_PATH_LITERAL("test"))
+      .Append(FILE_PATH_LITERAL("data"))
+      .Append(FILE_PATH_LITERAL("thumbnail"))
+      .AppendASCII(file_dir)
+      .AppendASCII(file_name);
+}
+
+}  // namespace
+
+using PDFiumPageTest = PDFiumTestBase;
+
+TEST_F(PDFiumPageTest, Constructor) {
+  PDFiumPage page(/*engine=*/nullptr, 2);
+  EXPECT_EQ(page.index(), 2);
+  EXPECT_TRUE(page.rect().IsEmpty());
+  EXPECT_FALSE(page.available());
+}
+
+class PDFiumPageLinkTest : public PDFiumTestBase {
+ public:
+  PDFiumPageLinkTest() = default;
+  PDFiumPageLinkTest(const PDFiumPageLinkTest&) = delete;
+  PDFiumPageLinkTest& operator=(const PDFiumPageLinkTest&) = delete;
+  ~PDFiumPageLinkTest() override = default;
+
+  const std::vector<PDFiumPage::Link>& GetLinks(PDFiumEngine& engine,
+                                                int page_index) {
+    PDFiumPage& page = GetPDFiumPageForTest(engine, page_index);
+    page.CalculateLinks();
+    return page.links_;
+  }
+};
+
+TEST_F(PDFiumPageLinkTest, TestLinkGeneration) {
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("weblinks.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  bool using_test_fonts = UsingTestFonts();
+
+  const std::vector<PDFiumPage::Link>& links = GetLinks(*engine, 0);
+  ASSERT_EQ(3u, links.size());
+
+  const PDFiumPage::Link& link = links[0];
+  EXPECT_EQ("http://yahoo.com", link.target.url);
+  EXPECT_EQ(7, link.start_char_index);
+  EXPECT_EQ(16, link.char_count);
+  ASSERT_EQ(1u, link.bounding_rects.size());
+  if (using_test_fonts) {
+    EXPECT_EQ(gfx::Rect(75, 192, 110, 15), link.bounding_rects[0]);
+  } else {
+    EXPECT_EQ(gfx::Rect(75, 191, 110, 16), link.bounding_rects[0]);
+  }
+
+  const PDFiumPage::Link& second_link = links[1];
+  EXPECT_EQ("http://bing.com", second_link.target.url);
+  EXPECT_EQ(52, second_link.start_char_index);
+  EXPECT_EQ(15, second_link.char_count);
+  ASSERT_EQ(1u, second_link.bounding_rects.size());
+  if (using_test_fonts) {
+    EXPECT_EQ(gfx::Rect(131, 120, 138, 22), second_link.bounding_rects[0]);
+  } else {
+    EXPECT_EQ(gfx::Rect(131, 121, 138, 20), second_link.bounding_rects[0]);
+  }
+
+  const PDFiumPage::Link& third_link = links[2];
+  EXPECT_EQ("http://google.com", third_link.target.url);
+  EXPECT_EQ(92, third_link.start_char_index);
+  EXPECT_EQ(17, third_link.char_count);
+  ASSERT_EQ(1u, third_link.bounding_rects.size());
+  EXPECT_EQ(gfx::Rect(82, 67, 161, 21), third_link.bounding_rects[0]);
+}
+
+TEST_F(PDFiumPageLinkTest, TestAnnotLinkGeneration) {
+  struct ExpectedLink {
+    int32_t start_char_index;
+    int32_t char_count;
+    std::vector<gfx::Rect> bounding_rects;
+    std::string url;
+    int page;
+    float y_in_pixels;
+  };
+  static ExpectedLink expected_links[] = {
+      {144, 38, {{99, 436, 236, 13}}, "https://pdfium.googlesource.com/pdfium"},
+      {27, 38, {{112, 215, 617, 28}}, "", 1, 89.333336},
+      {65, 27, {{93, 334, 174, 21}}, "https://www.adobe.com"},
+      {253,
+       18,
+       {{242, 455, 1, 18}, {242, 472, 1, 15}},
+       "https://cs.chromium.org"},
+      {-1, 0, {{58, 926, 28, 27}}, "https://www.google.com"}};
+  if (UsingTestFonts()) {
+    expected_links[0].bounding_rects[0] = {99, 436, 236, 14};
+  }
+  static constexpr size_t kExpectedLinkCount = base::size(expected_links);
+
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("link_annots.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(2, engine->GetNumberOfPages());
+
+  const std::vector<PDFiumPage::Link>& links = GetLinks(*engine, 0);
+  ASSERT_EQ(kExpectedLinkCount, links.size());
+
+  for (size_t i = 0; i < kExpectedLinkCount; ++i) {
+    const PDFiumPage::Link& actual_current_link = links[i];
+    const ExpectedLink& expected_current_link = expected_links[i];
+    EXPECT_EQ(expected_current_link.start_char_index,
+              actual_current_link.start_char_index);
+    EXPECT_EQ(expected_current_link.char_count, actual_current_link.char_count);
+    size_t bounds_size = actual_current_link.bounding_rects.size();
+    ASSERT_EQ(expected_current_link.bounding_rects.size(), bounds_size);
+    for (size_t bounds_index = 0; bounds_index < bounds_size; ++bounds_index) {
+      EXPECT_EQ(expected_current_link.bounding_rects[bounds_index],
+                actual_current_link.bounding_rects[bounds_index]);
+    }
+    EXPECT_EQ(expected_current_link.url, actual_current_link.target.url);
+    if (actual_current_link.target.url.empty()) {
+      EXPECT_EQ(expected_current_link.page, actual_current_link.target.page);
+      ASSERT_TRUE(actual_current_link.target.y_in_pixels.has_value());
+      EXPECT_FLOAT_EQ(expected_current_link.y_in_pixels,
+                      actual_current_link.target.y_in_pixels.value());
+    }
+  }
+}
+
+using PDFiumPageImageTest = PDFiumTestBase;
+
+TEST_F(PDFiumPageImageTest, TestCalculateImages) {
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("image_alt_text.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  PDFiumPage& page = GetPDFiumPageForTest(*engine, 0);
+  page.CalculateImages();
+  ASSERT_EQ(3u, page.images_.size());
+  EXPECT_EQ(gfx::Rect(380, 78, 67, 68), page.images_[0].bounding_rect);
+  EXPECT_EQ("Image 1", page.images_[0].alt_text);
+  EXPECT_EQ(gfx::Rect(380, 385, 27, 28), page.images_[1].bounding_rect);
+  EXPECT_EQ("Image 2", page.images_[1].alt_text);
+  EXPECT_EQ(gfx::Rect(380, 678, 1, 1), page.images_[2].bounding_rect);
+  EXPECT_EQ("Image 3", page.images_[2].alt_text);
+}
+
+TEST_F(PDFiumPageImageTest, TestImageAltText) {
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("text_with_image.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  PDFiumPage& page = GetPDFiumPageForTest(*engine, 0);
+  page.CalculateImages();
+  ASSERT_EQ(3u, page.images_.size());
+  EXPECT_EQ(gfx::Rect(380, 78, 67, 68), page.images_[0].bounding_rect);
+  EXPECT_EQ("Image 1", page.images_[0].alt_text);
+  EXPECT_EQ(gfx::Rect(380, 385, 27, 28), page.images_[1].bounding_rect);
+  EXPECT_EQ("", page.images_[1].alt_text);
+  EXPECT_EQ(gfx::Rect(380, 678, 1, 1), page.images_[2].bounding_rect);
+  EXPECT_EQ("", page.images_[2].alt_text);
+}
+
+using PDFiumPageTextTest = PDFiumTestBase;
+
+TEST_F(PDFiumPageTextTest, TestTextRunBounds) {
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine = InitializeEngine(
+      &client, FILE_PATH_LITERAL("leading_trailing_spaces_per_text_run.pdf"));
+  ASSERT_TRUE(engine);
+
+  constexpr int kFirstRunStartIndex = 0;
+  constexpr int kFirstRunEndIndex = 20;
+  constexpr int kPageIndex = 0;
+  base::Optional<AccessibilityTextRunInfo> text_run_info_1 =
+      engine->GetTextRunInfo(kPageIndex, kFirstRunStartIndex);
+  ASSERT_TRUE(text_run_info_1.has_value());
+
+  const auto& actual_text_run_1 = text_run_info_1.value();
+  EXPECT_EQ(21u, actual_text_run_1.len);
+
+  EXPECT_TRUE(base::IsUnicodeWhitespace(
+      engine->GetCharUnicode(kPageIndex, kFirstRunStartIndex)));
+  gfx::RectF text_run_bounds = actual_text_run_1.bounds;
+  EXPECT_TRUE(text_run_bounds.Contains(
+      engine->GetCharBounds(kPageIndex, kFirstRunStartIndex)));
+
+  // Last non-space character should fall in the bounding box of the text run.
+  // Text run looks like this:
+  // " Hello, world! \r\n "<17 characters><first Tj>
+  // " \r\n "<4 characters><second Tj>
+  // " "<1 character><third Tj starting spaces>
+  // Finally generated text run: " Hello, world! \r\n \r\n "
+  constexpr int kFirstRunLastNonSpaceCharIndex = 13;
+  EXPECT_FALSE(base::IsUnicodeWhitespace(
+      engine->GetCharUnicode(kPageIndex, kFirstRunLastNonSpaceCharIndex)));
+  EXPECT_TRUE(text_run_bounds.Contains(
+      engine->GetCharBounds(kPageIndex, kFirstRunLastNonSpaceCharIndex)));
+
+  EXPECT_TRUE(base::IsUnicodeWhitespace(
+      engine->GetCharUnicode(kPageIndex, kFirstRunEndIndex)));
+  gfx::RectF end_char_rect =
+      engine->GetCharBounds(kPageIndex, kFirstRunEndIndex);
+  EXPECT_FALSE(text_run_bounds.Contains(end_char_rect));
+  // Equals to the length of the previous text run.
+  constexpr int kSecondRunStartIndex = 21;
+  constexpr int kSecondRunEndIndex = 36;
+  // Test the properties of second text run.
+  // Note: The leading spaces in second text run are accounted for in the end
+  // of first text run. Hence we won't see a space leading the second text run.
+  base::Optional<AccessibilityTextRunInfo> text_run_info_2 =
+      engine->GetTextRunInfo(kPageIndex, kSecondRunStartIndex);
+  ASSERT_TRUE(text_run_info_2.has_value());
+
+  const auto& actual_text_run_2 = text_run_info_2.value();
+  EXPECT_EQ(16u, actual_text_run_2.len);
+
+  EXPECT_FALSE(base::IsUnicodeWhitespace(
+      engine->GetCharUnicode(kPageIndex, kSecondRunStartIndex)));
+  text_run_bounds = actual_text_run_2.bounds;
+  EXPECT_TRUE(text_run_bounds.Contains(
+      engine->GetCharBounds(kPageIndex, kSecondRunStartIndex)));
+
+  // Last non-space character should fall in the bounding box of the text run.
+  // Text run looks like this:
+  // "Goodbye, world! "<19 characters><first Tj>
+  // Finally generated text run: "Goodbye, world! "
+  constexpr int kSecondRunLastNonSpaceCharIndex = 35;
+  EXPECT_FALSE(base::IsUnicodeWhitespace(
+      engine->GetCharUnicode(kPageIndex, kSecondRunLastNonSpaceCharIndex)));
+  EXPECT_TRUE(text_run_bounds.Contains(
+      engine->GetCharBounds(kPageIndex, kSecondRunLastNonSpaceCharIndex)));
+
+  EXPECT_TRUE(base::IsUnicodeWhitespace(
+      engine->GetCharUnicode(kPageIndex, kSecondRunEndIndex)));
+  EXPECT_FALSE(text_run_bounds.Contains(
+      engine->GetCharBounds(kPageIndex, kSecondRunEndIndex)));
+}
+
+TEST_F(PDFiumPageTextTest, GetTextRunInfo) {
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("weblinks.pdf"));
+  ASSERT_TRUE(engine);
+
+  int current_char_index = 0;
+
+  AccessibilityTextStyleInfo expected_style_1 = {
+      "Times-Roman",
+      0,
+      AccessibilityTextRenderMode::kFill,
+      12,
+      0xff000000,
+      0xff000000,
+      false,
+      false};
+  AccessibilityTextStyleInfo expected_style_2 = {
+      "Helvetica", 0,          AccessibilityTextRenderMode::kFill,
+      16,          0xff000000, 0xff000000,
+      false,       false};
+  // The links span from [7, 22], [52, 66] and [92, 108] with 16, 15 and 17
+  // text run lengths respectively. There are text runs preceding and
+  // succeeding them.
+  AccessibilityTextRunInfo expected_text_runs[] = {
+      {7, gfx::RectF(26.666666f, 189.333333f, 38.666672f, 13.333344f),
+       AccessibilityTextDirection::kLeftToRight, expected_style_1},
+      {16, gfx::RectF(70.666664f, 189.333333f, 108.0f, 14.666672f),
+       AccessibilityTextDirection::kLeftToRight, expected_style_1},
+      {20, gfx::RectF(181.333333f, 189.333333f, 117.333333f, 14.666672f),
+       AccessibilityTextDirection::kLeftToRight, expected_style_1},
+      {9, gfx::RectF(28.0f, 117.33334f, 89.333328f, 20.0f),
+       AccessibilityTextDirection::kLeftToRight, expected_style_2},
+      {15, gfx::RectF(126.66666f, 117.33334f, 137.33334f, 20.0f),
+       AccessibilityTextDirection::kLeftToRight, expected_style_2},
+      {20, gfx::RectF(266.66666f, 118.66666f, 169.33334f, 18.666664f),
+       AccessibilityTextDirection::kLeftToRight, expected_style_2},
+      {5, gfx::RectF(28.0f, 65.333336f, 40.0f, 18.666664f),
+       AccessibilityTextDirection::kLeftToRight, expected_style_2},
+      {17, gfx::RectF(77.333336f, 64.0f, 160.0f, 20.0f),
+       AccessibilityTextDirection::kLeftToRight, expected_style_2}};
+
+  if (UsingTestFonts()) {
+    expected_text_runs[4].bounds =
+        gfx::RectF(126.66666f, 117.33334f, 137.33334f, 21.33334f);
+    expected_text_runs[5].bounds =
+        gfx::RectF(266.66666f, 118.66666f, 170.66666f, 20.0f);
+    expected_text_runs[7].bounds =
+        gfx::RectF(77.333336f, 64.0f, 160.0f, 21.33333f);
+  }
+
+  // Test negative char index returns nullopt
+  base::Optional<AccessibilityTextRunInfo> text_run_info_result =
+      engine->GetTextRunInfo(0, -1);
+  ASSERT_FALSE(text_run_info_result.has_value());
+
+  // Test valid char index returns expected text run info and expected text
+  // style info
+  for (const auto& expected_text_run : expected_text_runs) {
+    text_run_info_result = engine->GetTextRunInfo(0, current_char_index);
+    ASSERT_TRUE(text_run_info_result.has_value());
+    const auto& actual_text_run = text_run_info_result.value();
+    CompareTextRuns(expected_text_run, actual_text_run);
+    current_char_index += actual_text_run.len;
+  }
+
+  // Test char index outside char range returns nullopt
+  PDFiumPage& page = GetPDFiumPageForTest(*engine, 0);
+  EXPECT_EQ(page.GetCharCount(), current_char_index);
+  text_run_info_result = engine->GetTextRunInfo(0, current_char_index);
+  ASSERT_FALSE(text_run_info_result.has_value());
+}
+
+TEST_F(PDFiumPageTextTest, TestHighlightTextRunInfo) {
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("highlights.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  // Highlights span across text run indices 0, 2 and 3.
+  static const AccessibilityTextStyleInfo kExpectedStyle = {
+      "Helvetica", 0,          AccessibilityTextRenderMode::kFill,
+      16,          0xff000000, 0xff000000,
+      false,       false};
+  AccessibilityTextRunInfo expected_text_runs[] = {
+      {5, gfx::RectF(1.3333334f, 198.66667f, 46.666668f, 14.666672f),
+       AccessibilityTextDirection::kLeftToRight, kExpectedStyle},
+      {7, gfx::RectF(50.666668f, 198.66667f, 47.999996f, 17.333328f),
+       AccessibilityTextDirection::kLeftToRight, kExpectedStyle},
+      {7, gfx::RectF(106.66666f, 198.66667f, 73.333336f, 18.666672f),
+       AccessibilityTextDirection::kLeftToRight, kExpectedStyle},
+      {2, gfx::RectF(181.33333f, 202.66667f, 16.0f, 14.66667f),
+       AccessibilityTextDirection::kNone, kExpectedStyle},
+      {2, gfx::RectF(198.66667f, 202.66667f, 21.333328f, 10.666672f),
+       AccessibilityTextDirection::kLeftToRight, kExpectedStyle}};
+
+  if (UsingTestFonts()) {
+    expected_text_runs[2].bounds =
+        gfx::RectF(106.66666f, 198.66667f, 73.333336f, 19.999985f);
+    expected_text_runs[4].bounds =
+        gfx::RectF(198.66667f, 201.33333f, 21.333328f, 12.000015f);
+  }
+
+  int current_char_index = 0;
+  for (const auto& expected_text_run : expected_text_runs) {
+    base::Optional<AccessibilityTextRunInfo> text_run_info_result =
+        engine->GetTextRunInfo(0, current_char_index);
+    ASSERT_TRUE(text_run_info_result.has_value());
+    const auto& actual_text_run = text_run_info_result.value();
+    CompareTextRuns(expected_text_run, actual_text_run);
+    current_char_index += actual_text_run.len;
+  }
+}
+
+using PDFiumPageHighlightTest = PDFiumTestBase;
+
+TEST_F(PDFiumPageHighlightTest, TestPopulateHighlights) {
+  struct ExpectedHighlight {
+    int32_t start_char_index;
+    int32_t char_count;
+    gfx::Rect bounding_rect;
+    uint32_t color;
+  };
+
+  constexpr uint32_t kHighlightDefaultColor = MakeARGB(255, 255, 255, 0);
+  constexpr uint32_t kHighlightRedColor = MakeARGB(102, 230, 0, 0);
+  constexpr uint32_t kHighlightNoColor = MakeARGB(0, 0, 0, 0);
+  static const ExpectedHighlight kExpectedHighlights[] = {
+      {0, 5, {5, 196, 49, 26}, kHighlightDefaultColor},
+      {12, 7, {110, 196, 77, 26}, kHighlightRedColor},
+      {20, 1, {192, 196, 13, 26}, kHighlightNoColor}};
+
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("highlights.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  PDFiumPage& page = GetPDFiumPageForTest(*engine, 0);
+  page.PopulateAnnotations();
+  ASSERT_EQ(base::size(kExpectedHighlights), page.highlights_.size());
+
+  for (size_t i = 0; i < page.highlights_.size(); ++i) {
+    ASSERT_EQ(kExpectedHighlights[i].start_char_index,
+              page.highlights_[i].start_char_index);
+    ASSERT_EQ(kExpectedHighlights[i].char_count,
+              page.highlights_[i].char_count);
+    EXPECT_EQ(kExpectedHighlights[i].bounding_rect,
+              page.highlights_[i].bounding_rect);
+    ASSERT_EQ(kExpectedHighlights[i].color, page.highlights_[i].color);
+  }
+}
+
+using PDFiumPageTextFieldTest = PDFiumTestBase;
+
+TEST_F(PDFiumPageTextFieldTest, TestPopulateTextFields) {
+  struct ExpectedTextField {
+    const char* name;
+    const char* value;
+    gfx::Rect bounding_rect;
+    int flags;
+  };
+
+  static const ExpectedTextField kExpectedTextFields[] = {
+      {"Text Box", "Text", {138, 230, 135, 41}, 0},
+      {"ReadOnly", "Elephant", {138, 163, 135, 41}, 1},
+      {"Required", "Required Field", {138, 303, 135, 34}, 2},
+      {"Password", "", {138, 356, 135, 35}, 8192}};
+
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("form_text_fields.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  PDFiumPage& page = GetPDFiumPageForTest(*engine, 0);
+  page.PopulateAnnotations();
+  size_t text_fields_count = page.text_fields_.size();
+  ASSERT_EQ(base::size(kExpectedTextFields), text_fields_count);
+
+  for (size_t i = 0; i < text_fields_count; ++i) {
+    EXPECT_EQ(kExpectedTextFields[i].name, page.text_fields_[i].name);
+    EXPECT_EQ(kExpectedTextFields[i].value, page.text_fields_[i].value);
+    EXPECT_EQ(kExpectedTextFields[i].bounding_rect,
+              page.text_fields_[i].bounding_rect);
+    EXPECT_EQ(kExpectedTextFields[i].flags, page.text_fields_[i].flags);
+  }
+}
+
+using PDFiumPageChoiceFieldTest = PDFiumTestBase;
+
+TEST_F(PDFiumPageChoiceFieldTest, TestPopulateChoiceFields) {
+  struct ExpectedChoiceFieldOption {
+    const char* name;
+    bool is_selected;
+  };
+
+  struct ExpectedChoiceField {
+    const char* name;
+    std::vector<struct ExpectedChoiceFieldOption> options;
+    gfx::Rect bounding_rect;
+    int flags;
+  };
+
+  static const ExpectedChoiceField kExpectedChoiceFields[] = {
+      {"Listbox_SingleSelect",
+       {{"Foo", false}, {"Bar", false}, {"Qux", false}},
+       {138, 296, 135, 41},
+       0},
+      {"Combo1",
+       {{"Apple", false}, {"Banana", true}, {"Cherry", false}},
+       {138, 230, 135, 41},
+       131072},
+      {"Listbox_ReadOnly",
+       {{"Dog", false}, {"Elephant", false}, {"Frog", false}},
+       {138, 96, 135, 41},
+       1},
+      {"Listbox_MultiSelectMultipleIndices",
+       {
+           {"Albania", false},
+           {"Belgium", true},
+           {"Croatia", false},
+           {"Denmark", true},
+           {"Estonia", false},
+       },
+       {138, 430, 135, 41},
+       2097152},
+      {"Listbox_MultiSelectMultipleValues",
+       {
+           {"Alpha", false},
+           {"Beta", false},
+           {"Gamma", true},
+           {"Delta", false},
+           {"Epsilon", true},
+       },
+       {138, 496, 135, 41},
+       2097152},
+      {"Listbox_MultiSelectMultipleMismatch",
+       {
+           {"Alligator", true},
+           {"Bear", false},
+           {"Cougar", true},
+           {"Deer", false},
+           {"Echidna", false},
+       },
+       {138, 563, 135, 41},
+       2097152}};
+
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("form_choice_fields.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  PDFiumPage& page = GetPDFiumPageForTest(*engine, 0);
+  page.PopulateAnnotations();
+  size_t choice_fields_count = page.choice_fields_.size();
+  ASSERT_EQ(base::size(kExpectedChoiceFields), choice_fields_count);
+
+  for (size_t i = 0; i < choice_fields_count; ++i) {
+    EXPECT_EQ(kExpectedChoiceFields[i].name, page.choice_fields_[i].name);
+    size_t choice_field_options_count = page.choice_fields_[i].options.size();
+    ASSERT_EQ(base::size(kExpectedChoiceFields[i].options),
+              choice_field_options_count);
+    for (size_t j = 0; j < choice_field_options_count; ++j) {
+      EXPECT_EQ(kExpectedChoiceFields[i].options[j].name,
+                page.choice_fields_[i].options[j].name);
+      EXPECT_EQ(kExpectedChoiceFields[i].options[j].is_selected,
+                page.choice_fields_[i].options[j].is_selected);
+    }
+    EXPECT_EQ(kExpectedChoiceFields[i].bounding_rect,
+              page.choice_fields_[i].bounding_rect);
+    EXPECT_EQ(kExpectedChoiceFields[i].flags, page.choice_fields_[i].flags);
+  }
+}
+
+using PDFiumPageButtonTest = PDFiumTestBase;
+
+TEST_F(PDFiumPageButtonTest, TestPopulateButtons) {
+  struct ExpectedButton {
+    const char* name;
+    const char* value;
+    int type;
+    int flags;
+    bool is_checked;
+    uint32_t control_count;
+    int control_index;
+    gfx::Rect bounding_rect;
+  };
+
+  static const ExpectedButton kExpectedButtons[] = {{"readOnlyCheckbox",
+                                                     "Yes",
+                                                     FPDF_FORMFIELD_CHECKBOX,
+                                                     1,
+                                                     true,
+                                                     1,
+                                                     0,
+                                                     {185, 43, 28, 28}},
+                                                    {"checkbox",
+                                                     "Yes",
+                                                     FPDF_FORMFIELD_CHECKBOX,
+                                                     2,
+                                                     false,
+                                                     1,
+                                                     0,
+                                                     {185, 96, 28, 28}},
+                                                    {"RadioButton",
+                                                     "value1",
+                                                     FPDF_FORMFIELD_RADIOBUTTON,
+                                                     49154,
+                                                     false,
+                                                     2,
+                                                     0,
+                                                     {185, 243, 28, 28}},
+                                                    {"RadioButton",
+                                                     "value2",
+                                                     FPDF_FORMFIELD_RADIOBUTTON,
+                                                     49154,
+                                                     true,
+                                                     2,
+                                                     1,
+                                                     {252, 243, 27, 28}},
+                                                    {"PushButton",
+                                                     "",
+                                                     FPDF_FORMFIELD_PUSHBUTTON,
+                                                     65536,
+                                                     false,
+                                                     0,
+                                                     -1,
+                                                     {118, 270, 55, 67}}};
+
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("form_buttons.pdf"));
+  ASSERT_TRUE(engine);
+  ASSERT_EQ(1, engine->GetNumberOfPages());
+
+  PDFiumPage& page = GetPDFiumPageForTest(*engine, 0);
+  page.PopulateAnnotations();
+  size_t buttons_count = page.buttons_.size();
+  ASSERT_EQ(base::size(kExpectedButtons), buttons_count);
+
+  for (size_t i = 0; i < buttons_count; ++i) {
+    EXPECT_EQ(kExpectedButtons[i].name, page.buttons_[i].name);
+    EXPECT_EQ(kExpectedButtons[i].value, page.buttons_[i].value);
+    EXPECT_EQ(kExpectedButtons[i].type, page.buttons_[i].type);
+    EXPECT_EQ(kExpectedButtons[i].flags, page.buttons_[i].flags);
+    EXPECT_EQ(kExpectedButtons[i].is_checked, page.buttons_[i].is_checked);
+    EXPECT_EQ(kExpectedButtons[i].control_count,
+              page.buttons_[i].control_count);
+    EXPECT_EQ(kExpectedButtons[i].control_index,
+              page.buttons_[i].control_index);
+    EXPECT_EQ(kExpectedButtons[i].bounding_rect,
+              page.buttons_[i].bounding_rect);
+  }
+}
+
+using PDFiumPageOverlappingTest = PDFiumTestBase;
+
+// The following scenarios are covered across both test cases:
+// 1. Links overlapping amongst themselves.
+// 2. Highlights overlapping amongst themselves.
+// 3. Links partially and completely overlapping with highlights.
+// 4. Adjacent annotations.
+TEST_F(PDFiumPageOverlappingTest, CountPartialOverlaps) {
+  static const std::vector<gfx::Range> kLinkRanges = {
+      {0, 10}, {13, 25}, {37, 52}, {71, 84}, {93, 113}};
+  static const std::vector<gfx::Range> kHighlightRanges = {
+      {4, 13}, {8, 15}, {14, 22}, {37, 73}, {49, 95}, {80, 101}};
+  std::vector<PDFiumPage::Link> links;
+  std::vector<PDFiumPage::Highlight> highlights;
+  PopulateTextObjects(kLinkRanges, &links);
+  PopulateTextObjects(kHighlightRanges, &highlights);
+  ASSERT_EQ(15u, PDFiumPage::CountLinkHighlightOverlaps(links, highlights));
+}
+
+TEST_F(PDFiumPageOverlappingTest, CountCompleteOverlaps) {
+  static const std::vector<gfx::Range> kLinkRanges = {
+      {0, 15}, {25, 40}, {30, 50}, {50, 67}, {61, 72}, {67, 81}};
+  static const std::vector<gfx::Range> kHighlightRanges = {
+      {6, 25}, {25, 40}, {30, 50}, {50, 83}};
+  std::vector<PDFiumPage::Link> links;
+  std::vector<PDFiumPage::Highlight> highlights;
+  PopulateTextObjects(kLinkRanges, &links);
+  PopulateTextObjects(kHighlightRanges, &highlights);
+  ASSERT_EQ(12u, PDFiumPage::CountLinkHighlightOverlaps(links, highlights));
+}
+
+class PDFiumPageThumbnailTest : public PDFiumTestBase {
+ public:
+  PDFiumPageThumbnailTest() = default;
+  PDFiumPageThumbnailTest(const PDFiumPageThumbnailTest&) = delete;
+  PDFiumPageThumbnailTest& operator=(const PDFiumPageThumbnailTest&) = delete;
+  ~PDFiumPageThumbnailTest() override = default;
+
+  void TestGenerateThumbnail(PDFiumEngine& engine,
+                             size_t page_index,
+                             float device_pixel_ratio,
+                             const gfx::Size& expected_thumbnail_size,
+                             const std::string& expectation_file_prefix) {
+    PDFiumPage& page = GetPDFiumPageForTest(engine, page_index);
+    Thumbnail thumbnail = page.GenerateThumbnail(device_pixel_ratio);
+    EXPECT_EQ(expected_thumbnail_size, gfx::Size(thumbnail.bitmap().width(),
+                                                 thumbnail.bitmap().height()));
+    EXPECT_EQ(device_pixel_ratio, thumbnail.device_pixel_ratio());
+
+    base::FilePath expectation_png_file_path = GetThumbnailTestData(
+        expectation_file_prefix, page_index, device_pixel_ratio);
+
+    cc::MatchesPNGFile(thumbnail.bitmap(), expectation_png_file_path,
+                       cc::ExactPixelComparator(/*discard_alpha=*/false));
+  }
+};
+
+TEST_F(PDFiumPageThumbnailTest, GenerateThumbnail) {
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("variable_page_sizes.pdf"));
+  ASSERT_EQ(7, engine->GetNumberOfPages());
+
+  static constexpr struct {
+    size_t page_index;
+    float device_pixel_ratio;
+    gfx::Size expected_thumbnail_size;
+  } kGenerateThumbnailTestParams[] = {
+      {0, 1, {108, 140}},  // ANSI Letter
+      {1, 1, {108, 152}},  // ISO 216 A4
+      {2, 1, {140, 140}},  // Square
+      {3, 1, {540, 108}},  // Wide
+      {4, 1, {108, 540}},  // Tall
+      {5, 1, {1399, 46}},  // Super wide
+      {6, 1, {46, 1399}},  // Super tall
+      {0, 2, {216, 280}},  // ANSI Letter
+      {1, 2, {214, 303}},  // ISO 216 A4
+      {2, 2, {255, 255}},  // Square
+      {3, 2, {571, 114}},  // Wide
+      {4, 2, {114, 571}},  // Tall
+      {5, 2, {1399, 46}},  // Super wide
+      {6, 2, {46, 1399}},  // Super tall
+  };
+
+  for (const auto& params : kGenerateThumbnailTestParams) {
+    TestGenerateThumbnail(*engine, params.page_index, params.device_pixel_ratio,
+                          params.expected_thumbnail_size,
+                          "variable_page_sizes");
+  }
+}
+
+}  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_permissions.cc b/pdf/pdfium/pdfium_permissions.cc
new file mode 100644
index 000000000000..b24c6f42a580
--- /dev/null
+++ b/pdf/pdfium/pdfium_permissions.cc
@@ -0,0 +1,68 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "pdf/pdfium/pdfium_permissions.h"
+
+#include "base/notreached.h"
+
+namespace chrome_pdf {
+
+// static
+PDFiumPermissions PDFiumPermissions::CreateForTesting(
+    int permissions_handler_revision,
+    unsigned long permission_bits) {
+  return PDFiumPermissions(permissions_handler_revision, permission_bits);
+}
+
+PDFiumPermissions::PDFiumPermissions(FPDF_DOCUMENT doc)
+    : permissions_handler_revision_(FPDF_GetSecurityHandlerRevision(doc)),
+      permission_bits_(FPDF_GetDocPermissions(doc)) {}
+
+PDFiumPermissions::PDFiumPermissions(int permissions_handler_revision,
+                                     unsigned long permission_bits)
+    : permissions_handler_revision_(permissions_handler_revision),
+      permission_bits_(permission_bits) {}
+
+bool PDFiumPermissions::HasPermission(
+    PDFEngine::DocumentPermission permission) const {
+  // PDF 1.7 spec, section 3.5.2 says: "If the revision number is 2 or greater,
+  // the operations to which user access can be controlled are as follows: ..."
+  //
+  // Thus for revision numbers less than 2, permissions are ignored and this
+  // always returns true.
+  if (permissions_handler_revision_ < 2)
+    return true;
+
+  if (permissions_handler_revision_ == 2) {
+    // Security handler revision 2 rules are simple.
+    switch (permission) {
+      case PDFEngine::PERMISSION_COPY:
+      case PDFEngine::PERMISSION_COPY_ACCESSIBLE:
+        // Check the same copy bit for all copying permissions.
+        return (permission_bits_ & kPDFPermissionCopyMask) != 0;
+      case PDFEngine::PERMISSION_PRINT_LOW_QUALITY:
+      case PDFEngine::PERMISSION_PRINT_HIGH_QUALITY:
+        // Check the same printing bit for all printing permissions.
+        return (permission_bits_ & kPDFPermissionPrintMask) != 0;
+    }
+  } else {
+    // Security handler revision 3+ have different rules for interpreting the
+    // bits in |permission_bits_|.
+    switch (permission) {
+      case PDFEngine::PERMISSION_COPY:
+        return (permission_bits_ & kPDFPermissionCopyMask) != 0;
+      case PDFEngine::PERMISSION_COPY_ACCESSIBLE:
+        return (permission_bits_ & kPDFPermissionCopyAccessibleMask) != 0;
+      case PDFEngine::PERMISSION_PRINT_LOW_QUALITY:
+        return (permission_bits_ & kPDFPermissionPrintMask) != 0;
+      case PDFEngine::PERMISSION_PRINT_HIGH_QUALITY:
+        return (permission_bits_ & kPDFPermissionPrintMask) != 0 &&
+               (permission_bits_ & kPDFPermissionPrintHighQualityMask) != 0;
+    }
+  }
+  NOTREACHED() << "Unknown permission " << permission;
+  return true;
+}
+
+}  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_permissions.h b/pdf/pdfium/pdfium_permissions.h
new file mode 100644
index 000000000000..9f0a7f69c427
--- /dev/null
+++ b/pdf/pdfium/pdfium_permissions.h
@@ -0,0 +1,44 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef PDF_PDFIUM_PDFIUM_PERMISSIONS_H_
+#define PDF_PDFIUM_PDFIUM_PERMISSIONS_H_
+
+#include "pdf/pdf_engine.h"
+#include "third_party/pdfium/public/fpdfview.h"
+
+namespace chrome_pdf {
+
+// See Table 3.20 in the PDF 1.7 spec for details on how to interpret permission
+// bits. Exposed for use in testing.
+constexpr uint32_t kPDFPermissionPrintMask = 1 << 2;
+constexpr uint32_t kPDFPermissionPrintHighQualityMask = 1 << 11;
+constexpr uint32_t kPDFPermissionCopyMask = 1 << 4;
+constexpr uint32_t kPDFPermissionCopyAccessibleMask = 1 << 9;
+
+// The permissions for a given FPDF_DOCUMENT.
+class PDFiumPermissions final {
+ public:
+  static PDFiumPermissions CreateForTesting(int permissions_handler_revision,
+                                            unsigned long permission_bits);
+
+  explicit PDFiumPermissions(FPDF_DOCUMENT doc);
+
+  bool HasPermission(PDFEngine::DocumentPermission permission) const;
+
+ private:
+  // For unit tests.
+  PDFiumPermissions(int permissions_handler_revision,
+                    unsigned long permission_bits);
+
+  // Permissions security handler revision number. -1 for unknown.
+  const int permissions_handler_revision_;
+
+  // Permissions bitfield.
+  const unsigned long permission_bits_;
+};
+
+}  // namespace chrome_pdf
+
+#endif  // PDF_PDFIUM_PDFIUM_PERMISSIONS_H_
diff --git a/pdf/pdfium/pdfium_permissions_unittest.cc b/pdf/pdfium/pdfium_permissions_unittest.cc
new file mode 100644
index 000000000000..bb3b8ef0952f
--- /dev/null
+++ b/pdf/pdfium/pdfium_permissions_unittest.cc
@@ -0,0 +1,154 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "pdf/pdfium/pdfium_permissions.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace chrome_pdf {
+
+namespace {
+
+constexpr auto kPermCopy = PDFEngine::PERMISSION_COPY;
+constexpr auto kPermCopya11y = PDFEngine::PERMISSION_COPY_ACCESSIBLE;
+constexpr auto kPermPrintHigh = PDFEngine::PERMISSION_PRINT_HIGH_QUALITY;
+constexpr auto kPermPrintLow = PDFEngine::PERMISSION_PRINT_LOW_QUALITY;
+
+constexpr uint32_t GeneratePermissions2(uint32_t permissions) {
+  constexpr uint32_t kBasePermissions = 0xffffffc0;
+  return kBasePermissions | permissions;
+}
+
+constexpr uint32_t GeneratePermissions3(uint32_t permissions) {
+  constexpr uint32_t kBasePermissions = 0xfffff0c0;
+  return kBasePermissions | permissions;
+}
+
+// Sanity check the permission constants are correct.
+static_assert(kPDFPermissionCopyAccessibleMask == 0x200, "Wrong permission");
+static_assert(kPDFPermissionCopyMask == 0x10, "Wrong permission");
+static_assert(kPDFPermissionPrintHighQualityMask == 0x800, "Wrong permission");
+static_assert(kPDFPermissionPrintMask == 0x4, "Wrong permission");
+
+// Sanity check the permission generation functions above do the right thing.
+static_assert(GeneratePermissions2(0) == 0xffffffc0, "Wrong permission");
+static_assert(GeneratePermissions2(kPDFPermissionCopyMask |
+                                   kPDFPermissionPrintMask) == 0xffffffd4,
+              "Wrong permission");
+static_assert(GeneratePermissions3(0) == 0xfffff0c0, "Wrong permission");
+static_assert(GeneratePermissions3(kPDFPermissionCopyAccessibleMask |
+                                   kPDFPermissionCopyMask |
+                                   kPDFPermissionPrintHighQualityMask |
+                                   kPDFPermissionPrintMask) == 0xfffffad4,
+              "Wrong permission");
+
+TEST(PDFiumPermissionTest, InvalidSecurityHandler) {
+  constexpr int kPDFiumUnknownRevision = -1;
+  constexpr uint32_t kNoPermissions = 0;
+  auto unknown_perms = PDFiumPermissions::CreateForTesting(
+      kPDFiumUnknownRevision, kNoPermissions);
+  EXPECT_TRUE(unknown_perms.HasPermission(kPermCopy));
+  EXPECT_TRUE(unknown_perms.HasPermission(kPermCopya11y));
+  EXPECT_TRUE(unknown_perms.HasPermission(kPermPrintLow));
+  EXPECT_TRUE(unknown_perms.HasPermission(kPermPrintHigh));
+
+  constexpr int kInvalidRevision = 1;
+  auto obsolete_perms =
+      PDFiumPermissions::CreateForTesting(kInvalidRevision, kNoPermissions);
+  EXPECT_TRUE(obsolete_perms.HasPermission(kPermCopy));
+  EXPECT_TRUE(obsolete_perms.HasPermission(kPermCopya11y));
+  EXPECT_TRUE(obsolete_perms.HasPermission(kPermPrintLow));
+  EXPECT_TRUE(obsolete_perms.HasPermission(kPermPrintHigh));
+}
+
+TEST(PDFiumPermissionTest, Revision2SecurityHandler) {
+  uint32_t permissions = GeneratePermissions2(0);
+  auto no_perms = PDFiumPermissions::CreateForTesting(2, permissions);
+  EXPECT_FALSE(no_perms.HasPermission(kPermCopy));
+  EXPECT_FALSE(no_perms.HasPermission(kPermCopya11y));
+  EXPECT_FALSE(no_perms.HasPermission(kPermPrintLow));
+  EXPECT_FALSE(no_perms.HasPermission(kPermPrintHigh));
+
+  permissions =
+      GeneratePermissions2(kPDFPermissionCopyMask | kPDFPermissionPrintMask);
+  auto all_known_perms = PDFiumPermissions::CreateForTesting(2, permissions);
+  EXPECT_TRUE(all_known_perms.HasPermission(kPermCopy));
+  EXPECT_TRUE(all_known_perms.HasPermission(kPermCopya11y));
+  EXPECT_TRUE(all_known_perms.HasPermission(kPermPrintLow));
+  EXPECT_TRUE(all_known_perms.HasPermission(kPermPrintHigh));
+
+  permissions = GeneratePermissions2(kPDFPermissionCopyMask);
+  auto no_print_perms = PDFiumPermissions::CreateForTesting(2, permissions);
+  EXPECT_TRUE(no_print_perms.HasPermission(kPermCopy));
+  EXPECT_TRUE(no_print_perms.HasPermission(kPermCopya11y));
+  EXPECT_FALSE(no_print_perms.HasPermission(kPermPrintLow));
+  EXPECT_FALSE(no_print_perms.HasPermission(kPermPrintHigh));
+
+  permissions = GeneratePermissions2(kPDFPermissionPrintMask);
+  auto no_copy_perms = PDFiumPermissions::CreateForTesting(2, permissions);
+  EXPECT_FALSE(no_copy_perms.HasPermission(kPermCopy));
+  EXPECT_FALSE(no_copy_perms.HasPermission(kPermCopya11y));
+  EXPECT_TRUE(no_copy_perms.HasPermission(kPermPrintLow));
+  EXPECT_TRUE(no_copy_perms.HasPermission(kPermPrintHigh));
+}
+
+TEST(PDFiumPermissionTest, Revision3SecurityHandler) {
+  uint32_t permissions = GeneratePermissions3(0);
+  auto no_perms = PDFiumPermissions::CreateForTesting(3, permissions);
+  EXPECT_FALSE(no_perms.HasPermission(kPermCopy));
+  EXPECT_FALSE(no_perms.HasPermission(kPermCopya11y));
+  EXPECT_FALSE(no_perms.HasPermission(kPermPrintLow));
+  EXPECT_FALSE(no_perms.HasPermission(kPermPrintHigh));
+
+  permissions = GeneratePermissions3(
+      kPDFPermissionCopyAccessibleMask | kPDFPermissionCopyMask |
+      kPDFPermissionPrintHighQualityMask | kPDFPermissionPrintMask);
+  auto all_known_perms = PDFiumPermissions::CreateForTesting(3, permissions);
+  EXPECT_TRUE(all_known_perms.HasPermission(kPermCopy));
+  EXPECT_TRUE(all_known_perms.HasPermission(kPermCopya11y));
+  EXPECT_TRUE(all_known_perms.HasPermission(kPermPrintLow));
+  EXPECT_TRUE(all_known_perms.HasPermission(kPermPrintHigh));
+
+  permissions = GeneratePermissions3(kPDFPermissionCopyAccessibleMask |
+                                     kPDFPermissionCopyMask);
+  auto copy_no_print_perms =
+      PDFiumPermissions::CreateForTesting(3, permissions);
+  EXPECT_TRUE(copy_no_print_perms.HasPermission(kPermCopy));
+  EXPECT_TRUE(copy_no_print_perms.HasPermission(kPermCopya11y));
+  EXPECT_FALSE(copy_no_print_perms.HasPermission(kPermPrintLow));
+  EXPECT_FALSE(copy_no_print_perms.HasPermission(kPermPrintHigh));
+
+  permissions =
+      GeneratePermissions3(kPDFPermissionCopyAccessibleMask |
+                           kPDFPermissionCopyMask | kPDFPermissionPrintMask);
+  auto copy_low_print_perms =
+      PDFiumPermissions::CreateForTesting(3, permissions);
+  EXPECT_TRUE(copy_low_print_perms.HasPermission(kPermCopy));
+  EXPECT_TRUE(copy_low_print_perms.HasPermission(kPermCopya11y));
+  EXPECT_TRUE(copy_low_print_perms.HasPermission(kPermPrintLow));
+  EXPECT_FALSE(copy_low_print_perms.HasPermission(kPermPrintHigh));
+
+  permissions = GeneratePermissions3(kPDFPermissionPrintHighQualityMask |
+                                     kPDFPermissionPrintMask);
+  auto print_no_copy_perms =
+      PDFiumPermissions::CreateForTesting(3, permissions);
+  EXPECT_FALSE(print_no_copy_perms.HasPermission(kPermCopy));
+  EXPECT_FALSE(print_no_copy_perms.HasPermission(kPermCopya11y));
+  EXPECT_TRUE(print_no_copy_perms.HasPermission(kPermPrintLow));
+  EXPECT_TRUE(print_no_copy_perms.HasPermission(kPermPrintHigh));
+
+  permissions = GeneratePermissions3(kPDFPermissionCopyAccessibleMask |
+                                     kPDFPermissionPrintHighQualityMask |
+                                     kPDFPermissionPrintMask);
+  auto print_a11y_copy_perms =
+      PDFiumPermissions::CreateForTesting(3, permissions);
+  EXPECT_FALSE(print_a11y_copy_perms.HasPermission(kPermCopy));
+  EXPECT_TRUE(print_a11y_copy_perms.HasPermission(kPermCopya11y));
+  EXPECT_TRUE(print_a11y_copy_perms.HasPermission(kPermPrintLow));
+  EXPECT_TRUE(print_a11y_copy_perms.HasPermission(kPermPrintHigh));
+}
+
+}  // namespace
+
+}  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_print.cc b/pdf/pdfium/pdfium_print.cc
index ea3e2f372f2b..f6df2b1c5157 100644
--- a/pdf/pdfium/pdfium_print.cc
+++ b/pdf/pdfium/pdfium_print.cc
@@ -4,24 +4,31 @@
 
 #include "pdf/pdfium/pdfium_print.h"
 
+#include <algorithm>
 #include <string>
 #include <utility>
 
 #include "base/strings/string_number_conversions.h"
+#include "build/chromeos_buildflags.h"
 #include "pdf/pdf_transform.h"
 #include "pdf/pdfium/pdfium_engine.h"
 #include "pdf/pdfium/pdfium_mem_buffer_file_read.h"
 #include "pdf/pdfium/pdfium_mem_buffer_file_write.h"
+#include "pdf/ppapi_migration/geometry_conversions.h"
 #include "ppapi/c/dev/ppp_printing_dev.h"
 #include "ppapi/c/private/ppp_pdf.h"
 #include "printing/nup_parameters.h"
+#include "printing/page_setup.h"
 #include "printing/units.h"
-#include "third_party/pdfium/public/cpp/fpdf_scopers.h"
 #include "third_party/pdfium/public/fpdf_flatten.h"
 #include "third_party/pdfium/public/fpdf_ppo.h"
 #include "third_party/pdfium/public/fpdf_transformpage.h"
+#include "third_party/skia/include/core/SkImageInfo.h"
 #include "ui/gfx/codec/jpeg_codec.h"
+#include "ui/gfx/geometry/point_f.h"
 #include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/geometry/size_f.h"
 
 using printing::ConvertUnit;
 using printing::ConvertUnitDouble;
@@ -37,22 +44,9 @@ bool ShouldDoNup(int pages_per_sheet) {
   return pages_per_sheet > 1;
 }
 
-// Check the source doc orientation.  Returns true if the doc is landscape.
-// For now the orientation of the doc is determined by its first page's
-// orientation.  Improvement can be added in the future to better determine the
-// orientation of the source docs that have mixed orientation.
-// TODO(xlou): rotate pages if the source doc has mixed orientation.  So that
-// the orientation of all pages of the doc are uniform.  Pages of square size
-// will not be rotated.
-bool IsSourcePdfLandscape(FPDF_DOCUMENT doc) {
-  DCHECK(doc);
-
-  ScopedFPDFPage pdf_page(FPDF_LoadPage(doc, 0));
-  DCHECK(pdf_page);
-
-  bool is_source_landscape =
-      FPDF_GetPageWidth(pdf_page.get()) > FPDF_GetPageHeight(pdf_page.get());
-  return is_source_landscape;
+// Returns the valid, positive page count, or 0 on failure.
+int GetDocumentPageCount(FPDF_DOCUMENT doc) {
+  return std::max(FPDF_GetPageCount(doc), 0);
 }
 
 // Set the destination page size and content area in points based on source
@@ -65,8 +59,8 @@ bool IsSourcePdfLandscape(FPDF_DOCUMENT doc) {
 // points.
 void SetPageSizeAndContentRect(bool rotated,
                                bool is_src_page_landscape,
-                               pp::Size* page_size,
-                               pp::Rect* content_rect) {
+                               gfx::Size* page_size,
+                               gfx::Rect* content_rect) {
   bool is_dst_page_landscape = page_size->width() > page_size->height();
   bool page_orientation_mismatched =
       is_src_page_landscape != is_dst_page_landscape;
@@ -80,20 +74,19 @@ void SetPageSizeAndContentRect(bool rotated,
 
 // Transform |page| contents to fit in the selected printer paper size.
 void TransformPDFPageForPrinting(FPDF_PAGE page,
-                                 double scale_factor,
-                                 const PP_PrintSettings_Dev& print_settings) {
+                                 float scale_factor,
+                                 PP_PrintScalingOption_Dev scaling_option,
+                                 const gfx::Size& paper_size,
+                                 const gfx::Rect& printable_area) {
   // Get the source page width and height in points.
-  const double src_page_width = FPDF_GetPageWidth(page);
-  const double src_page_height = FPDF_GetPageHeight(page);
-
+  gfx::SizeF src_page_size(FPDF_GetPageWidthF(page), FPDF_GetPageHeightF(page));
   const int src_page_rotation = FPDFPage_GetRotation(page);
-  const bool fit_to_page = print_settings.print_scaling_option ==
-                           PP_PRINTSCALINGOPTION_FIT_TO_PRINTABLE_AREA;
 
-  pp::Size page_size(print_settings.paper_size);
-  pp::Rect content_rect(print_settings.printable_area);
+  gfx::Size page_size = paper_size;
+  gfx::Rect content_rect = printable_area;
   const bool rotated = (src_page_rotation % 2 == 1);
-  SetPageSizeAndContentRect(rotated, src_page_width > src_page_height,
+  SetPageSizeAndContentRect(rotated,
+                            src_page_size.width() > src_page_size.height(),
                             &page_size, &content_rect);
 
   // Compute the screen page width and height in points.
@@ -102,11 +95,26 @@ void TransformPDFPageForPrinting(FPDF_PAGE page,
   const int actual_page_height =
       rotated ? page_size.width() : page_size.height();
 
-  const gfx::Rect gfx_content_rect(content_rect.x(), content_rect.y(),
+  gfx::Rect gfx_printed_rect;
+  bool fitted_scaling;
+  switch (scaling_option) {
+    case PP_PRINTSCALINGOPTION_FIT_TO_PRINTABLE_AREA:
+      gfx_printed_rect = gfx::Rect(content_rect.x(), content_rect.y(),
                                    content_rect.width(), content_rect.height());
-  if (fit_to_page) {
-    scale_factor = CalculateScaleFactor(gfx_content_rect, src_page_width,
-                                        src_page_height, rotated);
+      fitted_scaling = true;
+      break;
+    case PP_PRINTSCALINGOPTION_FIT_TO_PAPER:
+      gfx_printed_rect = gfx::Rect(page_size.width(), page_size.height());
+      fitted_scaling = true;
+      break;
+    default:
+      fitted_scaling = false;
+      break;
+  }
+
+  if (fitted_scaling) {
+    scale_factor =
+        CalculateScaleFactor(gfx_printed_rect, src_page_size, rotated);
   }
 
   // Calculate positions for the clip box.
@@ -123,16 +131,12 @@ void TransformPDFPageForPrinting(FPDF_PAGE page,
   ScalePdfRectangle(scale_factor, &source_clip_box);
 
   // Calculate the translation offset values.
-  double offset_x = 0;
-  double offset_y = 0;
-  if (fit_to_page) {
-    CalculateScaledClipBoxOffset(gfx_content_rect, source_clip_box, &offset_x,
-                                 &offset_y);
-  } else {
-    CalculateNonScaledClipBoxOffset(gfx_content_rect, src_page_rotation,
-                                    actual_page_width, actual_page_height,
-                                    source_clip_box, &offset_x, &offset_y);
-  }
+  gfx::PointF offset =
+      fitted_scaling
+          ? CalculateScaledClipBoxOffset(gfx_printed_rect, source_clip_box)
+          : CalculateNonScaledClipBoxOffset(
+                src_page_rotation, actual_page_width, actual_page_height,
+                source_clip_box);
 
   // Reset the media box and crop box. When the page has crop box and media box,
   // the plugin will display the crop box contents and not the entire media box.
@@ -146,31 +150,28 @@ void TransformPDFPageForPrinting(FPDF_PAGE page,
   // Transformation is not required, return. Do this check only after updating
   // the media box and crop box. For more detailed information, please refer to
   // the comment block right before FPDF_SetMediaBox and FPDF_GetMediaBox calls.
-  if (scale_factor == 1.0 && offset_x == 0 && offset_y == 0)
+  if (scale_factor == 1.0f && offset.IsOrigin())
     return;
 
   // All the positions have been calculated, now manipulate the PDF.
-  FS_MATRIX matrix = {static_cast<float>(scale_factor),
-                      0,
-                      0,
-                      static_cast<float>(scale_factor),
-                      static_cast<float>(offset_x),
-                      static_cast<float>(offset_y)};
-  FS_RECTF cliprect = {static_cast<float>(source_clip_box.left + offset_x),
-                       static_cast<float>(source_clip_box.top + offset_y),
-                       static_cast<float>(source_clip_box.right + offset_x),
-                       static_cast<float>(source_clip_box.bottom + offset_y)};
+  const FS_MATRIX matrix = {scale_factor, 0.0f,       0.0f,
+                            scale_factor, offset.x(), offset.y()};
+  const FS_RECTF cliprect = {
+      source_clip_box.left + offset.x(), source_clip_box.top + offset.y(),
+      source_clip_box.right + offset.x(), source_clip_box.bottom + offset.y()};
   FPDFPage_TransFormWithClip(page, &matrix, &cliprect);
-  FPDFPage_TransformAnnots(page, scale_factor, 0, 0, scale_factor, offset_x,
-                           offset_y);
+  FPDFPage_TransformAnnots(page, scale_factor, 0, 0, scale_factor, offset.x(),
+                           offset.y());
 }
 
 void FitContentsToPrintableAreaIfRequired(
     FPDF_DOCUMENT doc,
-    double scale_factor,
-    const PP_PrintSettings_Dev& print_settings) {
+    float scale_factor,
+    PP_PrintScalingOption_Dev scaling_option,
+    const gfx::Size& paper_size,
+    const gfx::Rect& printable_area) {
   // Check to see if we need to fit pdf contents to printer paper size.
-  if (print_settings.print_scaling_option == PP_PRINTSCALINGOPTION_SOURCE_SIZE)
+  if (scaling_option == PP_PRINTSCALINGOPTION_SOURCE_SIZE)
     return;
 
   int num_pages = FPDF_GetPageCount(doc);
@@ -179,10 +180,50 @@ void FitContentsToPrintableAreaIfRequired(
   // every page to fit the contents in the selected printer paper.
   for (int i = 0; i < num_pages; ++i) {
     ScopedFPDFPage page(FPDF_LoadPage(doc, i));
-    TransformPDFPageForPrinting(page.get(), scale_factor, print_settings);
+    TransformPDFPageForPrinting(page.get(), scale_factor, scaling_option,
+                                paper_size, printable_area);
   }
 }
 
+// Takes the same parameters as PDFiumPrint::CreateNupPdf().
+// On success, returns the N-up version of |doc|. On failure, returns nullptr.
+ScopedFPDFDocument CreateNupPdfDocument(ScopedFPDFDocument doc,
+                                        size_t pages_per_sheet,
+                                        const gfx::Size& page_size,
+                                        const gfx::Rect& printable_area) {
+  DCHECK(doc);
+  DCHECK(ShouldDoNup(pages_per_sheet));
+
+  int page_size_width = page_size.width();
+  int page_size_height = page_size.height();
+
+  printing::NupParameters nup_params;
+  bool is_landscape = PDFiumPrint::IsSourcePdfLandscape(doc.get());
+  nup_params.SetParameters(pages_per_sheet, is_landscape);
+  bool paper_is_landscape = page_size_width > page_size_height;
+  if (nup_params.landscape() != paper_is_landscape)
+    std::swap(page_size_width, page_size_height);
+
+  ScopedFPDFDocument nup_doc(FPDF_ImportNPagesToOne(
+      doc.get(), page_size_width, page_size_height,
+      nup_params.num_pages_on_x_axis(), nup_params.num_pages_on_y_axis()));
+  if (nup_doc) {
+    PDFiumPrint::FitContentsToPrintableArea(nup_doc.get(), page_size,
+                                            printable_area);
+  }
+  return nup_doc;
+}
+
+std::vector<uint8_t> ConvertDocToBuffer(ScopedFPDFDocument doc) {
+  DCHECK(doc);
+
+  std::vector<uint8_t> buffer;
+  PDFiumMemBufferFileWrite output_file_write;
+  if (FPDF_SaveAsCopy(doc.get(), &output_file_write, 0))
+    buffer = output_file_write.TakeBuffer();
+  return buffer;
+}
+
 int GetBlockForJpeg(void* param,
                     unsigned long pos,
                     unsigned char* buf,
@@ -204,21 +245,43 @@ std::string GetPageRangeStringFromRange(
     if (!page_number_str.empty())
       page_number_str.push_back(',');
     const PP_PrintPageNumberRange_Dev& range = page_ranges[i];
-    page_number_str.append(base::UintToString(range.first_page_number + 1));
+    page_number_str.append(base::NumberToString(range.first_page_number + 1));
     if (range.first_page_number != range.last_page_number) {
       page_number_str.push_back('-');
-      page_number_str.append(base::UintToString(range.last_page_number + 1));
+      page_number_str.append(base::NumberToString(range.last_page_number + 1));
     }
   }
   return page_number_str;
 }
 
+bool FlattenPrintData(FPDF_DOCUMENT doc) {
+  DCHECK(doc);
+
+  int page_count = FPDF_GetPageCount(doc);
+  for (int i = 0; i < page_count; ++i) {
+    ScopedFPDFPage page(FPDF_LoadPage(doc, i));
+    DCHECK(page);
+    if (FPDFPage_Flatten(page.get(), FLAT_PRINT) == FLATTEN_FAIL)
+      return false;
+  }
+  return true;
+}
+
 }  // namespace
 
 PDFiumPrint::PDFiumPrint(PDFiumEngine* engine) : engine_(engine) {}
 
 PDFiumPrint::~PDFiumPrint() = default;
 
+#if BUILDFLAG(IS_CHROMEOS_ASH)
+// static
+std::vector<uint8_t> PDFiumPrint::CreateFlattenedPdf(ScopedFPDFDocument doc) {
+  if (!FlattenPrintData(doc.get()))
+    return std::vector<uint8_t>();
+  return ConvertDocToBuffer(std::move(doc));
+}
+#endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+
 // static
 std::vector<uint32_t> PDFiumPrint::GetPageNumbersFromPrintPageNumberRange(
     const PP_PrintPageNumberRange_Dev* page_ranges,
@@ -235,80 +298,57 @@ std::vector<uint32_t> PDFiumPrint::GetPageNumbersFromPrintPageNumberRange(
   return page_numbers;
 }
 
-pp::Buffer_Dev PDFiumPrint::PrintPagesAsRasterPDF(
+// static
+std::vector<uint8_t> PDFiumPrint::CreateNupPdf(
+    ScopedFPDFDocument doc,
+    size_t pages_per_sheet,
+    const gfx::Size& page_size,
+    const gfx::Rect& printable_area) {
+  ScopedFPDFDocument nup_doc = CreateNupPdfDocument(
+      std::move(doc), pages_per_sheet, page_size, printable_area);
+  if (!nup_doc)
+    return std::vector<uint8_t>();
+  return ConvertDocToBuffer(std::move(nup_doc));
+}
+
+// static
+bool PDFiumPrint::IsSourcePdfLandscape(FPDF_DOCUMENT doc) {
+  DCHECK(doc);
+
+  ScopedFPDFPage pdf_page(FPDF_LoadPage(doc, 0));
+  DCHECK(pdf_page);
+
+  bool is_source_landscape =
+      FPDF_GetPageWidthF(pdf_page.get()) > FPDF_GetPageHeightF(pdf_page.get());
+  return is_source_landscape;
+}
+
+// static
+void PDFiumPrint::FitContentsToPrintableArea(FPDF_DOCUMENT doc,
+                                             const gfx::Size& page_size,
+                                             const gfx::Rect& printable_area) {
+  FitContentsToPrintableAreaIfRequired(
+      doc, /*scale_factor=*/1.0f, PP_PRINTSCALINGOPTION_FIT_TO_PRINTABLE_AREA,
+      page_size, printable_area);
+}
+
+std::vector<uint8_t> PDFiumPrint::PrintPagesAsPdf(
     const PP_PrintPageNumberRange_Dev* page_ranges,
     uint32_t page_range_count,
     const PP_PrintSettings_Dev& print_settings,
-    const PP_PdfPrintSettings_Dev& pdf_print_settings) {
-  std::vector<PDFiumPage> pages_to_print;
-  // width and height of source PDF pages.
-  std::vector<std::pair<double, double>> source_page_sizes;
-  // Collect pages to print and sizes of source pages.
-  std::vector<uint32_t> page_numbers =
-      PDFiumPrint::GetPageNumbersFromPrintPageNumberRange(page_ranges,
-                                                          page_range_count);
-  for (uint32_t page_number : page_numbers) {
-    ScopedFPDFPage pdf_page(FPDF_LoadPage(engine_->doc(), page_number));
-    double source_page_width = FPDF_GetPageWidth(pdf_page.get());
-    double source_page_height = FPDF_GetPageHeight(pdf_page.get());
-    source_page_sizes.push_back(
-        std::make_pair(source_page_width, source_page_height));
-    // For computing size in pixels, use a square dpi since the source PDF page
-    // has square DPI.
-    int width_in_pixels =
-        ConvertUnit(source_page_width, kPointsPerInch, print_settings.dpi);
-    int height_in_pixels =
-        ConvertUnit(source_page_height, kPointsPerInch, print_settings.dpi);
-
-    pp::Rect rect(width_in_pixels, height_in_pixels);
-    pages_to_print.push_back(PDFiumPage(engine_, page_number, rect, true));
-  }
-
-  ScopedFPDFDocument output_doc(FPDF_CreateNewDocument());
-  DCHECK(output_doc);
-
-  size_t i = 0;
-  for (; i < pages_to_print.size(); ++i) {
-    double source_page_width = source_page_sizes[i].first;
-    double source_page_height = source_page_sizes[i].second;
-
-    // Use |temp_doc| to compress image by saving PDF to |buffer|.
-    pp::Buffer_Dev buffer;
-    {
-      ScopedFPDFDocument temp_doc(
-          CreateSinglePageRasterPdf(source_page_width, source_page_height,
-                                    print_settings, &pages_to_print[i]));
-
-      if (!temp_doc)
-        break;
-
-      buffer = GetFlattenedPrintData(temp_doc.get());
-    }
-
-    PDFiumMemBufferFileRead file_read(buffer.data(), buffer.size());
-    ScopedFPDFDocument temp_doc(FPDF_LoadCustomDocument(&file_read, nullptr));
-    if (!FPDF_ImportPages(output_doc.get(), temp_doc.get(), "1", i))
-      break;
-  }
-
-  pp::Buffer_Dev buffer;
-  if (i == pages_to_print.size()) {
-    FPDF_CopyViewerPreferences(output_doc.get(), engine_->doc());
-    uint32_t pages_per_sheet = pdf_print_settings.pages_per_sheet;
-    uint32_t scale_factor = pdf_print_settings.scale_factor;
-    if (ShouldDoNup(pages_per_sheet)) {
-      buffer = NupPdfToPdf(output_doc.get(), pages_per_sheet, print_settings);
-    } else {
-      FitContentsToPrintableAreaIfRequired(
-          output_doc.get(), scale_factor / 100.0f, print_settings);
-      buffer = GetPrintData(output_doc.get());
-    }
-  }
-
+    const PP_PdfPrintSettings_Dev& pdf_print_settings,
+    bool raster) {
+  std::vector<uint8_t> buffer;
+  ScopedFPDFDocument output_doc = CreatePrintPdf(
+      page_ranges, page_range_count, print_settings, pdf_print_settings);
+  if (raster)
+    output_doc = CreateRasterPdf(std::move(output_doc), print_settings);
+  if (GetDocumentPageCount(output_doc.get()))
+    buffer = ConvertDocToBuffer(std::move(output_doc));
   return buffer;
 }
 
-pp::Buffer_Dev PDFiumPrint::PrintPagesAsPDF(
+ScopedFPDFDocument PDFiumPrint::CreatePrintPdf(
     const PP_PrintPageNumberRange_Dev* page_ranges,
     uint32_t page_range_count,
     const PP_PrintSettings_Dev& print_settings,
@@ -321,63 +361,92 @@ pp::Buffer_Dev PDFiumPrint::PrintPagesAsPDF(
       GetPageRangeStringFromRange(page_ranges, page_range_count);
   if (!FPDF_ImportPages(output_doc.get(), engine_->doc(),
                         page_number_str.c_str(), 0)) {
-    return pp::Buffer_Dev();
+    return nullptr;
   }
 
-  // Now flatten all the output pages.
+  float scale_factor = pdf_print_settings.scale_factor / 100.0f;
+  FitContentsToPrintableAreaIfRequired(
+      output_doc.get(), scale_factor, print_settings.print_scaling_option,
+      SizeFromPPSize(print_settings.paper_size),
+      RectFromPPRect(print_settings.printable_area));
   if (!FlattenPrintData(output_doc.get()))
-    return pp::Buffer_Dev();
+    return nullptr;
 
-  pp::Buffer_Dev buffer;
   uint32_t pages_per_sheet = pdf_print_settings.pages_per_sheet;
-  uint32_t scale_factor = pdf_print_settings.scale_factor;
-  if (ShouldDoNup(pages_per_sheet)) {
-    buffer = NupPdfToPdf(output_doc.get(), pages_per_sheet, print_settings);
-  } else {
-    FitContentsToPrintableAreaIfRequired(output_doc.get(),
-                                         scale_factor / 100.0f, print_settings);
-    buffer = GetPrintData(output_doc.get());
-  }
+  if (!ShouldDoNup(pages_per_sheet))
+    return output_doc;
 
-  return buffer;
+  gfx::Size page_size(print_settings.paper_size.width,
+                      print_settings.paper_size.height);
+  gfx::Rect printable_area(print_settings.printable_area.point.x,
+                           print_settings.printable_area.point.y,
+                           print_settings.printable_area.size.width,
+                           print_settings.printable_area.size.height);
+  gfx::Rect symmetrical_printable_area =
+      printing::PageSetup::GetSymmetricalPrintableArea(page_size,
+                                                       printable_area);
+  if (symmetrical_printable_area.IsEmpty())
+    return nullptr;
+  return CreateNupPdfDocument(std::move(output_doc), pages_per_sheet, page_size,
+                              symmetrical_printable_area);
 }
 
-FPDF_DOCUMENT PDFiumPrint::CreateSinglePageRasterPdf(
-    double source_page_width,
-    double source_page_height,
-    const PP_PrintSettings_Dev& print_settings,
-    PDFiumPage* page_to_print) {
-  FPDF_DOCUMENT temp_doc = FPDF_CreateNewDocument();
+ScopedFPDFDocument PDFiumPrint::CreateRasterPdf(
+    ScopedFPDFDocument doc,
+    const PP_PrintSettings_Dev& print_settings) {
+  int page_count = GetDocumentPageCount(doc.get());
+  if (page_count == 0)
+    return nullptr;
+
+  ScopedFPDFDocument rasterized_doc(FPDF_CreateNewDocument());
+  DCHECK(rasterized_doc);
+  FPDF_CopyViewerPreferences(rasterized_doc.get(), doc.get());
+
+  for (int i = 0; i < page_count; ++i) {
+    ScopedFPDFPage pdf_page(FPDF_LoadPage(doc.get(), i));
+    if (!pdf_page)
+      return nullptr;
+
+    ScopedFPDFDocument temp_doc =
+        CreateSinglePageRasterPdf(pdf_page.get(), print_settings);
+    if (!temp_doc)
+      return nullptr;
+
+    if (!FPDF_ImportPages(rasterized_doc.get(), temp_doc.get(), "1", i))
+      return nullptr;
+  }
+
+  return rasterized_doc;
+}
+
+ScopedFPDFDocument PDFiumPrint::CreateSinglePageRasterPdf(
+    FPDF_PAGE page_to_print,
+    const PP_PrintSettings_Dev& print_settings) {
+  ScopedFPDFDocument temp_doc(FPDF_CreateNewDocument());
   DCHECK(temp_doc);
 
-  const pp::Size& bitmap_size(page_to_print->rect().size());
+  float source_page_width = FPDF_GetPageWidthF(page_to_print);
+  float source_page_height = FPDF_GetPageHeightF(page_to_print);
 
-  pp::ImageData image =
-      pp::ImageData(engine_->GetPluginInstance(),
-                    PP_IMAGEDATAFORMAT_BGRA_PREMUL, bitmap_size, false);
+  // For computing size in pixels, use a square dpi since the source PDF page
+  // has square DPI.
+  int width_in_pixels =
+      ConvertUnit(source_page_width, kPointsPerInch, print_settings.dpi);
+  int height_in_pixels =
+      ConvertUnit(source_page_height, kPointsPerInch, print_settings.dpi);
 
-  ScopedFPDFBitmap bitmap(
-      FPDFBitmap_CreateEx(bitmap_size.width(), bitmap_size.height(),
-                          FPDFBitmap_BGRx, image.data(), image.stride()));
+  gfx::Size bitmap_size(width_in_pixels, height_in_pixels);
+  ScopedFPDFBitmap bitmap(FPDFBitmap_Create(
+      bitmap_size.width(), bitmap_size.height(), /*alpha=*/false));
 
   // Clear the bitmap
   FPDFBitmap_FillRect(bitmap.get(), 0, 0, bitmap_size.width(),
                       bitmap_size.height(), 0xFFFFFFFF);
 
-  pp::Rect page_rect = page_to_print->rect();
-  FPDF_RenderPageBitmap(bitmap.get(), page_to_print->GetPrintPage(),
-                        page_rect.x(), page_rect.y(), page_rect.width(),
-                        page_rect.height(), print_settings.orientation,
-                        FPDF_PRINTING | FPDF_NO_CATCH);
+  FPDF_RenderPageBitmap(bitmap.get(), page_to_print, 0, 0, bitmap_size.width(),
+                        bitmap_size.height(), print_settings.orientation,
+                        FPDF_PRINTING);
 
-  // Draw the forms.
-  FPDF_FFLDraw(engine_->form(), bitmap.get(), page_to_print->GetPrintPage(),
-               page_rect.x(), page_rect.y(), page_rect.width(),
-               page_rect.height(), print_settings.orientation,
-               FPDF_ANNOT | FPDF_PRINTING | FPDF_NO_CATCH);
-
-  unsigned char* bitmap_data =
-      static_cast<unsigned char*>(FPDFBitmap_GetBuffer(bitmap.get()));
   double ratio_x = ConvertUnitDouble(bitmap_size.width(), print_settings.dpi,
                                      kPointsPerInch);
   double ratio_y = ConvertUnitDouble(bitmap_size.height(), print_settings.dpi,
@@ -385,7 +454,7 @@ FPDF_DOCUMENT PDFiumPrint::CreateSinglePageRasterPdf(
 
   // Add the bitmap to an image object and add the image object to the output
   // page.
-  FPDF_PAGEOBJECT temp_img = FPDFPageObj_NewImageObj(temp_doc);
+  ScopedFPDFPageObject temp_img(FPDFPageObj_NewImageObj(temp_doc.get()));
 
   bool encoded = false;
   std::vector<uint8_t> compressed_bitmap_data;
@@ -393,17 +462,18 @@ FPDF_DOCUMENT PDFiumPrint::CreateSinglePageRasterPdf(
     // Use quality = 40 as this does not significantly degrade the printed
     // document relative to a normal bitmap and provides better compression than
     // a higher quality setting.
-    const int kQuality = 40;
+    constexpr int kQuality = 40;
     SkImageInfo info = SkImageInfo::Make(
         FPDFBitmap_GetWidth(bitmap.get()), FPDFBitmap_GetHeight(bitmap.get()),
         kBGRA_8888_SkColorType, kOpaque_SkAlphaType);
-    SkPixmap src(info, bitmap_data, FPDFBitmap_GetStride(bitmap.get()));
+    SkPixmap src(info, FPDFBitmap_GetBuffer(bitmap.get()),
+                 FPDFBitmap_GetStride(bitmap.get()));
     encoded = gfx::JPEGCodec::Encode(src, kQuality, &compressed_bitmap_data);
   }
 
   {
     ScopedFPDFPage temp_page_holder(
-        FPDFPage_New(temp_doc, 0, source_page_width, source_page_height));
+        FPDFPage_New(temp_doc.get(), 0, source_page_width, source_page_height));
     FPDF_PAGE temp_page = temp_page_holder.get();
     if (encoded) {
       FPDF_FILEACCESS file_access = {};
@@ -412,84 +482,18 @@ FPDF_DOCUMENT PDFiumPrint::CreateSinglePageRasterPdf(
       file_access.m_GetBlock = &GetBlockForJpeg;
       file_access.m_Param = &compressed_bitmap_data;
 
-      FPDFImageObj_LoadJpegFileInline(&temp_page, 1, temp_img, &file_access);
+      FPDFImageObj_LoadJpegFileInline(&temp_page, 1, temp_img.get(),
+                                      &file_access);
     } else {
-      FPDFImageObj_SetBitmap(&temp_page, 1, temp_img, bitmap.get());
+      FPDFImageObj_SetBitmap(&temp_page, 1, temp_img.get(), bitmap.get());
     }
 
-    FPDFImageObj_SetMatrix(temp_img, ratio_x, 0, 0, ratio_y, 0, 0);
-    FPDFPage_InsertObject(temp_page, temp_img);
+    FPDFImageObj_SetMatrix(temp_img.get(), ratio_x, 0, 0, ratio_y, 0, 0);
+    FPDFPage_InsertObject(temp_page, temp_img.release());
     FPDFPage_GenerateContent(temp_page);
   }
 
-  page_to_print->ClosePrintPage();
   return temp_doc;
 }
 
-pp::Buffer_Dev PDFiumPrint::NupPdfToPdf(
-    FPDF_DOCUMENT doc,
-    uint32_t pages_per_sheet,
-    const PP_PrintSettings_Dev& print_settings) {
-  DCHECK(doc);
-  DCHECK(ShouldDoNup(pages_per_sheet));
-
-  PP_Size page_size = print_settings.paper_size;
-
-  printing::NupParameters nup_params;
-  bool is_landscape = IsSourcePdfLandscape(doc);
-  nup_params.SetParameters(pages_per_sheet, is_landscape);
-
-  // Import n pages to one.
-  bool paper_is_landscape = page_size.width > page_size.height;
-  if (nup_params.landscape() != paper_is_landscape)
-    std::swap(page_size.width, page_size.height);
-
-  ScopedFPDFDocument output_doc_nup(FPDF_ImportNPagesToOne(
-      doc, page_size.width, page_size.height, nup_params.num_pages_on_x_axis(),
-      nup_params.num_pages_on_y_axis()));
-  if (!output_doc_nup)
-    return pp::Buffer_Dev();
-
-  FitContentsToPrintableAreaIfRequired(output_doc_nup.get(), 1.0f,
-                                       print_settings);
-  return GetPrintData(output_doc_nup.get());
-}
-
-bool PDFiumPrint::FlattenPrintData(FPDF_DOCUMENT doc) {
-  DCHECK(doc);
-
-  ScopedSubstFont scoped_subst_font(engine_);
-  int page_count = FPDF_GetPageCount(doc);
-  for (int i = 0; i < page_count; ++i) {
-    ScopedFPDFPage page(FPDF_LoadPage(doc, i));
-    DCHECK(page);
-    if (FPDFPage_Flatten(page.get(), FLAT_PRINT) == FLATTEN_FAIL)
-      return false;
-  }
-  return true;
-}
-
-pp::Buffer_Dev PDFiumPrint::GetPrintData(FPDF_DOCUMENT doc) {
-  DCHECK(doc);
-
-  pp::Buffer_Dev buffer;
-  PDFiumMemBufferFileWrite output_file_write;
-  if (FPDF_SaveAsCopy(doc, &output_file_write, 0)) {
-    size_t size = output_file_write.size();
-    buffer = pp::Buffer_Dev(engine_->GetPluginInstance(), size);
-    if (!buffer.is_null())
-      memcpy(buffer.data(), output_file_write.buffer().c_str(), size);
-  }
-  return buffer;
-}
-
-pp::Buffer_Dev PDFiumPrint::GetFlattenedPrintData(FPDF_DOCUMENT doc) {
-  DCHECK(doc);
-
-  pp::Buffer_Dev buffer;
-  if (FlattenPrintData(doc))
-    buffer = GetPrintData(doc);
-  return buffer;
-}
-
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_print.h b/pdf/pdfium/pdfium_print.h
index c0df7d99e447..ab9f14454cd2 100644
--- a/pdf/pdfium/pdfium_print.h
+++ b/pdf/pdfium/pdfium_print.h
@@ -7,61 +7,87 @@
 
 #include <vector>
 
-#include "base/macros.h"
-#include "ppapi/cpp/dev/buffer_dev.h"
+#include "build/build_config.h"
+#include "build/chromeos_buildflags.h"
+#include "third_party/pdfium/public/cpp/fpdf_scopers.h"
 #include "third_party/pdfium/public/fpdfview.h"
 
 struct PP_PdfPrintSettings_Dev;
 struct PP_PrintSettings_Dev;
 struct PP_PrintPageNumberRange_Dev;
 
+namespace gfx {
+class Rect;
+class Size;
+}  // namespace gfx
+
 namespace chrome_pdf {
 
 class PDFiumEngine;
-class PDFiumPage;
 
 class PDFiumPrint {
  public:
   explicit PDFiumPrint(PDFiumEngine* engine);
+  PDFiumPrint(const PDFiumPrint&) = delete;
+  PDFiumPrint& operator=(const PDFiumPrint&) = delete;
   ~PDFiumPrint();
 
+#if BUILDFLAG(IS_CHROMEOS_ASH)
+  // Flattens the |doc|.
+  // On success, returns the flattened version of |doc| as a vector.
+  // On failure, returns an empty vector.
+  static std::vector<uint8_t> CreateFlattenedPdf(ScopedFPDFDocument doc);
+#endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+
   static std::vector<uint32_t> GetPageNumbersFromPrintPageNumberRange(
       const PP_PrintPageNumberRange_Dev* page_ranges,
       uint32_t page_range_count);
 
-  pp::Buffer_Dev PrintPagesAsRasterPDF(
+  // Performs N-up PDF generation for |doc| based on |pages_per_sheet|,
+  // |page_size|, and |printable_area|.
+  // On success, returns the N-up version of |doc| as a vector.
+  // On failure, returns an empty vector.
+  static std::vector<uint8_t> CreateNupPdf(ScopedFPDFDocument doc,
+                                           size_t pages_per_sheet,
+                                           const gfx::Size& page_size,
+                                           const gfx::Rect& printable_area);
+
+  // Check the source doc orientation.  Returns true if the doc is landscape.
+  // For now the orientation of the doc is determined by its first page's
+  // orientation.  Improvement can be added in the future to better determine
+  // the orientation of the source docs that have mixed orientation.
+  // TODO(xlou): rotate pages if the source doc has mixed orientation.  So that
+  // the orientation of all pages of the doc are uniform.  Pages of square size
+  // will not be rotated.
+  static bool IsSourcePdfLandscape(FPDF_DOCUMENT doc);
+
+  static void FitContentsToPrintableArea(FPDF_DOCUMENT doc,
+                                         const gfx::Size& page_size,
+                                         const gfx::Rect& printable_area);
+
+  std::vector<uint8_t> PrintPagesAsPdf(
       const PP_PrintPageNumberRange_Dev* page_ranges,
       uint32_t page_range_count,
       const PP_PrintSettings_Dev& print_settings,
-      const PP_PdfPrintSettings_Dev& pdf_print_settings);
-  pp::Buffer_Dev PrintPagesAsPDF(
-      const PP_PrintPageNumberRange_Dev* page_ranges,
-      uint32_t page_range_count,
-      const PP_PrintSettings_Dev& print_settings,
-      const PP_PdfPrintSettings_Dev& pdf_print_settings);
+      const PP_PdfPrintSettings_Dev& pdf_print_settings,
+      bool raster);
 
  private:
-  FPDF_DOCUMENT CreateSinglePageRasterPdf(
-      double source_page_width,
-      double source_page_height,
+  ScopedFPDFDocument CreatePrintPdf(
+      const PP_PrintPageNumberRange_Dev* page_ranges,
+      uint32_t page_range_count,
       const PP_PrintSettings_Dev& print_settings,
-      PDFiumPage* page_to_print);
+      const PP_PdfPrintSettings_Dev& pdf_print_settings);
 
-  // Perform N-up PDF generation from |doc| based on |pages_per_sheet| and
-  // the parameters in |print_settings|.
-  // On success, the returned buffer contains the N-up version of |doc|.
-  // On failure, the returned buffer is empty.
-  pp::Buffer_Dev NupPdfToPdf(FPDF_DOCUMENT doc,
-                             uint32_t pages_per_sheet,
-                             const PP_PrintSettings_Dev& print_settings);
+  ScopedFPDFDocument CreateRasterPdf(
+      ScopedFPDFDocument doc,
+      const PP_PrintSettings_Dev& print_settings);
 
-  bool FlattenPrintData(FPDF_DOCUMENT doc);
-  pp::Buffer_Dev GetPrintData(FPDF_DOCUMENT doc);
-  pp::Buffer_Dev GetFlattenedPrintData(FPDF_DOCUMENT doc);
+  ScopedFPDFDocument CreateSinglePageRasterPdf(
+      FPDF_PAGE page_to_print,
+      const PP_PrintSettings_Dev& print_settings);
 
   PDFiumEngine* const engine_;
-
-  DISALLOW_COPY_AND_ASSIGN(PDFiumPrint);
 };
 
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_print_unittest.cc b/pdf/pdfium/pdfium_print_unittest.cc
new file mode 100644
index 000000000000..28f472f0fe63
--- /dev/null
+++ b/pdf/pdfium/pdfium_print_unittest.cc
@@ -0,0 +1,251 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "pdf/pdfium/pdfium_print.h"
+
+#include <memory>
+
+#include "base/hash/md5.h"
+#include "base/optional.h"
+#include "base/stl_util.h"
+#include "pdf/pdfium/pdfium_engine.h"
+#include "pdf/pdfium/pdfium_engine_exports.h"
+#include "pdf/pdfium/pdfium_test_base.h"
+#include "pdf/test/test_client.h"
+#include "ppapi/c/dev/ppp_printing_dev.h"
+#include "ppapi/c/private/ppp_pdf.h"
+#include "printing/pdf_render_settings.h"
+#include "printing/units.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/size_f.h"
+
+namespace chrome_pdf {
+
+using PDFiumPrintTest = PDFiumTestBase;
+using testing::ElementsAre;
+
+namespace {
+
+// Number of color channels in a BGRA bitmap.
+constexpr int kColorChannels = 4;
+
+constexpr PP_Size kUSLetterSize = {612, 792};
+constexpr PP_Rect kUSLetterRect = {{0, 0}, kUSLetterSize};
+constexpr PP_Rect kPrintableAreaRect = {{18, 18}, {576, 733}};
+
+using ExpectedDimensions = std::vector<gfx::SizeF>;
+
+void CheckPdfDimensions(const std::vector<uint8_t>& pdf_data,
+                        const ExpectedDimensions& expected_dimensions) {
+  PDFiumEngineExports exports;
+  int page_count;
+  ASSERT_TRUE(exports.GetPDFDocInfo(pdf_data, &page_count, nullptr));
+  ASSERT_GT(page_count, 0);
+  ASSERT_EQ(expected_dimensions.size(), static_cast<size_t>(page_count));
+
+  for (int i = 0; i < page_count; ++i) {
+    base::Optional<gfx::SizeF> page_size =
+        exports.GetPDFPageSizeByIndex(pdf_data, i);
+    ASSERT_TRUE(page_size.has_value());
+    EXPECT_EQ(expected_dimensions[i], page_size.value());
+  }
+}
+
+void CheckPdfRendering(const std::vector<uint8_t>& pdf_data,
+                       int page_number,
+                       const gfx::SizeF& size_in_points,
+                       const char* expected_md5_hash) {
+  int width_in_pixels =
+      printing::ConvertUnit(size_in_points.width(), printing::kPointsPerInch,
+                            printing::kDefaultPdfDpi);
+  int height_in_pixels =
+      printing::ConvertUnit(size_in_points.height(), printing::kPointsPerInch,
+                            printing::kDefaultPdfDpi);
+
+  const gfx::Rect page_rect(width_in_pixels, height_in_pixels);
+  std::vector<uint8_t> page_bitmap_data(kColorChannels * page_rect.width() *
+                                        page_rect.height());
+
+  PDFEngineExports::RenderingSettings settings(
+      gfx::Size(printing::kDefaultPdfDpi, printing::kDefaultPdfDpi), page_rect,
+      /*fit_to_bounds=*/true,
+      /*stretch_to_bounds=*/false,
+      /*keep_aspect_ratio=*/true,
+      /*center_in_bounds=*/true,
+      /*autorotate=*/false, /*use_color=*/true, /*render_for_printing=*/true);
+
+  PDFiumEngineExports exports;
+  ASSERT_TRUE(exports.RenderPDFPageToBitmap(pdf_data, page_number, settings,
+                                            page_bitmap_data.data()));
+
+  base::MD5Digest hash;
+  base::MD5Sum(page_bitmap_data.data(), page_bitmap_data.size(), &hash);
+  EXPECT_STREQ(expected_md5_hash, base::MD5DigestToBase16(hash).c_str());
+}
+
+}  // namespace
+
+TEST_F(PDFiumPrintTest, GetPageNumbersFromPrintPageNumberRange) {
+  std::vector<uint32_t> page_numbers;
+
+  {
+    const PP_PrintPageNumberRange_Dev page_ranges[] = {{0, 2}};
+    page_numbers = PDFiumPrint::GetPageNumbersFromPrintPageNumberRange(
+        &page_ranges[0], base::size(page_ranges));
+    EXPECT_THAT(page_numbers, ElementsAre(0, 1, 2));
+  }
+  {
+    const PP_PrintPageNumberRange_Dev page_ranges[] = {{0, 0}, {2, 2}, {4, 5}};
+    page_numbers = PDFiumPrint::GetPageNumbersFromPrintPageNumberRange(
+        &page_ranges[0], base::size(page_ranges));
+    EXPECT_THAT(page_numbers, ElementsAre(0, 2, 4, 5));
+  }
+}
+
+TEST_F(PDFiumPrintTest, Basic) {
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("hello_world2.pdf"));
+  ASSERT_TRUE(engine);
+
+  PDFiumPrint print(engine.get());
+
+  constexpr PP_PrintSettings_Dev print_settings = {kUSLetterRect,
+                                                   kUSLetterRect,
+                                                   kUSLetterSize,
+                                                   72,
+                                                   PP_PRINTORIENTATION_NORMAL,
+                                                   PP_PRINTSCALINGOPTION_NONE,
+                                                   PP_FALSE,
+                                                   PP_PRINTOUTPUTFORMAT_PDF};
+  constexpr PP_PdfPrintSettings_Dev pdf_print_settings = {1, 100};
+
+  {
+    // Print 2 pages.
+    const ExpectedDimensions kExpectedDimensions = {{612.0, 792.0},
+                                                    {612.0, 792.0}};
+    const PP_PrintPageNumberRange_Dev page_ranges[] = {{0, 1}};
+    std::vector<uint8_t> pdf_data =
+        print.PrintPagesAsPdf(&page_ranges[0], base::size(page_ranges),
+                              print_settings, pdf_print_settings,
+                              /*raster=*/false);
+    CheckPdfDimensions(pdf_data, kExpectedDimensions);
+
+    pdf_data = print.PrintPagesAsPdf(&page_ranges[0], base::size(page_ranges),
+                                     print_settings, pdf_print_settings,
+                                     /*raster=*/true);
+    CheckPdfDimensions(pdf_data, kExpectedDimensions);
+  }
+  {
+    // Print 1 page.
+    const ExpectedDimensions kExpectedDimensions = {{612.0, 792.0}};
+    const PP_PrintPageNumberRange_Dev page_ranges[] = {{0, 0}};
+    std::vector<uint8_t> pdf_data =
+        print.PrintPagesAsPdf(&page_ranges[0], base::size(page_ranges),
+                              print_settings, pdf_print_settings,
+                              /*raster=*/false);
+    CheckPdfDimensions(pdf_data, kExpectedDimensions);
+
+    pdf_data = print.PrintPagesAsPdf(&page_ranges[0], base::size(page_ranges),
+                                     print_settings, pdf_print_settings,
+                                     /*raster=*/true);
+    CheckPdfDimensions(pdf_data, kExpectedDimensions);
+  }
+  {
+    // Print the other page.
+    const ExpectedDimensions kExpectedDimensions = {{612.0, 792.0}};
+    const PP_PrintPageNumberRange_Dev page_ranges[] = {{1, 1}};
+    std::vector<uint8_t> pdf_data =
+        print.PrintPagesAsPdf(&page_ranges[0], base::size(page_ranges),
+                              print_settings, pdf_print_settings,
+                              /*raster=*/false);
+    CheckPdfDimensions(pdf_data, kExpectedDimensions);
+
+    pdf_data = print.PrintPagesAsPdf(&page_ranges[0], base::size(page_ranges),
+                                     print_settings, pdf_print_settings,
+                                     /*raster=*/true);
+    CheckPdfDimensions(pdf_data, kExpectedDimensions);
+  }
+}
+
+TEST_F(PDFiumPrintTest, AlterScaling) {
+  TestClient client;
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("rectangles.pdf"));
+  ASSERT_TRUE(engine);
+
+  PDFiumPrint print(engine.get());
+
+  PP_PrintSettings_Dev print_settings = {kPrintableAreaRect,
+                                         kUSLetterRect,
+                                         kUSLetterSize,
+                                         72,
+                                         PP_PRINTORIENTATION_NORMAL,
+                                         PP_PRINTSCALINGOPTION_NONE,
+                                         PP_FALSE,
+                                         PP_PRINTOUTPUTFORMAT_PDF};
+  constexpr PP_PdfPrintSettings_Dev pdf_print_settings = {1, 100};
+  const ExpectedDimensions kExpectedDimensions = {{612.0, 792.0}};
+  constexpr PP_PrintPageNumberRange_Dev page_range = {0, 0};
+
+  {
+    // Default scaling
+    static const char md5_hash[] = "40e2e16416015cdde5c6e5735c1d06ac";
+    static const char md5_hash_raster[] = "c29b9ed661143ea7f177d7af8a336ef7";
+
+    std::vector<uint8_t> pdf_data = print.PrintPagesAsPdf(
+        &page_range, 1, print_settings, pdf_print_settings,
+        /*raster=*/false);
+    CheckPdfDimensions(pdf_data, kExpectedDimensions);
+    CheckPdfRendering(pdf_data, 0, kExpectedDimensions[0], md5_hash);
+
+    pdf_data = print.PrintPagesAsPdf(&page_range, 1, print_settings,
+                                     pdf_print_settings,
+                                     /*raster=*/true);
+    CheckPdfDimensions(pdf_data, kExpectedDimensions);
+    CheckPdfRendering(pdf_data, 0, kExpectedDimensions[0], md5_hash_raster);
+  }
+  {
+    // "Fit to Page" scaling
+    print_settings.print_scaling_option =
+        PP_PRINTSCALINGOPTION_FIT_TO_PRINTABLE_AREA;
+
+    static const char md5_hash[] = "41847e1f0c581150a84794482528f790";
+    static const char md5_hash_raster[] = "436354693512c8144ae51837ff9f951e";
+
+    std::vector<uint8_t> pdf_data = print.PrintPagesAsPdf(
+        &page_range, 1, print_settings, pdf_print_settings,
+        /*raster=*/false);
+    CheckPdfDimensions(pdf_data, kExpectedDimensions);
+    CheckPdfRendering(pdf_data, 0, kExpectedDimensions[0], md5_hash);
+
+    pdf_data = print.PrintPagesAsPdf(&page_range, 1, print_settings,
+                                     pdf_print_settings,
+                                     /*raster=*/true);
+    CheckPdfDimensions(pdf_data, kExpectedDimensions);
+    CheckPdfRendering(pdf_data, 0, kExpectedDimensions[0], md5_hash_raster);
+  }
+  {
+    // "Fit to Paper" scaling
+    print_settings.print_scaling_option = PP_PRINTSCALINGOPTION_FIT_TO_PAPER;
+
+    static const char md5_hash[] = "3a4828228bcbae230574c057b7a0669e";
+    static const char md5_hash_raster[] = "8834ddfb3ef4483acf8da9d27d43cf1f";
+
+    std::vector<uint8_t> pdf_data = print.PrintPagesAsPdf(
+        &page_range, 1, print_settings, pdf_print_settings,
+        /*raster=*/false);
+    CheckPdfDimensions(pdf_data, kExpectedDimensions);
+    CheckPdfRendering(pdf_data, 0, kExpectedDimensions[0], md5_hash);
+
+    pdf_data = print.PrintPagesAsPdf(&page_range, 1, print_settings,
+                                     pdf_print_settings,
+                                     /*raster=*/true);
+    CheckPdfDimensions(pdf_data, kExpectedDimensions);
+    CheckPdfRendering(pdf_data, 0, kExpectedDimensions[0], md5_hash_raster);
+  }
+}
+
+}  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_range.cc b/pdf/pdfium/pdfium_range.cc
index bec834ff3d96..eda743c256b5 100644
--- a/pdf/pdfium/pdfium_range.cc
+++ b/pdf/pdfium/pdfium_range.cc
@@ -4,9 +4,11 @@
 
 #include "pdf/pdfium/pdfium_range.h"
 
-#include "base/logging.h"
+#include "base/check_op.h"
 #include "base/strings/string_util.h"
 #include "pdf/pdfium/pdfium_api_string_buffer_adapter.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/rect.h"
 
 namespace chrome_pdf {
 
@@ -23,6 +25,10 @@ void AdjustForBackwardsRange(int* index, int* count) {
 
 }  // namespace
 
+bool IsIgnorableCharacter(char16_t c) {
+  return (c == kZeroWidthSpace) || (c == kPDFSoftHyphenMarker);
+}
+
 PDFiumRange::PDFiumRange(PDFiumPage* page, int char_index, int char_count)
     : page_(page), char_index_(char_index), char_count_(char_count) {
 #if DCHECK_IS_ON()
@@ -43,21 +49,21 @@ void PDFiumRange::SetCharCount(int char_count) {
   DCHECK_LE(char_count, FPDFText_CountChars(page_->GetTextPage()));
 #endif
 
-  cached_screen_rects_offset_ = pp::Point();
+  cached_screen_rects_point_ = gfx::Point();
   cached_screen_rects_zoom_ = 0;
 }
 
-const std::vector<pp::Rect>& PDFiumRange::GetScreenRects(
-    const pp::Point& offset,
+const std::vector<gfx::Rect>& PDFiumRange::GetScreenRects(
+    const gfx::Point& point,
     double zoom,
-    int rotation) {
-  if (offset == cached_screen_rects_offset_ &&
+    PageOrientation orientation) const {
+  if (point == cached_screen_rects_point_ &&
       zoom == cached_screen_rects_zoom_) {
     return cached_screen_rects_;
   }
 
   cached_screen_rects_.clear();
-  cached_screen_rects_offset_ = offset;
+  cached_screen_rects_point_ = point;
   cached_screen_rects_zoom_ = zoom;
 
   int char_index = char_index_;
@@ -78,8 +84,8 @@ const std::vector<pp::Rect>& PDFiumRange::GetScreenRects(
     double right;
     double bottom;
     FPDFText_GetRect(page_->GetTextPage(), i, &left, &top, &right, &bottom);
-    pp::Rect rect =
-        page_->PageToScreen(offset, zoom, left, top, right, bottom, rotation);
+    gfx::Rect rect =
+        page_->PageToScreen(point, zoom, left, top, right, bottom, orientation);
     if (rect.IsEmpty())
       continue;
     cached_screen_rects_.push_back(rect);
@@ -88,16 +94,16 @@ const std::vector<pp::Rect>& PDFiumRange::GetScreenRects(
   return cached_screen_rects_;
 }
 
-base::string16 PDFiumRange::GetText() const {
+std::u16string PDFiumRange::GetText() const {
   int index = char_index_;
   int count = char_count_;
-  base::string16 rv;
+  std::u16string rv;
   if (count == 0)
     return rv;
 
   AdjustForBackwardsRange(&index, &count);
   if (count > 0) {
-    PDFiumAPIStringBufferAdapter<base::string16> api_string_adapter(&rv, count,
+    PDFiumAPIStringBufferAdapter<std::u16string> api_string_adapter(&rv, count,
                                                                     false);
     unsigned short* data =
         reinterpret_cast<unsigned short*>(api_string_adapter.GetData());
@@ -105,6 +111,8 @@ base::string16 PDFiumRange::GetText() const {
     api_string_adapter.Close(written);
   }
 
+  base::EraseIf(rv, [](char16_t c) { return IsIgnorableCharacter(c); });
+
   return rv;
 }
 
diff --git a/pdf/pdfium/pdfium_range.h b/pdf/pdfium/pdfium_range.h
index 56b0fcadb8ec..17a5dbd24df5 100644
--- a/pdf/pdfium/pdfium_range.h
+++ b/pdf/pdfium/pdfium_range.h
@@ -8,12 +8,21 @@
 #include <string>
 #include <vector>
 
-#include "base/strings/string16.h"
+#include "pdf/page_orientation.h"
 #include "pdf/pdfium/pdfium_page.h"
-#include "ppapi/cpp/rect.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/rect.h"
 
 namespace chrome_pdf {
 
+constexpr char16_t kZeroWidthSpace = 0x200B;
+constexpr char16_t kPDFSoftHyphenMarker = 0xFFFE;
+
+// Helper for identifying characters that PDFium outputs, via FPDFText_GetText,
+// that have special meaning, but should not be included in things like copied
+// text or when running find.
+bool IsIgnorableCharacter(char16_t c);
+
 // Describes location of a string of characters.
 class PDFiumRange {
  public:
@@ -30,12 +39,13 @@ class PDFiumRange {
   int char_count() const { return char_count_; }
 
   // Gets bounding rectangles of range in screen coordinates.
-  const std::vector<pp::Rect>& GetScreenRects(const pp::Point& offset,
-                                              double zoom,
-                                              int rotation);
+  const std::vector<gfx::Rect>& GetScreenRects(
+      const gfx::Point& point,
+      double zoom,
+      PageOrientation orientation) const;
 
   // Gets the string of characters in this range.
-  base::string16 GetText() const;
+  std::u16string GetText() const;
 
  private:
   PDFiumPage* page_;
@@ -45,9 +55,9 @@ class PDFiumRange {
   int char_count_;
 
   // Cache of ScreenRect, and the associated variables used when caching it.
-  std::vector<pp::Rect> cached_screen_rects_;
-  pp::Point cached_screen_rects_offset_;
-  double cached_screen_rects_zoom_ = 0;
+  mutable std::vector<gfx::Rect> cached_screen_rects_;
+  mutable gfx::Point cached_screen_rects_point_;
+  mutable double cached_screen_rects_zoom_ = 0;
 };
 
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_test_base.cc b/pdf/pdfium/pdfium_test_base.cc
new file mode 100644
index 000000000000..300f9f56cc83
--- /dev/null
+++ b/pdf/pdfium/pdfium_test_base.cc
@@ -0,0 +1,142 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "pdf/pdfium/pdfium_test_base.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "base/check_op.h"
+#include "base/memory/scoped_refptr.h"
+#include "build/build_config.h"
+#include "pdf/pdfium/pdfium_engine.h"
+#include "pdf/pdfium/pdfium_form_filler.h"
+#include "pdf/ppapi_migration/url_loader.h"
+#include "pdf/test/test_client.h"
+#include "pdf/test/test_document_loader.h"
+
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#include "base/environment.h"
+#endif
+
+namespace chrome_pdf {
+
+namespace {
+
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+base::FilePath GetTestFontsDir() {
+  // base::TestSuite::Initialize() should have already set this.
+  std::unique_ptr<base::Environment> env(base::Environment::Create());
+  std::string fontconfig_sysroot;
+  CHECK(env->GetVar("FONTCONFIG_SYSROOT", &fontconfig_sysroot));
+  return base::FilePath(fontconfig_sysroot).AppendASCII("test_fonts");
+}
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+
+}  // namespace
+
+PDFiumTestBase::PDFiumTestBase() = default;
+
+PDFiumTestBase::~PDFiumTestBase() = default;
+
+// static
+bool PDFiumTestBase::UsingTestFonts() {
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+  return true;
+#else
+  return false;
+#endif
+}
+
+void PDFiumTestBase::SetUp() {
+  InitializePDFium();
+}
+
+void PDFiumTestBase::TearDown() {
+  FPDF_DestroyLibrary();
+}
+
+std::unique_ptr<PDFiumEngine> PDFiumTestBase::InitializeEngine(
+    TestClient* client,
+    const base::FilePath::CharType* pdf_name) {
+  InitializeEngineResult result =
+      InitializeEngineWithoutLoading(client, pdf_name);
+  if (result.engine) {
+    // Incrementally read the PDF. To detect linearized PDFs, the first read
+    // should be at least 1024 bytes.
+    while (result.document_loader->SimulateLoadData(1024))
+      continue;
+  }
+  return std::move(result.engine);
+}
+
+PDFiumTestBase::InitializeEngineResult
+PDFiumTestBase::InitializeEngineWithoutLoading(
+    TestClient* client,
+    const base::FilePath::CharType* pdf_name) {
+  InitializeEngineResult result;
+
+  result.engine = std::make_unique<PDFiumEngine>(
+      client, PDFiumFormFiller::ScriptOption::kNoJavaScript);
+  client->set_engine(result.engine.get());
+
+  auto test_loader =
+      std::make_unique<TestDocumentLoader>(result.engine.get(), pdf_name);
+  result.document_loader = test_loader.get();
+  result.engine->SetDocumentLoaderForTesting(std::move(test_loader));
+
+  if (!result.engine->New("https://chromium.org/dummy.pdf", "") ||
+      !result.engine->HandleDocumentLoad(nullptr)) {
+    client->set_engine(nullptr);
+    result.engine = nullptr;
+    result.document_loader = nullptr;
+  }
+  return result;
+}
+
+void PDFiumTestBase::InitializePDFium() {
+  font_paths_.clear();
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+  test_fonts_path_ = GetTestFontsDir();
+  font_paths_.push_back(test_fonts_path_.value().c_str());
+  // When non-empty, `font_paths_` has to be terminated with a nullptr.
+  font_paths_.push_back(nullptr);
+#endif
+
+  FPDF_LIBRARY_CONFIG config;
+  config.version = 3;
+  config.m_pUserFontPaths = font_paths_.data();
+  config.m_pIsolate = nullptr;
+  config.m_v8EmbedderSlot = 0;
+  config.m_pPlatform = nullptr;
+  FPDF_InitLibraryWithConfig(&config);
+}
+
+const PDFiumPage& PDFiumTestBase::GetPDFiumPageForTest(
+    const PDFiumEngine& engine,
+    size_t page_index) {
+  return GetPDFiumPageForTest(const_cast<PDFiumEngine&>(engine), page_index);
+}
+
+PDFiumPage& PDFiumTestBase::GetPDFiumPageForTest(PDFiumEngine& engine,
+                                                 size_t page_index) {
+  DCHECK_LT(page_index, engine.pages_.size());
+  PDFiumPage* page = engine.pages_[page_index].get();
+  DCHECK(page);
+  return *page;
+}
+
+PDFiumTestBase::InitializeEngineResult::InitializeEngineResult() = default;
+
+PDFiumTestBase::InitializeEngineResult::InitializeEngineResult(
+    InitializeEngineResult&& other) noexcept = default;
+
+PDFiumTestBase::InitializeEngineResult&
+PDFiumTestBase::InitializeEngineResult::operator=(
+    InitializeEngineResult&& other) noexcept = default;
+
+PDFiumTestBase::InitializeEngineResult::~InitializeEngineResult() = default;
+
+}  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_test_base.h b/pdf/pdfium/pdfium_test_base.h
new file mode 100644
index 000000000000..1a16e812233b
--- /dev/null
+++ b/pdf/pdfium/pdfium_test_base.h
@@ -0,0 +1,89 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef PDF_PDFIUM_PDFIUM_TEST_BASE_H_
+#define PDF_PDFIUM_PDFIUM_TEST_BASE_H_
+
+#include <stddef.h>
+
+#include <memory>
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "build/build_config.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace chrome_pdf {
+
+class PDFiumEngine;
+class PDFiumPage;
+class TestClient;
+class TestDocumentLoader;
+
+class PDFiumTestBase : public testing::Test {
+ public:
+  PDFiumTestBase();
+  PDFiumTestBase(const PDFiumTestBase&) = delete;
+  PDFiumTestBase& operator=(const PDFiumTestBase&) = delete;
+  ~PDFiumTestBase() override;
+
+  // Returns true in test environments that use //third_party/test_fonts.
+  static bool UsingTestFonts();
+
+ protected:
+  // Result of calling InitializeEngineWithoutLoading().
+  struct InitializeEngineResult {
+    InitializeEngineResult();
+    InitializeEngineResult(InitializeEngineResult&& other) noexcept;
+    InitializeEngineResult& operator=(InitializeEngineResult&& other) noexcept;
+    ~InitializeEngineResult();
+
+    // Initialized engine.
+    std::unique_ptr<PDFiumEngine> engine;
+
+    // Corresponding test document loader.
+    TestDocumentLoader* document_loader;
+  };
+
+  // testing::Test:
+  void SetUp() override;
+  void TearDown() override;
+
+  // Initializes a PDFiumEngine for use in testing with |client|. Loads a PDF
+  // named |pdf_name|. See TestDocumentLoader for more info about |pdf_name|.
+  std::unique_ptr<PDFiumEngine> InitializeEngine(
+      TestClient* client,
+      const base::FilePath::CharType* pdf_name);
+
+  // Initializes a PDFiumEngine as with InitializeEngine(), but defers loading
+  // until the test calls SimulateLoadData() on the returned TestDocumentLoader.
+  InitializeEngineResult InitializeEngineWithoutLoading(
+      TestClient* client,
+      const base::FilePath::CharType* pdf_name);
+
+  // Returns the `PDFiumPage` for the page index. The page index must be valid
+  // (less than `engine.GetNumberOfPages()`).
+  static const PDFiumPage& GetPDFiumPageForTest(const PDFiumEngine& engine,
+                                                size_t page_index);
+  static PDFiumPage& GetPDFiumPageForTest(PDFiumEngine& engine,
+                                          size_t page_index);
+
+ private:
+  void InitializePDFium();
+
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+  base::FilePath test_fonts_path_;
+#endif
+
+  // Stores custom font paths, if any, in a format compatible with
+  // FPDF_InitLibraryWithConfig(). This must outlive `test_fonts_path_`, as it
+  // may point to it. This must remain valid while PDFium is active, from when
+  // FPDF_InitLibraryWithConfig() first gets called to when
+  // FPDF_DestroyLibrary() gets called.
+  std::vector<const char*> font_paths_;
+};
+
+}  // namespace chrome_pdf
+
+#endif  // PDF_PDFIUM_PDFIUM_TEST_BASE_H_
diff --git a/pdf/pdfium/pdfium_unsupported_features.cc b/pdf/pdfium/pdfium_unsupported_features.cc
index 55dbd2d140a9..01fdd0a8b13f 100644
--- a/pdf/pdfium/pdfium_unsupported_features.cc
+++ b/pdf/pdfium/pdfium_unsupported_features.cc
@@ -4,7 +4,7 @@
 
 #include "pdf/pdfium/pdfium_unsupported_features.h"
 
-#include "base/logging.h"
+#include "base/notreached.h"
 #include "pdf/pdfium/pdfium_engine.h"
 #include "third_party/pdfium/public/fpdf_ext.h"
 
diff --git a/pdf/pdfium/pdfium_unsupported_features.h b/pdf/pdfium/pdfium_unsupported_features.h
index 35f5e1d20d49..9823802f3fb0 100644
--- a/pdf/pdfium/pdfium_unsupported_features.h
+++ b/pdf/pdfium/pdfium_unsupported_features.h
@@ -5,8 +5,6 @@
 #ifndef PDF_PDFIUM_PDFIUM_UNSUPPORTED_FEATURES_H_
 #define PDF_PDFIUM_PDFIUM_UNSUPPORTED_FEATURES_H_
 
-#include "base/macros.h"
-
 namespace chrome_pdf {
 
 class PDFiumEngine;
@@ -18,12 +16,12 @@ void InitializeUnsupportedFeaturesHandler();
 class ScopedUnsupportedFeature {
  public:
   explicit ScopedUnsupportedFeature(PDFiumEngine* engine);
+  ScopedUnsupportedFeature(const ScopedUnsupportedFeature&) = delete;
+  ScopedUnsupportedFeature& operator=(const ScopedUnsupportedFeature&) = delete;
   ~ScopedUnsupportedFeature();
 
  private:
   PDFiumEngine* const old_engine_;
-
-  DISALLOW_COPY_AND_ASSIGN(ScopedUnsupportedFeature);
 };
 
 }  // namespace chrome_pdf
diff --git a/third_party/blink/renderer/platform/fonts/DEPS b/third_party/blink/renderer/platform/fonts/DEPS
index 98ddf831ee06..16e13d217542 100644
--- a/third_party/blink/renderer/platform/fonts/DEPS
+++ b/third_party/blink/renderer/platform/fonts/DEPS
@@ -6,23 +6,24 @@ include_rules = [
     "+third_party/blink/renderer/platform/fonts",
 
     # Dependencies.
+    "+base/mac",
+    "+cc",
     "+third_party/blink/renderer/platform/font_family_names.h",
     "+third_party/blink/renderer/platform/geometry",
-    "+third_party/blink/renderer/platform/graphics",
-    "+third_party/blink/renderer/platform/heap/handle.h",
     "+third_party/blink/renderer/platform/heap",
-    "+third_party/blink/renderer/platform/histogram.h",
+    "+third_party/blink/renderer/platform/instrumentation/histogram.h",
     "+third_party/blink/renderer/platform/instrumentation",
     "+third_party/blink/renderer/platform/language.h",
-    "+third_party/blink/renderer/platform/layout_test_support.h",
-    "+third_party/blink/renderer/platform/layout_unit.h",
-    "+third_party/blink/renderer/platform/mac/version_util_mac.h",
     "+third_party/blink/renderer/platform/platform_export.h",
+    "+third_party/blink/renderer/platform/privacy_budget",
     "+third_party/blink/renderer/platform/resolution_units.h",
     "+third_party/blink/renderer/platform/runtime_enabled_features.h",
-    "+third_party/blink/renderer/platform/shared_buffer.h",
+    "+third_party/blink/renderer/platform/scheduler/public",
+    "+third_party/blink/renderer/platform/wtf/shared_buffer.h",
     "+third_party/blink/renderer/platform/testing",
     "+third_party/blink/renderer/platform/text",
-    "+third_party/blink/renderer/platform/transforms/affine_transform.h",
+    "+third_party/blink/renderer/platform/timer.h",
+    "+third_party/blink/renderer/platform/web_test_support.h",
     "+third_party/blink/renderer/platform/wtf",
+    "+ui/base/mojom/attributed_string.mojom-blink.h",
 ]
diff --git a/third_party/blink/renderer/platform/fonts/LocaleInFonts.md b/third_party/blink/renderer/platform/fonts/LocaleInFonts.md
index 3696adffad3a..dc2070493dac 100644
--- a/third_party/blink/renderer/platform/fonts/LocaleInFonts.md
+++ b/third_party/blink/renderer/platform/fonts/LocaleInFonts.md
@@ -31,10 +31,10 @@ Note that `ComputedStyle::locale()` is an `AtomicString`
 for the style system to work without special casing,
 while `FontDescription::locale()` is a pointer to `LayoutLocale`.
 
-[lang attribute]: https://html.spec.whatwg.org/multipage/dom.html#the-lang-and-xml:lang-attributes
+[lang attribute]: https://html.spec.whatwg.org/C/#the-lang-and-xml:lang-attributes
 [BCP 47]: https://tools.ietf.org/html/bcp47
-[language of a node]: https://html.spec.whatwg.org/multipage/dom.html#language
-[content-language]: https://html.spec.whatwg.org/multipage/semantics.html#pragma-set-default-language
+[language of a node]: https://html.spec.whatwg.org/C/#language
+[content-language]: https://html.spec.whatwg.org/C/#pragma-set-default-language
 
 ## Generic Family
 
@@ -52,12 +52,12 @@ Blink uses the following prioritized list to determine the script.
 
 This result is available at `ComputedStyle::getFontDescription().localeOrDefault().script()`.
 
-[generic-family]: https://drafts.csswg.org/css-fonts-3/#generic-family-value
+[generic-family]: https://drafts.csswg.org/css-fonts/#generic-family-value
 [Advanced Font Settings]: https://chrome.google.com/webstore/detail/advanced-font-settings/caclkomlalccbpcdllchkeecicepbmbm
 
-## System Font Fallback
+## Installed Font Fallback
 
-[CSS Fonts] defines a concept of [system font fallback],
+[CSS Fonts] defines a concept of [installed font fallback],
 though its behavior is UA dependent.
 
 As Blink tries to match the font fallback behavior
@@ -66,8 +66,27 @@ the logic varies by platforms.
 While the complete logic varies by platforms,
 we try to share parts of the logic where possible.
 
-[CSS Fonts]: https://drafts.csswg.org/css-fonts-3/
-[system font fallback]: https://drafts.csswg.org/css-fonts-3/#system-font-fallback
+[CSS Fonts]: https://drafts.csswg.org/css-fonts/
+[installed font fallback]: https://drafts.csswg.org/css-fonts/#installed-font-fallback
+
+### Emojis
+
+If we've determined that a character is [emoji-default], also known as "emoji
+in emoji" representation, we treat the character a bit differently. The goal is
+to not only find a font that supports emojis, but also to prioritize color
+emoji fonts over traditional monochrome fonts that happen to have the glyph.
+
+On Android/Skia, Linux, and Windows, Blink will pass the special locale
+`und-Zsye` to the operating system when looking for an emoji font. The [Zsye]
+script tag is defined by UTS #51 as "prefer emoji style for characters that
+have both text and emoji styles available", which is precisely what we need.
+
+On Linux, Blink will additionally always use U+1F46A FAMILY () when matching
+potential candidates to increase the odds of finding the right emoji font, in
+case the installed emoji font doesn't support the actual emoji in question.
+
+[emoji-default]: https://unicode.org/reports/tr51/#Presentation_Style
+[Zsye]: https://unicode.org/reports/tr51/#Emoji_Script
 
 ### Unified Han Ideographs
 
@@ -75,7 +94,7 @@ As seen in [CJK Unified Ideographs code charts] in Unicode,
 glyphs of Han Ideographs vary by locales.
 
 To render correct glyphs,
-the system font fallback uses the following prioritized list of locales.
+the installed font fallback uses the following prioritized list of locales.
 
 1. The [language of a node] as defined in HTML, if known.
 2. The list of languages the browser sends in the [Accept-Language] header.
@@ -89,7 +108,7 @@ For this purpose,
 `LayoutLocale::hasScriptForHan()` determines whether
 the locale can choose the correct font for the Unified Han Ideographs or not.
 
-When the system font fallback needs to determine the font
+When the installed font fallback needs to determine the font
 for a Unified Han Ideograph,
 it uses `scriptForHan()` of the first locale in the prioritized list
 that has `hasScriptForHan()` true.
diff --git a/third_party/blink/renderer/platform/fonts/OWNERS b/third_party/blink/renderer/platform/fonts/OWNERS
new file mode 100644
index 000000000000..c0787f405b1b
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/OWNERS
@@ -0,0 +1,2 @@
+per-file font_matching_metrics.cc=file://third_party/blink/public/common/privacy_budget/OWNERS
+per-file font_matching_metrics.h=file://third_party/blink/public/common/privacy_budget/OWNERS
\ No newline at end of file
diff --git a/third_party/blink/renderer/platform/fonts/README.md b/third_party/blink/renderer/platform/fonts/README.md
index c926090d9630..ef7f2b3a7af7 100644
--- a/third_party/blink/renderer/platform/fonts/README.md
+++ b/third_party/blink/renderer/platform/fonts/README.md
@@ -157,7 +157,7 @@ Emoji place additional requirements in isolating sub-runs for shaping. Emoji
 Unicode code points and code point sequences have different default presentation
 styles, text-default, or emoji-default. This is defined in the
 section
-[Presentation Style of Unicode Technical Report #51](http://unicode.org/draft/reports/tr51/tr51.html#Presentation_Style). So
+[Presentation Style of Unicode Technical Standard #51](https://unicode.org/reports/tr51/#Presentation_Style). So
 in order to select the correct font for emoji presentation  either a color
 font, or a regular contour font  the incoming text needs to be segmented and
 isolated by its emoji properties as well.
@@ -359,7 +359,9 @@ fonts are searched next. This behavior matches the requirements of the font
 style matching algorithm of
 the
 [CSS Fonts specification](https://drafts.csswg.org/css-fonts/#font-style-matching),
-which mandates to prioritize web fonts over system fonts.
+which mandates to prioritize web fonts over system fonts. Some additional
+details can be found in
+[LocaleInFonts.md](https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/fonts/LocaleInFonts.md#Installed-Font-Fallback).
 
 `FontFallbackIterator` is intialized with a `FontFallbackList` and starts
 retrieving fonts from this list as its first source for fonts. If during shaping
@@ -379,4 +381,5 @@ additional system fonts pulled in to the shaping process.
 In summary, `FontFallbackIterator` feeds fonts from the CSS `font-family` list
 as well as system fallback fonts to `HarfBuzzShaper` for use in the shaping
 iterations until ideally all gaps are filled and the full text run can be drawn
-with the correct glyphs.
+with the correct glyphs.  When there are gaps, and the .notdef tofu character
+must be rendered, the primary font is used for this.
diff --git a/third_party/blink/renderer/platform/fonts/alternate_font_family.h b/third_party/blink/renderer/platform/fonts/alternate_font_family.h
index 62ae63d6b669..2382615a524b 100644
--- a/third_party/blink/renderer/platform/fonts/alternate_font_family.h
+++ b/third_party/blink/renderer/platform/fonts/alternate_font_family.h
@@ -48,20 +48,20 @@ inline const AtomicString& AdjustFamilyNameToAvoidUnsupportedFonts(
   // 'Courier' is a bitmap font. On Mac on the other hand 'Courier' is
   // a truetype font. Thus pages asking for Courier are better of
   // using 'Courier New' on windows.
-  if (EqualIgnoringASCIICase(family_name, FontFamilyNames::Courier))
-    return FontFamilyNames::Courier_New;
+  if (EqualIgnoringASCIICase(family_name, font_family_names::kCourier))
+    return font_family_names::kCourierNew;
 
   // Alias 'MS Sans Serif' (bitmap font) -> 'Microsoft Sans Serif'
   // (truetype font).
-  if (EqualIgnoringASCIICase(family_name, FontFamilyNames::MS_Sans_Serif))
-    return FontFamilyNames::Microsoft_Sans_Serif;
+  if (EqualIgnoringASCIICase(family_name, font_family_names::kMSSansSerif))
+    return font_family_names::kMicrosoftSansSerif;
 
   // Alias 'MS Serif' (bitmap) -> 'Times New Roman' (truetype font).
   // Alias 'Times' -> 'Times New Roman' (truetype font).
   // There's no 'Microsoft Sans Serif-equivalent' for Serif.
-  if (EqualIgnoringASCIICase(family_name, FontFamilyNames::MS_Serif) ||
-      EqualIgnoringASCIICase(family_name, FontFamilyNames::Times))
-    return FontFamilyNames::Times_New_Roman;
+  if (EqualIgnoringASCIICase(family_name, font_family_names::kMSSerif) ||
+      EqualIgnoringASCIICase(family_name, font_family_names::kTimes))
+    return font_family_names::kTimesNewRoman;
 #endif
 
   return family_name;
@@ -70,27 +70,27 @@ inline const AtomicString& AdjustFamilyNameToAvoidUnsupportedFonts(
 inline const AtomicString& AlternateFamilyName(
     const AtomicString& family_name) {
   // Alias Courier <-> Courier New
-  if (EqualIgnoringASCIICase(family_name, FontFamilyNames::Courier))
-    return FontFamilyNames::Courier_New;
+  if (EqualIgnoringASCIICase(family_name, font_family_names::kCourier))
+    return font_family_names::kCourierNew;
 #if !defined(OS_WIN)
   // On Windows, Courier New (truetype font) is always present and
   // Courier is a bitmap font. So, we don't want to map Courier New to
   // Courier.
-  if (EqualIgnoringASCIICase(family_name, FontFamilyNames::Courier_New))
-    return FontFamilyNames::Courier;
+  if (EqualIgnoringASCIICase(family_name, font_family_names::kCourierNew))
+    return font_family_names::kCourier;
 #endif
 
   // Alias Times and Times New Roman.
-  if (EqualIgnoringASCIICase(family_name, FontFamilyNames::Times))
-    return FontFamilyNames::Times_New_Roman;
-  if (EqualIgnoringASCIICase(family_name, FontFamilyNames::Times_New_Roman))
-    return FontFamilyNames::Times;
+  if (EqualIgnoringASCIICase(family_name, font_family_names::kTimes))
+    return font_family_names::kTimesNewRoman;
+  if (EqualIgnoringASCIICase(family_name, font_family_names::kTimesNewRoman))
+    return font_family_names::kTimes;
 
   // Alias Arial and Helvetica
-  if (EqualIgnoringASCIICase(family_name, FontFamilyNames::Arial))
-    return FontFamilyNames::Helvetica;
-  if (EqualIgnoringASCIICase(family_name, FontFamilyNames::Helvetica))
-    return FontFamilyNames::Arial;
+  if (EqualIgnoringASCIICase(family_name, font_family_names::kArial))
+    return font_family_names::kHelvetica;
+  if (EqualIgnoringASCIICase(family_name, font_family_names::kHelvetica))
+    return font_family_names::kArial;
 
   return g_empty_atom;
 }
@@ -99,15 +99,15 @@ inline const AtomicString& GetFallbackFontFamily(
     const FontDescription& description) {
   switch (description.GenericFamily()) {
     case FontDescription::kSansSerifFamily:
-      return FontFamilyNames::sans_serif;
+      return font_family_names::kSansSerif;
     case FontDescription::kSerifFamily:
-      return FontFamilyNames::serif;
+      return font_family_names::kSerif;
     case FontDescription::kMonospaceFamily:
-      return FontFamilyNames::monospace;
+      return font_family_names::kMonospace;
     case FontDescription::kCursiveFamily:
-      return FontFamilyNames::cursive;
+      return font_family_names::kCursive;
     case FontDescription::kFantasyFamily:
-      return FontFamilyNames::fantasy;
+      return font_family_names::kFantasy;
     default:
       // Let the caller use the system default font.
       return g_empty_atom;
diff --git a/third_party/blink/renderer/platform/fonts/android/font_cache_android.cc b/third_party/blink/renderer/platform/fonts/android/font_cache_android.cc
index 6c8efc827f5f..99aec1d670c7 100644
--- a/third_party/blink/renderer/platform/fonts/android/font_cache_android.cc
+++ b/third_party/blink/renderer/platform/fonts/android/font_cache_android.cc
@@ -56,7 +56,7 @@ static AtomicString DefaultFontFamily(sk_sp<SkFontMgr> font_manager) {
   // do here, use "Arial", the value LayoutTheme uses for CSS system font
   // keywords such as "menu".
   NOTREACHED();
-  return FontFamilyNames::Arial;
+  return font_family_names::kArial;
 }
 
 static AtomicString DefaultFontFamily() {
@@ -99,7 +99,7 @@ AtomicString FontCache::GetGenericFamilyNameForScript(
   // i18n fonts are likely not monospace. Monospace is mostly used
   // for code, but when i18n characters appear in monospace, system
   // fallback can still render the characters.
-  if (family_name == FontFamilyNames::webkit_monospace)
+  if (family_name == font_family_names::kWebkitMonospace)
     return family_name;
 
   // The CJK hack below should be removed, at latest when we have
diff --git a/third_party/blink/renderer/platform/fonts/android/font_cache_android_test.cc b/third_party/blink/renderer/platform/fonts/android/font_cache_android_test.cc
index efe8ddc64ef9..5f03b588f82c 100644
--- a/third_party/blink/renderer/platform/fonts/android/font_cache_android_test.cc
+++ b/third_party/blink/renderer/platform/fonts/android/font_cache_android_test.cc
@@ -39,26 +39,25 @@ TEST(FontCacheAndroid, genericFamilyNameForScript) {
   FontDescription chinese;
   chinese.SetLocale(LayoutLocale::Get("zh"));
 
-  if (FontFamilyNames::webkit_standard.IsEmpty())
-    FontFamilyNames::init();
+  font_family_names::Init();
 
   // For non-CJK, getGenericFamilyNameForScript should return the given
   // familyName.
-  EXPECT_EQ(FontFamilyNames::webkit_standard,
+  EXPECT_EQ(font_family_names::kWebkitStandard,
             FontCache::GetGenericFamilyNameForScript(
-                FontFamilyNames::webkit_standard, english));
-  EXPECT_EQ(FontFamilyNames::webkit_monospace,
+                font_family_names::kWebkitStandard, english));
+  EXPECT_EQ(font_family_names::kWebkitMonospace,
             FontCache::GetGenericFamilyNameForScript(
-                FontFamilyNames::webkit_monospace, english));
+                font_family_names::kWebkitMonospace, english));
 
   // For CJK, getGenericFamilyNameForScript should return CJK fonts except
   // monospace.
-  EXPECT_NE(FontFamilyNames::webkit_standard,
+  EXPECT_NE(font_family_names::kWebkitStandard,
             FontCache::GetGenericFamilyNameForScript(
-                FontFamilyNames::webkit_standard, chinese));
-  EXPECT_EQ(FontFamilyNames::webkit_monospace,
+                font_family_names::kWebkitStandard, chinese));
+  EXPECT_EQ(font_family_names::kWebkitMonospace,
             FontCache::GetGenericFamilyNameForScript(
-                FontFamilyNames::webkit_monospace, chinese));
+                font_family_names::kWebkitMonospace, chinese));
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/android/font_unique_name_lookup_android.cc b/third_party/blink/renderer/platform/fonts/android/font_unique_name_lookup_android.cc
new file mode 100644
index 000000000000..db83df87816b
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/android/font_unique_name_lookup_android.cc
@@ -0,0 +1,206 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/files/file.h"
+#include "base/timer/elapsed_timer.h"
+
+#include "third_party/blink/public/common/font_unique_name_lookup/icu_fold_case_util.h"
+#include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
+#include "third_party/blink/public/platform/platform.h"
+#include "third_party/blink/renderer/platform/fonts/android/font_unique_name_lookup_android.h"
+#include "third_party/blink/renderer/platform/instrumentation/histogram.h"
+#include "third_party/blink/renderer/platform/runtime_enabled_features.h"
+
+#include "third_party/skia/include/core/SkData.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace blink {
+
+FontUniqueNameLookupAndroid::~FontUniqueNameLookupAndroid() = default;
+
+void FontUniqueNameLookupAndroid::PrepareFontUniqueNameLookup(
+    NotifyFontUniqueNameLookupReady callback) {
+  DCHECK(!font_table_matcher_.get());
+  DCHECK(RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled());
+
+  pending_callbacks_.push_back(std::move(callback));
+
+  // We bind the service on the first call to PrepareFontUniqueNameLookup. After
+  // that we do not need to make additional IPC requests to retrieve the table.
+  // The observing callback was added to the list, so all clients will be
+  // informed when the lookup table has arrived.
+  if (pending_callbacks_.size() > 1)
+    return;
+
+  EnsureServiceConnected();
+
+  firmware_font_lookup_service_->GetUniqueNameLookupTable(base::BindOnce(
+      &FontUniqueNameLookupAndroid::ReceiveReadOnlySharedMemoryRegion,
+      base::Unretained(this)));
+}
+
+bool FontUniqueNameLookupAndroid::IsFontUniqueNameLookupReadyForSyncLookup() {
+  if (!RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled())
+    return true;
+
+  EnsureServiceConnected();
+
+  // If we have the table already, we're ready for sync lookups.
+  if (font_table_matcher_.get())
+    return true;
+
+  // We have previously determined via IPC whether the table is sync available.
+  // Return what we found out before.
+  if (sync_available_.has_value())
+    return sync_available_.value();
+
+  // If we haven't asked the browser before, probe synchronously - if the table
+  // is available on the browser side, we can continue with sync operation.
+
+  bool sync_available_from_mojo = false;
+  base::ReadOnlySharedMemoryRegion shared_memory_region;
+  firmware_font_lookup_service_->GetUniqueNameLookupTableIfAvailable(
+      &sync_available_from_mojo, &shared_memory_region);
+  sync_available_ = sync_available_from_mojo;
+
+  if (*sync_available_) {
+    // Adopt the shared memory region, do not notify anyone in callbacks as
+    // PrepareFontUniqueNameLookup must not have been called yet. Just return
+    // true from this function.
+    DCHECK_EQ(pending_callbacks_.size(), 0u);
+    ReceiveReadOnlySharedMemoryRegion(std::move(shared_memory_region));
+  }
+
+  // If it wasn't available synchronously LocalFontFaceSource has to call
+  // PrepareFontUniqueNameLookup.
+  return *sync_available_;
+}
+
+sk_sp<SkTypeface> FontUniqueNameLookupAndroid::MatchUniqueName(
+    const String& font_unique_name) {
+  if (!IsFontUniqueNameLookupReadyForSyncLookup())
+    return nullptr;
+  sk_sp<SkTypeface> result_font =
+      MatchUniqueNameFromFirmwareFonts(font_unique_name);
+  if (result_font)
+    return result_font;
+  if (RuntimeEnabledFeatures::AndroidDownloadableFontsMatchingEnabled()) {
+    return MatchUniqueNameFromDownloadableFonts(font_unique_name);
+  } else {
+    return nullptr;
+  }
+}
+
+void FontUniqueNameLookupAndroid::EnsureServiceConnected() {
+  if (firmware_font_lookup_service_ &&
+      (!RuntimeEnabledFeatures::AndroidDownloadableFontsMatchingEnabled() ||
+       android_font_lookup_service_))
+    return;
+
+  if (!firmware_font_lookup_service_) {
+    Platform::Current()->GetBrowserInterfaceBroker()->GetInterface(
+        firmware_font_lookup_service_.BindNewPipeAndPassReceiver());
+  }
+
+  if (RuntimeEnabledFeatures::AndroidDownloadableFontsMatchingEnabled() &&
+      !android_font_lookup_service_) {
+    Platform::Current()->GetBrowserInterfaceBroker()->GetInterface(
+        android_font_lookup_service_.BindNewPipeAndPassReceiver());
+  }
+}
+
+void FontUniqueNameLookupAndroid::ReceiveReadOnlySharedMemoryRegion(
+    base::ReadOnlySharedMemoryRegion shared_memory_region) {
+  font_table_matcher_ =
+      std::make_unique<FontTableMatcher>(shared_memory_region.Map());
+  while (!pending_callbacks_.IsEmpty()) {
+    NotifyFontUniqueNameLookupReady callback = pending_callbacks_.TakeFirst();
+    std::move(callback).Run();
+  }
+}
+
+sk_sp<SkTypeface> FontUniqueNameLookupAndroid::MatchUniqueNameFromFirmwareFonts(
+    const String& font_unique_name) {
+  base::Optional<FontTableMatcher::MatchResult> match_result =
+      font_table_matcher_->MatchName(font_unique_name.Utf8().c_str());
+  if (!match_result)
+    return nullptr;
+  return SkTypeface::MakeFromFile(match_result->font_path.c_str(),
+                                  match_result->ttc_index);
+}
+
+bool FontUniqueNameLookupAndroid::RequestedNameInQueryableFonts(
+    const String& font_unique_name) {
+  if (!queryable_fonts_) {
+    Vector<String> retrieved_fonts;
+    android_font_lookup_service_->GetUniqueNameLookupTable(&retrieved_fonts);
+    queryable_fonts_ = std::move(retrieved_fonts);
+  }
+  return queryable_fonts_ && queryable_fonts_->Contains(String::FromUTF8(
+                                 IcuFoldCase(font_unique_name.Utf8()).c_str()));
+}
+
+sk_sp<SkTypeface>
+FontUniqueNameLookupAndroid::MatchUniqueNameFromDownloadableFonts(
+    const String& font_unique_name) {
+  if (!android_font_lookup_service_.is_bound()) {
+    LOG(ERROR) << "Service not connected.";
+    return nullptr;
+  }
+
+  if (!RequestedNameInQueryableFonts(font_unique_name))
+    return nullptr;
+
+  DEFINE_STATIC_LOCAL_IMPL(
+      CustomCountHistogram, lookup_latency_histogram_success,
+      ("Android.FontLookup.Blink.DLFontsLatencySuccess", 0, 10000000, 50),
+      false);
+  DEFINE_STATIC_LOCAL_IMPL(
+      CustomCountHistogram, lookup_latency_histogram_failure,
+      ("Android.FontLookup.Blink.DLFontsLatencySuccess", 0, 10000000, 50),
+      false);
+
+  base::File font_file;
+  String case_folded_unique_font_name =
+      String::FromUTF8(IcuFoldCase(font_unique_name.Utf8()).c_str());
+
+  base::ElapsedTimer elapsed_timer;
+
+  if (!android_font_lookup_service_->MatchLocalFontByUniqueName(
+          case_folded_unique_font_name, &font_file)) {
+    LOG(ERROR)
+        << "Mojo method returned false for case-folded unique font name: "
+        << case_folded_unique_font_name;
+    lookup_latency_histogram_failure.CountMicroseconds(elapsed_timer.Elapsed());
+    return nullptr;
+  }
+
+  if (!font_file.IsValid()) {
+    LOG(ERROR) << "Received platform font handle invalid, fd: "
+               << font_file.GetPlatformFile();
+    lookup_latency_histogram_failure.CountMicroseconds(elapsed_timer.Elapsed());
+    return nullptr;
+  }
+
+  sk_sp<SkData> font_data = SkData::MakeFromFD(font_file.GetPlatformFile());
+
+  if (!font_data || font_data->isEmpty()) {
+    LOG(ERROR) << "Received file descriptor has 0 size.";
+    lookup_latency_histogram_failure.CountMicroseconds(elapsed_timer.Elapsed());
+    return nullptr;
+  }
+
+  sk_sp<SkTypeface> return_typeface(SkTypeface::MakeFromData(font_data));
+
+  if (!return_typeface) {
+    lookup_latency_histogram_failure.CountMicroseconds(elapsed_timer.Elapsed());
+    LOG(ERROR) << "Cannot instantiate SkTypeface from font blob SkData.";
+  }
+
+  lookup_latency_histogram_success.CountMicroseconds(elapsed_timer.Elapsed());
+  return return_typeface;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/android/font_unique_name_lookup_android.h b/third_party/blink/renderer/platform/fonts/android/font_unique_name_lookup_android.h
new file mode 100644
index 000000000000..773c9be4aebc
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/android/font_unique_name_lookup_android.h
@@ -0,0 +1,62 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_ANDROID_FONT_UNIQUE_NAME_LOOKUP_ANDROID_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_ANDROID_FONT_UNIQUE_NAME_LOOKUP_ANDROID_H_
+
+#include "mojo/public/cpp/bindings/remote.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
+#include "third_party/blink/public/mojom/android_font_lookup/android_font_lookup.mojom-blink.h"
+#include "third_party/blink/public/mojom/font_unique_name_lookup/font_unique_name_lookup.mojom-blink.h"
+#include "third_party/blink/renderer/platform/fonts/font_unique_name_lookup.h"
+#include "third_party/blink/renderer/platform/wtf/deque.h"
+
+#include <memory>
+
+namespace blink {
+
+// Unique font lookup implementation for Android, uses two backends: Fonts from
+// the firmware in the font directories indexed by
+// content/browser/font_unique_name_lookup/font_unique_name_lookup.cc as well
+// as the Mojo IPC connection to a java implementation that fetches fonts from
+// GMSCore, see
+// content/public/android/java/src/org/chromium/content/browser/font/AndroidFontLookupImpl.java
+class FontUniqueNameLookupAndroid : public FontUniqueNameLookup {
+ public:
+  FontUniqueNameLookupAndroid() = default;
+  ~FontUniqueNameLookupAndroid() override;
+
+  bool IsFontUniqueNameLookupReadyForSyncLookup() override;
+
+  void PrepareFontUniqueNameLookup(
+      NotifyFontUniqueNameLookupReady callback) override;
+
+  sk_sp<SkTypeface> MatchUniqueName(const String& font_unique_name) override;
+
+ private:
+  void EnsureServiceConnected();
+
+  void ReceiveReadOnlySharedMemoryRegion(
+      base::ReadOnlySharedMemoryRegion shared_memory_region);
+
+  sk_sp<SkTypeface> MatchUniqueNameFromFirmwareFonts(
+      const String& font_unique_name);
+
+  bool RequestedNameInQueryableFonts(const String& font_unique_name);
+  sk_sp<SkTypeface> MatchUniqueNameFromDownloadableFonts(
+      const String& font_unique_name);
+
+  mojo::Remote<mojom::blink::FontUniqueNameLookup>
+      firmware_font_lookup_service_;
+  mojo::Remote<mojom::blink::AndroidFontLookup> android_font_lookup_service_;
+  WTF::Deque<NotifyFontUniqueNameLookupReady> pending_callbacks_;
+  base::Optional<bool> sync_available_;
+  base::Optional<Vector<String>> queryable_fonts_;
+
+  DISALLOW_COPY_AND_ASSIGN(FontUniqueNameLookupAndroid);
+};
+
+}  // namespace blink
+
+#endif
diff --git a/third_party/blink/renderer/platform/fonts/bitmap_glyphs_blacklist.cc b/third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.cc
similarity index 64%
rename from third_party/blink/renderer/platform/fonts/bitmap_glyphs_blacklist.cc
rename to third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.cc
index 099c3dd9e340..076078f51809 100644
--- a/third_party/blink/renderer/platform/fonts/bitmap_glyphs_blacklist.cc
+++ b/third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.cc
@@ -2,10 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "third_party/blink/renderer/platform/fonts/bitmap_glyphs_blacklist.h"
-#include "third_party/blink/renderer/platform/wtf/assertions.h"
+#include "third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.h"
 
-#include "SkTypeface.h"
+#include "third_party/blink/renderer/platform/wtf/assertions.h"
+#include "third_party/skia/include/core/SkTypeface.h"
 
 namespace blink {
 
@@ -16,17 +16,16 @@ namespace {
 // because they cause issues with uneven spacing when combined with
 // subpixel positioning, see
 // https://bugs.chromium.org/p/chromium/issues/detail?id=707713#c5
-constexpr const char* kBitmapGlyphsBlacklist[] = {"Calibri", "Courier New"};
+constexpr const char* kBitmapGlyphsBlockList[] = {"Calibri", "Courier New"};
 
 }  // namespace
 
-bool BitmapGlyphsBlacklist::AvoidEmbeddedBitmapsForTypeface(
-    SkTypeface* typeface) {
-  CHECK(typeface);
+bool BitmapGlyphsBlockList::ShouldAvoidEmbeddedBitmapsForTypeface(
+    const SkTypeface& typeface) {
   SkString font_family_name;
-  typeface->getFamilyName(&font_family_name);
-  return font_family_name.equals(kBitmapGlyphsBlacklist[0]) ||
-         font_family_name.equals(kBitmapGlyphsBlacklist[1]);
+  typeface.getFamilyName(&font_family_name);
+  return font_family_name.equals(kBitmapGlyphsBlockList[0]) ||
+         font_family_name.equals(kBitmapGlyphsBlockList[1]);
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/bitmap_glyphs_blacklist.h b/third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.h
similarity index 56%
rename from third_party/blink/renderer/platform/fonts/bitmap_glyphs_blacklist.h
rename to third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.h
index 56ef5d6f6755..b8a4621570d0 100644
--- a/third_party/blink/renderer/platform/fonts/bitmap_glyphs_blacklist.h
+++ b/third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.h
@@ -2,20 +2,23 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_BITMAP_GLYPHS_BLACKLIST_H_
-#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_BITMAP_GLYPHS_BLACKLIST_H_
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_BITMAP_GLYPHS_BLOCK_LIST_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_BITMAP_GLYPHS_BLOCK_LIST_H_
 
 #include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
 class SkTypeface;
 
 namespace blink {
 
-class PLATFORM_EXPORT BitmapGlyphsBlacklist {
+class PLATFORM_EXPORT BitmapGlyphsBlockList {
+  STATIC_ONLY(BitmapGlyphsBlockList);
+
  public:
-  static bool AvoidEmbeddedBitmapsForTypeface(SkTypeface*);
+  static bool ShouldAvoidEmbeddedBitmapsForTypeface(const SkTypeface&);
 };
 
 }  // namespace blink
 
-#endif
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_BITMAP_GLYPHS_BLOCK_LIST_H_
diff --git a/third_party/blink/renderer/platform/fonts/bitmap_glyphs_blacklist_test.cc b/third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list_test.cc
similarity index 60%
rename from third_party/blink/renderer/platform/fonts/bitmap_glyphs_blacklist_test.cc
rename to third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list_test.cc
index d735092e1da7..238ccae98f64 100644
--- a/third_party/blink/renderer/platform/fonts/bitmap_glyphs_blacklist_test.cc
+++ b/third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list_test.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "third_party/blink/renderer/platform/fonts/bitmap_glyphs_blacklist.h"
+#include "third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 
 #include "build/build_config.h"
@@ -12,8 +12,8 @@ namespace blink {
 
 #if defined(OS_WIN)
 
-static void TestBitmapGlyphsBlacklisted(AtomicString windows_family_name,
-                                        bool blacklisted_expected) {
+static void TestBitmapGlyphsBlockListed(AtomicString windows_family_name,
+                                        bool block_listed_expected) {
   FontCache* font_cache = FontCache::GetFontCache();
   FontDescription font_description;
   FontFamily font_family;
@@ -24,22 +24,22 @@ static void TestBitmapGlyphsBlacklisted(AtomicString windows_family_name,
   ASSERT_TRUE(simple_font_data);
   const FontPlatformData& font_platform_data = simple_font_data->PlatformData();
   ASSERT_TRUE(font_platform_data.Typeface());
-  ASSERT_EQ(blacklisted_expected,
-            BitmapGlyphsBlacklist::AvoidEmbeddedBitmapsForTypeface(
-                font_platform_data.Typeface()));
+  ASSERT_EQ(block_listed_expected,
+            BitmapGlyphsBlockList::ShouldAvoidEmbeddedBitmapsForTypeface(
+                *font_platform_data.Typeface()));
 }
 
-TEST(BlacklistBitmapGlyphsTest, Simsun) {
-  TestBitmapGlyphsBlacklisted("Simsun", false);
+TEST(BlockListBitmapGlyphsTest, Simsun) {
+  TestBitmapGlyphsBlockListed("Simsun", false);
 }
 
-TEST(BlacklistBitmapGlyphsTest, Arial) {
-  TestBitmapGlyphsBlacklisted("Arial", false);
+TEST(BlockListBitmapGlyphsTest, Arial) {
+  TestBitmapGlyphsBlockListed("Arial", false);
 }
 
-TEST(BlacklistBitmapGlyphsTest, Calibri) {
-  TestBitmapGlyphsBlacklisted("Calibri", true);
+TEST(BlockListBitmapGlyphsTest, Calibri) {
+  TestBitmapGlyphsBlockListed("Calibri", true);
 }
 
 #endif
-}
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/canvas_rotation_in_vertical.h b/third_party/blink/renderer/platform/fonts/canvas_rotation_in_vertical.h
index 62d6bb25c3f7..d081bc5b6e83 100644
--- a/third_party/blink/renderer/platform/fonts/canvas_rotation_in_vertical.h
+++ b/third_party/blink/renderer/platform/fonts/canvas_rotation_in_vertical.h
@@ -7,7 +7,23 @@
 
 namespace blink {
 
-enum class CanvasRotationInVertical : char { kRegular, kRotateCanvasUpright };
+enum class CanvasRotationInVertical : char {
+  kRegular = 0,
+  kRotateCanvasUpright = 1,
+  kOblique = 2,
+  kRotateCanvasUprightOblique = 3,
+};
+
+inline bool IsCanvasRotationInVerticalUpright(CanvasRotationInVertical r) {
+  return static_cast<char>(r) &
+         static_cast<char>(CanvasRotationInVertical::kRotateCanvasUpright);
 }
 
+inline bool IsCanvasRotationOblque(CanvasRotationInVertical r) {
+  return static_cast<char>(r) &
+         static_cast<char>(CanvasRotationInVertical::kOblique);
+}
+
+}  // namespace blink
+
 #endif
diff --git a/third_party/blink/renderer/platform/fonts/cursor_position_test.cc b/third_party/blink/renderer/platform/fonts/cursor_position_test.cc
index 2ffd9a83713b..cddc02f5d8da 100644
--- a/third_party/blink/renderer/platform/fonts/cursor_position_test.cc
+++ b/third_party/blink/renderer/platform/fonts/cursor_position_test.cc
@@ -30,9 +30,10 @@ class CursorPositionTest : public ::testing::Test {
                  int end = -1) {
     FontDescription::VariantLigatures ligatures(
         FontDescription::kEnabledLigaturesState);
-    Font font = CreateTestFont("TestFont",
-                               test::PlatformTestDataPath(font_path[font_name]),
-                               100, &ligatures);
+    Font font = CreateTestFont(
+        "TestFont",
+        test::PlatformTestDataPath(font_path.find(font_name)->value), 100,
+        &ligatures);
     TextRun text_run(
         text, /* xpos */ 0, /* expansion */ 0,
         TextRun::kAllowTrailingExpansion | TextRun::kForbidLeadingExpansion,
@@ -56,9 +57,10 @@ class CursorPositionTest : public ::testing::Test {
                    bool partial) {
     FontDescription::VariantLigatures ligatures(
         FontDescription::kEnabledLigaturesState);
-    Font font = CreateTestFont("TestFont",
-                               test::PlatformTestDataPath(font_path[font_name]),
-                               100, &ligatures);
+    Font font = CreateTestFont(
+        "TestFont",
+        test::PlatformTestDataPath(font_path.find(font_name)->value), 100,
+        &ligatures);
     TextRun text_run(
         text, /* xpos */ 0, /* expansion */ 0,
         TextRun::kAllowTrailingExpansion | TextRun::kForbidLeadingExpansion,
@@ -70,7 +72,7 @@ class CursorPositionTest : public ::testing::Test {
   }
 
  private:
-  std::map<FontName, String> font_path = {
+  HashMap<FontName, String, WTF::IntHash<FontName>> font_path = {
       {ahem, "Ahem.woff"},
       {amiri, "third_party/Amiri/amiri_arabic.woff2"},
       {megalopolis, "third_party/MEgalopolis/MEgalopolisExtra.woff"},
diff --git a/third_party/blink/renderer/platform/fonts/fallback_list_composite_key.h b/third_party/blink/renderer/platform/fonts/fallback_list_composite_key.h
index 06a411740fff..14572e7c17ca 100644
--- a/third_party/blink/renderer/platform/fonts/fallback_list_composite_key.h
+++ b/third_party/blink/renderer/platform/fonts/fallback_list_composite_key.h
@@ -7,7 +7,7 @@
 
 #include "third_party/blink/renderer/platform/fonts/font_cache_key.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/hash_map.h"
 #include "third_party/blink/renderer/platform/wtf/hash_table_deleted_value_type.h"
 
@@ -21,7 +21,7 @@ class FontDescription;
 // TODO(eae,drott): Ideally this should be replaced by a combination of
 // FontDescription and CSSFontSelector.
 struct FallbackListCompositeKey {
-  DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
+  DISALLOW_NEW();
 
  public:
   FallbackListCompositeKey(const FontDescription& font_description)
diff --git a/third_party/blink/renderer/platform/fonts/font.cc b/third_party/blink/renderer/platform/fonts/font.cc
index 140c9e341536..00e0cdb85f3b 100644
--- a/third_party/blink/renderer/platform/fonts/font.cc
+++ b/third_party/blink/renderer/platform/fonts/font.cc
@@ -24,26 +24,24 @@
 
 #include "third_party/blink/renderer/platform/fonts/font.h"
 
+#include "cc/paint/paint_canvas.h"
+#include "cc/paint/paint_flags.h"
 #include "third_party/blink/renderer/platform/fonts/character_range.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
-#include "third_party/blink/renderer/platform/fonts/font_fallback_iterator.h"
 #include "third_party/blink/renderer/platform/fonts/font_fallback_list.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_map.h"
 #include "third_party/blink/renderer/platform/fonts/ng_text_fragment_paint_info.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
 #include "third_party/blink/renderer/platform/fonts/text_run_paint_info.h"
 #include "third_party/blink/renderer/platform/geometry/float_rect.h"
-#include "third_party/blink/renderer/platform/graphics/paint/paint_canvas.h"
-#include "third_party/blink/renderer/platform/graphics/paint/paint_flags.h"
-#include "third_party/blink/renderer/platform/graphics/paint/paint_text_blob.h"
-#include "third_party/blink/renderer/platform/layout_test_support.h"
-#include "third_party/blink/renderer/platform/layout_unit.h"
+#include "third_party/blink/renderer/platform/geometry/layout_unit.h"
 #include "third_party/blink/renderer/platform/text/bidi_resolver.h"
 #include "third_party/blink/renderer/platform/text/character.h"
 #include "third_party/blink/renderer/platform/text/text_run.h"
 #include "third_party/blink/renderer/platform/text/text_run_iterator.h"
-#include "third_party/blink/renderer/platform/transforms/affine_transform.h"
 #include "third_party/blink/renderer/platform/wtf/std_lib_extras.h"
 #include "third_party/blink/renderer/platform/wtf/text/character_names.h"
 #include "third_party/blink/renderer/platform/wtf/text/unicode.h"
@@ -51,79 +49,157 @@
 
 namespace blink {
 
-Font::Font() : can_shape_word_by_word_(0), shape_word_by_word_computed_(0) {}
+namespace {
 
-Font::Font(const FontDescription& fd)
-    : font_description_(fd),
-      can_shape_word_by_word_(0),
-      shape_word_by_word_computed_(0) {}
+FontFallbackMap& GetFontFallbackMap(FontSelector* font_selector) {
+  if (font_selector)
+    return font_selector->GetFontFallbackMap();
+  return FontCache::GetFontCache()->GetFontFallbackMap();
+}
 
-Font::Font(const Font& other)
-    : font_description_(other.font_description_),
-      font_fallback_list_(other.font_fallback_list_),
-      // TODO(yosin): We should have a comment the reason why don't we copy
-      // |m_canShapeWordByWord| and |m_shapeWordByWordComputed| from |other|,
-      // since |operator=()| copies them from |other|.
-      can_shape_word_by_word_(0),
-      shape_word_by_word_computed_(0) {}
+scoped_refptr<FontFallbackList> GetOrCreateFontFallbackList(
+    const FontDescription& font_description,
+    FontSelector* font_selector) {
+  return GetFontFallbackMap(font_selector).Get(font_description);
+}
+
+}  // namespace
+
+Font::Font() = default;
+
+Font::Font(const FontDescription& fd) : font_description_(fd) {}
+
+Font::Font(const FontDescription& font_description, FontSelector* font_selector)
+    : font_description_(font_description),
+      font_fallback_list_(
+          font_selector
+              ? GetOrCreateFontFallbackList(font_description, font_selector)
+              : nullptr) {}
+
+Font::Font(const Font& other) = default;
 
 Font& Font::operator=(const Font& other) {
+  if (this == &other || *this == other)
+    return *this;
+  ReleaseFontFallbackListRef();
   font_description_ = other.font_description_;
   font_fallback_list_ = other.font_fallback_list_;
-  can_shape_word_by_word_ = other.can_shape_word_by_word_;
-  shape_word_by_word_computed_ = other.shape_word_by_word_computed_;
   return *this;
 }
 
+Font::~Font() {
+  ReleaseFontFallbackListRef();
+}
+
+// Ensures that FontFallbackMap only keeps FontFallbackLists that are still in
+// use by at least one Font object. If the last Font releases its reference, we
+// should clear the entry from FontFallbackMap.
+// Note that we must not persist a FontFallbackList reference outside Font.
+void Font::ReleaseFontFallbackListRef() const {
+  if (!font_fallback_list_ || !font_fallback_list_->IsValid() ||
+      !font_fallback_list_->HasFontFallbackMap()) {
+    font_fallback_list_.reset();
+    return;
+  }
+
+  FontFallbackList& list_ref = *font_fallback_list_;
+  // Failing this CHECK causes use-after-free below.
+  CHECK(!list_ref.HasOneRef());
+  font_fallback_list_.reset();
+  if (list_ref.HasOneRef())
+    list_ref.GetFontFallbackMap().Remove(font_description_);
+}
+
+void Font::RevalidateFontFallbackList() const {
+  DCHECK(font_fallback_list_);
+  font_fallback_list_ =
+      font_fallback_list_->GetFontFallbackMap().Get(font_description_);
+}
+
+FontFallbackList* Font::EnsureFontFallbackList() const {
+  if (!font_fallback_list_) {
+    font_fallback_list_ =
+        GetOrCreateFontFallbackList(font_description_, nullptr);
+  }
+  if (!font_fallback_list_->IsValid())
+    RevalidateFontFallbackList();
+  return font_fallback_list_.get();
+}
+
 bool Font::operator==(const Font& other) const {
+  // Two Font objects with the same FontDescription and FontSelector should
+  // always hold reference to the same FontFallbackList object, unless
+  // invalidated.
+  if (font_fallback_list_ && font_fallback_list_->IsValid() &&
+      other.font_fallback_list_ && other.font_fallback_list_->IsValid()) {
+    return font_fallback_list_ == other.font_fallback_list_;
+  }
+
   FontSelector* first =
       font_fallback_list_ ? font_fallback_list_->GetFontSelector() : nullptr;
   FontSelector* second = other.font_fallback_list_
                              ? other.font_fallback_list_->GetFontSelector()
                              : nullptr;
 
-  return first == second && font_description_ == other.font_description_ &&
-         (font_fallback_list_
-              ? font_fallback_list_->FontSelectorVersion()
-              : 0) == (other.font_fallback_list_
-                           ? other.font_fallback_list_->FontSelectorVersion()
-                           : 0) &&
-         (font_fallback_list_ ? font_fallback_list_->Generation() : 0) ==
-             (other.font_fallback_list_
-                  ? other.font_fallback_list_->Generation()
-                  : 0);
-}
-
-void Font::Update(FontSelector* font_selector) const {
-  // FIXME: It is pretty crazy that we are willing to just poke into a RefPtr,
-  // but it ends up being reasonably safe (because inherited fonts in the render
-  // tree pick up the new style anyway. Other copies are transient, e.g., the
-  // state in the GraphicsContext, and won't stick around long enough to get you
-  // in trouble). Still, this is pretty disgusting, and could eventually be
-  // rectified by using RefPtrs for Fonts themselves.
-  if (!font_fallback_list_)
-    font_fallback_list_ = FontFallbackList::Create();
-  font_fallback_list_->Invalidate(font_selector);
+  return first == second && font_description_ == other.font_description_;
 }
 
 namespace {
 
 void DrawBlobs(cc::PaintCanvas* canvas,
-               const PaintFlags& flags,
+               const cc::PaintFlags& flags,
                const ShapeResultBloberizer::BlobBuffer& blobs,
-               const FloatPoint& point) {
+               const FloatPoint& point,
+               cc::NodeId node_id = cc::kInvalidNodeId) {
   for (const auto& blob_info : blobs) {
     DCHECK(blob_info.blob);
-    PaintCanvasAutoRestore auto_restore(canvas, false);
-    if (blob_info.rotation == CanvasRotationInVertical::kRotateCanvasUpright) {
-      canvas->save();
+    cc::PaintCanvasAutoRestore auto_restore(canvas, false);
+    switch (blob_info.rotation) {
+      case CanvasRotationInVertical::kRegular:
+        break;
+      case CanvasRotationInVertical::kRotateCanvasUpright: {
+        canvas->save();
 
-      SkMatrix m;
-      m.setSinCos(-1, 0, point.X(), point.Y());
-      canvas->concat(m);
+        SkMatrix m;
+        m.setSinCos(-1, 0, point.X(), point.Y());
+        canvas->concat(m);
+        break;
+      }
+      case CanvasRotationInVertical::kRotateCanvasUprightOblique: {
+        canvas->save();
+
+        SkMatrix m;
+        m.setSinCos(-1, 0, point.X(), point.Y());
+        // TODO(yosin): We should use angle specified in CSS instead of
+        // constant value -15deg.
+        // Note: We draw glyph in right-top corner upper.
+        // See CSS "transform: skew(0, -15deg)"
+        SkMatrix skewY;
+        constexpr SkScalar kSkewY = -0.2679491924311227;  // tan(-15deg)
+        skewY.setSkew(0, kSkewY, point.X(), point.Y());
+        m.preConcat(skewY);
+        canvas->concat(m);
+        break;
+      }
+      case CanvasRotationInVertical::kOblique: {
+        // TODO(yosin): We should use angle specified in CSS instead of
+        // constant value 15deg.
+        // Note: We draw glyph in right-top corner upper.
+        // See CSS "transform: skew(0, -15deg)"
+        canvas->save();
+        SkMatrix skewX;
+        constexpr SkScalar kSkewX = 0.2679491924311227;  // tan(15deg)
+        skewX.setSkew(kSkewX, 0, point.X(), point.Y());
+        canvas->concat(skewX);
+        break;
+      }
+    }
+    if (node_id != cc::kInvalidNodeId) {
+      canvas->drawTextBlob(blob_info.blob, point.X(), point.Y(), node_id,
+                           flags);
+    } else {
+      canvas->drawTextBlob(blob_info.blob, point.X(), point.Y(), flags);
     }
-
-    canvas->drawTextBlob(blob_info.blob, point.X(), point.Y(), flags);
   }
 }
 
@@ -133,34 +209,54 @@ void Font::DrawText(cc::PaintCanvas* canvas,
                     const TextRunPaintInfo& run_info,
                     const FloatPoint& point,
                     float device_scale_factor,
-                    const PaintFlags& flags) const {
+                    const cc::PaintFlags& flags,
+                    DrawType draw_type) const {
+  DrawText(canvas, run_info, point, device_scale_factor, cc::kInvalidNodeId,
+           flags, draw_type);
+}
+
+void Font::DrawText(cc::PaintCanvas* canvas,
+                    const TextRunPaintInfo& run_info,
+                    const FloatPoint& point,
+                    float device_scale_factor,
+                    cc::NodeId node_id,
+                    const cc::PaintFlags& flags,
+                    DrawType draw_type) const {
   // Don't draw anything while we are using custom fonts that are in the process
   // of loading.
   if (ShouldSkipDrawing())
     return;
 
-  ShapeResultBloberizer bloberizer(*this, device_scale_factor);
   CachingWordShaper word_shaper(*this);
   ShapeResultBuffer buffer;
   word_shaper.FillResultBuffer(run_info, &buffer);
-  bloberizer.FillGlyphs(run_info, buffer);
-  DrawBlobs(canvas, flags, bloberizer.Blobs(), point);
+  ShapeResultBloberizer::FillGlyphs bloberizer(
+      GetFontDescription(), device_scale_factor, run_info, buffer,
+      draw_type == Font::DrawType::kGlyphsOnly
+          ? ShapeResultBloberizer::Type::kNormal
+          : ShapeResultBloberizer::Type::kEmitText);
+  DrawBlobs(canvas, flags, bloberizer.Blobs(), point, node_id);
 }
 
 void Font::DrawText(cc::PaintCanvas* canvas,
                     const NGTextFragmentPaintInfo& text_info,
                     const FloatPoint& point,
                     float device_scale_factor,
-                    const PaintFlags& flags) const {
+                    cc::NodeId node_id,
+                    const cc::PaintFlags& flags,
+                    DrawType draw_type) const {
   // Don't draw anything while we are using custom fonts that are in the process
   // of loading.
   if (ShouldSkipDrawing())
     return;
 
-  ShapeResultBloberizer bloberizer(*this, device_scale_factor);
-  bloberizer.FillGlyphs(text_info.text, text_info.from, text_info.to,
-                        text_info.shape_result);
-  DrawBlobs(canvas, flags, bloberizer.Blobs(), point);
+  ShapeResultBloberizer::FillGlyphsNG bloberizer(
+      GetFontDescription(), device_scale_factor, text_info.text, text_info.from,
+      text_info.to, text_info.shape_result,
+      draw_type == Font::DrawType::kGlyphsOnly
+          ? ShapeResultBloberizer::Type::kNormal
+          : ShapeResultBloberizer::Type::kEmitText);
+  DrawBlobs(canvas, flags, bloberizer.Blobs(), point, node_id);
 }
 
 bool Font::DrawBidiText(cc::PaintCanvas* canvas,
@@ -168,7 +264,8 @@ bool Font::DrawBidiText(cc::PaintCanvas* canvas,
                         const FloatPoint& point,
                         CustomFontNotReadyAction custom_font_not_ready_action,
                         float device_scale_factor,
-                        const PaintFlags& flags) const {
+                        const cc::PaintFlags& flags,
+                        DrawType draw_type) const {
   // Don't draw anything while we are using custom fonts that are in the process
   // of loading, except if the 'force' argument is set to true (in which case it
   // will use a fallback font).
@@ -203,16 +300,21 @@ bool Font::DrawBidiText(cc::PaintCanvas* canvas,
     subrun.SetDirectionalOverride(bidi_run->DirOverride(false));
 
     TextRunPaintInfo subrun_info(subrun);
-    subrun_info.bounds = run_info.bounds;
 
-    ShapeResultBloberizer bloberizer(*this, device_scale_factor);
     ShapeResultBuffer buffer;
     word_shaper.FillResultBuffer(subrun_info, &buffer);
-    float run_width = bloberizer.FillGlyphs(subrun_info, buffer);
+
+    // Fix regression with -ftrivial-auto-var-init=pattern. See
+    // crbug.com/1055652.
+    STACK_UNINITIALIZED ShapeResultBloberizer::FillGlyphs bloberizer(
+        GetFontDescription(), device_scale_factor, subrun_info, buffer,
+        draw_type == Font::DrawType::kGlyphsOnly
+            ? ShapeResultBloberizer::Type::kNormal
+            : ShapeResultBloberizer::Type::kEmitText);
     DrawBlobs(canvas, flags, bloberizer.Blobs(), curr_point);
 
     bidi_run = bidi_run->Next();
-    curr_point.Move(run_width, 0);
+    curr_point.Move(bloberizer.Advance(), 0);
   }
 
   bidi_runs.DeleteRuns();
@@ -224,7 +326,7 @@ void Font::DrawEmphasisMarks(cc::PaintCanvas* canvas,
                              const AtomicString& mark,
                              const FloatPoint& point,
                              float device_scale_factor,
-                             const PaintFlags& flags) const {
+                             const cc::PaintFlags& flags) const {
   if (ShouldSkipDrawing())
     return;
 
@@ -234,11 +336,12 @@ void Font::DrawEmphasisMarks(cc::PaintCanvas* canvas,
   if (!emphasis_glyph_data.font_data)
     return;
 
-  ShapeResultBloberizer bloberizer(*this, device_scale_factor);
   CachingWordShaper word_shaper(*this);
   ShapeResultBuffer buffer;
   word_shaper.FillResultBuffer(run_info, &buffer);
-  bloberizer.FillTextEmphasisGlyphs(run_info, emphasis_glyph_data, buffer);
+  ShapeResultBloberizer::FillTextEmphasisGlyphs bloberizer(
+      GetFontDescription(), device_scale_factor, run_info, buffer,
+      emphasis_glyph_data);
   DrawBlobs(canvas, flags, bloberizer.Blobs(), point);
 }
 
@@ -247,7 +350,7 @@ void Font::DrawEmphasisMarks(cc::PaintCanvas* canvas,
                              const AtomicString& mark,
                              const FloatPoint& point,
                              float device_scale_factor,
-                             const PaintFlags& flags) const {
+                             const cc::PaintFlags& flags) const {
   if (ShouldSkipDrawing())
     return;
 
@@ -256,15 +359,27 @@ void Font::DrawEmphasisMarks(cc::PaintCanvas* canvas,
   if (!emphasis_glyph_data.font_data)
     return;
 
-  ShapeResultBloberizer bloberizer(*this, device_scale_factor);
-  // TODO(layout-dev): This should either not take a direction argument or we
-  // need to plumb the proper one through. I don't think we need it.
-  bloberizer.FillTextEmphasisGlyphs(
-      text_info.text, TextDirection::kLtr, text_info.from, text_info.to,
-      emphasis_glyph_data, text_info.shape_result);
+  ShapeResultBloberizer::FillTextEmphasisGlyphsNG bloberizer(
+      GetFontDescription(), device_scale_factor, text_info.text, text_info.from,
+      text_info.to, text_info.shape_result, emphasis_glyph_data);
   DrawBlobs(canvas, flags, bloberizer.Blobs(), point);
 }
 
+FloatRect Font::TextInkBounds(const NGTextFragmentPaintInfo& text_info) const {
+  // No need to compute bounds if using custom fonts that are in the process
+  // of loading as it won't be painted.
+  if (ShouldSkipDrawing())
+    return FloatRect();
+
+  // NOTE(eae): We could use the SkTextBlob::bounds API [1] however by default
+  // itreturns conservative bounds (rather than tight bounds) which are
+  // unsuitablefor our needs.If we could get the tight bounds from Skia that
+  // would be quite a bit faster than the two-stage approach employed by the
+  // ShapeResultView::ComputeInkBounds method.
+  // 1: https://skia.org/user/api/SkTextBlob_Reference#SkTextBlob_bounds
+  return text_info.shape_result->ComputeInkBounds();
+}
+
 float Font::Width(const TextRun& run,
                   HashSet<const SimpleFontData*>* fallback_fonts,
                   FloatRect* glyph_bounds) const {
@@ -289,21 +404,20 @@ unsigned InterceptsFromBlobs(const ShapeResultBloberizer::BlobBuffer& blobs,
     // for a change in font. A TextBlob can contain runs with differing fonts
     // and the getTextBlobIntercepts method handles multiple fonts for us. For
     // upright in vertical blobs we currently have to bail, see crbug.com/655154
-    if (blob_info.rotation == CanvasRotationInVertical::kRotateCanvasUpright)
+    if (IsCanvasRotationInVerticalUpright(blob_info.rotation))
       continue;
 
     SkScalar* offset_intercepts_buffer = nullptr;
     if (intercepts_buffer)
       offset_intercepts_buffer = &intercepts_buffer[num_intervals];
-    num_intervals +=
-        paint.getTextBlobIntercepts(blob_info.blob->ToSkTextBlob().get(),
-                                    bounds_array, offset_intercepts_buffer);
+    num_intervals += blob_info.blob->getIntercepts(
+        bounds_array, offset_intercepts_buffer, &paint);
   }
   return num_intervals;
 }
 
 void GetTextInterceptsInternal(const ShapeResultBloberizer::BlobBuffer& blobs,
-                               const PaintFlags& flags,
+                               const cc::PaintFlags& flags,
                                const std::tuple<float, float>& bounds,
                                Vector<Font::TextIntercept>& intercepts) {
   // Get the number of intervals, without copying the actual values by
@@ -324,34 +438,34 @@ void GetTextInterceptsInternal(const ShapeResultBloberizer::BlobBuffer& blobs,
 
 void Font::GetTextIntercepts(const TextRunPaintInfo& run_info,
                              float device_scale_factor,
-                             const PaintFlags& flags,
+                             const cc::PaintFlags& flags,
                              const std::tuple<float, float>& bounds,
                              Vector<TextIntercept>& intercepts) const {
   if (ShouldSkipDrawing())
     return;
 
-  ShapeResultBloberizer bloberizer(
-      *this, device_scale_factor, ShapeResultBloberizer::Type::kTextIntercepts);
   CachingWordShaper word_shaper(*this);
   ShapeResultBuffer buffer;
   word_shaper.FillResultBuffer(run_info, &buffer);
-  bloberizer.FillGlyphs(run_info, buffer);
+  ShapeResultBloberizer::FillGlyphs bloberizer(
+      GetFontDescription(), device_scale_factor, run_info, buffer,
+      ShapeResultBloberizer::Type::kTextIntercepts);
 
   GetTextInterceptsInternal(bloberizer.Blobs(), flags, bounds, intercepts);
 }
 
 void Font::GetTextIntercepts(const NGTextFragmentPaintInfo& text_info,
                              float device_scale_factor,
-                             const PaintFlags& flags,
+                             const cc::PaintFlags& flags,
                              const std::tuple<float, float>& bounds,
                              Vector<TextIntercept>& intercepts) const {
   if (ShouldSkipDrawing())
     return;
 
-  ShapeResultBloberizer bloberizer(
-      *this, device_scale_factor, ShapeResultBloberizer::Type::kTextIntercepts);
-  bloberizer.FillGlyphs(text_info.text, text_info.from, text_info.to,
-                        text_info.shape_result);
+  ShapeResultBloberizer::FillGlyphsNG bloberizer(
+      GetFontDescription(), device_scale_factor, text_info.text, text_info.from,
+      text_info.to, text_info.shape_result,
+      ShapeResultBloberizer::Type::kTextIntercepts);
 
   GetTextInterceptsInternal(bloberizer.Blobs(), flags, bounds, intercepts);
 }
@@ -366,7 +480,7 @@ static inline FloatRect PixelSnappedSelectionRect(FloatRect rect) {
 
 FloatRect Font::SelectionRectForText(const TextRun& run,
                                      const FloatPoint& point,
-                                     int height,
+                                     float height,
                                      int from,
                                      int to) const {
   to = (to == -1 ? run.length() : to);
@@ -380,14 +494,6 @@ FloatRect Font::SelectionRectForText(const TextRun& run,
       FloatRect(point.X() + range.start, point.Y(), range.Width(), height));
 }
 
-FloatRect Font::BoundingBox(const TextRun& run, int from, int to) const {
-  to = (to == -1 ? run.length() : to);
-  FontCachePurgePreventer purge_preventer;
-  CachingWordShaper shaper(*this);
-  CharacterRange range = shaper.GetCharacterRange(run, from, to);
-  return FloatRect(range.start, -range.ascent, range.Width(), range.Height());
-}
-
 int Font::OffsetForPosition(const TextRun& run,
                             float x_float,
                             IncludePartialGlyphsOption partial_glyphs,
@@ -398,31 +504,15 @@ int Font::OffsetForPosition(const TextRun& run,
 }
 
 ShapeCache* Font::GetShapeCache() const {
-  return font_fallback_list_->GetShapeCache(font_description_);
+  return EnsureFontFallbackList()->GetShapeCache(font_description_);
 }
 
 bool Font::CanShapeWordByWord() const {
-  if (!shape_word_by_word_computed_) {
-    can_shape_word_by_word_ = ComputeCanShapeWordByWord();
-    shape_word_by_word_computed_ = true;
-  }
-  return can_shape_word_by_word_;
-};
-
-bool Font::ComputeCanShapeWordByWord() const {
-  if (!GetFontDescription().GetTypesettingFeatures())
-    return true;
-
-  if (!PrimaryFont())
-    return false;
-
-  const FontPlatformData& platform_data = PrimaryFont()->PlatformData();
-  TypesettingFeatures features = GetFontDescription().GetTypesettingFeatures();
-  return !platform_data.HasSpaceInLigaturesOrKerning(features);
-};
+  return EnsureFontFallbackList()->CanShapeWordByWord(GetFontDescription());
+}
 
 void Font::ReportNotDefGlyph() const {
-  FontSelector* fontSelector = font_fallback_list_->GetFontSelector();
+  FontSelector* fontSelector = EnsureFontFallbackList()->GetFontSelector();
   // We have a few non-DOM usages of Font code, for example in DragImage::Create
   // and in EmbeddedObjectPainter::paintReplaced. In those cases, we can't
   // retrieve a font selector as our connection to a Document object to report
@@ -431,6 +521,17 @@ void Font::ReportNotDefGlyph() const {
     fontSelector->ReportNotDefGlyph();
 }
 
+void Font::ReportEmojiSegmentGlyphCoverage(unsigned num_clusters,
+                                           unsigned num_broken_clusters) const {
+  FontSelector* fontSelector = EnsureFontFallbackList()->GetFontSelector();
+  // See ReportNotDefGlyph(), sometimes no fontSelector is available in non-DOM
+  // usages of Font.
+  if (fontSelector) {
+    fontSelector->ReportEmojiSegmentGlyphCoverage(num_clusters,
+                                                  num_broken_clusters);
+  }
+}
+
 void Font::WillUseFontData(const String& text) const {
   const FontFamily& family = GetFontDescription().Family();
   if (font_fallback_list_ && font_fallback_list_->GetFontSelector() &&
@@ -439,12 +540,6 @@ void Font::WillUseFontData(const String& text) const {
         GetFontDescription(), family.Family(), text);
 }
 
-scoped_refptr<FontFallbackIterator> Font::CreateFontFallbackIterator(
-    FontFallbackPriority fallback_priority) const {
-  return FontFallbackIterator::Create(font_description_, font_fallback_list_,
-                                      fallback_priority);
-}
-
 GlyphData Font::GetEmphasisMarkGlyphData(const AtomicString& mark) const {
   if (mark.IsEmpty())
     return GlyphData();
@@ -507,6 +602,12 @@ Vector<CharacterRange> Font::IndividualCharacterRanges(
   return ranges;
 }
 
+Vector<double> Font::IndividualCharacterAdvances(const TextRun& run) const {
+  FontCachePurgePreventer purge_preventer;
+  CachingWordShaper shaper(*this);
+  return shaper.IndividualCharacterAdvances(run);
+}
+
 void Font::ExpandRangeToIncludePartialGlyphs(const TextRun& text_run,
                                              int* from,
                                              int* to) const {
@@ -519,6 +620,24 @@ void Font::ExpandRangeToIncludePartialGlyphs(const TextRun& text_run,
   buffer.ExpandRangeToIncludePartialGlyphs(from, to);
 }
 
+float Font::TabWidth(const SimpleFontData* font_data,
+                     const TabSize& tab_size,
+                     float position) const {
+  float base_tab_width = TabWidth(font_data, tab_size);
+  if (!base_tab_width)
+    return GetFontDescription().LetterSpacing();
+
+  float distance_to_tab_stop = base_tab_width - fmodf(position, base_tab_width);
+
+  // Let the minimum width be the half of the space width so that it's always
+  // recognizable.  if the distance to the next tab stop is less than that,
+  // advance an additional tab stop.
+  if (distance_to_tab_stop < font_data->SpaceWidth() / 2)
+    distance_to_tab_stop += base_tab_width;
+
+  return distance_to_tab_stop;
+}
+
 LayoutUnit Font::TabWidth(const TabSize& tab_size, LayoutUnit position) const {
   const SimpleFontData* font_data = PrimaryFont();
   if (!font_data)
@@ -539,10 +658,6 @@ LayoutUnit Font::TabWidth(const TabSize& tab_size, LayoutUnit position) const {
   return distance_to_tab_stop;
 }
 
-bool Font::LoadingCustomFonts() const {
-  return font_fallback_list_ && font_fallback_list_->LoadingCustomFonts();
-}
-
 bool Font::IsFallbackValid() const {
   return !font_fallback_list_ || font_fallback_list_->IsValid();
 }
diff --git a/third_party/blink/renderer/platform/fonts/font.h b/third_party/blink/renderer/platform/fonts/font.h
index de3a27cbd69d..98a781d71b4d 100644
--- a/third_party/blink/renderer/platform/fonts/font.h
+++ b/third_party/blink/renderer/platform/fonts/font.h
@@ -25,15 +25,17 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_H_
 
+#include "cc/paint/node_id.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_iterator.h"
 #include "third_party/blink/renderer/platform/fonts/font_fallback_list.h"
 #include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
-#include "third_party/blink/renderer/platform/layout_unit.h"
+#include "third_party/blink/renderer/platform/geometry/layout_unit.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/text/tab_size.h"
 #include "third_party/blink/renderer/platform/text/text_direction.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/hash_map.h"
 #include "third_party/blink/renderer/platform/wtf/hash_set.h"
 #include "third_party/blink/renderer/platform/wtf/math_extras.h"
@@ -52,8 +54,6 @@ namespace blink {
 struct CharacterRange;
 class FloatPoint;
 class FloatRect;
-class FontFallbackIterator;
-class FontData;
 class FontSelector;
 class ShapeCache;
 class TextRun;
@@ -65,7 +65,8 @@ class PLATFORM_EXPORT Font {
 
  public:
   Font();
-  Font(const FontDescription&);
+  explicit Font(const FontDescription&);
+  Font(const FontDescription&, FontSelector*);
   ~Font();
 
   Font(const Font&);
@@ -78,28 +79,43 @@ class PLATFORM_EXPORT Font {
     return font_description_;
   }
 
-  void Update(FontSelector*) const;
+  enum class DrawType { kGlyphsOnly, kGlyphsAndClusters };
 
   enum CustomFontNotReadyAction {
     kDoNotPaintIfFontNotReady,
     kUseFallbackIfFontNotReady
   };
+
+  // TODO(layout-dev): Once zoom-for-dsf launches on Mac the device_scale_factor
+  // parameter can be removed from all of these methods.
+  // https://crbug.com/716231
   void DrawText(cc::PaintCanvas*,
                 const TextRunPaintInfo&,
                 const FloatPoint&,
                 float device_scale_factor,
-                const cc::PaintFlags&) const;
+                const cc::PaintFlags&,
+                DrawType = DrawType::kGlyphsOnly) const;
+  void DrawText(cc::PaintCanvas*,
+                const TextRunPaintInfo&,
+                const FloatPoint&,
+                float device_scale_factor,
+                cc::NodeId node_id,
+                const cc::PaintFlags&,
+                DrawType = DrawType::kGlyphsOnly) const;
   void DrawText(cc::PaintCanvas*,
                 const NGTextFragmentPaintInfo&,
                 const FloatPoint&,
                 float device_scale_factor,
-                const cc::PaintFlags&) const;
+                cc::NodeId node_id,
+                const cc::PaintFlags&,
+                DrawType = DrawType::kGlyphsOnly) const;
   bool DrawBidiText(cc::PaintCanvas*,
                     const TextRunPaintInfo&,
                     const FloatPoint&,
                     CustomFontNotReadyAction,
                     float device_scale_factor,
-                    const cc::PaintFlags&) const;
+                    const cc::PaintFlags&,
+                    DrawType = DrawType::kGlyphsOnly) const;
   void DrawEmphasisMarks(cc::PaintCanvas*,
                          const TextRunPaintInfo&,
                          const AtomicString& mark,
@@ -113,6 +129,8 @@ class PLATFORM_EXPORT Font {
                          float device_scale_factor,
                          const cc::PaintFlags&) const;
 
+  FloatRect TextInkBounds(const NGTextFragmentPaintInfo&) const;
+
   struct TextIntercept {
     float begin_, end_;
   };
@@ -147,15 +165,19 @@ class PLATFORM_EXPORT Font {
                         BreakGlyphsOption) const;
   FloatRect SelectionRectForText(const TextRun&,
                                  const FloatPoint&,
-                                 int h,
+                                 float height,
                                  int from = 0,
                                  int to = -1) const;
-  FloatRect BoundingBox(const TextRun&, int from = 0, int to = -1) const;
   CharacterRange GetCharacterRange(const TextRun&,
                                    unsigned from,
                                    unsigned to) const;
   Vector<CharacterRange> IndividualCharacterRanges(const TextRun&) const;
 
+  // Returns a vector of same size as TextRun.length() with advances measured
+  // in pixels from the left bounding box of the full TextRun to the left bound
+  // of the glyph rendered by each character. Values should always be positive.
+  Vector<double> IndividualCharacterAdvances(const TextRun&) const;
+
   void ExpandRangeToIncludePartialGlyphs(const TextRun&,
                                          int* from,
                                          int* to) const;
@@ -166,6 +188,10 @@ class PLATFORM_EXPORT Font {
     return (PrimaryFont() ? PrimaryFont()->SpaceWidth() : 0) +
            GetFontDescription().LetterSpacing();
   }
+
+  // Compute the base tab width; the width when its position is zero.
+  float TabWidth(const SimpleFontData*, const TabSize&) const;
+  // Compute the tab width for the specified |position|.
   float TabWidth(const SimpleFontData*, const TabSize&, float position) const;
   float TabWidth(const TabSize& tab_size, float position) const {
     return TabWidth(PrimaryFont(), tab_size, position);
@@ -180,7 +206,6 @@ class PLATFORM_EXPORT Font {
   // loaded. This *should* not happen but in reality it does ever now and then
   // when, for whatever reason, the last resort font cannot be loaded.
   const SimpleFontData* PrimaryFont() const;
-  const FontData* FontDataAt(unsigned) const;
 
   // Access the shape cache associated with this particular font object.
   // Should *not* be retained across layout calls as it may become invalid.
@@ -192,53 +217,57 @@ class PLATFORM_EXPORT Font {
   bool CanShapeWordByWord() const;
 
   void SetCanShapeWordByWordForTesting(bool b) {
-    can_shape_word_by_word_ = b;
-    shape_word_by_word_computed_ = true;
+    EnsureFontFallbackList()->SetCanShapeWordByWordForTesting(b);
   }
 
   void ReportNotDefGlyph() const;
 
+  void ReportEmojiSegmentGlyphCoverage(unsigned num_clusters,
+                                       unsigned num_broken_clusters) const;
+
  private:
   enum ForTextEmphasisOrNot { kNotForTextEmphasis, kForTextEmphasis };
 
   GlyphData GetEmphasisMarkGlyphData(const AtomicString&) const;
 
-  bool ComputeCanShapeWordByWord() const;
-
  public:
   FontSelector* GetFontSelector() const;
-  scoped_refptr<FontFallbackIterator> CreateFontFallbackIterator(
-      FontFallbackPriority) const;
+  FontFallbackIterator CreateFontFallbackIterator(
+      FontFallbackPriority fallback_priority) const {
+    EnsureFontFallbackList();
+    return FontFallbackIterator(font_description_, font_fallback_list_,
+                                fallback_priority);
+  }
 
   void WillUseFontData(const String& text) const;
 
-  bool LoadingCustomFonts() const;
   bool IsFallbackValid() const;
 
- private:
   bool ShouldSkipDrawing() const {
-    return font_fallback_list_ && font_fallback_list_->ShouldSkipDrawing();
+    if (!font_fallback_list_)
+      return false;
+    return EnsureFontFallbackList()->ShouldSkipDrawing();
   }
 
+  // Returns true if any of the matched @font-face rules has set a
+  // advance-override value.
+  bool HasAdvanceOverride() const {
+    return font_fallback_list_ && font_fallback_list_->HasAdvanceOverride();
+  }
+
+ private:
+  // TODO(xiaochengh): The function not only initializes null FontFallbackList,
+  // but also syncs invalid FontFallbackList. Rename it for better readability.
+  FontFallbackList* EnsureFontFallbackList() const;
+  void RevalidateFontFallbackList() const;
+  void ReleaseFontFallbackListRef() const;
+
   FontDescription font_description_;
   mutable scoped_refptr<FontFallbackList> font_fallback_list_;
-  mutable unsigned can_shape_word_by_word_ : 1;
-  mutable unsigned shape_word_by_word_computed_ : 1;
-
-  // For m_fontDescription & m_fontFallbackList access.
-  friend class CachingWordShaper;
 };
 
-inline Font::~Font() = default;
-
 inline const SimpleFontData* Font::PrimaryFont() const {
-  DCHECK(font_fallback_list_);
-  return font_fallback_list_->PrimarySimpleFontData(font_description_);
-}
-
-inline const FontData* Font::FontDataAt(unsigned index) const {
-  DCHECK(font_fallback_list_);
-  return font_fallback_list_->FontDataAt(font_description_, index);
+  return EnsureFontFallbackList()->PrimarySimpleFontData(font_description_);
 }
 
 inline FontSelector* Font::GetFontSelector() const {
@@ -246,22 +275,11 @@ inline FontSelector* Font::GetFontSelector() const {
 }
 
 inline float Font::TabWidth(const SimpleFontData* font_data,
-                            const TabSize& tab_size,
-                            float position) const {
+                            const TabSize& tab_size) const {
   if (!font_data)
     return GetFontDescription().LetterSpacing();
   float base_tab_width = tab_size.GetPixelSize(font_data->SpaceWidth());
-  if (!base_tab_width)
-    return GetFontDescription().LetterSpacing();
-  float distance_to_tab_stop = base_tab_width - fmodf(position, base_tab_width);
-
-  // Let the minimum width be the half of the space width so that it's always
-  // recognizable.  if the distance to the next tab stop is less than that,
-  // advance an additional tab stop.
-  if (distance_to_tab_stop < font_data->SpaceWidth() / 2)
-    distance_to_tab_stop += base_tab_width;
-
-  return distance_to_tab_stop;
+  return base_tab_width ? base_tab_width : GetFontDescription().LetterSpacing();
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.cc b/third_party/blink/renderer/platform/fonts/font_cache.cc
index ac44cca505d4..df794d75c13d 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/font_cache.cc
@@ -33,8 +33,10 @@
 #include <memory>
 
 #include "base/debug/alias.h"
+#include "base/feature_list.h"
 #include "base/memory/ptr_util.h"
 #include "base/trace_event/process_memory_dump.h"
+#include "base/trace_event/trace_event.h"
 #include "build/build_config.h"
 #include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/renderer/platform/font_family_names.h"
@@ -43,13 +45,15 @@
 #include "third_party/blink/renderer/platform/fonts/font_cache_key.h"
 #include "third_party/blink/renderer/platform/fonts/font_data_cache.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_map.h"
 #include "third_party/blink/renderer/platform/fonts/font_global_context.h"
 #include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
 #include "third_party/blink/renderer/platform/fonts/font_smoothing_mode.h"
+#include "third_party/blink/renderer/platform/fonts/font_unique_name_lookup.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_cache.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
 #include "third_party/blink/renderer/platform/fonts/text_rendering_mode.h"
-#include "third_party/blink/renderer/platform/histogram.h"
+#include "third_party/blink/renderer/platform/instrumentation/histogram.h"
 #include "third_party/blink/renderer/platform/instrumentation/tracing/web_memory_allocator_dump.h"
 #include "third_party/blink/renderer/platform/instrumentation/tracing/web_process_memory_dump.h"
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
@@ -61,8 +65,19 @@
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 #include "ui/gfx/font_list.h"
 
+#if defined(OS_WIN)
+#include "third_party/skia/include/ports/SkTypeface_win.h"
+#endif
+
 namespace blink {
 
+namespace {
+const base::Feature kFontCacheNoSizeInKey{"FontCacheNoSizeInKey",
+                                          base::FEATURE_DISABLED_BY_DEFAULT};
+}
+
+const char kColorEmojiLocale[] = "und-Zsye";
+
 SkFontMgr* FontCache::static_font_manager_ = nullptr;
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS)
@@ -75,24 +90,41 @@ bool FontCache::lcd_text_enabled_ = false;
 bool FontCache::use_skia_font_fallback_ = false;
 #endif  // defined(OS_WIN)
 
-FontCache* FontCache::GetFontCache() {
-  return &FontGlobalContext::GetFontCache();
+FontCache* FontCache::GetFontCache(CreateIfNeeded create) {
+  return FontGlobalContext::GetFontCache(create);
 }
 
-#if !defined(OS_WIN)
 FontCache::FontCache()
-    : purge_prevent_count_(0), font_manager_(sk_ref_sp(static_font_manager_)) {}
-#endif  // !defined(OS_WIN) && !defined(OS_LINUX)
+    : no_size_in_key_(base::FeatureList::IsEnabled(kFontCacheNoSizeInKey)),
+      purge_prevent_count_(0),
+      font_manager_(sk_ref_sp(static_font_manager_)),
+      font_size_limit_(std::nextafter(
+          (static_cast<float>(std::numeric_limits<unsigned>::max()) - 2.f) /
+              static_cast<float>(blink::FontCacheKey::PrecisionMultiplier()),
+          0.f)) {
+#if defined(OS_WIN)
+  if (!font_manager_) {
+    // This code path is only for unit tests. This SkFontMgr does not work in
+    // sandboxed environments, but injecting this initialization code to all
+    // unit tests isn't easy.
+    font_manager_ = SkFontMgr_New_DirectWrite();
+    // Set |is_test_font_mgr_| to capture if this is not happening in the
+    // production code. crbug.com/561873
+    is_test_font_mgr_ = true;
+  }
+  DCHECK(font_manager_.get());
+#endif
+}
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MAC)
 FontPlatformData* FontCache::SystemFontPlatformData(
     const FontDescription& font_description) {
   const AtomicString& family = FontCache::SystemFontFamily();
-#if defined(OS_LINUX)
-  if (family.IsEmpty() || family == FontFamilyNames::system_ui)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+  if (family.IsEmpty() || family == font_family_names::kSystemUi)
     return nullptr;
 #else
-  DCHECK(!family.IsEmpty() && family != FontFamilyNames::system_ui);
+  DCHECK(!family.IsEmpty() && family != font_family_names::kSystemUi);
 #endif
   return GetFontPlatformData(font_description, FontFaceCreationParams(family),
                              AlternateFontName::kNoAlternate);
@@ -103,34 +135,55 @@ FontPlatformData* FontCache::GetFontPlatformData(
     const FontDescription& font_description,
     const FontFaceCreationParams& creation_params,
     AlternateFontName alternate_font_name) {
+  TRACE_EVENT0("fonts", "FontCache::GetFontPlatformData");
+
   if (!platform_init_) {
     platform_init_ = true;
     PlatformInit();
   }
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MAC)
   if (creation_params.CreationType() == kCreateFontByFamily &&
-      creation_params.Family() == FontFamilyNames::system_ui) {
+      creation_params.Family() == font_family_names::kSystemUi) {
     return SystemFontPlatformData(font_description);
   }
 #endif
 
   float size = font_description.EffectiveFontSize();
+  size = std::min(size, font_size_limit_);
+
   unsigned rounded_size = size * FontCacheKey::PrecisionMultiplier();
-  FontCacheKey key = font_description.CacheKey(creation_params);
+
+  // Assert that the computed hash map key rounded_size value does not hit
+  // the empty (max()) or deleted (max()-1) sentinel values of the hash map,
+  // compare UnsignedWithZeroKeyHashTraits() in hash_traits.h.
+  DCHECK_LT(rounded_size, std::numeric_limits<unsigned>::max() - 1);
+  // Assert that rounded_size was not reset to 0 due to an integer overflow,
+  // i.e. if size was non-zero, rounded_size can't be zero, but if size was 0,
+  // it may be 0.
+  DCHECK_EQ(!!size, !!rounded_size);
+
+  bool is_unique_match =
+      alternate_font_name == AlternateFontName::kLocalUniqueFace;
+  FontCacheKey key =
+      font_description.CacheKey(creation_params, is_unique_match);
+  DCHECK(!key.IsHashTableDeletedValue());
+
+  if (no_size_in_key_) {
+    // Clear font size from they key. Size is not required in the primary key
+    // because per-size FontPlatformData are held in a nested map.
+    key.ClearFontSize();
+  }
 
   // Remove the font size from the cache key, and handle the font size
   // separately in the inner HashMap. So that different size of FontPlatformData
   // can share underlying SkTypeface.
-  if (RuntimeEnabledFeatures::FontCacheScalingEnabled())
-    key.ClearFontSize();
-
   FontPlatformData* result;
   bool found_result;
 
   {
     // addResult's scope must end before we recurse for alternate family names
-    // below, to avoid trigering its dtor hash-changed asserts.
+    // below, to avoid triggering its dtor hash-changed asserts.
     SizedFontPlatformDataSet* sized_fonts =
         &font_platform_data_cache_.insert(key, SizedFontPlatformDataSet())
              .stored_value->value;
@@ -186,7 +239,9 @@ std::unique_ptr<FontPlatformData> FontCache::ScaleFontPlatformData(
     const FontDescription& font_description,
     const FontFaceCreationParams& creation_params,
     float font_size) {
-#if defined(OS_MACOSX)
+  TRACE_EVENT0("fonts,ui", "FontCache::ScaleFontPlatformData");
+
+#if defined(OS_MAC)
   return CreateFontPlatformData(font_description, creation_params, font_size);
 #else
   return std::make_unique<FontPlatformData>(font_platform_data, font_size);
@@ -270,7 +325,7 @@ String FontCache::FirstAvailableOrFirst(const String& families) {
   // only from grd/xtb and all ASCII, and b) at most only a few times per
   // setting change/script.
   return String::FromUTF8(
-      gfx::FontList::FirstAvailableOrFirst(families.Utf8().data()).c_str());
+      gfx::FontList::FirstAvailableOrFirst(families.Utf8().c_str()));
 }
 
 SimpleFontData* FontCache::GetNonRetainedLastResortFallbackFont(
@@ -286,6 +341,8 @@ scoped_refptr<SimpleFontData> FontCache::FallbackFontForCharacter(
     UChar32 lookup_char,
     const SimpleFontData* font_data_to_substitute,
     FontFallbackPriority fallback_priority) {
+  TRACE_EVENT0("fonts", "FontCache::FallbackFontForCharacter");
+
   // In addition to PUA, do not perform fallback for non-characters either. Some
   // of these are sentinel characters to detect encodings and do appear on
   // websites. More details on
@@ -304,6 +361,7 @@ void FontCache::ReleaseFontData(const SimpleFontData* font_data) {
 }
 
 void FontCache::PurgePlatformFontDataCache() {
+  TRACE_EVENT0("fonts,ui", "FontCache::PurgePlatformFontDataCache");
   Vector<FontCacheKey> keys_to_remove;
   keys_to_remove.ReserveInitialCapacity(font_platform_data_cache_.size());
   for (auto& sized_fonts : font_platform_data_cache_) {
@@ -322,6 +380,7 @@ void FontCache::PurgePlatformFontDataCache() {
 }
 
 void FontCache::PurgeFallbackListShaperCache() {
+  TRACE_EVENT0("fonts,ui", "FontCache::PurgeFallbackListShaperCache");
   unsigned items = 0;
   FallbackListShaperCache::iterator iter;
   for (iter = fallback_list_shaper_cache_.begin();
@@ -341,7 +400,7 @@ void FontCache::InvalidateShapeCache() {
 void FontCache::Purge(PurgeSeverity purge_severity) {
   // Ideally we should never be forcing the purge while the
   // FontCachePurgePreventer is in scope, but we call purge() at any timing
-  // via MemoryCoordinator.
+  // via MemoryPressureListenerRegistry.
   if (purge_prevent_count_)
     return;
 
@@ -355,18 +414,20 @@ void FontCache::Purge(PurgeSeverity purge_severity) {
 void FontCache::AddClient(FontCacheClient* client) {
   CHECK(client);
   if (!font_cache_clients_) {
-    font_cache_clients_ = new HeapHashSet<WeakMember<FontCacheClient>>();
-    font_cache_clients_.RegisterAsStaticReference();
+    font_cache_clients_ =
+        MakeGarbageCollected<HeapHashSet<WeakMember<FontCacheClient>>>();
+    LEAK_SANITIZER_IGNORE_OBJECT(&font_cache_clients_);
   }
   DCHECK(!font_cache_clients_->Contains(client));
   font_cache_clients_->insert(client);
 }
 
-unsigned short FontCache::Generation() {
+uint16_t FontCache::Generation() {
   return generation_;
 }
 
 void FontCache::Invalidate() {
+  TRACE_EVENT0("fonts,ui", "FontCache::Invalidate");
   font_platform_data_cache_.clear();
   generation_++;
 
@@ -439,4 +500,47 @@ void FontCache::DumpShapeResultCache(
                                 WTF::Partitions::kAllocatedObjectPoolName);
 }
 
+sk_sp<SkTypeface> FontCache::CreateTypefaceFromUniqueName(
+    const FontFaceCreationParams& creation_params) {
+  FontUniqueNameLookup* unique_name_lookup =
+      FontGlobalContext::Get()->GetFontUniqueNameLookup();
+  DCHECK(unique_name_lookup);
+  sk_sp<SkTypeface> uniquely_identified_font =
+      unique_name_lookup->MatchUniqueName(creation_params.Family());
+  if (uniquely_identified_font) {
+    return uniquely_identified_font;
+  }
+  return nullptr;
+}
+
+// static
+FontCache::Bcp47Vector FontCache::GetBcp47LocaleForRequest(
+    const FontDescription& font_description,
+    FontFallbackPriority fallback_priority) {
+  Bcp47Vector result;
+
+  // Fill in the list of locales in the reverse priority order.
+  // Skia expects the highest array index to be the first priority.
+  const LayoutLocale* content_locale = font_description.Locale();
+  if (const LayoutLocale* han_locale =
+          LayoutLocale::LocaleForHan(content_locale)) {
+    result.push_back(han_locale->LocaleForHanForSkFontMgr());
+  }
+  result.push_back(LayoutLocale::GetDefault().LocaleForSkFontMgr());
+  if (content_locale)
+    result.push_back(content_locale->LocaleForSkFontMgr());
+
+  if (fallback_priority == FontFallbackPriority::kEmojiEmoji)
+    result.push_back(kColorEmojiLocale);
+  return result;
+}
+
+FontFallbackMap& FontCache::GetFontFallbackMap() {
+  if (!font_fallback_map_) {
+    font_fallback_map_ = MakeGarbageCollected<FontFallbackMap>(nullptr);
+    AddClient(font_fallback_map_);
+  }
+  return *font_fallback_map_;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.h b/third_party/blink/renderer/platform/fonts/font_cache.h
index 81020921035a..e87551ae4096 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.h
+++ b/third_party/blink/renderer/platform/fonts/font_cache.h
@@ -33,9 +33,11 @@
 #include <limits.h>
 
 #include <memory>
+#include <string>
 
 #include "base/memory/scoped_refptr.h"
 #include "build/build_config.h"
+#include "mojo/public/cpp/bindings/remote.h"
 #include "third_party/blink/renderer/platform/fonts/fallback_list_composite_key.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache_client.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache_key.h"
@@ -45,17 +47,26 @@
 #include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_cache.h"
 #include "third_party/blink/renderer/platform/heap/heap_allocator.h"
+#include "third_party/blink/renderer/platform/heap/persistent.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/forward.h"
 #include "third_party/blink/renderer/platform/wtf/hash_map.h"
 #include "third_party/blink/renderer/platform/wtf/std_lib_extras.h"
-#include "third_party/blink/renderer/platform/wtf/text/cstring.h"
 #include "third_party/blink/renderer/platform/wtf/text/unicode.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 #include "third_party/skia/include/core/SkFontMgr.h"
 #include "third_party/skia/include/core/SkRefCnt.h"
 
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#include "ui/gfx/font_fallback_linux.h"
+#endif
+
+#if defined(OS_WIN)
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+#endif
+
 class SkString;
 class SkTypeface;
 
@@ -67,9 +78,10 @@ class ProcessMemoryDump;
 
 namespace blink {
 
-class FontFaceCreationParams;
-class FontGlobalContext;
 class FontDescription;
+class FontFaceCreationParams;
+class FontFallbackMap;
+class FontGlobalContext;
 class SimpleFontData;
 
 enum class AlternateFontName {
@@ -79,30 +91,35 @@ enum class AlternateFontName {
   kLastResort
 };
 
+enum CreateIfNeeded { kDoNotCreate, kCreate };
+
 typedef HashMap<unsigned,
                 std::unique_ptr<FontPlatformData>,
                 WTF::IntHash<unsigned>,
                 WTF::UnsignedWithZeroKeyHashTraits<unsigned>>
     SizedFontPlatformDataSet;
-typedef HashMap<FontCacheKey,
-                SizedFontPlatformDataSet,
-                FontCacheKeyHash,
-                FontCacheKeyTraits>
-    FontPlatformDataCache;
+typedef HashMap<FontCacheKey, SizedFontPlatformDataSet> FontPlatformDataCache;
 typedef HashMap<FallbackListCompositeKey,
                 std::unique_ptr<ShapeCache>,
                 FallbackListCompositeKeyHash,
                 FallbackListCompositeKeyTraits>
     FallbackListShaperCache;
 
+// "und-Zsye", the special locale for retrieving the color emoji font defined
+// in UTS #51: https://unicode.org/reports/tr51/#Emoji_Script
+extern const char kColorEmojiLocale[];
+
 class PLATFORM_EXPORT FontCache {
   friend class FontCachePurgePreventer;
 
-  WTF_MAKE_NONCOPYABLE(FontCache);
   USING_FAST_MALLOC(FontCache);
 
  public:
-  static FontCache* GetFontCache();
+  // FontCache initialisation on Windows depends on a global FontMgr being
+  // configured through a call from the browser process. CreateIfNeeded helps
+  // avoid early creation of a font cache when these globals have not yet
+  // been set.
+  static FontCache* GetFontCache(CreateIfNeeded = kCreate);
 
   void ReleaseFontData(const SimpleFontData*);
 
@@ -150,7 +167,7 @@ class PLATFORM_EXPORT FontCache {
 
   void AddClient(FontCacheClient*);
 
-  unsigned short Generation();
+  uint16_t Generation();
   void Invalidate();
 
   sk_sp<SkFontMgr> FontManager() { return font_manager_; }
@@ -165,13 +182,13 @@ class PLATFORM_EXPORT FontCache {
   }
 #endif
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MAC)
   static const AtomicString& SystemFontFamily();
 #else
   static const AtomicString& LegacySystemFontFamily();
 #endif
 
-#if !defined(OS_WIN) && !defined(OS_MACOSX)
+#if !defined(OS_MAC)
   static void SetSystemFontFamily(const AtomicString&);
 #endif
 
@@ -186,11 +203,11 @@ class PLATFORM_EXPORT FontCache {
   static void SetLCDTextEnabled(bool enabled) { lcd_text_enabled_ = enabled; }
   static void AddSideloadedFontForTesting(sk_sp<SkTypeface>);
   // Functions to cache and retrieve the system font metrics.
-  static void SetMenuFontMetrics(const wchar_t* family_name,
+  static void SetMenuFontMetrics(const AtomicString& family_name,
                                  int32_t font_height);
-  static void SetSmallCaptionFontMetrics(const wchar_t* family_name,
+  static void SetSmallCaptionFontMetrics(const AtomicString& family_name,
                                          int32_t font_height);
-  static void SetStatusFontMetrics(const wchar_t* family_name,
+  static void SetStatusFontMetrics(const AtomicString& family_name,
                                    int32_t font_height);
   static int32_t MenuFontHeight() { return menu_font_height_; }
   static const AtomicString& MenuFontFamily() {
@@ -207,6 +224,20 @@ class PLATFORM_EXPORT FontCache {
   static void SetUseSkiaFontFallback(bool use_skia_font_fallback) {
     use_skia_font_fallback_ = use_skia_font_fallback;
   }
+
+  // On Windows pre 8.1 establish a connection to the DWriteFontProxy service in
+  // order to retrieve family names for fallback lookup.
+  void EnsureServiceConnected();
+
+  scoped_refptr<SimpleFontData> GetFallbackFamilyNameFromHardcodedChoices(
+      const FontDescription&,
+      UChar32 codepoint,
+      FontFallbackPriority fallback_priority);
+
+  scoped_refptr<SimpleFontData> GetDWriteFallbackFamily(
+      const FontDescription&,
+      UChar32 codepoint,
+      FontFallbackPriority fallback_priority);
 #endif  // defined(OS_WIN)
 
   static void AcceptLanguagesChanged(const String&);
@@ -217,19 +248,11 @@ class PLATFORM_EXPORT FontCache {
       const FontDescription&);
 #endif  // defined(OS_ANDROID)
 
-#if defined(OS_LINUX)
-  struct PlatformFallbackFont {
-    String name;
-    CString filename;
-    int fontconfig_interface_id;
-    int ttc_index;
-    bool is_bold;
-    bool is_italic;
-  };
-  static void GetFontForCharacter(UChar32,
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+  static bool GetFontForCharacter(UChar32,
                                   const char* preferred_locale,
-                                  PlatformFallbackFont*);
-#endif  // defined(OS_LINUX)
+                                  gfx::FallbackFontData*);
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
   scoped_refptr<SimpleFontData> FontDataFromFontPlatformData(
       const FontPlatformData*,
@@ -244,14 +267,27 @@ class PLATFORM_EXPORT FontCache {
   void DumpFontPlatformDataCache(base::trace_event::ProcessMemoryDump*);
   void DumpShapeResultCache(base::trace_event::ProcessMemoryDump*);
 
+  FontFallbackMap& GetFontFallbackMap();
+
   ~FontCache() = default;
 
  private:
+  // BCP47 list used when requesting fallback font for a character.
+  // inlineCapacity is set to 4: the array vector not need to hold more than 4
+  // elements.
+  using Bcp47Vector = WTF::Vector<const char*, 4>;
+
   scoped_refptr<SimpleFontData> PlatformFallbackFontForCharacter(
       const FontDescription&,
       UChar32,
       const SimpleFontData* font_data_to_substitute,
       FontFallbackPriority = FontFallbackPriority::kText);
+  sk_sp<SkTypeface> CreateTypefaceFromUniqueName(
+      const FontFaceCreationParams& creation_params);
+
+  static Bcp47Vector GetBcp47LocaleForRequest(
+      const FontDescription& font_description,
+      FontFallbackPriority fallback_priority);
 
   friend class FontGlobalContext;
   FontCache();
@@ -270,9 +306,9 @@ class PLATFORM_EXPORT FontCache {
       const FontDescription&,
       const FontFaceCreationParams&,
       AlternateFontName = AlternateFontName::kAllowAlternate);
-#if !defined(OS_MACOSX)
+#if !defined(OS_MAC)
   FontPlatformData* SystemFontPlatformData(const FontDescription&);
-#endif  // !defined(OS_MACOSX)
+#endif  // !defined(OS_MAC)
 
   // These methods are implemented by each platform.
   std::unique_ptr<FontPlatformData> CreateFontPlatformData(
@@ -286,20 +322,26 @@ class PLATFORM_EXPORT FontCache {
       const FontFaceCreationParams&,
       float font_size);
 
-  // Implemented on skia platforms.
-  PaintTypeface CreateTypeface(const FontDescription&,
-                               const FontFaceCreationParams&,
-                               CString& name);
+  sk_sp<SkTypeface> CreateTypeface(const FontDescription&,
+                                   const FontFaceCreationParams&,
+                                   std::string& name);
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_FUCHSIA)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
   static AtomicString GetFamilyNameForCharacter(SkFontMgr*,
                                                 UChar32,
                                                 const FontDescription&,
                                                 FontFallbackPriority);
-#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_FUCHSIA)
+#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
 
-  scoped_refptr<SimpleFontData> FallbackOnStandardFontStyle(const FontDescription&,
-                                                     UChar32);
+  scoped_refptr<SimpleFontData> FallbackOnStandardFontStyle(
+      const FontDescription&,
+      UChar32);
+
+  // When true, the font size is removed from primary keys in
+  // |font_platform_data_cache_|. The font size is not necessary in the primary
+  // key, because per-size FontPlatformData are held in a nested map. This is
+  // controlled by a base::Feature to assess impact with an experiment.
+  const bool no_size_in_key_;
 
   // Don't purge if this count is > 0;
   int purge_prevent_count_;
@@ -312,7 +354,7 @@ class PLATFORM_EXPORT FontCache {
 #if defined(OS_WIN)
   static bool antialiased_text_enabled_;
   static bool lcd_text_enabled_;
-  static HashMap<String, sk_sp<SkTypeface>>* sideloaded_fonts_;
+  static HashMap<String, sk_sp<SkTypeface>, CaseFoldingHash>* sideloaded_fonts_;
   // The system font metrics cache.
   static AtomicString* menu_font_family_name_;
   static int32_t menu_font_height_;
@@ -325,37 +367,54 @@ class PLATFORM_EXPORT FontCache {
   // Windows creates an SkFontMgr for unit testing automatically. This flag is
   // to ensure it's not happening in the production from the crash log.
   bool is_test_font_mgr_ = false;
+  mojo::Remote<mojom::blink::DWriteFontProxy> service_;
+  std::unique_ptr<FallbackFamilyStyleCache> fallback_params_cache_;
 #endif  // defined(OS_WIN)
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS)
   static float device_scale_factor_;
 #endif
 
-  unsigned short generation_ = 0;
+  uint16_t generation_ = 0;
   bool platform_init_ = false;
   Persistent<HeapHashSet<WeakMember<FontCacheClient>>> font_cache_clients_;
   FontPlatformDataCache font_platform_data_cache_;
   FallbackListShaperCache fallback_list_shaper_cache_;
   FontDataCache font_data_cache_;
 
+  Persistent<FontFallbackMap> font_fallback_map_;
+
   void PurgePlatformFontDataCache();
   void PurgeFallbackListShaperCache();
 
+  // A maximum float value to which we limit incoming font sizes. This is the
+  // smallest float so that multiplying it by
+  // FontCacheKey::PrecisionMultiplier() is still smaller than
+  // std::numeric_limits<unsigned>::max() - 1 in order to avoid hitting HashMap
+  // sentinel values (placed at std::numeric_limits<unsigned>::max() and
+  // std::numeric_limits<unsigned>::max() - 1) for SizedFontPlatformDataSet and
+  // FontPlatformDataCache.
+  const float font_size_limit_;
+
   friend class SimpleFontData;  // For fontDataFromFontPlatformData
   friend class FontFallbackList;
+
+  DISALLOW_COPY_AND_ASSIGN(FontCache);
 };
 
 class PLATFORM_EXPORT FontCachePurgePreventer {
   USING_FAST_MALLOC(FontCachePurgePreventer);
-  WTF_MAKE_NONCOPYABLE(FontCachePurgePreventer);
 
  public:
   FontCachePurgePreventer() { FontCache::GetFontCache()->DisablePurging(); }
   ~FontCachePurgePreventer() { FontCache::GetFontCache()->EnablePurging(); }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(FontCachePurgePreventer);
 };
 
 AtomicString ToAtomicString(const SkString&);
 
 }  // namespace blink
 
-#endif
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_CACHE_H_
diff --git a/third_party/blink/renderer/platform/fonts/font_cache_client.h b/third_party/blink/renderer/platform/fonts/font_cache_client.h
index d56df8c0c039..89e0da6a85e5 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache_client.h
+++ b/third_party/blink/renderer/platform/fonts/font_cache_client.h
@@ -37,12 +37,12 @@
 namespace blink {
 
 class PLATFORM_EXPORT FontCacheClient
-    : public GarbageCollectedFinalized<FontCacheClient> {
+    : public GarbageCollected<FontCacheClient> {
  public:
   virtual ~FontCacheClient() = default;
 
   virtual void FontCacheInvalidated() = 0;
-  virtual void Trace(blink::Visitor* visitor) {}
+  virtual void Trace(Visitor* visitor) const {}
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_cache_key.h b/third_party/blink/renderer/platform/fonts/font_cache_key.h
index 5c0c209237ad..a860a0ad051e 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache_key.h
+++ b/third_party/blink/renderer/platform/fonts/font_cache_key.h
@@ -31,9 +31,11 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_CACHE_KEY_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_CACHE_KEY_H_
 
+#include <limits>
+
 #include "third_party/blink/renderer/platform/fonts/font_face_creation_params.h"
 #include "third_party/blink/renderer/platform/fonts/opentype/font_settings.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/hash_map.h"
 #include "third_party/blink/renderer/platform/wtf/hash_table_deleted_value_type.h"
 #include "third_party/blink/renderer/platform/wtf/text/atomic_string_hash.h"
@@ -43,58 +45,74 @@ namespace blink {
 
 // Multiplying the floating point size by 100 gives two decimal point
 // precision which should be sufficient.
-static const unsigned kFontSizePrecisionMultiplier = 100;
+static constexpr unsigned kFontSizePrecisionMultiplier = 100;
 
 struct FontCacheKey {
-  DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
+  DISALLOW_NEW();
 
  public:
   FontCacheKey()
       : creation_params_(),
         font_size_(0),
         options_(0),
-        device_scale_factor_(0) {}
+        device_scale_factor_(0),
+        is_unique_match_(false) {}
   FontCacheKey(FontFaceCreationParams creation_params,
                float font_size,
                unsigned options,
                float device_scale_factor,
-               scoped_refptr<FontVariationSettings> variation_settings)
+               scoped_refptr<FontVariationSettings> variation_settings,
+               bool is_unique_match)
       : creation_params_(creation_params),
         font_size_(font_size * kFontSizePrecisionMultiplier),
         options_(options),
         device_scale_factor_(device_scale_factor),
-        variation_settings_(std::move(variation_settings)) {}
+        variation_settings_(std::move(variation_settings)),
+        is_unique_match_(is_unique_match) {}
 
   FontCacheKey(WTF::HashTableDeletedValueType)
-      : font_size_(HashTableDeletedSize()) {}
+      : font_size_(std::numeric_limits<unsigned>::max()),
+        device_scale_factor_(std::numeric_limits<float>::max()) {}
+
+  bool IsHashTableDeletedValue() const {
+    return font_size_ == std::numeric_limits<unsigned>::max() &&
+           device_scale_factor_ == std::numeric_limits<float>::max();
+  }
 
   unsigned GetHash() const {
     // Convert from float with 3 digit precision before hashing.
     unsigned device_scale_factor_hash = device_scale_factor_ * 1000;
-    unsigned hash_codes[5] = {
-        creation_params_.GetHash(), font_size_, options_,
+    unsigned hash_codes[6] = {
+        creation_params_.GetHash(),
+        font_size_,
+        options_,
         device_scale_factor_hash,
-        variation_settings_ ? variation_settings_->GetHash() : 0};
+        variation_settings_ ? variation_settings_->GetHash() : 0,
+        is_unique_match_};
     return StringHasher::HashMemory<sizeof(hash_codes)>(hash_codes);
   }
 
   bool operator==(const FontCacheKey& other) const {
+    bool variation_settings_equal =
+        (!variation_settings_ && !other.variation_settings_) ||
+        (variation_settings_ && other.variation_settings_ &&
+         *variation_settings_ == *other.variation_settings_);
     return creation_params_ == other.creation_params_ &&
            font_size_ == other.font_size_ && options_ == other.options_ &&
            device_scale_factor_ == other.device_scale_factor_ &&
-           variation_settings_ == other.variation_settings_;
+           variation_settings_equal &&
+           is_unique_match_ == other.is_unique_match_;
   }
 
-  bool IsHashTableDeletedValue() const {
-    return font_size_ == HashTableDeletedSize();
-  }
+  bool operator!=(const FontCacheKey& other) const { return !(*this == other); }
 
-  static unsigned PrecisionMultiplier() { return kFontSizePrecisionMultiplier; }
+  static constexpr unsigned PrecisionMultiplier() {
+    return kFontSizePrecisionMultiplier;
+  }
 
   void ClearFontSize() { font_size_ = 0; }
 
  private:
-  static unsigned HashTableDeletedSize() { return 0xFFFFFFFFU; }
 
   FontFaceCreationParams creation_params_;
   unsigned font_size_;
@@ -105,6 +123,7 @@ struct FontCacheKey {
   // device_scale_factor_ to be a part of computing the cache key.
   float device_scale_factor_;
   scoped_refptr<FontVariationSettings> variation_settings_;
+  bool is_unique_match_;
 };
 
 struct FontCacheKeyHash {
@@ -120,8 +139,31 @@ struct FontCacheKeyHash {
 
 struct FontCacheKeyTraits : WTF::SimpleClassHashTraits<FontCacheKey> {
   STATIC_ONLY(FontCacheKeyTraits);
+
+  // std::string's empty state need not be zero in all implementations,
+  // and it is held within FontFaceCreationParams.
+  static const bool kEmptyValueIsZero = false;
 };
 
 }  // namespace blink
 
+namespace WTF {
+template <>
+struct DefaultHash<blink::FontCacheKey> {
+  STATIC_ONLY(DefaultHash);
+  typedef blink::FontCacheKeyHash Hash;
+};
+
+template <>
+struct HashTraits<blink::FontCacheKey>
+    : WTF::SimpleClassHashTraits<blink::FontCacheKey> {
+  STATIC_ONLY(HashTraits);
+
+  // std::string's empty state need not be zero in all implementations,
+  // and it is held within FontFaceCreationParams.
+  static const bool kEmptyValueIsZero = false;
+};
+
+}  // namespace WTF
+
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_CACHE_KEY_H_
diff --git a/third_party/blink/renderer/platform/fonts/font_cache_memory_dump_provider.cc b/third_party/blink/renderer/platform/fonts/font_cache_memory_dump_provider.cc
index b079ea3fa81b..b772fd8f3285 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache_memory_dump_provider.cc
+++ b/third_party/blink/renderer/platform/fonts/font_cache_memory_dump_provider.cc
@@ -18,8 +18,11 @@ bool FontCacheMemoryDumpProvider::OnMemoryDump(
     const base::trace_event::MemoryDumpArgs&,
     base::trace_event::ProcessMemoryDump* memory_dump) {
   DCHECK(IsMainThread());
-  FontCache::GetFontCache()->DumpFontPlatformDataCache(memory_dump);
-  FontCache::GetFontCache()->DumpShapeResultCache(memory_dump);
+  FontCache* cache = FontCache::GetFontCache(kDoNotCreate);
+  if (cache) {
+    cache->DumpFontPlatformDataCache(memory_dump);
+    cache->DumpShapeResultCache(memory_dump);
+  }
   return true;
 }
 
diff --git a/third_party/blink/renderer/platform/fonts/font_cache_memory_dump_provider.h b/third_party/blink/renderer/platform/fonts/font_cache_memory_dump_provider.h
index 12896385fae3..6bd0fb9f878b 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache_memory_dump_provider.h
+++ b/third_party/blink/renderer/platform/fonts/font_cache_memory_dump_provider.h
@@ -5,11 +5,11 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_CACHE_MEMORY_DUMP_PROVIDER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_CACHE_MEMORY_DUMP_PROVIDER_H_
 
+#include "base/macros.h"
 #include "base/trace_event/memory_dump_provider.h"
 #include "base/trace_event/process_memory_dump.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
-#include "third_party/blink/renderer/platform/wtf/noncopyable.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
 namespace blink {
 
@@ -28,7 +28,7 @@ class PLATFORM_EXPORT FontCacheMemoryDumpProvider final
  private:
   FontCacheMemoryDumpProvider() = default;
 
-  WTF_MAKE_NONCOPYABLE(FontCacheMemoryDumpProvider);
+  DISALLOW_COPY_AND_ASSIGN(FontCacheMemoryDumpProvider);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_cache_test.cc b/third_party/blink/renderer/platform/fonts/font_cache_test.cc
index b8b1c50ee643..8eaefc6d110b 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache_test.cc
+++ b/third_party/blink/renderer/platform/fonts/font_cache_test.cc
@@ -4,6 +4,10 @@
 
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 
+#include <unicode/unistr.h>
+#include <string>
+#include <tuple>
+
 #include "build/build_config.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/public/platform/platform.h"
@@ -43,6 +47,57 @@ TEST(FontCache, NoFallbackForPrivateUseArea) {
   }
 }
 
+#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+TEST(FontCache, FallbackForEmojis) {
+  FontCache* font_cache = FontCache::GetFontCache();
+  ASSERT_TRUE(font_cache);
+  FontCachePurgePreventer purge_preventer;
+
+  FontDescription font_description;
+  font_description.SetGenericFamily(FontDescription::kStandardFamily);
+
+  static constexpr char kNotoColorEmoji[] = "Noto Color Emoji";
+
+  // We should use structured binding when it becomes available...
+  for (auto info : {
+           std::pair<UChar32, bool>{U'', true},
+           {U'', true},
+           {U'', false},
+       }) {
+    UChar32 character = info.first;
+    // Set to true if the installed contour fonts support this glyph.
+    bool available_in_contour_font = info.second;
+    std::string character_utf8;
+    icu::UnicodeString(character).toUTF8String(character_utf8);
+
+    {
+      scoped_refptr<SimpleFontData> font_data =
+          font_cache->FallbackFontForCharacter(
+              font_description, character, nullptr,
+              FontFallbackPriority::kEmojiEmoji);
+      EXPECT_EQ(font_data->PlatformData().FontFamilyName(), kNotoColorEmoji)
+          << "Character " << character_utf8
+          << " doesn't match what we expected for kEmojiEmoji.";
+    }
+    {
+      scoped_refptr<SimpleFontData> font_data =
+          font_cache->FallbackFontForCharacter(
+              font_description, character, nullptr,
+              FontFallbackPriority::kEmojiText);
+      if (available_in_contour_font) {
+        EXPECT_NE(font_data->PlatformData().FontFamilyName(), kNotoColorEmoji)
+            << "Character " << character_utf8
+            << " doesn't match what we expected for kEmojiText.";
+      } else {
+        EXPECT_EQ(font_data->PlatformData().FontFamilyName(), kNotoColorEmoji)
+            << "Character " << character_utf8
+            << " doesn't match what we expected for kEmojiText.";
+      }
+    }
+  }
+}
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+
 TEST(FontCache, firstAvailableOrFirst) {
   EXPECT_TRUE(FontCache::FirstAvailableOrFirst("").IsEmpty());
   EXPECT_TRUE(FontCache::FirstAvailableOrFirst(String()).IsEmpty());
@@ -63,7 +118,26 @@ TEST(FontCache, firstAvailableOrFirst) {
             FontCache::FirstAvailableOrFirst(", not exist, not exist"));
 }
 
-#if !defined(OS_MACOSX)
+// https://crbug.com/969402
+TEST(FontCache, getLargerThanMaxUnsignedFont) {
+  FontCache* font_cache = FontCache::GetFontCache();
+  ASSERT_TRUE(font_cache);
+
+  FontDescription font_description;
+  font_description.SetGenericFamily(FontDescription::kStandardFamily);
+  font_description.SetComputedSize(std::numeric_limits<unsigned>::max() + 1.f);
+  FontFaceCreationParams creation_params;
+  scoped_refptr<blink::SimpleFontData> font_data =
+      font_cache->GetFontData(font_description, AtomicString());
+#if !defined(OS_ANDROID) && !defined(OS_MAC) && !defined(OS_WIN)
+  // Unfortunately, we can't ensure a font here since on Android and Mac the
+  // unittests can't access the font configuration. However, this test passes
+  // when it's not crashing in FontCache.
+  EXPECT_TRUE(font_data);
+#endif
+}
+
+#if !defined(OS_MAC)
 TEST(FontCache, systemFont) {
   FontCache::SystemFontFamily();
   // Test the function does not crash. Return value varies by system and config.
diff --git a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
index b02c8ac10757..212ae08ce3cb 100644
--- a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
+++ b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
@@ -37,26 +37,14 @@
 #include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
 #include "third_party/blink/renderer/platform/fonts/opentype/font_format_check.h"
 #include "third_party/blink/renderer/platform/fonts/opentype/font_settings.h"
+#include "third_party/blink/renderer/platform/fonts/opentype/variable_axes_names.h"
 #include "third_party/blink/renderer/platform/fonts/web_font_decoder.h"
 #include "third_party/blink/renderer/platform/fonts/web_font_typeface_factory.h"
-#include "third_party/blink/renderer/platform/graphics/paint/paint_typeface.h"
-#include "third_party/blink/renderer/platform/layout_test_support.h"
-#include "third_party/blink/renderer/platform/shared_buffer.h"
-#include "third_party/skia/include/core/SkStream.h"
+#include "third_party/blink/renderer/platform/wtf/shared_buffer.h"
 #include "third_party/skia/include/core/SkTypeface.h"
 
 namespace blink {
 
-namespace {
-sk_sp<SkFontMgr> FontManagerForSubType(
-    FontFormatCheck::VariableFontSubType font_sub_type) {
-  CHECK_NE(font_sub_type, FontFormatCheck::VariableFontSubType::kNotVariable);
-  if (font_sub_type == FontFormatCheck::VariableFontSubType::kVariableCFF2)
-    return WebFontTypefaceFactory::FreeTypeFontManager();
-  return WebFontTypefaceFactory::FontManagerForVariations();
-}
-}  // namespace
-
 FontCustomPlatformData::FontCustomPlatformData(sk_sp<SkTypeface> typeface,
                                                size_t data_size)
     : base_typeface_(std::move(typeface)), data_size_(data_size) {}
@@ -69,6 +57,7 @@ FontPlatformData FontCustomPlatformData::GetFontPlatformData(
     bool italic,
     const FontSelectionRequest& selection_request,
     const FontSelectionCapabilities& selection_capabilities,
+    const OpticalSizing& optical_sizing,
     FontOrientation orientation,
     const FontVariationSettings* variation_settings) {
   DCHECK(base_typeface_);
@@ -88,40 +77,51 @@ FontPlatformData FontCustomPlatformData::GetFontPlatformData(
   if (font_sub_type ==
           FontFormatCheck::VariableFontSubType::kVariableTrueType ||
       font_sub_type == FontFormatCheck::VariableFontSubType::kVariableCFF2) {
-    Vector<SkFontArguments::Axis, 0> axes;
+    Vector<SkFontArguments::VariationPosition::Coordinate, 0> variation;
 
-    SkFontArguments::Axis weight_axis = {
+    SkFontArguments::VariationPosition::Coordinate weight_coordinate = {
         SkSetFourByteTag('w', 'g', 'h', 't'),
         SkFloatToScalar(selection_capabilities.weight.clampToRange(
             selection_request.weight))};
-    SkFontArguments::Axis width_axis = {
+    SkFontArguments::VariationPosition::Coordinate width_coordinate = {
         SkSetFourByteTag('w', 'd', 't', 'h'),
         SkFloatToScalar(selection_capabilities.width.clampToRange(
             selection_request.width))};
-    SkFontArguments::Axis slant_axis = {
+    // CSS and OpenType have opposite definitions of direction of slant
+    // angle. In OpenType positive values turn counter-clockwise, negative
+    // values clockwise - in CSS positive values are clockwise rotations /
+    // skew. See note in https://drafts.csswg.org/css-fonts/#font-style-prop -
+    // map value from CSS to OpenType here.
+    SkFontArguments::VariationPosition::Coordinate slant_coordinate = {
         SkSetFourByteTag('s', 'l', 'n', 't'),
-        SkFloatToScalar(selection_capabilities.slope.clampToRange(
+        SkFloatToScalar(-selection_capabilities.slope.clampToRange(
             selection_request.slope))};
 
-    axes.push_back(weight_axis);
-    axes.push_back(width_axis);
-    axes.push_back(slant_axis);
+    variation.push_back(weight_coordinate);
+    variation.push_back(width_coordinate);
+    variation.push_back(slant_coordinate);
 
+    bool explicit_opsz_configured = false;
     if (variation_settings && variation_settings->size() < UINT16_MAX) {
-      axes.ReserveCapacity(variation_settings->size() + axes.size());
-      for (size_t i = 0; i < variation_settings->size(); ++i) {
-        SkFontArguments::Axis axis = {
-            AtomicStringToFourByteTag(variation_settings->at(i).Tag()),
-            SkFloatToScalar(variation_settings->at(i).Value())};
-        axes.push_back(axis);
+      variation.ReserveCapacity(variation_settings->size() + variation.size());
+      for (const auto& setting : *variation_settings) {
+        if (setting.Tag() == SkSetFourByteTag('o', 'p', 's', 'z'))
+          explicit_opsz_configured = true;
+        SkFontArguments::VariationPosition::Coordinate setting_coordinate =
+            {setting.Tag(), SkFloatToScalar(setting.Value())};
+        variation.push_back(setting_coordinate);
       }
     }
 
-    sk_sp<SkTypeface> sk_variation_font(
-        FontManagerForSubType(font_sub_type)
-            ->makeFromStream(
-                base_typeface_->openStream(nullptr)->duplicate(),
-                SkFontArguments().setAxes(axes.data(), axes.size())));
+    if (optical_sizing == kAutoOpticalSizing && !explicit_opsz_configured) {
+      SkFontArguments::VariationPosition::Coordinate opsz_coordinate =
+          {SkSetFourByteTag('o', 'p', 's', 'z'), SkFloatToScalar(size)};
+      variation.push_back(opsz_coordinate);
+    }
+
+    SkFontArguments font_args;
+    font_args.setVariationDesignPosition({variation.data(), variation.size()});
+    sk_sp<SkTypeface> sk_variation_font(base_typeface_->makeClone(font_args));
 
     if (sk_variation_font) {
       return_typeface = sk_variation_font;
@@ -134,14 +134,16 @@ FontPlatformData FontCustomPlatformData::GetFontPlatformData(
     }
   }
 
-  // TODO(vmpstr): Handle web fonts PaintTypefaces.
-  PaintTypeface paint_tf = PaintTypeface::FromSkTypeface(return_typeface);
-  return FontPlatformData(std::move(paint_tf), CString(), size,
+  return FontPlatformData(std::move(return_typeface), std::string(), size,
                           bold && !base_typeface_->isBold(),
                           italic && !base_typeface_->isItalic(), orientation);
 }
 
-SkString FontCustomPlatformData::FamilyNameForInspector() const {
+Vector<VariationAxis> FontCustomPlatformData::GetVariationAxes() const {
+  return VariableAxesNames::GetVariationAxes(base_typeface_);
+}
+
+String FontCustomPlatformData::FamilyNameForInspector() const {
   SkTypeface::LocalizedStrings* font_family_iterator =
       base_typeface_->createFamilyNameIterator();
   SkTypeface::LocalizedString localized_string;
@@ -154,7 +156,8 @@ SkString FontCustomPlatformData::FamilyNameForInspector() const {
     }
   }
   font_family_iterator->unref();
-  return localized_string.fString;
+  return String::FromUTF8(localized_string.fString.c_str(),
+                          localized_string.fString.size());
 }
 
 scoped_refptr<FontCustomPlatformData> FontCustomPlatformData::Create(
@@ -184,4 +187,39 @@ bool FontCustomPlatformData::SupportsFormat(const String& format) {
          EqualIgnoringASCIICase(format, "woff2-variations");
 }
 
+bool FontCustomPlatformData::MayBeIconFont() const {
+  if (!may_be_icon_font_computed_) {
+    // We observed that many icon fonts define almost all of their glyphs in the
+    // Unicode Private Use Area, while non-icon fonts rarely use PUA. We use
+    // this as a heuristic to determine if a font is an icon font.
+
+    // We first obtain the list of glyphs mapped from PUA codepoint range:
+    // https://unicode.org/charts/PDF/UE000.pdf
+    // Note: The two supplementary PUA here are too long but not used much by
+    // icon fonts, so we don't include them in this heuristic.
+    wtf_size_t pua_length =
+        kPrivateUseLastCharacter - kPrivateUseFirstCharacter + 1;
+    Vector<SkUnichar> pua_codepoints(pua_length);
+    for (wtf_size_t i = 0; i < pua_length; ++i)
+      pua_codepoints[i] = kPrivateUseFirstCharacter + i;
+
+    Vector<SkGlyphID> glyphs(pua_codepoints.size());
+    base_typeface_->unicharsToGlyphs(pua_codepoints.data(),
+                                     pua_codepoints.size(), glyphs.data());
+
+    // Deduplicate and exclude glyph ID 0 (which means undefined glyph)
+    std::sort(glyphs.begin(), glyphs.end());
+    glyphs.erase(std::unique(glyphs.begin(), glyphs.end()), glyphs.end());
+    if (!glyphs[0])
+      glyphs.EraseAt(0);
+
+    // We use the heuristic that if more than half of the define glyphs are in
+    // PUA, then the font may be an icon font.
+    wtf_size_t pua_glyph_count = glyphs.size();
+    wtf_size_t total_glyphs = base_typeface_->countGlyphs();
+    may_be_icon_font_ = pua_glyph_count * 2 > total_glyphs;
+  }
+  return may_be_icon_font_;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.h b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.h
index 826258026f90..5c7df68523d7 100644
--- a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.h
+++ b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.h
@@ -32,29 +32,28 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_CUSTOM_PLATFORM_DATA_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_CUSTOM_PLATFORM_DATA_H_
 
+#include "base/macros.h"
+#include "third_party/blink/renderer/platform/fonts/font_optical_sizing.h"
 #include "third_party/blink/renderer/platform/fonts/font_orientation.h"
 #include "third_party/blink/renderer/platform/fonts/font_selection_types.h"
+#include "third_party/blink/renderer/platform/fonts/opentype/variable_axes_names.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/forward.h"
-#include "third_party/blink/renderer/platform/wtf/noncopyable.h"
 #include "third_party/blink/renderer/platform/wtf/ref_counted.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 #include "third_party/skia/include/core/SkRefCnt.h"
-#include "third_party/skia/include/core/SkString.h"
 
 class SkTypeface;
 
 namespace blink {
 
 class FontPlatformData;
-class SharedBuffer;
 class FontVariationSettings;
 
 class PLATFORM_EXPORT FontCustomPlatformData
     : public RefCounted<FontCustomPlatformData> {
   USING_FAST_MALLOC(FontCustomPlatformData);
-  WTF_MAKE_NONCOPYABLE(FontCustomPlatformData);
 
  public:
   static scoped_refptr<FontCustomPlatformData> Create(SharedBuffer*,
@@ -67,18 +66,28 @@ class PLATFORM_EXPORT FontCustomPlatformData
       bool italic,
       const FontSelectionRequest&,
       const FontSelectionCapabilities&,
+      const OpticalSizing& optical_sizing,
       FontOrientation = FontOrientation::kHorizontal,
       const FontVariationSettings* = nullptr);
 
-  SkString FamilyNameForInspector() const;
+  String FamilyNameForInspector() const;
+
+  Vector<VariationAxis> GetVariationAxes() const;
 
   size_t DataSize() const { return data_size_; }
   static bool SupportsFormat(const String&);
 
+  bool MayBeIconFont() const;
+
  private:
   FontCustomPlatformData(sk_sp<SkTypeface>, size_t data_size);
   sk_sp<SkTypeface> base_typeface_;
   size_t data_size_;
+
+  mutable bool may_be_icon_font_computed_ = false;
+  mutable bool may_be_icon_font_ = false;
+
+  DISALLOW_COPY_AND_ASSIGN(FontCustomPlatformData);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_data.h b/third_party/blink/renderer/platform/fonts/font_data.h
index 2b770f6a2efc..56e0097a693b 100644
--- a/third_party/blink/renderer/platform/fonts/font_data.h
+++ b/third_party/blink/renderer/platform/fonts/font_data.h
@@ -26,11 +26,11 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_DATA_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_DATA_H_
 
+#include "base/macros.h"
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/forward.h"
-#include "third_party/blink/renderer/platform/wtf/noncopyable.h"
 #include "third_party/blink/renderer/platform/wtf/ref_counted.h"
 #include "third_party/blink/renderer/platform/wtf/text/unicode.h"
 
@@ -39,8 +39,6 @@ namespace blink {
 class SimpleFontData;
 
 class PLATFORM_EXPORT FontData : public RefCounted<FontData> {
-  WTF_MAKE_NONCOPYABLE(FontData);
-
  public:
   FontData() = default;
 
@@ -54,16 +52,11 @@ class PLATFORM_EXPORT FontData : public RefCounted<FontData> {
   virtual bool IsLoadingFallback() const = 0;
   virtual bool IsSegmented() const = 0;
   virtual bool ShouldSkipDrawing() const = 0;
-};
+  virtual bool HasAdvanceOverride() const = 0;
 
-#define DEFINE_FONT_DATA_TYPE_CASTS(thisType, predicate)     \
-  template <typename T>                                      \
-  inline thisType* To##thisType(const scoped_refptr<T>& fontData) { \
-    return To##thisType(fontData.get());                     \
-  }                                                          \
-  DEFINE_TYPE_CASTS(thisType, FontData, fontData,            \
-                    fontData->IsSegmented() == predicate,    \
-                    fontData.IsSegmented() == predicate)
+ private:
+  DISALLOW_COPY_AND_ASSIGN(FontData);
+};
 
 }  // namespace blink
 
diff --git a/third_party/blink/renderer/platform/fonts/font_data_cache.cc b/third_party/blink/renderer/platform/fonts/font_data_cache.cc
index 060207ea5e5e..680da1679bdd 100644
--- a/third_party/blink/renderer/platform/fonts/font_data_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/font_data_cache.cc
@@ -132,7 +132,7 @@ bool FontDataCache::PurgeLeastRecentlyUsed(int count) {
   auto end = inactive_font_data_.end();
   auto it = inactive_font_data_.begin();
   for (int i = 0; i < count && it != end; ++it, ++i) {
-    scoped_refptr<SimpleFontData>& font_data = *it.Get();
+    const scoped_refptr<SimpleFontData>& font_data = *it;
     cache_.erase(&(font_data->PlatformData()));
     // We should not delete SimpleFontData here because deletion can modify
     // m_inactiveFontData. See http://trac.webkit.org/changeset/44011
diff --git a/third_party/blink/renderer/platform/fonts/font_data_cache.h b/third_party/blink/renderer/platform/fonts/font_data_cache.h
index 685a26926d6c..0fc60f3e9d8c 100644
--- a/third_party/blink/renderer/platform/fonts/font_data_cache.h
+++ b/third_party/blink/renderer/platform/fonts/font_data_cache.h
@@ -69,7 +69,6 @@ struct FontDataCacheKeyHash {
 
 class FontDataCache {
   USING_FAST_MALLOC(FontDataCache);
-  WTF_MAKE_NONCOPYABLE(FontDataCache);
 
  public:
   FontDataCache() = default;
@@ -93,6 +92,8 @@ class FontDataCache {
       Cache;
   Cache cache_;
   LinkedHashSet<scoped_refptr<SimpleFontData>> inactive_font_data_;
+
+  DISALLOW_COPY_AND_ASSIGN(FontDataCache);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_data_for_range_set.h b/third_party/blink/renderer/platform/fonts/font_data_for_range_set.h
index 04ae4b0bc6de..bb2d02489998 100644
--- a/third_party/blink/renderer/platform/fonts/font_data_for_range_set.h
+++ b/third_party/blink/renderer/platform/fonts/font_data_for_range_set.h
@@ -29,7 +29,7 @@
 #include "third_party/blink/renderer/platform/fonts/font_data.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
 #include "third_party/blink/renderer/platform/fonts/unicode_range_set.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/text/character_names.h"
 
 namespace blink {
@@ -39,14 +39,14 @@ class SimpleFontData;
 class PLATFORM_EXPORT FontDataForRangeSet
     : public RefCounted<FontDataForRangeSet> {
  public:
-  explicit FontDataForRangeSet(scoped_refptr<SimpleFontData> font_data = nullptr,
-                               scoped_refptr<UnicodeRangeSet> range_set = nullptr)
+  explicit FontDataForRangeSet(
+      scoped_refptr<SimpleFontData> font_data = nullptr,
+      scoped_refptr<UnicodeRangeSet> range_set = nullptr)
       : font_data_(std::move(font_data)), range_set_(std::move(range_set)) {}
 
   FontDataForRangeSet(const FontDataForRangeSet& other);
 
   virtual ~FontDataForRangeSet() = default;
-  ;
 
   bool Contains(UChar32 test_char) const {
     return !range_set_ || range_set_->Contains(test_char);
@@ -58,6 +58,12 @@ class PLATFORM_EXPORT FontDataForRangeSet
   bool HasFontData() const { return font_data_.get(); }
   const SimpleFontData* FontData() const { return font_data_.get(); }
 
+  // TODO(xiaochengh): |FontData::IsLoadingFallback()| returns true if the
+  // FontData is a pending custom font. We should rename it for better clarity.
+  bool IsPendingCustomFont() const {
+    return font_data_ && font_data_->IsLoadingFallback();
+  }
+
  protected:
   scoped_refptr<SimpleFontData> font_data_;
   scoped_refptr<UnicodeRangeSet> range_set_;
diff --git a/third_party/blink/renderer/platform/fonts/font_description.cc b/third_party/blink/renderer/platform/fonts/font_description.cc
index 32d2a97d5a2f..e733fab47024 100644
--- a/third_party/blink/renderer/platform/fonts/font_description.cc
+++ b/third_party/blink/renderer/platform/fonts/font_description.cc
@@ -34,9 +34,10 @@
 #include "third_party/blink/renderer/platform/language.h"
 #include "third_party/blink/renderer/platform/wtf/assertions.h"
 #include "third_party/blink/renderer/platform/wtf/hash_functions.h"
-#include "third_party/blink/renderer/platform/wtf/string_hasher.h"
+#include "third_party/blink/renderer/platform/wtf/size_assertions.h"
 #include "third_party/blink/renderer/platform/wtf/text/atomic_string_hash.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_hasher.h"
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS)
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
@@ -55,13 +56,25 @@ struct SameSizeAsFontDescription {
   FieldsAsUnsignedType bitfields;
 };
 
-static_assert(sizeof(FontDescription) == sizeof(SameSizeAsFontDescription),
-              "FontDescription should stay small");
+ASSERT_SIZE(FontDescription, SameSizeAsFontDescription);
 
 TypesettingFeatures FontDescription::default_typesetting_features_ = 0;
 
 bool FontDescription::use_subpixel_text_positioning_ = false;
 
+// static
+FontDescription FontDescription::CreateHashTableEmptyValue() {
+  FontDescription result;
+  memset(&result, 0, sizeof(FontDescription));
+  DCHECK(result.IsHashTableEmptyValue());
+  return result;
+}
+
+FontDescription::FontDescription(WTF::HashTableDeletedValueType) {
+  memset(this, 0, sizeof(FontDescription));
+  fields_.hash_category_ = kHashDeletedValue;
+}
+
 FontDescription::FontDescription()
     : specified_size_(0),
       computed_size_(0),
@@ -93,6 +106,8 @@ FontDescription::FontDescription()
   fields_.typesetting_features_ = default_typesetting_features_;
   fields_.variant_numeric_ = FontVariantNumeric().fields_as_unsigned_;
   fields_.subpixel_ascent_descent_ = false;
+  fields_.font_optical_sizing_ = OpticalSizing::kAutoOpticalSizing;
+  fields_.hash_category_ = kHashRegularValue;
 }
 
 FontDescription::FontDescription(const FontDescription&) = default;
@@ -214,13 +229,15 @@ float FontDescription::EffectiveFontSize() const {
 
 FontCacheKey FontDescription::CacheKey(
     const FontFaceCreationParams& creation_params,
+    bool is_unique_match,
     const FontSelectionRequest& font_selection_request) const {
   unsigned options =
-      static_cast<unsigned>(fields_.synthetic_italic_) << 6 |  // bit 7
-      static_cast<unsigned>(fields_.synthetic_bold_) << 5 |    // bit 6
-      static_cast<unsigned>(fields_.text_rendering_) << 3 |    // bits 4-5
-      static_cast<unsigned>(fields_.orientation_) << 1 |       // bit 2-3
-      static_cast<unsigned>(fields_.subpixel_text_position_);  // bit 1
+      static_cast<unsigned>(fields_.font_optical_sizing_) << 7 |  // bit 8
+      static_cast<unsigned>(fields_.synthetic_italic_) << 6 |     // bit 7
+      static_cast<unsigned>(fields_.synthetic_bold_) << 5 |       // bit 6
+      static_cast<unsigned>(fields_.text_rendering_) << 3 |       // bits 4-5
+      static_cast<unsigned>(fields_.orientation_) << 1 |          // bit 2-3
+      static_cast<unsigned>(fields_.subpixel_text_position_);     // bit 1
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS)
   float device_scale_factor_for_key = FontCache::DeviceScaleFactor();
@@ -228,8 +245,9 @@ FontCacheKey FontDescription::CacheKey(
   float device_scale_factor_for_key = 1.0f;
 #endif
   FontCacheKey cache_key(creation_params, EffectiveFontSize(),
-                         options | font_selection_request_.GetHash() << 8,
-                         device_scale_factor_for_key, variation_settings_);
+                         options | font_selection_request_.GetHash() << 9,
+                         device_scale_factor_for_key, variation_settings_,
+                         is_unique_match);
   return cache_key;
 }
 
@@ -296,6 +314,18 @@ void FontDescription::UpdateTypesettingFeatures() {
     fields_.typesetting_features_ |= blink::kCaps;
 }
 
+namespace {
+
+// This converts -0.0 to 0.0, so that they have the same hash value. This
+// ensures that equal FontDescription have the same hash value.
+float NormalizeSign(float number) {
+  if (UNLIKELY(number == 0.0))
+    return 0.0;
+  return number;
+}
+
+}  // namespace
+
 unsigned FontDescription::StyleHashWithoutFamilyList() const {
   unsigned hash = 0;
   StringHasher string_hasher;
@@ -303,9 +333,7 @@ unsigned FontDescription::StyleHashWithoutFamilyList() const {
   if (settings) {
     unsigned num_features = settings->size();
     for (unsigned i = 0; i < num_features; ++i) {
-      const AtomicString& tag = settings->at(i).Tag();
-      for (unsigned j = 0; j < tag.length(); j++)
-        string_hasher.AddCharacter(tag[j]);
+      WTF::AddIntToHash(hash, settings->at(i).Tag());
       WTF::AddIntToHash(hash, settings->at(i).Value());
     }
   }
@@ -320,12 +348,12 @@ unsigned FontDescription::StyleHashWithoutFamilyList() const {
   }
   WTF::AddIntToHash(hash, string_hasher.GetHash());
 
-  WTF::AddFloatToHash(hash, specified_size_);
-  WTF::AddFloatToHash(hash, computed_size_);
-  WTF::AddFloatToHash(hash, adjusted_size_);
-  WTF::AddFloatToHash(hash, size_adjust_);
-  WTF::AddFloatToHash(hash, letter_spacing_);
-  WTF::AddFloatToHash(hash, word_spacing_);
+  WTF::AddFloatToHash(hash, NormalizeSign(specified_size_));
+  WTF::AddFloatToHash(hash, NormalizeSign(computed_size_));
+  WTF::AddFloatToHash(hash, NormalizeSign(adjusted_size_));
+  WTF::AddFloatToHash(hash, NormalizeSign(size_adjust_));
+  WTF::AddFloatToHash(hash, NormalizeSign(letter_spacing_));
+  WTF::AddFloatToHash(hash, NormalizeSign(word_spacing_));
   WTF::AddIntToHash(hash, fields_as_unsigned_.parts[0]);
   WTF::AddIntToHash(hash, fields_as_unsigned_.parts[1]);
   WTF::AddIntToHash(hash, font_selection_request_.GetHash());
@@ -333,6 +361,42 @@ unsigned FontDescription::StyleHashWithoutFamilyList() const {
   return hash;
 }
 
+unsigned FontDescription::GetHash() const {
+  unsigned hash = StyleHashWithoutFamilyList();
+  for (const FontFamily* family = &family_list_; family;
+       family = family->Next()) {
+    if (!family->Family().length())
+      continue;
+    WTF::AddIntToHash(hash, WTF::AtomicStringHash::GetHash(family->Family()));
+  }
+  return hash;
+}
+
+void FontDescription::SetOrientation(FontOrientation orientation) {
+  fields_.orientation_ = static_cast<unsigned>(orientation);
+  UpdateSyntheticOblique();
+}
+
+void FontDescription::SetStyle(FontSelectionValue value) {
+  font_selection_request_.slope = value;
+  original_slope = value;
+  UpdateSyntheticOblique();
+}
+
+void FontDescription::UpdateSyntheticOblique() {
+  // Doing synthetic oblique for vertical writing mode with upright text
+  // orientation when negative angle parameter of "oblique" keyword, e.g.
+  // "font-style: oblique -15deg" for simulating "tts:fontShear"[1][2], we
+  // need to have normal font style instead of italic/oblique.
+  // [1]
+  // https://www.w3.org/TR/2018/REC-ttml2-20181108/#style-attribute-fontShear
+  // [2] See http://crbug.com/1112923
+  fields_.synthetic_oblique_ =
+      IsVerticalAnyUpright() && original_slope < FontSelectionValue(0);
+  font_selection_request_.slope =
+      fields_.synthetic_oblique_ ? NormalSlopeValue() : original_slope;
+}
+
 SkFontStyle FontDescription::SkiaFontStyle() const {
   // FIXME(drott): This is a lossy conversion, compare
   // https://bugs.chromium.org/p/skia/issues/detail?id=6844
@@ -363,12 +427,48 @@ SkFontStyle FontDescription::SkiaFontStyle() const {
   }
 
   int skia_weight = SkFontStyle::kNormal_Weight;
-  if (Weight() >= 100 && Weight() <= 1000)
-    skia_weight = static_cast<int>(roundf(Weight() / 100) * 100);
+  if (Weight() >= MinWeightValue() && Weight() <= MaxWeightValue())
+    skia_weight = static_cast<int>(Weight());
 
   return SkFontStyle(skia_weight, skia_width, slant);
 }
 
+void FontDescription::UpdateFromSkiaFontStyle(const SkFontStyle& font_style) {
+  SetWeight(FontSelectionValue(font_style.weight()));
+
+  switch (font_style.width()) {
+    case (SkFontStyle::kUltraCondensed_Width):
+      SetStretch(UltraCondensedWidthValue());
+      break;
+    case (SkFontStyle::kExtraCondensed_Width):
+      SetStretch(ExtraCondensedWidthValue());
+      break;
+    case (SkFontStyle::kCondensed_Width):
+      SetStretch(CondensedWidthValue());
+      break;
+    case (SkFontStyle::kSemiCondensed_Width):
+      SetStretch(SemiCondensedWidthValue());
+      break;
+    case (SkFontStyle::kSemiExpanded_Width):
+      SetStretch(SemiExpandedWidthValue());
+      break;
+    case (SkFontStyle::kExpanded_Width):
+      SetStretch(ExpandedWidthValue());
+      break;
+    case (SkFontStyle::kExtraExpanded_Width):
+      SetStretch(ExtraExpandedWidthValue());
+      break;
+    case (SkFontStyle::kUltraExpanded_Width):
+      SetStretch(UltraExpandedWidthValue());
+      break;
+  }
+
+  if (font_style.slant() == SkFontStyle::kOblique_Slant)
+    SetStyle(ItalicSlopeValue());
+  else
+    SetStyle(NormalSlopeValue());
+}
+
 int FontDescription::MinimumPrefixWidthToHyphenate() const {
   // If the maximum width available for the prefix before the hyphen is small,
   // then it is very unlikely that an hyphenation opportunity exists, so do not
@@ -396,8 +496,18 @@ String FontDescription::ToString(GenericFamilyType familyType) {
       return "Cursive";
     case GenericFamilyType::kFantasyFamily:
       return "Fantasy";
-    case GenericFamilyType::kPictographFamily:
-      return "Pictograph";
+  }
+  return "Unknown";
+}
+
+String FontDescription::ToString(LigaturesState state) {
+  switch (state) {
+    case LigaturesState::kNormalLigaturesState:
+      return "Normal";
+    case LigaturesState::kDisabledLigaturesState:
+      return "Disabled";
+    case LigaturesState::kEnabledLigaturesState:
+      return "Enabled";
   }
   return "Unknown";
 }
@@ -414,15 +524,26 @@ String FontDescription::ToString(Kerning kerning) {
   return "Unknown";
 }
 
-String FontDescription::ToString(LigaturesState state) {
-  switch (state) {
-    case LigaturesState::kNormalLigaturesState:
-      return "Normal";
-    case LigaturesState::kDisabledLigaturesState:
-      return "Disabled";
-    case LigaturesState::kEnabledLigaturesState:
-      return "Enabled";
-  }
+String FontDescription::ToString(FontSelectionValue selection_value) {
+  if (selection_value == UltraCondensedWidthValue())
+    return "Ultra-Condensed";
+  else if (selection_value == ExtraCondensedWidthValue())
+    return "Extra-Condensed";
+  else if (selection_value == CondensedWidthValue())
+    return "Condensed";
+  else if (selection_value == SemiCondensedWidthValue())
+    return "Semi-Condensed";
+  else if (selection_value == NormalWidthValue())
+    return "Normal";
+  else if (selection_value == SemiExpandedWidthValue())
+    return "Semi-Expanded";
+  else if (selection_value == ExpandedWidthValue())
+    return "Expanded";
+  else if (selection_value == ExtraExpandedWidthValue())
+    return "Extra-Expanded";
+  else if (selection_value == UltraExpandedWidthValue())
+    return "Ultra-Expanded";
+
   return "Unknown";
 }
 
@@ -472,8 +593,8 @@ String FontDescription::Size::ToString() const {
 String FontDescription::FamilyDescription::ToString() const {
   return String::Format(
       "generic_family=%s, family=[%s]",
-      FontDescription::ToString(generic_family).Ascii().data(),
-      family.ToString().Ascii().data());
+      FontDescription::ToString(generic_family).Ascii().c_str(),
+      family.ToString().Ascii().c_str());
 }
 
 static const char* ToBooleanString(bool value) {
@@ -494,35 +615,36 @@ String FontDescription::ToString() const {
       "keyword_size=%u, font_smoothing=%s, text_rendering=%s, "
       "synthetic_bold=%s, synthetic_italic=%s, subpixel_positioning=%s, "
       "subpixel_ascent_descent=%s, variant_numeric=[%s], "
-      "variant_east_asian=[%s]",
-      family_list_.ToString().Ascii().data(),
-      (feature_settings_ ? feature_settings_->ToString().Ascii().data() : ""),
-      (variation_settings_ ? variation_settings_->ToString().Ascii().data()
+      "variant_east_asian=[%s], font_optical_sizing=%s",
+      family_list_.ToString().Ascii().c_str(),
+      (feature_settings_ ? feature_settings_->ToString().Ascii().c_str() : ""),
+      (variation_settings_ ? variation_settings_->ToString().Ascii().c_str()
                            : ""),
       // TODO(wkorman): Locale has additional internal fields such as
       // hyphenation and script. Consider adding a more detailed
       // string method.
-      (locale_ ? locale_->LocaleString().Ascii().data() : ""), specified_size_,
+      (locale_ ? locale_->LocaleString().Ascii().c_str() : ""), specified_size_,
       computed_size_, adjusted_size_, size_adjust_, letter_spacing_,
-      word_spacing_, font_selection_request_.ToString().Ascii().data(),
+      word_spacing_, font_selection_request_.ToString().Ascii().c_str(),
       blink::ToString(
           static_cast<TypesettingFeatures>(fields_.typesetting_features_))
           .Ascii()
           .data(),
-      blink::ToString(Orientation()).Ascii().data(),
-      blink::ToString(WidthVariant()).Ascii().data(),
-      FontDescription::ToString(VariantCaps()).Ascii().data(),
+      blink::ToString(Orientation()).Ascii().c_str(),
+      blink::ToString(WidthVariant()).Ascii().c_str(),
+      FontDescription::ToString(VariantCaps()).Ascii().c_str(),
       ToBooleanString(IsAbsoluteSize()),
-      FontDescription::ToString(GenericFamily()).Ascii().data(),
-      FontDescription::ToString(Kerning()).Ascii().data(),
-      GetVariantLigatures().ToString().Ascii().data(), KeywordSize(),
-      blink::ToString(FontSmoothing()).Ascii().data(),
-      blink::ToString(TextRendering()).Ascii().data(),
+      FontDescription::ToString(GenericFamily()).Ascii().c_str(),
+      FontDescription::ToString(Kerning()).Ascii().c_str(),
+      GetVariantLigatures().ToString().Ascii().c_str(), KeywordSize(),
+      blink::ToString(FontSmoothing()).Ascii().c_str(),
+      blink::ToString(TextRendering()).Ascii().c_str(),
       ToBooleanString(IsSyntheticBold()), ToBooleanString(IsSyntheticItalic()),
       ToBooleanString(UseSubpixelPositioning()),
       ToBooleanString(SubpixelAscentDescent()),
-      VariantNumeric().ToString().Ascii().data(),
-      VariantEastAsian().ToString().Ascii().data());
+      VariantNumeric().ToString().Ascii().c_str(),
+      VariantEastAsian().ToString().Ascii().c_str(),
+      blink::ToString(FontOpticalSizing()).Ascii().c_str());
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_description.h b/third_party/blink/renderer/platform/fonts/font_description.h
index 140e099364fa..769bdaa403b9 100644
--- a/third_party/blink/renderer/platform/fonts/font_description.h
+++ b/third_party/blink/renderer/platform/fonts/font_description.h
@@ -26,11 +26,13 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_DESCRIPTION_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_DESCRIPTION_H_
 
-#include "SkFontStyle.h"
+#include <unicode/uscript.h>
+
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/platform/font_family_names.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache_key.h"
 #include "third_party/blink/renderer/platform/fonts/font_family.h"
+#include "third_party/blink/renderer/platform/fonts/font_optical_sizing.h"
 #include "third_party/blink/renderer/platform/fonts/font_orientation.h"
 #include "third_party/blink/renderer/platform/fonts/font_selection_types.h"
 #include "third_party/blink/renderer/platform/fonts/font_smoothing_mode.h"
@@ -41,10 +43,9 @@
 #include "third_party/blink/renderer/platform/fonts/text_rendering_mode.h"
 #include "third_party/blink/renderer/platform/fonts/typesetting_features.h"
 #include "third_party/blink/renderer/platform/text/layout_locale.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/math_extras.h"
-
-#include <unicode/uscript.h>
+#include "third_party/skia/include/core/SkFontStyle.h"
 
 namespace blink {
 
@@ -55,6 +56,12 @@ class PLATFORM_EXPORT FontDescription {
   USING_FAST_MALLOC(FontDescription);
 
  public:
+  enum HashCategory {
+    kHashEmptyValue = 0,
+    kHashDeletedValue,
+    kHashRegularValue
+  };
+
   enum GenericFamilyType {
     kNoFamily,
     kStandardFamily,
@@ -62,14 +69,10 @@ class PLATFORM_EXPORT FontDescription {
     kSansSerifFamily,
     kMonospaceFamily,
     kCursiveFamily,
-    kFantasyFamily,
-    kPictographFamily
+    kFantasyFamily
   };
   static String ToString(GenericFamilyType);
 
-  enum Kerning { kAutoKerning, kNormalKerning, kNoneKerning };
-  static String ToString(Kerning);
-
   enum LigaturesState {
     kNormalLigaturesState,
     kDisabledLigaturesState,
@@ -77,6 +80,11 @@ class PLATFORM_EXPORT FontDescription {
   };
   static String ToString(LigaturesState);
 
+  enum Kerning { kAutoKerning, kNormalKerning, kNoneKerning };
+  static String ToString(Kerning);
+
+  static String ToString(FontSelectionValue);
+
   enum FontVariantCaps {
     kCapsNormal,
     kSmallCaps,
@@ -91,6 +99,9 @@ class PLATFORM_EXPORT FontDescription {
   FontDescription();
   FontDescription(const FontDescription&);
 
+  static FontDescription CreateHashTableEmptyValue();
+  explicit FontDescription(WTF::HashTableDeletedValueType);
+
   FontDescription& operator=(const FontDescription&);
 
   bool operator==(const FontDescription&) const;
@@ -100,6 +111,8 @@ class PLATFORM_EXPORT FontDescription {
 
   struct VariantLigatures {
     STACK_ALLOCATED();
+
+   public:
     VariantLigatures(LigaturesState state = kNormalLigaturesState)
         : common(state),
           discretionary(state),
@@ -116,6 +129,8 @@ class PLATFORM_EXPORT FontDescription {
 
   struct Size {
     STACK_ALLOCATED();
+
+   public:
     Size(unsigned keyword, float value, bool is_absolute)
         : keyword(keyword), is_absolute(is_absolute), value(value) {}
 
@@ -128,6 +143,8 @@ class PLATFORM_EXPORT FontDescription {
 
   struct FamilyDescription {
     STACK_ALLOCATED();
+
+   public:
     FamilyDescription(GenericFamilyType generic_family)
         : generic_family(generic_family) {}
     FamilyDescription(GenericFamilyType generic_family,
@@ -173,7 +190,7 @@ class PLATFORM_EXPORT FontDescription {
   // family is "monospace"
   bool IsMonospace() const {
     return GenericFamily() == kMonospaceFamily && !Family().Next() &&
-           Family().Family() == FontFamilyNames::webkit_monospace;
+           Family().Family() == font_family_names::kWebkitMonospace;
   }
   Kerning GetKerning() const { return static_cast<Kerning>(fields_.kerning_); }
   FontVariantEastAsian VariantEastAsian() const {
@@ -183,7 +200,7 @@ class PLATFORM_EXPORT FontDescription {
   VariantLigatures GetVariantLigatures() const;
   FontVariantNumeric VariantNumeric() const {
     return FontVariantNumeric::InitializeFromUnsigned(fields_.variant_numeric_);
-  };
+  }
   LigaturesState CommonLigaturesState() const {
     return static_cast<LigaturesState>(fields_.common_ligatures_state_);
   }
@@ -200,6 +217,9 @@ class PLATFORM_EXPORT FontDescription {
   FontSmoothingMode FontSmoothing() const {
     return static_cast<FontSmoothingMode>(fields_.font_smoothing_);
   }
+  OpticalSizing FontOpticalSizing() const {
+    return static_cast<OpticalSizing>(fields_.font_optical_sizing_);
+  }
   TextRenderingMode TextRendering() const {
     return static_cast<TextRenderingMode>(fields_.text_rendering_);
   }
@@ -210,6 +230,7 @@ class PLATFORM_EXPORT FontDescription {
   UScriptCode GetScript() const { return LocaleOrDefault().GetScript(); }
   bool IsSyntheticBold() const { return fields_.synthetic_bold_; }
   bool IsSyntheticItalic() const { return fields_.synthetic_italic_; }
+  bool IsSyntheticOblique() const { return fields_.synthetic_oblique_; }
   bool UseSubpixelPositioning() const {
     return fields_.subpixel_text_position_;
   }
@@ -246,6 +267,7 @@ class PLATFORM_EXPORT FontDescription {
       const;  // Returns either the computedSize or the computedPixelSize
   FontCacheKey CacheKey(
       const FontFaceCreationParams&,
+      bool is_unique_match,
       const FontSelectionRequest& = FontSelectionRequest()) const;
 
   void SetFamily(const FontFamily& family) { family_list_ = family; }
@@ -254,7 +276,7 @@ class PLATFORM_EXPORT FontDescription {
   void SetAdjustedSize(float s) { adjusted_size_ = clampTo<float>(s); }
   void SetSizeAdjust(float aspect) { size_adjust_ = clampTo<float>(aspect); }
 
-  void SetStyle(FontSelectionValue i) { font_selection_request_.slope = i; }
+  void SetStyle(FontSelectionValue i);
   void SetWeight(FontSelectionValue w) { font_selection_request_.weight = w; }
   void SetStretch(FontSelectionValue s) { font_selection_request_.width = s; }
 
@@ -275,13 +297,14 @@ class PLATFORM_EXPORT FontDescription {
   void SetFontSmoothing(FontSmoothingMode smoothing) {
     fields_.font_smoothing_ = smoothing;
   }
+  void SetFontOpticalSizing(OpticalSizing font_optical_sizing) {
+    fields_.font_optical_sizing_ = font_optical_sizing;
+  }
   void SetTextRendering(TextRenderingMode rendering) {
     fields_.text_rendering_ = rendering;
     UpdateTypesettingFeatures();
   }
-  void SetOrientation(FontOrientation orientation) {
-    fields_.orientation_ = static_cast<unsigned>(orientation);
-  }
+  void SetOrientation(FontOrientation orientation);
   void SetWidthVariant(FontWidthVariant width_variant) {
     fields_.width_variant_ = width_variant;
   }
@@ -315,7 +338,7 @@ class PLATFORM_EXPORT FontDescription {
   }
   static bool SubpixelPositioning() { return use_subpixel_text_positioning_; }
 
-  void SetSubpixelAscentDescent(bool sp) const {
+  void SetSubpixelAscentDescent(bool sp) {
     fields_.subpixel_ascent_descent_ = sp;
   }
 
@@ -323,10 +346,28 @@ class PLATFORM_EXPORT FontDescription {
     return fields_.subpixel_ascent_descent_;
   }
 
+  void SetHashCategory(HashCategory category) {
+    fields_.hash_category_ = category;
+  }
+
+  HashCategory GetHashCategory() const {
+    return static_cast<HashCategory>(fields_.hash_category_);
+  }
+
+  bool IsHashTableEmptyValue() const {
+    return GetHashCategory() == kHashEmptyValue;
+  }
+
+  bool IsHashTableDeletedValue() const {
+    return GetHashCategory() == kHashDeletedValue;
+  }
+
   static void SetDefaultTypesettingFeatures(TypesettingFeatures);
   static TypesettingFeatures DefaultTypesettingFeatures();
 
   unsigned StyleHashWithoutFamilyList() const;
+  unsigned GetHash() const;
+
   // TODO(drott): We should not expose internal structure here, but rather
   // introduce a hash function here.
   unsigned BitmapFields() const { return fields_as_unsigned_.parts[0]; }
@@ -336,11 +377,15 @@ class PLATFORM_EXPORT FontDescription {
 
   SkFontStyle SkiaFontStyle() const;
 
+  void UpdateFromSkiaFontStyle(const SkFontStyle& font_style);
+
   int MinimumPrefixWidthToHyphenate() const;
 
   String ToString() const;
 
  private:
+  void UpdateSyntheticOblique();
+
   FontFamily family_list_;  // The list of font families to be used.
   scoped_refptr<FontFeatureSettings> feature_settings_;
   scoped_refptr<FontVariationSettings> variation_settings_;
@@ -367,6 +412,7 @@ class PLATFORM_EXPORT FontDescription {
 
   // Covers stretch, style, weight.
   FontSelectionRequest font_selection_request_;
+  FontSelectionValue original_slope;
 
   struct BitFields {
     DISALLOW_NEW();
@@ -401,11 +447,15 @@ class PLATFORM_EXPORT FontDescription {
     unsigned text_rendering_ : 2;  // TextRenderingMode
     unsigned synthetic_bold_ : 1;
     unsigned synthetic_italic_ : 1;
+    unsigned synthetic_oblique_ : 1;
     unsigned subpixel_text_position_ : 1;
     unsigned typesetting_features_ : 3;
     unsigned variant_numeric_ : 8;
     unsigned variant_east_asian_ : 6;
-    mutable unsigned subpixel_ascent_descent_ : 1;
+    unsigned subpixel_ascent_descent_ : 1;
+    unsigned font_optical_sizing_ : 1;
+
+    unsigned hash_category_ : 2;  // HashCategory
   };
 
   static_assert(sizeof(BitFields) == sizeof(FieldsAsUnsignedType),
@@ -420,6 +470,45 @@ class PLATFORM_EXPORT FontDescription {
   static bool use_subpixel_text_positioning_;
 };
 
+struct FontDescriptionHash {
+  STATIC_ONLY(FontDescriptionHash);
+
+  static unsigned GetHash(const FontDescription& description) {
+    return description.GetHash();
+  }
+
+  static bool Equal(const FontDescription& a, const FontDescription& b) {
+    return a == b;
+  }
+
+  // Empty and deleted FontDescriptions have different HashCategory flag values
+  // from all regular FontDescriptions.
+  static const bool safe_to_compare_to_empty_or_deleted = true;
+};
+
 }  // namespace blink
 
+namespace WTF {
+
+template <typename T>
+struct DefaultHash;
+template <>
+struct DefaultHash<blink::FontDescription> {
+  using Hash = blink::FontDescriptionHash;
+};
+
+template <typename T>
+struct HashTraits;
+template <>
+struct HashTraits<blink::FontDescription>
+    : SimpleClassHashTraits<blink::FontDescription> {
+  // FontDescription default constructor creates a regular value instead of the
+  // empty value.
+  static blink::FontDescription EmptyValue() {
+    return blink::FontDescription::CreateHashTableEmptyValue();
+  }
+};
+
+}  // namespace WTF
+
 #endif
diff --git a/third_party/blink/renderer/platform/fonts/font_description_test.cc b/third_party/blink/renderer/platform/fonts/font_description_test.cc
index e573d634fb5c..a2677f2b847d 100644
--- a/third_party/blink/renderer/platform/fonts/font_description_test.cc
+++ b/third_party/blink/renderer/platform/fonts/font_description_test.cc
@@ -25,7 +25,9 @@
 
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
 
+#include "base/stl_util.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/wtf/hash_map.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 
 namespace blink {
@@ -48,11 +50,11 @@ TEST(FontDescriptionTest, TestHashCollision) {
 
   FontDescription source;
   WTF::Vector<unsigned> hashes;
-  for (size_t i = 0; i < arraysize(weights); i++) {
+  for (size_t i = 0; i < base::size(weights); i++) {
     source.SetWeight(weights[i]);
-    for (size_t j = 0; j < arraysize(stretches); j++) {
+    for (size_t j = 0; j < base::size(stretches); j++) {
       source.SetStretch(stretches[j]);
-      for (size_t k = 0; k < arraysize(slopes); k++) {
+      for (size_t k = 0; k < base::size(slopes); k++) {
         source.SetStyle(slopes[k]);
         unsigned hash = source.StyleHashWithoutFamilyList();
         ASSERT_FALSE(hashes.Contains(hash));
@@ -62,6 +64,78 @@ TEST(FontDescriptionTest, TestHashCollision) {
   }
 }
 
+TEST(FontDescriptionTest, VariationSettingsIdentical) {
+  FontDescription a;
+  FontDescription b(a);
+
+  scoped_refptr<FontVariationSettings> settings_a =
+      FontVariationSettings::Create();
+  settings_a->Append(FontVariationAxis("test", 1));
+
+  scoped_refptr<FontVariationSettings> settings_b =
+      FontVariationSettings::Create();
+  settings_b->Append(FontVariationAxis("test", 1));
+
+  ASSERT_EQ(*settings_a, *settings_b);
+
+  a.SetVariationSettings(settings_a);
+  b.SetVariationSettings(settings_b);
+
+  ASSERT_EQ(a, b);
+
+  FontFaceCreationParams test_creation_params;
+  FontCacheKey cache_key_a = a.CacheKey(test_creation_params, false);
+  FontCacheKey cache_key_b = b.CacheKey(test_creation_params, false);
+
+  ASSERT_EQ(cache_key_a, cache_key_b);
+}
+
+TEST(FontDescriptionTest, VariationSettingsDifferent) {
+  FontDescription a;
+  FontDescription b(a);
+
+  scoped_refptr<FontVariationSettings> settings_a =
+      FontVariationSettings::Create();
+  settings_a->Append(FontVariationAxis("test", 1));
+
+  scoped_refptr<FontVariationSettings> settings_b =
+      FontVariationSettings::Create();
+  settings_b->Append(FontVariationAxis("0000", 1));
+
+  ASSERT_NE(*settings_a, *settings_b);
+
+  a.SetVariationSettings(settings_a);
+  b.SetVariationSettings(settings_b);
+
+  ASSERT_NE(a, b);
+
+  FontFaceCreationParams test_creation_params;
+
+  FontCacheKey cache_key_a = a.CacheKey(test_creation_params, false);
+  FontCacheKey cache_key_b = b.CacheKey(test_creation_params, false);
+
+  ASSERT_NE(cache_key_a, cache_key_b);
+
+  scoped_refptr<FontVariationSettings> second_settings_a =
+      FontVariationSettings::Create();
+  second_settings_a->Append(FontVariationAxis("test", 1));
+
+  scoped_refptr<FontVariationSettings> second_settings_b =
+      FontVariationSettings::Create();
+
+  ASSERT_NE(*second_settings_a, *second_settings_b);
+
+  a.SetVariationSettings(second_settings_a);
+  b.SetVariationSettings(second_settings_b);
+
+  ASSERT_NE(a, b);
+
+  FontCacheKey second_cache_key_a = a.CacheKey(test_creation_params, false);
+  FontCacheKey second_cache_key_b = b.CacheKey(test_creation_params, false);
+
+  ASSERT_NE(second_cache_key_a, second_cache_key_b);
+}
+
 TEST(FontDescriptionTest, ToString) {
   FontDescription description;
 
@@ -76,13 +150,13 @@ TEST(FontDescriptionTest, ToString) {
 
   scoped_refptr<FontVariationSettings> variation_settings =
       FontVariationSettings::Create();
-  variation_settings->Append(FontVariationAxis{"a", 42});
-  variation_settings->Append(FontVariationAxis{"b", 8118});
+  variation_settings->Append(FontVariationAxis{"aaaa", 42});
+  variation_settings->Append(FontVariationAxis{"bbbb", 8118});
   description.SetVariationSettings(variation_settings);
 
   scoped_refptr<FontFeatureSettings> feature_settings = FontFeatureSettings::Create();
-  feature_settings->Append(FontFeature{"c", 76});
-  feature_settings->Append(FontFeature{"d", 94});
+  feature_settings->Append(FontFeature{"cccc", 76});
+  feature_settings->Append(FontFeature{"dddd", 94});
   description.SetFeatureSettings(feature_settings);
 
   description.SetSpecifiedSize(1.1f);
@@ -99,8 +173,9 @@ TEST(FontDescriptionTest, ToString) {
   description.SetTextRendering(kOptimizeLegibility);
 
   EXPECT_EQ(
-      "family_list=[A,B], feature_settings=[c=76,d=94], "
-      "variation_settings=[a=42,b=8118], locale=no, specified_size=1.100000, "
+      "family_list=[A,B], feature_settings=[cccc=76,dddd=94], "
+      "variation_settings=[aaaa=42,bbbb=8118], locale=no, "
+      "specified_size=1.100000, "
       "computed_size=2.200000, adjusted_size=3.300000, size_adjust=4.400000, "
       "letter_spacing=5.500000, word_spacing=6.600000, "
       "font_selection_request=[weight=32.500000, width=33.500000, "
@@ -115,8 +190,78 @@ TEST(FontDescriptionTest, ToString) {
       "variant_numeric=[numeric_figure=NormalFigure, "
       "numeric_spacing=NormalSpacing, numeric_fraction=Normal, ordinal=Off, "
       "slashed_zero=Off], variant_east_asian=[form=Normal, width=Normal, "
-      "ruby=false]",
+      "ruby=false], font_optical_sizing=Auto",
       description.ToString());
 }
 
+// Verifies the correctness of the default hash trait of FontDescription.
+TEST(FontDescriptionTest, DefaultHashTrait) {
+  HashMap<FontDescription, int> map;
+
+  FontDescription description1;
+
+  FontDescription description2;
+  description1.SetWeight(FontSelectionValue(100));
+
+  FontFamily family;
+  family.SetFamily("A");
+  scoped_refptr<SharedFontFamily> b_family = SharedFontFamily::Create();
+  b_family->SetFamily("B");
+  family.AppendFamily(b_family);
+  FontDescription description3;
+  description3.SetFamily(family);
+
+  EXPECT_TRUE(map.insert(description1, 1).is_new_entry);
+  EXPECT_FALSE(map.insert(description1, 1).is_new_entry);
+  EXPECT_EQ(1u, map.size());
+
+  EXPECT_TRUE(map.insert(description2, 2).is_new_entry);
+  EXPECT_FALSE(map.insert(description2, 2).is_new_entry);
+  EXPECT_EQ(2u, map.size());
+
+  EXPECT_TRUE(map.insert(description3, 3).is_new_entry);
+  EXPECT_FALSE(map.insert(description3, 3).is_new_entry);
+  EXPECT_EQ(3u, map.size());
+
+  EXPECT_EQ(1, map.at(description1));
+  EXPECT_EQ(2, map.at(description2));
+  EXPECT_EQ(3, map.at(description3));
+
+  FontDescription not_in_map;
+  not_in_map.SetWeight(FontSelectionValue(200));
+  EXPECT_FALSE(map.Contains(not_in_map));
+
+  map.erase(description2);
+  EXPECT_EQ(2u, map.size());
+  EXPECT_TRUE(map.Contains(description1));
+  EXPECT_FALSE(map.Contains(description2));
+  EXPECT_TRUE(map.Contains(description3));
+
+  map.erase(description3);
+  EXPECT_EQ(1u, map.size());
+  EXPECT_TRUE(map.Contains(description1));
+  EXPECT_FALSE(map.Contains(description2));
+  EXPECT_FALSE(map.Contains(description3));
+
+  map.erase(description1);
+  EXPECT_EQ(0u, map.size());
+  EXPECT_FALSE(map.Contains(description1));
+  EXPECT_FALSE(map.Contains(description2));
+  EXPECT_FALSE(map.Contains(description3));
+}
+
+// https://crbug.com/1081017
+TEST(FontDescriptionTest, NegativeZeroEmFontSize) {
+  // 'font-size: -0.0em' sets the following
+  FontDescription description1;
+  description1.SetSpecifiedSize(-0.0);
+
+  FontDescription description2;
+  description2.SetSpecifiedSize(0.0);
+
+  // Equal font descriptions must have equal hash values
+  EXPECT_EQ(description1, description2);
+  EXPECT_EQ(description1.GetHash(), description2.GetHash());
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_face_creation_params.h b/third_party/blink/renderer/platform/fonts/font_face_creation_params.h
index 0fdbf572520d..825dd56a3b9a 100644
--- a/third_party/blink/renderer/platform/fonts/font_face_creation_params.h
+++ b/third_party/blink/renderer/platform/fonts/font_face_creation_params.h
@@ -32,11 +32,11 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_FACE_CREATION_PARAMS_H_
 
 #include "build/build_config.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/assertions.h"
-#include "third_party/blink/renderer/platform/wtf/string_hasher.h"
 #include "third_party/blink/renderer/platform/wtf/text/atomic_string.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_hasher.h"
 
 namespace blink {
 
@@ -52,14 +52,14 @@ class FontFaceCreationParams {
   FontFaceCreationParams()
       : creation_type_(kCreateFontByFamily),
         family_(AtomicString()),
-        filename_(CString()),
+        filename_(std::string()),
         fontconfig_interface_id_(0),
         ttc_index_(0) {}
 
   explicit FontFaceCreationParams(AtomicString family)
       : creation_type_(kCreateFontByFamily),
         family_(family),
-        filename_(CString()),
+        filename_(std::string()),
         fontconfig_interface_id_(0),
         ttc_index_(0) {
 #if defined(OS_WIN)
@@ -73,7 +73,7 @@ class FontFaceCreationParams {
 #endif
   }
 
-  FontFaceCreationParams(CString filename,
+  FontFaceCreationParams(const std::string& filename,
                          int fontconfig_interface_id,
                          int ttc_index = 0)
       : creation_type_(kCreateFontByFciIdAndTtcIndex),
@@ -86,7 +86,7 @@ class FontFaceCreationParams {
     DCHECK_EQ(creation_type_, kCreateFontByFamily);
     return family_;
   }
-  CString Filename() const {
+  const std::string& Filename() const {
     DCHECK_EQ(creation_type_, kCreateFontByFciIdAndTtcIndex);
     return filename_;
   }
@@ -107,7 +107,7 @@ class FontFaceCreationParams {
       // over a network or permanently stored and only used for the runtime of
       // Chromium, this is not a concern.
       hasher.AddCharacters(reinterpret_cast<const LChar*>(filename_.data()),
-                           filename_.length());
+                           static_cast<unsigned>(filename_.length()));
       hasher.AddCharacters(reinterpret_cast<const LChar*>(&ttc_index_),
                            sizeof(ttc_index_));
       hasher.AddCharacters(
@@ -129,7 +129,7 @@ class FontFaceCreationParams {
  private:
   FontFaceCreationType creation_type_;
   AtomicString family_;
-  CString filename_;
+  std::string filename_;
   int fontconfig_interface_id_;
   int ttc_index_;
 };
diff --git a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
index fd825e721ccd..cd01d8ea627b 100644
--- a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
@@ -9,18 +9,9 @@
 #include "third_party/blink/renderer/platform/fonts/font_fallback_list.h"
 #include "third_party/blink/renderer/platform/fonts/segmented_font_data.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
-#include "third_party/blink/renderer/platform/text/icu_error.h"
 
 namespace blink {
 
-scoped_refptr<FontFallbackIterator> FontFallbackIterator::Create(
-    const FontDescription& description,
-    scoped_refptr<FontFallbackList> fallback_list,
-    FontFallbackPriority font_fallback_priority) {
-  return base::AdoptRef(new FontFallbackIterator(
-      description, std::move(fallback_list), font_fallback_priority));
-}
-
 FontFallbackIterator::FontFallbackIterator(
     const FontDescription& description,
     scoped_refptr<FontFallbackList> fallback_list,
@@ -42,11 +33,15 @@ bool FontFallbackIterator::AlreadyLoadingRangeForHintChar(UChar32 hint_char) {
 }
 
 bool FontFallbackIterator::RangeSetContributesForHint(
-    const Vector<UChar32> hint_list,
+    const Vector<UChar32>& hint_list,
     const FontDataForRangeSet* segmented_face) {
   for (auto* it = hint_list.begin(); it != hint_list.end(); ++it) {
     if (segmented_face->Contains(*it)) {
-      if (!AlreadyLoadingRangeForHintChar(*it))
+      // If it's a pending custom font, we need to make sure it can render any
+      // new characters, otherwise we may trigger a redundant load. In other
+      // cases (already loaded or not a custom font), we can use it right away.
+      if (!segmented_face->IsPendingCustomFont() ||
+          !AlreadyLoadingRangeForHintChar(*it))
         return true;
     }
   }
@@ -65,6 +60,9 @@ void FontFallbackIterator::WillUseRange(const AtomicString& family,
 scoped_refptr<FontDataForRangeSet> FontFallbackIterator::UniqueOrNext(
     scoped_refptr<FontDataForRangeSet> candidate,
     const Vector<UChar32>& hint_list) {
+  if (!candidate->HasFontData())
+    return Next(hint_list);
+
   SkTypeface* candidate_typeface =
       candidate->FontData()->PlatformData().Typeface();
   if (!candidate_typeface)
@@ -79,9 +77,30 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::UniqueOrNext(
   // depends on the subsetting.
   if (candidate->IsEntireRange())
     unique_font_data_for_range_sets_returned_.insert(candidate_id);
+
+  // Save first candidate to be returned if all other fonts fail, and we need
+  // it to render the .notdef glyph.
+  if (!first_candidate_)
+    first_candidate_ = candidate;
   return candidate;
 }
 
+bool FontFallbackIterator::NeedsHintList() const {
+  if (fallback_stage_ == kSegmentedFace)
+    return true;
+
+  if (fallback_stage_ != kFontGroupFonts)
+    return false;
+
+  const FontData* font_data = font_fallback_list_->FontDataAt(
+      font_description_, current_font_data_index_);
+
+  if (!font_data)
+    return false;
+
+  return font_data->IsSegmented();
+}
+
 scoped_refptr<FontDataForRangeSet> FontFallbackIterator::Next(
     const Vector<UChar32>& hint_list) {
   if (fallback_stage_ == kOutOfLuck)
@@ -114,14 +133,26 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::Next(
     // resort font that has glyphs for everything, for example the Unicode
     // LastResort font, not just Times or Arial.
     FontCache* font_cache = FontCache::GetFontCache();
-    fallback_stage_ = kOutOfLuck;
+    fallback_stage_ = kFirstCandidateForNotdefGlyph;
     scoped_refptr<SimpleFontData> last_resort =
         font_cache->GetLastResortFallbackFont(font_description_).get();
-    if (!last_resort)
+
+    if (FontSelector* font_selector = font_fallback_list_->GetFontSelector()) {
+      font_selector->ReportLastResortFallbackFontLookup(
+          font_description_,
+          last_resort.get());
+    }
+
+    return UniqueOrNext(
+        base::AdoptRef(new FontDataForRangeSetFromCache(last_resort)),
+        hint_list);
+  }
+
+  if (fallback_stage_ == kFirstCandidateForNotdefGlyph) {
+    fallback_stage_ = kOutOfLuck;
+    if (!first_candidate_)
       FontCache::CrashWithFontInfo(&font_description_);
-    // Don't skip the LastResort font in uniqueOrNext() since HarfBuzzShaper
-    // needs to use this one to place missing glyph boxes.
-    return base::AdoptRef(new FontDataForRangeSetFromCache(last_resort));
+    return first_candidate_;
   }
 
   DCHECK(fallback_stage_ == kFontGroupFonts ||
@@ -146,7 +177,7 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::Next(
     current_font_data_index_++;
     if (!font_data->IsLoading()) {
       scoped_refptr<SimpleFontData> non_segmented =
-          const_cast<SimpleFontData*>(ToSimpleFontData(font_data));
+          const_cast<SimpleFontData*>(To<SimpleFontData>(font_data));
       // The fontData object that we have here is tracked in m_fontList of
       // FontFallbackList and gets released in the font cache when the
       // FontFallbackList is destroyed.
@@ -158,7 +189,7 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::Next(
 
   // Iterate over ranges of a segmented font below.
 
-  const SegmentedFontData* segmented = ToSegmentedFontData(font_data);
+  const auto* segmented = To<SegmentedFontData>(font_data);
   if (fallback_stage_ != kSegmentedFace) {
     segmented_face_index_ = 0;
     fallback_stage_ = kSegmentedFace;
@@ -177,10 +208,12 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::Next(
   }
 
   if (RangeSetContributesForHint(hint_list, current_segmented_face.get())) {
-    const SimpleFontData* font_data = current_segmented_face->FontData();
-    if (const CustomFontData* custom_font_data = font_data->GetCustomFontData())
-      custom_font_data->BeginLoadIfNeeded();
-    if (!font_data->IsLoading())
+    const SimpleFontData* current_segmented_face_font_data =
+        current_segmented_face->FontData();
+    if (const CustomFontData* current_segmented_face_custom_font_data =
+            current_segmented_face_font_data->GetCustomFontData())
+      current_segmented_face_custom_font_data->BeginLoadIfNeeded();
+    if (!current_segmented_face_font_data->IsLoading())
       return UniqueOrNext(current_segmented_face, hint_list);
     tracked_loading_range_sets_.push_back(current_segmented_face);
   }
@@ -190,10 +223,17 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::Next(
 
 scoped_refptr<SimpleFontData> FontFallbackIterator::FallbackPriorityFont(
     UChar32 hint) {
-  return FontCache::GetFontCache()->FallbackFontForCharacter(
-      font_description_, hint,
-      font_fallback_list_->PrimarySimpleFontData(font_description_),
-      font_fallback_priority_);
+  scoped_refptr<SimpleFontData> font_data =
+      FontCache::GetFontCache()->FallbackFontForCharacter(
+          font_description_, hint,
+          font_fallback_list_->PrimarySimpleFontData(font_description_),
+          font_fallback_priority_);
+
+  if (FontSelector* font_selector = font_fallback_list_->GetFontSelector()) {
+    font_selector->ReportFontLookupByFallbackCharacter(
+        hint, font_fallback_priority_, font_description_, font_data.get());
+  }
+  return font_data;
 }
 
 static inline unsigned ChooseHintIndex(const Vector<UChar32>& hint_list) {
@@ -209,16 +249,8 @@ static inline unsigned ChooseHintIndex(const Vector<UChar32>& hint_list) {
   if (hint_list.size() <= 1)
     return 0;
 
-  ICUError err;
-  UScriptCode hint_char_script = uscript_getScript(hint_list[0], &err);
-  if (!U_SUCCESS(err) || hint_char_script > USCRIPT_INHERITED)
-    return 0;
-
-  for (size_t i = 1; i < hint_list.size(); ++i) {
-    UScriptCode new_hint_script = uscript_getScript(hint_list[i], &err);
-    if (!U_SUCCESS(err))
-      return 0;
-    if (new_hint_script > USCRIPT_INHERITED)
+  for (wtf_size_t i = 1; i < hint_list.size(); ++i) {
+    if (Character::HasDefiniteScript(hint_list[i]))
       return i;
   }
   return 0;
@@ -238,9 +270,17 @@ scoped_refptr<SimpleFontData> FontFallbackIterator::UniqueSystemFontForHintList(
   if (!hint || previously_asked_for_hint_.Contains(hint))
     return nullptr;
   previously_asked_for_hint_.insert(hint);
-  return font_cache->FallbackFontForCharacter(
-      font_description_, hint,
-      font_fallback_list_->PrimarySimpleFontData(font_description_));
+
+  scoped_refptr<SimpleFontData> font_data =
+      font_cache->FallbackFontForCharacter(
+          font_description_, hint,
+          font_fallback_list_->PrimarySimpleFontData(font_description_));
+
+  if (FontSelector* font_selector = font_fallback_list_->GetFontSelector()) {
+    font_selector->ReportFontLookupByFallbackCharacter(
+        hint, FontFallbackPriority::kText, font_description_, font_data.get());
+  }
+  return font_data;
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.h b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.h
index 22e1667ce0ed..3eaa249d4fcf 100644
--- a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.h
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.h
@@ -8,6 +8,7 @@
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/platform/fonts/font_data_for_range_set.h"
 #include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/hash_map.h"
 #include "third_party/blink/renderer/platform/wtf/ref_counted.h"
 #include "third_party/blink/renderer/platform/wtf/text/unicode.h"
@@ -19,15 +20,25 @@ class FontDescription;
 class FontFallbackList;
 class SimpleFontData;
 
-class FontFallbackIterator : public RefCounted<FontFallbackIterator> {
-  WTF_MAKE_NONCOPYABLE(FontFallbackIterator);
+class FontFallbackIterator {
+  STACK_ALLOCATED();
 
  public:
-  static scoped_refptr<FontFallbackIterator> Create(const FontDescription&,
-                                             scoped_refptr<FontFallbackList>,
-                                             FontFallbackPriority);
+  FontFallbackIterator(const FontDescription&,
+                       scoped_refptr<FontFallbackList>,
+                       FontFallbackPriority);
+  FontFallbackIterator(FontFallbackIterator&&) = default;
+  FontFallbackIterator(const FontFallbackIterator&) = delete;
+  FontFallbackIterator& operator=(const FontFallbackIterator&) = delete;
 
-  bool HasNext() const { return fallback_stage_ != kOutOfLuck; };
+  bool HasNext() const { return fallback_stage_ != kOutOfLuck; }
+  // Returns whether the next call to Next() needs a full hint list, or whether
+  // a single character is sufficient. Intended to serve as an optimization in
+  // HarfBuzzShaper to avoid spending too much time and resources collecting a
+  // full hint character list. Returns true when the next font in line is a
+  // segmented font, i.e. one that requires the hint list to work out which
+  // unicode range segment should be used.
+  bool NeedsHintList() const;
 
   // Some system fallback APIs (Windows, Android) require a character, or a
   // portion of the string to be passed.  On Mac and Linux, we get a list of
@@ -35,10 +46,7 @@ class FontFallbackIterator : public RefCounted<FontFallbackIterator> {
   scoped_refptr<FontDataForRangeSet> Next(const Vector<UChar32>& hint_list);
 
  private:
-  FontFallbackIterator(const FontDescription&,
-                       scoped_refptr<FontFallbackList>,
-                       FontFallbackPriority);
-  bool RangeSetContributesForHint(const Vector<UChar32> hint_list,
+  bool RangeSetContributesForHint(const Vector<UChar32>& hint_list,
                                   const FontDataForRangeSet*);
   bool AlreadyLoadingRangeForHintChar(UChar32 hint_char);
   void WillUseRange(const AtomicString& family, const FontDataForRangeSet&);
@@ -62,6 +70,7 @@ class FontFallbackIterator : public RefCounted<FontFallbackIterator> {
     kSegmentedFace,
     kPreferencesFonts,
     kSystemFonts,
+    kFirstCandidateForNotdefGlyph,
     kOutOfLuck
   };
 
@@ -69,10 +78,13 @@ class FontFallbackIterator : public RefCounted<FontFallbackIterator> {
   HashSet<UChar32> previously_asked_for_hint_;
   // FontFallbackIterator is meant for single use by HarfBuzzShaper,
   // traversing through the fonts for shaping only once. We must not return
-  // duplicate FontDataForRangeSet objects from the next() iteration functions
+  // duplicate FontDataForRangeSet objects from the Next() iteration function
   // as returning a duplicate value causes a shaping run that won't return any
-  // results.
+  // results. The exception is that if all fonts fail, we return the first
+  // candidate to be used for rendering the .notdef glyph, and set HasNext() to
+  // false.
   HashSet<uint32_t> unique_font_data_for_range_sets_returned_;
+  scoped_refptr<FontDataForRangeSet> first_candidate_ = nullptr;
   Vector<scoped_refptr<FontDataForRangeSet>> tracked_loading_range_sets_;
   FontFallbackPriority font_fallback_priority_;
 };
diff --git a/third_party/blink/renderer/platform/fonts/font_fallback_list.cc b/third_party/blink/renderer/platform/fonts/font_fallback_list.cc
index a29433a64c5d..a759bfdc53d1 100644
--- a/third_party/blink/renderer/platform/fonts/font_fallback_list.cc
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_list.cc
@@ -33,30 +33,34 @@
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache_key.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_map.h"
 #include "third_party/blink/renderer/platform/fonts/font_family.h"
 #include "third_party/blink/renderer/platform/fonts/segmented_font_data.h"
 #include "third_party/blink/renderer/platform/wtf/text/character_names.h"
 
 namespace blink {
 
-FontFallbackList::FontFallbackList()
+FontFallbackList::FontFallbackList(FontFallbackMap& font_fallback_map)
     : cached_primary_simple_font_data_(nullptr),
-      font_selector_(nullptr),
-      font_selector_version_(0),
+      font_fallback_map_(font_fallback_map),
       family_index_(0),
       generation_(FontCache::GetFontCache()->Generation()),
-      has_loading_fallback_(false) {}
+      has_loading_fallback_(false),
+      has_custom_font_(false),
+      has_advance_override_(false),
+      can_shape_word_by_word_(false),
+      can_shape_word_by_word_computed_(false),
+      is_invalid_(false) {}
 
-void FontFallbackList::Invalidate(FontSelector* font_selector) {
+FontFallbackList::~FontFallbackList() {
   ReleaseFontData();
-  font_list_.clear();
-  cached_primary_simple_font_data_ = nullptr;
-  family_index_ = 0;
-  has_loading_fallback_ = false;
-  if (font_selector_ != font_selector)
-    font_selector_ = font_selector;
-  font_selector_version_ = font_selector_ ? font_selector_->Version() : 0;
-  generation_ = FontCache::GetFontCache()->Generation();
+}
+
+FontSelector* FontFallbackList::GetFontSelector() const {
+  // FontFallbackList objects are managed in FontFallbackMap, and should not be
+  // used after FontFallbackMap is destroyed.
+  DCHECK(font_fallback_map_);
+  return font_fallback_map_->GetFontSelector();
 }
 
 void FontFallbackList::ReleaseFontData() {
@@ -65,25 +69,17 @@ void FontFallbackList::ReleaseFontData() {
     if (!font_list_[i]->IsCustomFont()) {
       DCHECK(!font_list_[i]->IsSegmented());
       FontCache::GetFontCache()->ReleaseFontData(
-          ToSimpleFontData(font_list_[i]));
+          To<SimpleFontData>(font_list_[i].get()));
     }
   }
   shape_cache_.reset();  // Clear the weak pointer to the cache instance.
 }
 
-bool FontFallbackList::LoadingCustomFonts() const {
-  if (!has_loading_fallback_)
-    return false;
-
-  unsigned num_fonts = font_list_.size();
-  for (unsigned i = 0; i < num_fonts; ++i) {
-    if (font_list_[i]->IsLoading())
-      return true;
-  }
-  return false;
-}
-
 bool FontFallbackList::ShouldSkipDrawing() const {
+  // The DCHECK hit will be fixed by the runtime enabled feature below, so we
+  // don't fix it in the legacy code paths.
+  DCHECK(IsValid());
+
   if (!has_loading_fallback_)
     return false;
 
@@ -96,7 +92,7 @@ bool FontFallbackList::ShouldSkipDrawing() const {
 }
 
 const SimpleFontData* FontFallbackList::DeterminePrimarySimpleFontData(
-    const FontDescription& font_description) const {
+    const FontDescription& font_description) {
   bool should_load_custom_font = true;
 
   for (unsigned font_index = 0;; ++font_index) {
@@ -114,8 +110,8 @@ const SimpleFontData* FontFallbackList::DeterminePrimarySimpleFontData(
       return last_resort_fallback;
     }
 
-    if (font_data->IsSegmented() &&
-        !ToSegmentedFontData(font_data)->ContainsCharacter(kSpaceCharacter))
+    const auto* segmented = DynamicTo<SegmentedFontData>(font_data);
+    if (segmented && !segmented->ContainsCharacter(kSpaceCharacter))
       continue;
 
     const SimpleFontData* font_data_for_space =
@@ -128,8 +124,7 @@ const SimpleFontData* FontFallbackList::DeterminePrimarySimpleFontData(
     if (!font_data_for_space->IsLoadingFallback())
       return font_data_for_space;
 
-    if (font_data->IsSegmented()) {
-      const SegmentedFontData* segmented = ToSegmentedFontData(font_data);
+    if (segmented) {
       for (unsigned i = 0; i < segmented->NumFaces(); i++) {
         const SimpleFontData* range_font_data =
             segmented->FaceAt(i)->FontData();
@@ -149,37 +144,58 @@ const SimpleFontData* FontFallbackList::DeterminePrimarySimpleFontData(
 }
 
 scoped_refptr<FontData> FontFallbackList::GetFontData(
-    const FontDescription& font_description,
-    int& family_index) const {
+    const FontDescription& font_description) {
   const FontFamily* curr_family = &font_description.Family();
-  for (int i = 0; curr_family && i < family_index; i++)
+  for (int i = 0; curr_family && i < family_index_; i++)
     curr_family = curr_family->Next();
 
   for (; curr_family; curr_family = curr_family->Next()) {
-    family_index++;
+    family_index_++;
     if (curr_family->Family().length()) {
       scoped_refptr<FontData> result;
-      if (font_selector_)
-        result = font_selector_->GetFontData(font_description,
-                                             curr_family->Family());
-      if (!result)
+      if (GetFontSelector()) {
+        result = GetFontSelector()->GetFontData(font_description,
+                                                curr_family->Family());
+      }
+
+      if (!result) {
         result = FontCache::GetFontCache()->GetFontData(font_description,
                                                         curr_family->Family());
-      if (result)
+        if (GetFontSelector()) {
+          GetFontSelector()->ReportFontLookupByUniqueOrFamilyName(
+              curr_family->Family(), font_description,
+              DynamicTo<SimpleFontData>(result.get()));
+        }
+      }
+      if (result) {
+        if (GetFontSelector()) {
+          GetFontSelector()->ReportSuccessfulFontFamilyMatch(
+              curr_family->Family());
+        }
         return result;
+      }
+
+      if (GetFontSelector())
+        GetFontSelector()->ReportFailedFontFamilyMatch(curr_family->Family());
     }
   }
-  family_index = kCAllFamiliesScanned;
+  family_index_ = kCAllFamiliesScanned;
 
-  if (font_selector_) {
+  if (GetFontSelector()) {
     // Try the user's preferred standard font.
-    if (scoped_refptr<FontData> data = font_selector_->GetFontData(
-            font_description, FontFamilyNames::webkit_standard))
+    if (scoped_refptr<FontData> data = GetFontSelector()->GetFontData(
+            font_description, font_family_names::kWebkitStandard))
       return data;
   }
 
   // Still no result. Hand back our last resort fallback font.
-  return FontCache::GetFontCache()->GetLastResortFallbackFont(font_description);
+  auto last_resort =
+      FontCache::GetFontCache()->GetLastResortFallbackFont(font_description);
+  if (GetFontSelector()) {
+    GetFontSelector()->ReportLastResortFallbackFontLookup(font_description,
+                                                          last_resort.get());
+  }
+  return last_resort;
 }
 
 FallbackListCompositeKey FontFallbackList::CompositeKey(
@@ -191,9 +207,10 @@ FallbackListCompositeKey FontFallbackList::CompositeKey(
       FontFaceCreationParams params(
           AdjustFamilyNameToAvoidUnsupportedFonts(current_family->Family()));
       scoped_refptr<FontData> result;
-      if (font_selector_)
-        result = font_selector_->GetFontData(font_description,
-                                             current_family->Family());
+      if (GetFontSelector()) {
+        result = GetFontSelector()->GetFontData(font_description,
+                                                current_family->Family());
+      }
       if (!result) {
         if (FontPlatformData* platform_data =
                 FontCache::GetFontCache()->GetFontPlatformData(font_description,
@@ -202,9 +219,11 @@ FallbackListCompositeKey FontFallbackList::CompositeKey(
               platform_data);
       }
       if (result) {
-        key.Add(font_description.CacheKey(params));
-        if (!result->IsSegmented() && !result->IsCustomFont())
-          FontCache::GetFontCache()->ReleaseFontData(ToSimpleFontData(result));
+        bool is_unique_match = false;
+        key.Add(font_description.CacheKey(params, is_unique_match));
+        auto* font_data = DynamicTo<SimpleFontData>(result.get());
+        if (!font_data && !result->IsCustomFont())
+          FontCache::GetFontCache()->ReleaseFontData(font_data);
       }
     }
     current_family = current_family->Next();
@@ -215,7 +234,7 @@ FallbackListCompositeKey FontFallbackList::CompositeKey(
 
 const FontData* FontFallbackList::FontDataAt(
     const FontDescription& font_description,
-    unsigned realized_font_index) const {
+    unsigned realized_font_index) {
   // This fallback font is already in our list.
   if (realized_font_index < font_list_.size())
     return font_list_[realized_font_index].get();
@@ -228,24 +247,44 @@ const FontData* FontFallbackList::FontDataAt(
 
   // Ask the font cache for the font data.
   // We are obtaining this font for the first time.  We keep track of the
-  // families we've looked at before in |m_familyIndex|, so that we never scan
-  // the same spot in the list twice.  getFontData will adjust our
-  // |m_familyIndex| as it scans for the right font to make.
+  // families we've looked at before in |family_index_|, so that we never scan
+  // the same spot in the list twice.  GetFontData will adjust our
+  // |family_index_| as it scans for the right font to make.
   DCHECK_EQ(FontCache::GetFontCache()->Generation(), generation_);
-  scoped_refptr<FontData> result = GetFontData(font_description, family_index_);
+  scoped_refptr<FontData> result = GetFontData(font_description);
   if (result) {
     font_list_.push_back(result);
     if (result->IsLoadingFallback())
       has_loading_fallback_ = true;
+    if (result->IsCustomFont())
+      has_custom_font_ = true;
+    if (result->HasAdvanceOverride())
+      has_advance_override_ = true;
   }
   return result.get();
 }
 
-bool FontFallbackList::IsValid() const {
-  if (!font_selector_)
-    return font_selector_version_ == 0;
+bool FontFallbackList::ComputeCanShapeWordByWord(
+    const FontDescription& font_description) {
+  if (!font_description.GetTypesettingFeatures())
+    return true;
 
-  return font_selector_->Version() == font_selector_version_;
+  const SimpleFontData* primary_font = PrimarySimpleFontData(font_description);
+  if (!primary_font)
+    return false;
+
+  const FontPlatformData& platform_data = primary_font->PlatformData();
+  TypesettingFeatures features = font_description.GetTypesettingFeatures();
+  return !platform_data.HasSpaceInLigaturesOrKerning(features);
+}
+
+bool FontFallbackList::CanShapeWordByWord(
+    const FontDescription& font_description) {
+  if (!can_shape_word_by_word_computed_) {
+    can_shape_word_by_word_ = ComputeCanShapeWordByWord(font_description);
+    can_shape_word_by_word_computed_ = true;
+  }
+  return can_shape_word_by_word_;
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_fallback_list.h b/third_party/blink/renderer/platform/fonts/font_fallback_list.h
index 05b8b4bb8ab9..684d089aaba2 100644
--- a/third_party/blink/renderer/platform/fonts/font_fallback_list.h
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_list.h
@@ -27,37 +27,55 @@
 #include "third_party/blink/renderer/platform/fonts/font_selector.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_cache.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/heap/persistent.h"
+#include "third_party/blink/renderer/platform/runtime_enabled_features.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/forward.h"
 #include "third_party/blink/renderer/platform/wtf/ref_counted.h"
 
 namespace blink {
 
 class FontDescription;
+class FontFallbackMap;
 
 const int kCAllFamiliesScanned = -1;
 
+// FontFallbackList caches FontData from FontSelector and FontCache. If font
+// updates occur (e.g., @font-face rule changes, web font is loaded, etc.),
+// the cached data becomes stale and hence, invalid.
 class PLATFORM_EXPORT FontFallbackList : public RefCounted<FontFallbackList> {
-  WTF_MAKE_NONCOPYABLE(FontFallbackList);
+  USING_FAST_MALLOC(FontFallbackList);
 
  public:
-  static scoped_refptr<FontFallbackList> Create() {
-    return base::AdoptRef(new FontFallbackList());
+  static scoped_refptr<FontFallbackList> Create(
+      FontFallbackMap& font_fallback_map) {
+    return base::AdoptRef(new FontFallbackList(font_fallback_map));
   }
 
-  ~FontFallbackList() { ReleaseFontData(); }
-  bool IsValid() const;
-  void Invalidate(FontSelector*);
+  ~FontFallbackList();
+
+  // Returns whether the cached data is valid. We can use a FontFallbackList
+  // only when it's valid.
+  bool IsValid() const { return !is_invalid_; }
+
+  // Called when font updates (see class comment) have made the cached data
+  // invalid. Once marked, a Font object cannot reuse |this|, but have to work
+  // on a new instance obtained from FontFallbackMap.
+  void MarkInvalid() {
+    is_invalid_ = true;
+  }
 
-  bool LoadingCustomFonts() const;
   bool ShouldSkipDrawing() const;
 
-  FontSelector* GetFontSelector() const { return font_selector_.Get(); }
-  // FIXME: It should be possible to combine fontSelectorVersion and generation.
-  unsigned FontSelectorVersion() const { return font_selector_version_; }
-  unsigned Generation() const { return generation_; }
+  // Returns false only after the WeakPersistent to FontFallbackMap is turned to
+  // nullptr due to GC.
+  bool HasFontFallbackMap() const { return font_fallback_map_; }
+  FontFallbackMap& GetFontFallbackMap() const { return *font_fallback_map_; }
 
-  ShapeCache* GetShapeCache(const FontDescription& font_description) const {
+  FontSelector* GetFontSelector() const;
+  uint16_t Generation() const { return generation_; }
+
+  ShapeCache* GetShapeCache(const FontDescription& font_description) {
     if (!shape_cache_) {
       FallbackListCompositeKey key = CompositeKey(font_description);
       shape_cache_ =
@@ -78,28 +96,46 @@ class PLATFORM_EXPORT FontFallbackList : public RefCounted<FontFallbackList> {
     }
     return cached_primary_simple_font_data_;
   }
-  const FontData* FontDataAt(const FontDescription&, unsigned index) const;
+  const FontData* FontDataAt(const FontDescription&, unsigned index);
+
+  bool CanShapeWordByWord(const FontDescription&);
+
+  void SetCanShapeWordByWordForTesting(bool b) {
+    can_shape_word_by_word_ = b;
+    can_shape_word_by_word_computed_ = true;
+  }
+
+  bool HasLoadingFallback() const { return has_loading_fallback_; }
+  bool HasCustomFont() const { return has_custom_font_; }
+  bool HasAdvanceOverride() const { return has_advance_override_; }
+
+ private:
+  explicit FontFallbackList(FontFallbackMap& font_fallback_map);
+
+  scoped_refptr<FontData> GetFontData(const FontDescription&);
+
+  const SimpleFontData* DeterminePrimarySimpleFontData(const FontDescription&);
 
   FallbackListCompositeKey CompositeKey(const FontDescription&) const;
 
- private:
-  FontFallbackList();
-
-  scoped_refptr<FontData> GetFontData(const FontDescription&, int& family_index) const;
-
-  const SimpleFontData* DeterminePrimarySimpleFontData(
-      const FontDescription&) const;
-
   void ReleaseFontData();
+  bool ComputeCanShapeWordByWord(const FontDescription&);
 
-  mutable Vector<scoped_refptr<FontData>, 1> font_list_;
-  mutable const SimpleFontData* cached_primary_simple_font_data_;
-  Persistent<FontSelector> font_selector_;
-  unsigned font_selector_version_;
-  mutable int family_index_;
-  unsigned short generation_;
-  mutable bool has_loading_fallback_ : 1;
-  mutable base::WeakPtr<ShapeCache> shape_cache_;
+  Vector<scoped_refptr<FontData>, 1> font_list_;
+  const SimpleFontData* cached_primary_simple_font_data_;
+  const WeakPersistent<FontFallbackMap> font_fallback_map_;
+  int family_index_;
+  uint16_t generation_;
+  bool has_loading_fallback_ : 1;
+  bool has_custom_font_ : 1;
+  bool has_advance_override_ : 1;
+  bool can_shape_word_by_word_ : 1;
+  bool can_shape_word_by_word_computed_ : 1;
+  bool is_invalid_ : 1;
+
+  base::WeakPtr<ShapeCache> shape_cache_;
+
+  DISALLOW_COPY_AND_ASSIGN(FontFallbackList);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_fallback_map.cc b/third_party/blink/renderer/platform/fonts/font_fallback_map.cc
new file mode 100644
index 000000000000..624a815e4a53
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_map.cc
@@ -0,0 +1,81 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/font_fallback_map.h"
+
+#include "third_party/blink/renderer/platform/fonts/font_selector.h"
+
+namespace blink {
+
+void FontFallbackMap::Trace(Visitor* visitor) const {
+  visitor->Trace(font_selector_);
+  FontCacheClient::Trace(visitor);
+  FontSelectorClient::Trace(visitor);
+}
+
+FontFallbackMap::~FontFallbackMap() {
+  InvalidateAll();
+}
+
+scoped_refptr<FontFallbackList> FontFallbackMap::Get(
+    const FontDescription& font_description) {
+  auto iter = fallback_list_for_description_.find(font_description);
+  if (iter != fallback_list_for_description_.end()) {
+    DCHECK(iter->value->IsValid());
+    return iter->value;
+  }
+  auto add_result = fallback_list_for_description_.insert(
+      font_description, FontFallbackList::Create(*this));
+  return add_result.stored_value->value;
+}
+
+void FontFallbackMap::Remove(const FontDescription& font_description) {
+  auto iter = fallback_list_for_description_.find(font_description);
+  DCHECK_NE(iter, fallback_list_for_description_.end());
+  DCHECK(iter->value->IsValid());
+  DCHECK(iter->value->HasOneRef());
+  fallback_list_for_description_.erase(iter);
+}
+
+void FontFallbackMap::InvalidateAll() {
+  for (auto& entry : fallback_list_for_description_)
+    entry.value->MarkInvalid();
+  fallback_list_for_description_.clear();
+}
+
+template <typename Predicate>
+void FontFallbackMap::InvalidateInternal(Predicate predicate) {
+  Vector<FontDescription> invalidated;
+  for (auto& entry : fallback_list_for_description_) {
+    if (predicate(*entry.value)) {
+      invalidated.push_back(entry.key);
+      entry.value->MarkInvalid();
+    }
+  }
+  fallback_list_for_description_.RemoveAll(invalidated);
+}
+
+void FontFallbackMap::FontsNeedUpdate(FontSelector*,
+                                      FontInvalidationReason reason) {
+  switch (reason) {
+    case FontInvalidationReason::kFontFaceLoaded:
+      InvalidateInternal([](const FontFallbackList& fallback_list) {
+        return fallback_list.HasLoadingFallback();
+      });
+      break;
+    case FontInvalidationReason::kFontFaceDeleted:
+      InvalidateInternal([](const FontFallbackList& fallback_list) {
+        return fallback_list.HasCustomFont();
+      });
+      break;
+    default:
+      InvalidateAll();
+  }
+}
+
+void FontFallbackMap::FontCacheInvalidated() {
+  InvalidateAll();
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_fallback_map.h b/third_party/blink/renderer/platform/fonts/font_fallback_map.h
new file mode 100644
index 000000000000..135f11244783
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_map.h
@@ -0,0 +1,54 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_FALLBACK_MAP_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_FALLBACK_MAP_H_
+
+#include "third_party/blink/renderer/platform/fonts/font_cache_client.h"
+#include "third_party/blink/renderer/platform/fonts/font_description.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_list.h"
+#include "third_party/blink/renderer/platform/fonts/font_selector_client.h"
+#include "third_party/blink/renderer/platform/heap/handle.h"
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/wtf/vector.h"
+
+class FontSelector;
+
+namespace blink {
+
+class PLATFORM_EXPORT FontFallbackMap : public FontCacheClient,
+                                        public FontSelectorClient {
+ public:
+  explicit FontFallbackMap(FontSelector* font_selector)
+      : font_selector_(font_selector) {}
+
+  ~FontFallbackMap() override;
+
+  FontSelector* GetFontSelector() const { return font_selector_; }
+
+  scoped_refptr<FontFallbackList> Get(const FontDescription& font_description);
+  void Remove(const FontDescription& font_description);
+
+  void Trace(Visitor* visitor) const override;
+
+ private:
+  // FontSelectorClient
+  void FontsNeedUpdate(FontSelector*, FontInvalidationReason) override;
+
+  // FontCacheClient
+  void FontCacheInvalidated() override;
+
+  void InvalidateAll();
+
+  template <typename Predicate>
+  void InvalidateInternal(Predicate predicate);
+
+  Member<FontSelector> font_selector_;
+  HashMap<FontDescription, scoped_refptr<FontFallbackList>>
+      fallback_list_for_description_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_SELECTOR_H_
diff --git a/third_party/blink/renderer/platform/fonts/font_fallback_priority.cc b/third_party/blink/renderer/platform/fonts/font_fallback_priority.cc
index 5310cde786b0..b8c6544bbed1 100644
--- a/third_party/blink/renderer/platform/fonts/font_fallback_priority.cc
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_priority.cc
@@ -9,6 +9,6 @@ namespace blink {
 bool IsNonTextFallbackPriority(FontFallbackPriority fallback_priority) {
   return fallback_priority == FontFallbackPriority::kEmojiText ||
          fallback_priority == FontFallbackPriority::kEmojiEmoji;
-};
+}
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_fallback_priority.h b/third_party/blink/renderer/platform/fonts/font_fallback_priority.h
index 5626be46fe27..173601b125f6 100644
--- a/third_party/blink/renderer/platform/fonts/font_fallback_priority.h
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_priority.h
@@ -24,6 +24,6 @@ enum class FontFallbackPriority {
 
 bool IsNonTextFallbackPriority(FontFallbackPriority);
 
-};  // namespace blink
+}  // namespace blink
 
 #endif
diff --git a/third_party/blink/renderer/platform/fonts/font_family.cc b/third_party/blink/renderer/platform/fonts/font_family.cc
index 4aafd636d98a..1ad8aa04bb73 100644
--- a/third_party/blink/renderer/platform/fonts/font_family.cc
+++ b/third_party/blink/renderer/platform/fonts/font_family.cc
@@ -44,6 +44,12 @@ bool operator==(const FontFamily& a, const FontFamily& b) {
   return true;
 }
 
+void FontFamily::AppendFamily(AtomicString family) {
+  scoped_refptr<SharedFontFamily> appended_family = SharedFontFamily::Create();
+  appended_family->SetFamily(family);
+  AppendFamily(appended_family);
+}
+
 String FontFamily::ToString() const {
   StringBuilder builder;
   builder.Append(family_);
diff --git a/third_party/blink/renderer/platform/fonts/font_family.h b/third_party/blink/renderer/platform/fonts/font_family.h
index 90b03b7631fd..aa0cf82a9f20 100644
--- a/third_party/blink/renderer/platform/fonts/font_family.h
+++ b/third_party/blink/renderer/platform/fonts/font_family.h
@@ -50,6 +50,7 @@ class PLATFORM_EXPORT FontFamily {
   const FontFamily* Next() const;
 
   void AppendFamily(scoped_refptr<SharedFontFamily>);
+  void AppendFamily(AtomicString family);
   scoped_refptr<SharedFontFamily> ReleaseNext();
 
   // Returns this font family's name followed by all subsequent linked
diff --git a/third_party/blink/renderer/platform/fonts/font_family_names.json5 b/third_party/blink/renderer/platform/fonts/font_family_names.json5
index 638bf7995fe7..ac7a142f9bf9 100644
--- a/third_party/blink/renderer/platform/fonts/font_family_names.json5
+++ b/third_party/blink/renderer/platform/fonts/font_family_names.json5
@@ -1,6 +1,6 @@
 {
   metadata: {
-    namespace: "FontFamily",
+    namespace: "font_family_names",
     export: "PLATFORM_EXPORT",
   },
 
diff --git a/third_party/blink/renderer/platform/fonts/font_global_context.cc b/third_party/blink/renderer/platform/fonts/font_global_context.cc
index bbdabeddf37d..bd422ac3c84d 100644
--- a/third_party/blink/renderer/platform/fonts/font_global_context.cc
+++ b/third_party/blink/renderer/platform/fonts/font_global_context.cc
@@ -5,8 +5,16 @@
 #include "third_party/blink/renderer/platform/fonts/font_global_context.h"
 
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
+#include "third_party/blink/renderer/platform/fonts/font_unique_name_lookup.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_cache.h"
+#include "third_party/blink/renderer/platform/privacy_budget/identifiability_digest_helpers.h"
 #include "third_party/blink/renderer/platform/wtf/thread_specific.h"
 
+// While the size of these caches should usually be small (up to tens), we
+// protect against the possibility of it growing quickly to thousands when
+// animating variable font parameters.
+static constexpr size_t kCachesMaxSize = 250;
+
 namespace blink {
 
 FontGlobalContext* FontGlobalContext::Get(CreateIfNeeded create_if_needed) {
@@ -18,18 +26,77 @@ FontGlobalContext* FontGlobalContext::Get(CreateIfNeeded create_if_needed) {
   return *font_persistent;
 }
 
-FontGlobalContext::FontGlobalContext() : harfbuzz_font_funcs_(nullptr) {}
+FontGlobalContext::FontGlobalContext()
+    : harfbuzz_font_funcs_skia_advances_(nullptr),
+      harfbuzz_font_funcs_harfbuzz_advances_(nullptr),
+      typeface_digest_cache_(kCachesMaxSize),
+      postscript_name_digest_cache_(kCachesMaxSize) {}
 
-void FontGlobalContext::ClearMemory() {
-  if (!Get(kDoNotCreate))
-    return;
+FontGlobalContext::~FontGlobalContext() = default;
 
-  GetFontCache().Invalidate();
+FontUniqueNameLookup* FontGlobalContext::GetFontUniqueNameLookup() {
+  if (!Get()->font_unique_name_lookup_) {
+    Get()->font_unique_name_lookup_ =
+        FontUniqueNameLookup::GetPlatformUniqueNameLookup();
+  }
+  return Get()->font_unique_name_lookup_.get();
 }
 
-void FontGlobalContext::ClearForTesting() {
-  FontGlobalContext* ctx = Get();
-  ctx->font_cache_.Invalidate();
+HarfBuzzFontCache* FontGlobalContext::GetHarfBuzzFontCache() {
+  std::unique_ptr<HarfBuzzFontCache>& global_context_harfbuzz_font_cache =
+      Get()->harfbuzz_font_cache_;
+  if (!global_context_harfbuzz_font_cache) {
+    global_context_harfbuzz_font_cache = std::make_unique<HarfBuzzFontCache>();
+  }
+  return global_context_harfbuzz_font_cache.get();
+}
+
+IdentifiableToken FontGlobalContext::GetOrComputeTypefaceDigest(
+    const FontPlatformData& source) {
+  SkTypeface* typeface = source.Typeface();
+  if (!typeface)
+    return 0;
+
+  SkFontID font_id = typeface->uniqueID();
+
+  IdentifiableToken* cached_value = typeface_digest_cache_.Get(font_id);
+  if (!cached_value) {
+    typeface_digest_cache_.Put(font_id, source.ComputeTypefaceDigest());
+    cached_value = typeface_digest_cache_.Get(font_id);
+  } else {
+    DCHECK(*cached_value == source.ComputeTypefaceDigest());
+  }
+  return *cached_value;
+}
+
+IdentifiableToken FontGlobalContext::GetOrComputePostScriptNameDigest(
+    const FontPlatformData& source) {
+  SkTypeface* typeface = source.Typeface();
+  if (!typeface)
+    return IdentifiableToken();
+
+  SkFontID font_id = typeface->uniqueID();
+
+  IdentifiableToken* cached_value = postscript_name_digest_cache_.Get(font_id);
+  if (!cached_value) {
+    postscript_name_digest_cache_.Put(
+        font_id, IdentifiabilityBenignStringToken(source.GetPostScriptName()));
+    cached_value = postscript_name_digest_cache_.Get(font_id);
+  } else {
+    DCHECK(*cached_value ==
+           IdentifiabilityBenignStringToken(source.GetPostScriptName()));
+  }
+  return *cached_value;
+}
+
+void FontGlobalContext::ClearMemory() {
+  FontGlobalContext* context = Get(kDoNotCreate);
+  if (!context)
+    return;
+
+  context->font_cache_.Invalidate();
+  context->typeface_digest_cache_.Clear();
+  context->postscript_name_digest_cache_.Clear();
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_global_context.h b/third_party/blink/renderer/platform/fonts/font_global_context.h
index 928df28d42dd..250868bf6709 100644
--- a/third_party/blink/renderer/platform/fonts/font_global_context.h
+++ b/third_party/blink/renderer/platform/fonts/font_global_context.h
@@ -5,55 +5,82 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_GLOBAL_CONTEXT_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_GLOBAL_CONTEXT_H_
 
+#include "third_party/blink/public/common/privacy_budget/identifiable_token.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
-#include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_cache.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/text/layout_locale.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/lru_cache.h"
+#include "third_party/skia/include/core/SkTypeface.h"
 
 struct hb_font_funcs_t;
 
 namespace blink {
 
 class FontCache;
-
-enum CreateIfNeeded { kDoNotCreate, kCreate };
+class FontUniqueNameLookup;
+class HarfBuzzFontCache;
 
 // FontGlobalContext contains non-thread-safe, thread-specific data used for
 // font formatting.
 class PLATFORM_EXPORT FontGlobalContext {
-  WTF_MAKE_NONCOPYABLE(FontGlobalContext);
+  USING_FAST_MALLOC(FontGlobalContext);
 
  public:
   static FontGlobalContext* Get(CreateIfNeeded = kCreate);
 
-  static inline FontCache& GetFontCache() { return Get()->font_cache_; }
-
-  static inline HarfBuzzFontCache& GetHarfBuzzFontCache() {
-    return Get()->harfbuzz_font_cache_;
+  static inline FontCache* GetFontCache(CreateIfNeeded create = kCreate) {
+    FontGlobalContext* context = Get(create);
+    return context ? &context->font_cache_ : nullptr;
   }
 
-  static hb_font_funcs_t* GetHarfBuzzFontFuncs() {
-    return Get()->harfbuzz_font_funcs_;
+  static HarfBuzzFontCache* GetHarfBuzzFontCache();
+
+  enum HorizontalAdvanceSource {
+    kSkiaHorizontalAdvances,
+    kHarfBuzzHorizontalAdvances
+  };
+
+  static hb_font_funcs_t* GetHarfBuzzFontFuncs(
+      HorizontalAdvanceSource advance_source) {
+    if (advance_source == kHarfBuzzHorizontalAdvances) {
+      return Get()->harfbuzz_font_funcs_harfbuzz_advances_;
+    }
+    return Get()->harfbuzz_font_funcs_skia_advances_;
   }
 
-  static void SetHarfBuzzFontFuncs(hb_font_funcs_t* funcs) {
-    Get()->harfbuzz_font_funcs_ = funcs;
+  static void SetHarfBuzzFontFuncs(HorizontalAdvanceSource advance_source,
+                                   hb_font_funcs_t* funcs) {
+    if (advance_source == kHarfBuzzHorizontalAdvances) {
+      Get()->harfbuzz_font_funcs_harfbuzz_advances_ = funcs;
+    }
+    Get()->harfbuzz_font_funcs_skia_advances_ = funcs;
   }
 
-  // Called by MemoryCoordinator to clear memory.
+  static FontUniqueNameLookup* GetFontUniqueNameLookup();
+
+  IdentifiableToken GetOrComputeTypefaceDigest(const FontPlatformData& source);
+  IdentifiableToken GetOrComputePostScriptNameDigest(
+      const FontPlatformData& source);
+
+  // Called by MemoryPressureListenerRegistry to clear memory.
   static void ClearMemory();
 
-  static void ClearForTesting();
-
  private:
   friend class WTF::ThreadSpecific<FontGlobalContext>;
 
   FontGlobalContext();
-  ~FontGlobalContext() = default;
+  ~FontGlobalContext();
 
   FontCache font_cache_;
-  HarfBuzzFontCache harfbuzz_font_cache_;
-  hb_font_funcs_t* harfbuzz_font_funcs_;
+  std::unique_ptr<HarfBuzzFontCache> harfbuzz_font_cache_;
+  hb_font_funcs_t* harfbuzz_font_funcs_skia_advances_;
+  hb_font_funcs_t* harfbuzz_font_funcs_harfbuzz_advances_;
+  std::unique_ptr<FontUniqueNameLookup> font_unique_name_lookup_;
+  WTF::LruCache<SkFontID, IdentifiableToken> typeface_digest_cache_;
+  WTF::LruCache<SkFontID, IdentifiableToken> postscript_name_digest_cache_;
+
+  DISALLOW_COPY_AND_ASSIGN(FontGlobalContext);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_height.cc b/third_party/blink/renderer/platform/fonts/font_height.cc
new file mode 100644
index 000000000000..eaefe4dee7e4
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/font_height.cc
@@ -0,0 +1,42 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/font_height.h"
+
+namespace blink {
+
+void FontHeight::AddLeading(LayoutUnit line_height) {
+  DCHECK(!IsEmpty());
+  LayoutUnit half_leading = (line_height - (ascent + descent)) / 2;
+  // TODO(kojii): floor() is to make text dump compatible with legacy test
+  // results. Revisit when we paint.
+  ascent += half_leading.Floor();
+  descent = line_height - ascent;
+}
+
+void FontHeight::Move(LayoutUnit delta) {
+  DCHECK(!IsEmpty());
+  ascent -= delta;
+  descent += delta;
+}
+
+void FontHeight::Unite(const FontHeight& other) {
+  ascent = std::max(ascent, other.ascent);
+  descent = std::max(descent, other.descent);
+}
+
+void FontHeight::operator+=(const FontHeight& other) {
+  DCHECK(ascent != LayoutUnit::Min() && descent != LayoutUnit::Min());
+  DCHECK(other.ascent != LayoutUnit::Min() &&
+         other.descent != LayoutUnit::Min());
+  ascent += other.ascent;
+  descent += other.descent;
+}
+
+std::ostream& operator<<(std::ostream& stream, const FontHeight& metrics) {
+  return stream << "ascent=" << metrics.ascent
+                << ", descent=" << metrics.descent;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_height.h b/third_party/blink/renderer/platform/fonts/font_height.h
new file mode 100644
index 000000000000..6e6e7a8e02e8
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/font_height.h
@@ -0,0 +1,57 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_HEIGHT_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_HEIGHT_H_
+
+#include "third_party/blink/renderer/platform/fonts/font_baseline.h"
+#include "third_party/blink/renderer/platform/geometry/layout_unit.h"
+
+namespace blink {
+
+// Represents line-progression metrics for line boxes and inline boxes.
+// Computed for inline boxes, then the metrics of inline boxes are united to
+// compute metrics for line boxes.
+// https://drafts.csswg.org/css2/visudet.html#line-height
+struct PLATFORM_EXPORT FontHeight {
+  FontHeight() = default;
+  FontHeight(LayoutUnit ascent, LayoutUnit descent)
+      : ascent(ascent), descent(descent) {}
+
+  // "Empty" is for when zero is a valid non-empty value.
+  static FontHeight Empty() {
+    return FontHeight(LayoutUnit::Min(), LayoutUnit::Min());
+  }
+  bool IsEmpty() const { return ascent == LayoutUnit::Min(); }
+
+  LayoutUnit LineHeight() const { return ascent + descent; }
+
+  bool operator==(const FontHeight& other) const {
+    return ascent == other.ascent && descent == other.descent;
+  }
+  bool operator!=(const FontHeight& other) const { return !operator==(other); }
+
+  // Add the leading. Half the leading is added to ascent and descent each.
+  // https://drafts.csswg.org/css2/visudet.html#leading
+  void AddLeading(LayoutUnit line_height);
+
+  // Move the metrics by the specified amount, in line progression direction.
+  void Move(LayoutUnit);
+
+  // Unite a metrics for an inline box to a metrics for a line box.
+  void Unite(const FontHeight&);
+
+  void operator+=(const FontHeight&);
+
+  // Ascent and descent of glyphs, or synthesized for replaced elements.
+  // Then united to compute 'text-top' and 'text-bottom' of line boxes.
+  LayoutUnit ascent;
+  LayoutUnit descent;
+};
+
+PLATFORM_EXPORT std::ostream& operator<<(std::ostream&, const FontHeight&);
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_HEIGHT_H_
diff --git a/third_party/blink/renderer/platform/fonts/font_invalidation_reason.h b/third_party/blink/renderer/platform/fonts/font_invalidation_reason.h
new file mode 100644
index 000000000000..5efa9333aed6
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/font_invalidation_reason.h
@@ -0,0 +1,24 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_INVALIDATION_REASON_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_INVALIDATION_REASON_H_
+
+namespace blink {
+
+// Notifies FontSelectorClient of detailed reason of FontSelection invalidation.
+enum class FontInvalidationReason {
+  // The default reason without any specific details.
+  kGeneralInvalidation,
+  // A custom font has finished loading and is ready for use.
+  kFontFaceLoaded,
+  // A @font-face rule has been deleted.
+  kFontFaceDeleted,
+  // TODO(xiaochengh): Add more detailed entries for different callers, and
+  // implement different behaviors on FontSelectorClient.
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_INVALIDATION_REASON_H_
diff --git a/third_party/blink/renderer/platform/fonts/font_matching_metrics.cc b/third_party/blink/renderer/platform/fonts/font_matching_metrics.cc
new file mode 100644
index 000000000000..32e74cf0ee3c
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/font_matching_metrics.cc
@@ -0,0 +1,385 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/font_matching_metrics.h"
+
+#include "base/metrics/histogram_macros.h"
+#include "services/metrics/public/cpp/metrics_utils.h"
+#include "services/metrics/public/cpp/ukm_builders.h"
+#include "services/metrics/public/cpp/ukm_recorder.h"
+#include "third_party/blink/public/common/privacy_budget/identifiability_metric_builder.h"
+#include "third_party/blink/public/common/privacy_budget/identifiability_study_settings.h"
+#include "third_party/blink/public/common/privacy_budget/identifiable_surface.h"
+#include "third_party/blink/public/common/privacy_budget/identifiable_token.h"
+#include "third_party/blink/renderer/platform/fonts/font_global_context.h"
+#include "third_party/blink/renderer/platform/privacy_budget/identifiability_digest_helpers.h"
+
+namespace {
+
+constexpr double kUkmFontLoadCountBucketSpacing = 1.3;
+
+template <typename T>
+HashSet<T> SetIntersection(const HashSet<T>& a, const HashSet<T>& b) {
+  HashSet<T> result;
+  for (const T& a_value : a) {
+    if (b.Contains(a_value))
+      result.insert(a_value);
+  }
+  return result;
+}
+
+}  // namespace
+
+namespace blink {
+
+FontMatchingMetrics::FontMatchingMetrics(
+    bool top_level,
+    ukm::UkmRecorder* ukm_recorder,
+    ukm::SourceId source_id,
+    scoped_refptr<base::SingleThreadTaskRunner> task_runner)
+    : load_context_(top_level ? kTopLevelFrame : kSubframe),
+      ukm_recorder_(ukm_recorder),
+      source_id_(source_id),
+      identifiability_metrics_timer_(
+          task_runner,
+          this,
+          &FontMatchingMetrics::IdentifiabilityMetricsTimerFired) {
+  Initialize();
+}
+
+FontMatchingMetrics::FontMatchingMetrics(
+    ukm::UkmRecorder* ukm_recorder,
+    ukm::SourceId source_id,
+    scoped_refptr<base::SingleThreadTaskRunner> task_runner)
+    : load_context_(kWorker),
+      ukm_recorder_(ukm_recorder),
+      source_id_(source_id),
+      identifiability_metrics_timer_(
+          task_runner,
+          this,
+          &FontMatchingMetrics::IdentifiabilityMetricsTimerFired) {
+  Initialize();
+}
+
+void FontMatchingMetrics::Initialize() {
+  // Estimate of average page font use from anecdotal browsing session.
+  constexpr unsigned kEstimatedFontCount = 7;
+  local_fonts_succeeded_.ReserveCapacityForSize(kEstimatedFontCount);
+  local_fonts_failed_.ReserveCapacityForSize(kEstimatedFontCount);
+}
+
+void FontMatchingMetrics::ReportSuccessfulFontFamilyMatch(
+    const AtomicString& font_family_name) {
+  successful_font_families_.insert(font_family_name);
+}
+
+void FontMatchingMetrics::ReportFailedFontFamilyMatch(
+    const AtomicString& font_family_name) {
+  failed_font_families_.insert(font_family_name);
+}
+
+void FontMatchingMetrics::ReportSystemFontFamily(
+    const AtomicString& font_family_name) {
+  system_font_families_.insert(font_family_name);
+}
+
+void FontMatchingMetrics::ReportWebFontFamily(
+    const AtomicString& font_family_name) {
+  web_font_families_.insert(font_family_name);
+}
+
+void FontMatchingMetrics::ReportSuccessfulLocalFontMatch(
+    const AtomicString& font_name) {
+  local_fonts_succeeded_.insert(font_name);
+  ReportLocalFontExistenceByUniqueNameOnly(font_name, /*font_exists=*/true);
+}
+
+void FontMatchingMetrics::ReportFailedLocalFontMatch(
+    const AtomicString& font_name) {
+  local_fonts_failed_.insert(font_name);
+  ReportLocalFontExistenceByUniqueNameOnly(font_name, /*font_exists=*/false);
+}
+
+void FontMatchingMetrics::ReportLocalFontExistenceByUniqueNameOnly(
+    const AtomicString& font_name,
+    bool font_exists) {
+  if (!IdentifiabilityStudySettings::Get()->IsTypeAllowed(
+          IdentifiableSurface::Type::kLocalFontExistenceByUniqueNameOnly)) {
+    return;
+  }
+  IdentifiableTokenKey input_key(
+      IdentifiabilityBenignCaseFoldingStringToken(font_name));
+  local_font_existence_by_unique_name_only_.insert(input_key, font_exists);
+}
+
+void FontMatchingMetrics::InsertFontHashIntoMap(IdentifiableTokenKey input_key,
+                                                SimpleFontData* font_data,
+                                                TokenToTokenHashMap& hash_map) {
+  DCHECK(IdentifiabilityStudySettings::Get()->IsActive());
+  if (hash_map.Contains(input_key))
+    return;
+  IdentifiableToken output_token(GetHashForFontData(font_data));
+  hash_map.insert(input_key, output_token);
+
+  // We only record postscript name metrics if both the the broader lookup's
+  // type and kLocalFontLoadPostScriptName are allowed. (If the former is not,
+  // InsertFontHashIntoMap would not be called.)
+  if (!font_data ||
+      !IdentifiabilityStudySettings::Get()->IsTypeAllowed(
+          IdentifiableSurface::Type::kLocalFontLoadPostScriptName)) {
+    return;
+  }
+  IdentifiableTokenKey postscript_name_key(
+      GetPostScriptNameTokenForFontData(font_data));
+  font_load_postscript_name_.insert(postscript_name_key, output_token);
+}
+
+IdentifiableTokenBuilder
+FontMatchingMetrics::GetTokenBuilderWithFontSelectionRequest(
+    const FontDescription& font_description) {
+  IdentifiableTokenBuilder builder;
+  builder.AddValue(font_description.GetFontSelectionRequest().GetHash());
+  return builder;
+}
+
+void FontMatchingMetrics::ReportFontLookupByUniqueOrFamilyName(
+    const AtomicString& name,
+    const FontDescription& font_description,
+    SimpleFontData* resulting_font_data) {
+  if (!IdentifiabilityStudySettings::Get()->IsTypeAllowed(
+          IdentifiableSurface::Type::kLocalFontLookupByUniqueOrFamilyName)) {
+    return;
+  }
+  OnFontLookup();
+
+  IdentifiableTokenBuilder builder =
+      GetTokenBuilderWithFontSelectionRequest(font_description);
+
+  // Font name lookups are case-insensitive.
+  builder.AddToken(IdentifiabilityBenignCaseFoldingStringToken(name));
+
+  IdentifiableTokenKey input_key(builder.GetToken());
+  InsertFontHashIntoMap(input_key, resulting_font_data,
+                        font_lookups_by_unique_or_family_name_);
+}
+
+void FontMatchingMetrics::ReportFontLookupByUniqueNameOnly(
+    const AtomicString& name,
+    const FontDescription& font_description,
+    SimpleFontData* resulting_font_data,
+    bool is_loading_fallback) {
+  // We ignore lookups that result in loading fallbacks for now as they should
+  // only be temporary.
+  if (is_loading_fallback ||
+      !IdentifiabilityStudySettings::Get()->IsTypeAllowed(
+          IdentifiableSurface::Type::kLocalFontLookupByUniqueNameOnly)) {
+    return;
+  }
+  OnFontLookup();
+
+  IdentifiableTokenBuilder builder =
+      GetTokenBuilderWithFontSelectionRequest(font_description);
+
+  // Font name lookups are case-insensitive.
+  builder.AddToken(IdentifiabilityBenignCaseFoldingStringToken(name));
+
+  IdentifiableTokenKey input_key(builder.GetToken());
+  InsertFontHashIntoMap(input_key, resulting_font_data,
+                        font_lookups_by_unique_name_only_);
+}
+
+void FontMatchingMetrics::ReportFontLookupByFallbackCharacter(
+    UChar32 fallback_character,
+    FontFallbackPriority fallback_priority,
+    const FontDescription& font_description,
+    SimpleFontData* resulting_font_data) {
+  if (!IdentifiabilityStudySettings::Get()->IsTypeAllowed(
+          IdentifiableSurface::Type::kLocalFontLookupByFallbackCharacter)) {
+    return;
+  }
+  OnFontLookup();
+
+  IdentifiableTokenBuilder builder =
+      GetTokenBuilderWithFontSelectionRequest(font_description);
+  builder.AddValue(fallback_character)
+      .AddToken(IdentifiableToken(fallback_priority));
+
+  IdentifiableTokenKey input_key(builder.GetToken());
+  InsertFontHashIntoMap(input_key, resulting_font_data,
+                        font_lookups_by_fallback_character_);
+}
+
+void FontMatchingMetrics::ReportLastResortFallbackFontLookup(
+    const FontDescription& font_description,
+    SimpleFontData* resulting_font_data) {
+  if (!IdentifiabilityStudySettings::Get()->IsTypeAllowed(
+          IdentifiableSurface::Type::kLocalFontLookupAsLastResort)) {
+    return;
+  }
+  OnFontLookup();
+
+  IdentifiableTokenBuilder builder =
+      GetTokenBuilderWithFontSelectionRequest(font_description);
+
+  IdentifiableTokenKey input_key(builder.GetToken());
+  InsertFontHashIntoMap(input_key, resulting_font_data,
+                        font_lookups_as_last_resort_);
+}
+
+void FontMatchingMetrics::ReportFontFamilyLookupByGenericFamily(
+    const AtomicString& generic_font_family_name,
+    UScriptCode script,
+    FontDescription::GenericFamilyType generic_family_type,
+    const AtomicString& resulting_font_name) {
+  if (!IdentifiabilityStudySettings::Get()->IsTypeAllowed(
+          IdentifiableSurface::Type::kGenericFontLookup)) {
+    return;
+  }
+  OnFontLookup();
+
+  // kStandardFamily lookups override the |generic_font_family_name|. See
+  // FontSelector::FamilyNameFromSettings. No need to be case-insensitive as
+  // generic names should already be lowercase.
+  DCHECK(generic_family_type == FontDescription::kStandardFamily ||
+         generic_font_family_name == generic_font_family_name.LowerASCII());
+  IdentifiableToken lookup_name_token = IdentifiabilityBenignStringToken(
+      generic_family_type == FontDescription::kStandardFamily
+          ? font_family_names::kWebkitStandard
+          : generic_font_family_name);
+
+  IdentifiableTokenBuilder builder;
+  builder.AddToken(lookup_name_token).AddToken(IdentifiableToken(script));
+  IdentifiableTokenKey input_key(builder.GetToken());
+
+  // Font name lookups are case-insensitive.
+  generic_font_lookups_.insert(
+      input_key,
+      IdentifiabilityBenignCaseFoldingStringToken(resulting_font_name));
+}
+
+void FontMatchingMetrics::ReportEmojiSegmentGlyphCoverage(
+    unsigned num_clusters,
+    unsigned num_broken_clusters) {
+  total_emoji_clusters_shaped_ += num_clusters;
+  total_broken_emoji_clusters_ += num_broken_clusters;
+}
+
+void FontMatchingMetrics::PublishIdentifiabilityMetrics() {
+  if (!IdentifiabilityStudySettings::Get()->IsActive())
+    return;
+
+  IdentifiabilityMetricBuilder builder(source_id_);
+
+  std::pair<TokenToTokenHashMap*, IdentifiableSurface::Type>
+      hash_maps_with_corresponding_surface_types[] = {
+          {&font_lookups_by_unique_or_family_name_,
+           IdentifiableSurface::Type::kLocalFontLookupByUniqueOrFamilyName},
+          {&font_lookups_by_unique_name_only_,
+           IdentifiableSurface::Type::kLocalFontLookupByUniqueNameOnly},
+          {&font_lookups_by_fallback_character_,
+           IdentifiableSurface::Type::kLocalFontLookupByFallbackCharacter},
+          {&font_lookups_as_last_resort_,
+           IdentifiableSurface::Type::kLocalFontLookupAsLastResort},
+          {&generic_font_lookups_,
+           IdentifiableSurface::Type::kGenericFontLookup},
+          {&font_load_postscript_name_,
+           IdentifiableSurface::Type::kLocalFontLoadPostScriptName},
+          {&local_font_existence_by_unique_name_only_,
+           IdentifiableSurface::Type::kLocalFontExistenceByUniqueNameOnly},
+      };
+
+  for (const auto& surface_entry : hash_maps_with_corresponding_surface_types) {
+    TokenToTokenHashMap* hash_map = surface_entry.first;
+    const IdentifiableSurface::Type& surface_type = surface_entry.second;
+    for (const auto& individual_lookup : *hash_map) {
+      if (IdentifiabilityStudySettings::Get()->ShouldSample(surface_type)) {
+        builder.Set(IdentifiableSurface::FromTypeAndToken(
+                        surface_type, individual_lookup.key.token),
+                    individual_lookup.value);
+      }
+    }
+    hash_map->clear();
+  }
+
+  builder.Record(ukm_recorder_);
+}
+
+void FontMatchingMetrics::PublishUkmMetrics() {
+  ukm::builders::FontMatchAttempts(source_id_)
+      .SetLoadContext(load_context_)
+      .SetSystemFontFamilySuccesses(ukm::GetExponentialBucketMin(
+          SetIntersection(successful_font_families_, system_font_families_)
+              .size(),
+          kUkmFontLoadCountBucketSpacing))
+      .SetSystemFontFamilyFailures(ukm::GetExponentialBucketMin(
+          SetIntersection(failed_font_families_, system_font_families_).size(),
+          kUkmFontLoadCountBucketSpacing))
+      .SetSystemFontFamilyTotal(ukm::GetExponentialBucketMin(
+          system_font_families_.size(), kUkmFontLoadCountBucketSpacing))
+      .SetWebFontFamilySuccesses(ukm::GetExponentialBucketMin(
+          SetIntersection(successful_font_families_, web_font_families_).size(),
+          kUkmFontLoadCountBucketSpacing))
+      .SetWebFontFamilyFailures(ukm::GetExponentialBucketMin(
+          SetIntersection(failed_font_families_, web_font_families_).size(),
+          kUkmFontLoadCountBucketSpacing))
+      .SetWebFontFamilyTotal(ukm::GetExponentialBucketMin(
+          web_font_families_.size(), kUkmFontLoadCountBucketSpacing))
+      .SetLocalFontFailures(ukm::GetExponentialBucketMin(
+          local_fonts_failed_.size(), kUkmFontLoadCountBucketSpacing))
+      .SetLocalFontSuccesses(ukm::GetExponentialBucketMin(
+          local_fonts_succeeded_.size(), kUkmFontLoadCountBucketSpacing))
+      .SetLocalFontTotal(ukm::GetExponentialBucketMin(
+          local_fonts_succeeded_.size() + local_fonts_failed_.size(),
+          kUkmFontLoadCountBucketSpacing))
+      .Record(ukm_recorder_);
+  UMA_HISTOGRAM_COUNTS_10000("Blink.Fonts.FontFamilyMatchAttempts.System",
+                             system_font_families_.size());
+  UMA_HISTOGRAM_COUNTS_10000(
+      "Blink.Fonts.FontMatchAttempts.System",
+      local_fonts_failed_.size() + local_fonts_succeeded_.size());
+}
+
+void FontMatchingMetrics::PublishEmojiGlyphMetrics() {
+  DCHECK_LE(total_broken_emoji_clusters_, total_emoji_clusters_shaped_);
+  if (total_emoji_clusters_shaped_) {
+    double percentage = static_cast<double>(total_broken_emoji_clusters_) /
+                        total_emoji_clusters_shaped_;
+    UMA_HISTOGRAM_PERCENTAGE("Blink.Fonts.EmojiClusterBrokenness",
+                             static_cast<int>(round(percentage * 100)));
+  }
+}
+
+void FontMatchingMetrics::OnFontLookup() {
+  DCHECK(IdentifiabilityStudySettings::Get()->IsActive());
+  if (!identifiability_metrics_timer_.IsActive()) {
+    identifiability_metrics_timer_.StartOneShot(base::TimeDelta::FromMinutes(1),
+                                                FROM_HERE);
+  }
+}
+
+void FontMatchingMetrics::IdentifiabilityMetricsTimerFired(TimerBase*) {
+  PublishIdentifiabilityMetrics();
+}
+
+void FontMatchingMetrics::PublishAllMetrics() {
+  PublishIdentifiabilityMetrics();
+  PublishUkmMetrics();
+  PublishEmojiGlyphMetrics();
+}
+
+int64_t FontMatchingMetrics::GetHashForFontData(SimpleFontData* font_data) {
+  return font_data ? FontGlobalContext::Get()
+                         ->GetOrComputeTypefaceDigest(font_data->PlatformData())
+                         .ToUkmMetricValue()
+                   : 0;
+}
+
+IdentifiableToken FontMatchingMetrics::GetPostScriptNameTokenForFontData(
+    SimpleFontData* font_data) {
+  DCHECK(font_data);
+  return FontGlobalContext::Get()->GetOrComputePostScriptNameDigest(
+      font_data->PlatformData());
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_matching_metrics.h b/third_party/blink/renderer/platform/fonts/font_matching_metrics.h
new file mode 100644
index 000000000000..2dbadbca1ebb
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/font_matching_metrics.h
@@ -0,0 +1,277 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_MATCHING_METRICS_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_MATCHING_METRICS_H_
+
+#include "services/metrics/public/cpp/ukm_source_id.h"
+#include "third_party/blink/public/common/privacy_budget/identifiable_token.h"
+#include "third_party/blink/public/common/privacy_budget/identifiable_token_builder.h"
+#include "third_party/blink/renderer/platform/fonts/font_description.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
+#include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/timer.h"
+#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
+#include "third_party/blink/renderer/platform/wtf/hash_set.h"
+#include "third_party/blink/renderer/platform/wtf/text/atomic_string.h"
+
+namespace ukm {
+class UkmRecorder;
+}  // namespace ukm
+
+namespace blink {
+
+// A (generic) wrapper around IdentifiableToken to enable its use as a HashMap
+// key. The |token| represents the parameters by which a font was looked up.
+// However, if |is_deleted_value| or |is_empty_value|, this key represents an
+// object for HashMap's internal use only. In that case, |token| is left as a
+// default value.
+struct IdentifiableTokenKey {
+  IdentifiableToken token;
+  bool is_deleted_value = false;
+  bool is_empty_value = false;
+
+  IdentifiableTokenKey() : is_empty_value(true) {}
+  explicit IdentifiableTokenKey(const IdentifiableToken& token)
+      : token(token) {}
+  explicit IdentifiableTokenKey(WTF::HashTableDeletedValueType)
+      : is_deleted_value(true) {}
+
+  bool IsHashTableDeletedValue() const { return is_deleted_value; }
+
+  bool operator==(const IdentifiableTokenKey& other) const {
+    return token == other.token && is_deleted_value == other.is_deleted_value &&
+           is_empty_value == other.is_empty_value;
+  }
+  bool operator!=(const IdentifiableTokenKey& other) const {
+    return !(*this == other);
+  }
+};
+
+// A helper that defines the hash and equality functions that HashMap should use
+// internally for comparing IdentifiableTokenKeys.
+struct IdentifiableTokenKeyHash {
+  STATIC_ONLY(IdentifiableTokenKeyHash);
+  static unsigned GetHash(const IdentifiableTokenKey& key) {
+    IntHash<int64_t> hasher;
+    return hasher.GetHash(key.token.ToUkmMetricValue()) ^
+           hasher.GetHash((key.is_deleted_value << 1) + key.is_empty_value);
+  }
+  static bool Equal(const IdentifiableTokenKey& a,
+                    const IdentifiableTokenKey& b) {
+    return a == b;
+  }
+  static const bool safe_to_compare_to_empty_or_deleted = true;
+};
+
+// A helper that defines the invalid 'empty value' that HashMap should use
+// internally.
+struct IdentifiableTokenKeyHashTraits
+    : WTF::SimpleClassHashTraits<IdentifiableTokenKey> {
+  STATIC_ONLY(IdentifiableTokenKeyHashTraits);
+  static const bool kEmptyValueIsZero = false;
+  static IdentifiableTokenKey EmptyValue() { return IdentifiableTokenKey(); }
+};
+
+// Tracks and reports UKM metrics of attempted font family match attempts (both
+// successful and not successful) by the current frame.
+//
+// The number of successful / not successful font family match attempts are
+// reported to UKM. The class de-dupes attempts to match the same font family
+// name such that they are counted as one attempt.
+//
+// Each local font lookup is also reported as is each mapping of generic font
+// family name to its corresponding actual font family names. Local font lookups
+// are deduped according to the family name looked up in the FontCache and the
+// FontSelectionRequest parameters (i.e. weight, width and slope). Generic font
+// family lookups are de-duped according to the generic name, the
+// GenericFamilyType and the script. Both types of lookup events are reported
+// regularly.
+class PLATFORM_EXPORT FontMatchingMetrics {
+ public:
+  enum FontLoadContext { kTopLevelFrame = 0, kSubframe, kWorker };
+
+  // Create a FontMatchingMetrics objects for a frame, with |top_level|
+  // indicating whether it is a mainframe.
+  FontMatchingMetrics(bool top_level,
+                      ukm::UkmRecorder* ukm_recorder,
+                      ukm::SourceId source_id,
+                      scoped_refptr<base::SingleThreadTaskRunner> task_runner);
+
+  // Create a FontMatchingMetrics objects for a worker.
+  FontMatchingMetrics(ukm::UkmRecorder* ukm_recorder,
+                      ukm::SourceId source_id,
+                      scoped_refptr<base::SingleThreadTaskRunner> task_runner);
+
+  // Called when a page attempts to match a font family, and the font family is
+  // available.
+  void ReportSuccessfulFontFamilyMatch(const AtomicString& font_family_name);
+
+  // Called when a page attempts to match a font family, and the font family is
+  // not available.
+  void ReportFailedFontFamilyMatch(const AtomicString& font_family_name);
+
+  // Called when a page attempts to match a system font family.
+  void ReportSystemFontFamily(const AtomicString& font_family_name);
+
+  // Called when a page attempts to match a web font family.
+  void ReportWebFontFamily(const AtomicString& font_family_name);
+
+  // Reports a font listed in a @font-face src:local rule that successfully
+  // matched.
+  void ReportSuccessfulLocalFontMatch(const AtomicString& font_name);
+
+  // Reports a font listed in a @font-face src:local rule that didn't
+  // successfully match.
+  void ReportFailedLocalFontMatch(const AtomicString& font_name);
+
+  // Reports a local font was looked up by a name and font description. This
+  // only includes lookups where the name is allowed to match family names,
+  // PostScript names and full font names.
+  void ReportFontLookupByUniqueOrFamilyName(
+      const AtomicString& name,
+      const FontDescription& font_description,
+      SimpleFontData* resulting_font_data);
+
+  // Reports a local font was looked up by a name and font description. This
+  // only includes lookups where the name is allowed to match PostScript names
+  // and full font names, but not family names.
+  void ReportFontLookupByUniqueNameOnly(const AtomicString& name,
+                                        const FontDescription& font_description,
+                                        SimpleFontData* resulting_font_data,
+                                        bool is_loading_fallback = false);
+
+  // Reports a font was looked up by a fallback character, fallback priority,
+  // and a font description.
+  void ReportFontLookupByFallbackCharacter(
+      UChar32 fallback_character,
+      FontFallbackPriority fallback_priority,
+      const FontDescription& font_description,
+      SimpleFontData* resulting_font_data);
+
+  // Reports a last-resort fallback font was looked up by a font description.
+  void ReportLastResortFallbackFontLookup(
+      const FontDescription& font_description,
+      SimpleFontData* resulting_font_data);
+
+  // Reports a generic font family name was matched according to the script and
+  // the user's preferences to a font family name.
+  void ReportFontFamilyLookupByGenericFamily(
+      const AtomicString& generic_font_family_name,
+      UScriptCode script,
+      FontDescription::GenericFamilyType generic_family_type,
+      const AtomicString& resulting_font_name);
+
+  // Reports for each shaped emoji segment the number of total clusters and the
+  // number of clusters that either contain a .notdef/tofu glyph or that is
+  // shaped as multiple glyphs, which means the emoji displays incorrectly.
+  void ReportEmojiSegmentGlyphCoverage(unsigned num_clusters,
+                                       unsigned num_broken_clusters);
+
+  // Called on page unload and forces metrics to be flushed.
+  void PublishAllMetrics();
+
+  // Called whenever a font lookup event that will be saved in |font_tracker| or
+  // |user_font_preference_mapping| occurs.
+  void OnFontLookup();
+
+  // Publishes the font lookup events. Recorded on document shutdown/worker
+  // destruction and every minute, as long as additional lookups are occurring.
+  void PublishIdentifiabilityMetrics();
+
+  // Publishes the number of font family matches attempted (both successful
+  // and otherwise) to UKM. Recorded on page unload.
+  void PublishUkmMetrics();
+
+  // Publishes the ratio of correctly shaped to incorrectly shaped emoji
+  // segments during the lifetime of this metrics recorder, which usually is
+  // coupled to the lifetime of a document or WorkerGlobalContext.
+  void PublishEmojiGlyphMetrics();
+
+ private:
+  void IdentifiabilityMetricsTimerFired(TimerBase*);
+
+  // This HashMap generically stores details of font lookups, i.e. what was used
+  // to search for the font, and what the resulting font was. The key is an
+  // IdentifiableTokenKey representing a wrapper around a digest of the lookup
+  // parameters. The value is an IdentifiableToken representing either a digest
+  // of the returned typeface or 0, if no valid typeface was found.
+  using TokenToTokenHashMap = HashMap<IdentifiableTokenKey,
+                                      IdentifiableToken,
+                                      IdentifiableTokenKeyHash,
+                                      IdentifiableTokenKeyHashTraits>;
+
+  // Adds a digest of the |font_data|'s typeface to |hash_map| using the key
+  // |input_key|, unless that key is already present. If |font_data| is not
+  // nullptr, then the typeface digest will also be saved with its PostScript
+  // name in |font_load_postscript_name_|.
+  void InsertFontHashIntoMap(IdentifiableTokenKey input_key,
+                             SimpleFontData* font_data,
+                             TokenToTokenHashMap& hash_map);
+
+  // Reports a local font's existence was looked up by a name, but its actual
+  // font data may or may not have been loaded. This only includes lookups where
+  // the name is allowed to match PostScript names and full font names, but not
+  // family names.
+  void ReportLocalFontExistenceByUniqueNameOnly(const AtomicString& font_name,
+                                                bool font_exists);
+
+  // Constructs a builder with a hash of the FontSelectionRequest already added.
+  IdentifiableTokenBuilder GetTokenBuilderWithFontSelectionRequest(
+      const FontDescription& font_description);
+
+  // Get a hash that uniquely represents the font data. Returns 0 if |font_data|
+  // is nullptr.
+  int64_t GetHashForFontData(SimpleFontData* font_data);
+
+  void Initialize();
+
+  // Get a token that uniquely represents the typeface's PostScript name. May
+  // represent the empty string if no PostScript name was found.
+  IdentifiableToken GetPostScriptNameTokenForFontData(
+      SimpleFontData* font_data);
+
+  // Font family names successfully matched.
+  HashSet<AtomicString> successful_font_families_;
+
+  // Font family names that weren't successfully matched.
+  HashSet<AtomicString> failed_font_families_;
+
+  // System font families the page attempted to match.
+  HashSet<AtomicString> system_font_families_;
+
+  // Web font families the page attempted to match.
+  HashSet<AtomicString> web_font_families_;
+
+  // @font-face src:local fonts that successfully matched.
+  HashSet<AtomicString> local_fonts_succeeded_;
+
+  // @font-face src:local fonts that didn't successfully match.
+  HashSet<AtomicString> local_fonts_failed_;
+
+  // Indicates whether this FontMatchingMetrics instance is for a top-level
+  // frame, a subframe or a worker.
+  const FontLoadContext load_context_;
+
+  TokenToTokenHashMap font_lookups_by_unique_or_family_name_;
+  TokenToTokenHashMap font_lookups_by_unique_name_only_;
+  TokenToTokenHashMap font_lookups_by_fallback_character_;
+  TokenToTokenHashMap font_lookups_as_last_resort_;
+  TokenToTokenHashMap generic_font_lookups_;
+  TokenToTokenHashMap font_load_postscript_name_;
+  TokenToTokenHashMap local_font_existence_by_unique_name_only_;
+
+  uint64_t total_emoji_clusters_shaped_ = 0;
+  uint64_t total_broken_emoji_clusters_ = 0;
+
+  ukm::UkmRecorder* const ukm_recorder_;
+  const ukm::SourceId source_id_;
+
+  TaskRunnerTimer<FontMatchingMetrics> identifiability_metrics_timer_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_MATCHING_METRICS_H_
diff --git a/third_party/blink/renderer/platform/fonts/font_metrics.cc b/third_party/blink/renderer/platform/fonts/font_metrics.cc
index 0d431a2eb658..52ba1876f9da 100644
--- a/third_party/blink/renderer/platform/fonts/font_metrics.cc
+++ b/third_party/blink/renderer/platform/fonts/font_metrics.cc
@@ -32,13 +32,14 @@
 #include "build/build_config.h"
 #include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
 #include "third_party/blink/renderer/platform/fonts/vdmx_parser.h"
-
-#include <SkPaint.h>
-#include <SkTypeface.h>
+#include "third_party/skia/include/core/SkFont.h"
+#include "third_party/skia/include/core/SkFontMetrics.h"
+#include "third_party/skia/include/core/SkTypeface.h"
 
 namespace blink {
 
-#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
+    defined(OS_FUCHSIA)
 // This is the largest VDMX table which we'll try to load and parse.
 static const size_t kMaxVDMXTableSize = 1024 * 1024;  // 1 MB
 #endif
@@ -49,26 +50,35 @@ void FontMetrics::AscentDescentWithHacks(
     unsigned& visual_overflow_inflation_for_ascent,
     unsigned& visual_overflow_inflation_for_descent,
     const FontPlatformData& platform_data,
-    const SkPaint& paint,
-    bool subpixel_ascent_descent) {
-  SkTypeface* face = paint.getTypeface();
+    const SkFont& font,
+    bool subpixel_ascent_descent,
+    base::Optional<float> ascent_override,
+    base::Optional<float> descent_override) {
+  SkTypeface* face = font.getTypeface();
   DCHECK(face);
 
-  SkPaint::FontMetrics metrics;
-  paint.getFontMetrics(&metrics);
+  SkFontMetrics metrics;
+  font.getMetrics(&metrics);
+
+  if (ascent_override)
+    metrics.fAscent = -platform_data.size() * ascent_override.value();
+  if (descent_override)
+    metrics.fDescent = platform_data.size() * descent_override.value();
 
   int vdmx_ascent = 0, vdmx_descent = 0;
   bool is_vdmx_valid = false;
 
-#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
+    defined(OS_FUCHSIA)
   // Manually digging up VDMX metrics is only applicable when bytecode hinting
   // using FreeType.  With DirectWrite or CoreText, no bytecode hinting is ever
   // done.  This code should be pushed into FreeType (hinted font metrics).
   static const uint32_t kVdmxTag = SkSetFourByteTag('V', 'D', 'M', 'X');
   int pixel_size = platform_data.size() + 0.5;
-  if (!paint.isAutohinted() &&
-      (paint.getHinting() == SkPaint::kFull_Hinting ||
-       paint.getHinting() == SkPaint::kNormal_Hinting)) {
+  // TODO(xiaochengh): How do we support ascent/descent override with VDMX?
+  if (!ascent_override && !descent_override && !font.isForceAutoHinting() &&
+      (font.getHinting() == SkFontHinting::kFull ||
+       font.getHinting() == SkFontHinting::kNormal)) {
     size_t vdmx_size = face->getTableSize(kVdmxTag);
     if (vdmx_size && vdmx_size < kMaxVDMXTableSize) {
       uint8_t* vdmx_table = (uint8_t*)WTF::Partitions::FastMalloc(
@@ -106,7 +116,8 @@ void FontMetrics::AscentDescentWithHacks(
       visual_overflow_inflation_for_ascent = 1;
     if (descent < metrics.fDescent) {
       visual_overflow_inflation_for_descent = 1;
-#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
+    defined(OS_FUCHSIA)
       // When subpixel positioning is enabled, if the descent is rounded down,
       // the descent part of the glyph may be truncated when displayed in a
       // 'overflow: hidden' container.  To avoid that, borrow 1 unit from the
@@ -123,7 +134,7 @@ void FontMetrics::AscentDescentWithHacks(
     }
   }
 
-#if defined(OS_MACOSX)
+#if defined(OS_MAC)
   // We are preserving this ascent hack to match Safari's ascent adjustment
   // in their SimpleFontDataMac.mm, for details see crbug.com/445830.
   // We need to adjust Times, Helvetica, and Courier to closely match the
@@ -132,9 +143,9 @@ void FontMetrics::AscentDescentWithHacks(
   // incorrectly added to line spacing, so we use a 15% adjustment instead
   // and add it to the ascent.
   String family_name = platform_data.FontFamilyName();
-  if (family_name == FontFamilyNames::Times ||
-      family_name == FontFamilyNames::Helvetica ||
-      family_name == FontFamilyNames::Courier)
+  if (family_name == font_family_names::kTimes ||
+      family_name == font_family_names::kHelvetica ||
+      family_name == font_family_names::kCourier)
     ascent += floorf(((ascent + descent) * 0.15f) + 0.5f);
 #endif
 }
diff --git a/third_party/blink/renderer/platform/fonts/font_metrics.h b/third_party/blink/renderer/platform/fonts/font_metrics.h
index 89381754c8fa..4985eaf77151 100644
--- a/third_party/blink/renderer/platform/fonts/font_metrics.h
+++ b/third_party/blink/renderer/platform/fonts/font_metrics.h
@@ -20,12 +20,16 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_METRICS_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_METRICS_H_
 
+#include <base/optional.h>
+
 #include "third_party/blink/renderer/platform/fonts/font_baseline.h"
-#include "third_party/blink/renderer/platform/layout_unit.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/fonts/font_height.h"
+#include "third_party/blink/renderer/platform/fonts/font_metrics_override.h"
+#include "third_party/blink/renderer/platform/geometry/layout_unit.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/math_extras.h"
 
-#include <SkPaint.h>
+class SkFont;
 
 namespace blink {
 
@@ -44,8 +48,6 @@ class FontMetrics {
         line_spacing_(0),
         x_height_(0),
         zero_width_(0),
-        underlinethickness_(0),
-        underline_position_(0),
         ascent_int_(0),
         descent_int_(0),
         has_x_height_(false),
@@ -62,7 +64,7 @@ class FontMetrics {
 
   void SetAscent(float ascent) {
     ascent_ = ascent;
-    ascent_int_ = lroundf(ascent);
+    ascent_int_ = static_cast<int>(lroundf(ascent));
   }
 
   float FloatDescent(FontBaseline baseline_type = kAlphabeticBaseline) const {
@@ -73,7 +75,7 @@ class FontMetrics {
 
   void SetDescent(float descent) {
     descent_ = descent;
-    descent_int_ = lroundf(descent);
+    descent_int_ = static_cast<int>(lroundf(descent));
   }
 
   float FloatHeight(FontBaseline baseline_type = kAlphabeticBaseline) const {
@@ -112,8 +114,8 @@ class FontMetrics {
     return Ascent() + Descent();
   }
 
-  int LineGap() const { return lroundf(line_gap_); }
-  int LineSpacing() const { return lroundf(line_spacing_); }
+  int LineGap() const { return static_cast<int>(lroundf(line_gap_)); }
+  int LineSpacing() const { return static_cast<int>(lroundf(line_spacing_)); }
 
   // LayoutUnit variants of certain metrics.
   // LayoutNG should use LayoutUnit for the block progression metrics.
@@ -132,6 +134,16 @@ class FontMetrics {
     return LayoutUnit::FromFloatRound(line_spacing_);
   }
 
+  FontHeight GetFontHeight(
+      FontBaseline baseline_type = kAlphabeticBaseline) const {
+    // TODO(kojii): In future, we'd like to use LayoutUnit metrics to support
+    // sub-CSS-pixel layout.
+    if (baseline_type == kAlphabeticBaseline)
+      return FontHeight(LayoutUnit(ascent_int_), LayoutUnit(descent_int_));
+    int height = ascent_int_ + descent_int_;
+    return FontHeight(LayoutUnit(height - height / 2), LayoutUnit(height / 2));
+  }
+
   bool HasIdenticalAscentDescentAndLineGap(const FontMetrics& other) const {
     return Ascent() == other.Ascent() && Descent() == other.Descent() &&
            LineGap() == other.LineGap();
@@ -148,12 +160,16 @@ class FontMetrics {
     has_zero_width_ = has_zero_width;
   }
 
-  float UnderlineThickness() const { return underlinethickness_; }
+  base::Optional<float> UnderlineThickness() const {
+    return underline_thickness_;
+  }
   void SetUnderlineThickness(float underline_thickness) {
-    underlinethickness_ = underline_thickness;
+    underline_thickness_ = underline_thickness;
   }
 
-  float UnderlinePosition() const { return underline_position_; }
+  base::Optional<float> UnderlinePosition() const {
+    return underline_position_;
+  }
   void SetUnderlinePosition(float underline_position) {
     underline_position_ = underline_position;
   }
@@ -168,8 +184,10 @@ class FontMetrics {
       unsigned& visual_overflow_inflation_for_ascent,
       unsigned& visual_overflow_inflation_for_descent,
       const FontPlatformData&,
-      const SkPaint&,
-      bool subpixel_ascent_descent = false);
+      const SkFont&,
+      bool subpixel_ascent_descent = false,
+      base::Optional<float> ascent_override = base::nullopt,
+      base::Optional<float> descent_override = base::nullopt);
 
  private:
   friend class SimpleFontData;
@@ -184,8 +202,8 @@ class FontMetrics {
     line_spacing_ = 0;
     x_height_ = 0;
     has_x_height_ = false;
-    underlinethickness_ = 0;
-    underline_position_ = 0;
+    underline_thickness_.reset();
+    underline_position_.reset();
   }
 
   unsigned units_per_em_;
@@ -195,8 +213,8 @@ class FontMetrics {
   float line_spacing_;
   float x_height_;
   float zero_width_;
-  float underlinethickness_;
-  float underline_position_;
+  base::Optional<float> underline_thickness_ = base::nullopt;
+  base::Optional<float> underline_position_ = base::nullopt;
   int ascent_int_;
   int descent_int_;
   bool has_x_height_;
diff --git a/third_party/blink/renderer/platform/fonts/font_metrics_override.h b/third_party/blink/renderer/platform/fonts/font_metrics_override.h
new file mode 100644
index 000000000000..4c400119080f
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/font_metrics_override.h
@@ -0,0 +1,22 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_METRICS_OVERRIDE_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_METRICS_OVERRIDE_H_
+
+#include "base/optional.h"
+
+namespace blink {
+
+struct FontMetricsOverride {
+  base::Optional<float> ascent_override;
+  base::Optional<float> descent_override;
+  base::Optional<float> line_gap_override;
+  base::Optional<float> advance_override;
+  base::Optional<float> advance_override_vertical_upright;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_METRICS_OVERRIDE_H_
diff --git a/third_party/blink/renderer/platform/fonts/font_optical_sizing.cc b/third_party/blink/renderer/platform/fonts/font_optical_sizing.cc
new file mode 100644
index 000000000000..b912bfa2617c
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/font_optical_sizing.cc
@@ -0,0 +1,19 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/font_optical_sizing.h"
+
+namespace blink {
+
+String ToString(OpticalSizing font_optical_sizing) {
+  switch (font_optical_sizing) {
+    case OpticalSizing::kAutoOpticalSizing:
+      return "Auto";
+    case OpticalSizing::kNoneOpticalSizing:
+      return "None";
+  }
+  return "Unknown";
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_optical_sizing.h b/third_party/blink/renderer/platform/fonts/font_optical_sizing.h
new file mode 100644
index 000000000000..bd18e89ff8dc
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/font_optical_sizing.h
@@ -0,0 +1,17 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_OPTICAL_SIZING_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_OPTICAL_SIZING_H_
+
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+
+namespace blink {
+enum OpticalSizing { kAutoOpticalSizing, kNoneOpticalSizing };
+
+PLATFORM_EXPORT String ToString(OpticalSizing);
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_OPTICAL_SIZING_H_
diff --git a/third_party/blink/renderer/platform/fonts/font_platform_data.cc b/third_party/blink/renderer/platform/fonts/font_platform_data.cc
index 51a6adf7a3c4..ad318e8a2278 100644
--- a/third_party/blink/renderer/platform/fonts/font_platform_data.cc
+++ b/third_party/blink/renderer/platform/fonts/font_platform_data.cc
@@ -20,23 +20,25 @@
 
 #include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
 
-#include "SkTypeface.h"
 #include "build/build_config.h"
 #include "hb-ot.h"
 #include "hb.h"
+#include "third_party/blink/public/common/privacy_budget/identifiable_token_builder.h"
 #include "third_party/blink/public/platform/linux/web_sandbox_support.h"
 #include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h"
-#include "third_party/blink/renderer/platform/graphics/skia/skia_utils.h"
-#include "third_party/blink/renderer/platform/layout_test_support.h"
 #include "third_party/blink/renderer/platform/text/character.h"
+#include "third_party/blink/renderer/platform/web_test_support.h"
 #include "third_party/blink/renderer/platform/wtf/hash_map.h"
 #include "third_party/blink/renderer/platform/wtf/text/character_names.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkData.h"
+#include "third_party/skia/include/core/SkFont.h"
+#include "third_party/skia/include/core/SkTypeface.h"
 
-#if defined(OS_MACOSX)
+#if defined(OS_MAC)
 #include "third_party/skia/include/ports/SkTypeface_mac.h"
 #endif
 
@@ -49,10 +51,6 @@ FontPlatformData::FontPlatformData(WTF::HashTableDeletedValueType)
       avoid_embedded_bitmaps_(false),
       orientation_(FontOrientation::kHorizontal),
       is_hash_table_deleted_value_(true)
-#if defined(OS_WIN)
-      ,
-      paint_text_flags_(0)
-#endif
 {
 }
 
@@ -63,10 +61,6 @@ FontPlatformData::FontPlatformData()
       avoid_embedded_bitmaps_(false),
       orientation_(FontOrientation::kHorizontal),
       is_hash_table_deleted_value_(false)
-#if defined(OS_WIN)
-      ,
-      paint_text_flags_(0)
-#endif
 {
 }
 
@@ -80,16 +74,12 @@ FontPlatformData::FontPlatformData(float size,
       avoid_embedded_bitmaps_(false),
       orientation_(orientation),
       is_hash_table_deleted_value_(false)
-#if defined(OS_WIN)
-      ,
-      paint_text_flags_(0)
-#endif
 {
 }
 
 FontPlatformData::FontPlatformData(const FontPlatformData& source)
-    : paint_typeface_(source.paint_typeface_),
-#if !defined(OS_WIN)
+    : typeface_(source.typeface_),
+#if !defined(OS_WIN) && !defined(OS_MAC)
       family_(source.family_),
 #endif
       text_size_(source.text_size_),
@@ -97,24 +87,19 @@ FontPlatformData::FontPlatformData(const FontPlatformData& source)
       synthetic_italic_(source.synthetic_italic_),
       avoid_embedded_bitmaps_(source.avoid_embedded_bitmaps_),
       orientation_(source.orientation_),
-#if !defined(OS_WIN) && !defined(OS_MACOSX)
+#if !defined(OS_MAC)
       style_(source.style_),
 #endif
       harfbuzz_face_(nullptr),
-      is_hash_table_deleted_value_(false)
-#if defined(OS_WIN)
-      ,
-      paint_text_flags_(source.paint_text_flags_)
-#endif
-{
+      is_hash_table_deleted_value_(false) {
 }
 
 FontPlatformData::FontPlatformData(const FontPlatformData& src, float text_size)
-    : FontPlatformData(src.paint_typeface_,
-#if !defined(OS_WIN)
+    : FontPlatformData(src.typeface_,
+#if !defined(OS_WIN) && !defined(OS_MAC)
                        src.family_.data(),
 #else
-                       CString(),
+                       std::string(),
 #endif
                        text_size,
                        src.synthetic_bold_,
@@ -122,14 +107,14 @@ FontPlatformData::FontPlatformData(const FontPlatformData& src, float text_size)
                        src.orientation_) {
 }
 
-FontPlatformData::FontPlatformData(const PaintTypeface& paint_tf,
-                                   const CString& family,
+FontPlatformData::FontPlatformData(sk_sp<SkTypeface> typeface,
+                                   const std::string& family,
                                    float text_size,
                                    bool synthetic_bold,
                                    bool synthetic_italic,
                                    FontOrientation orientation)
-    : paint_typeface_(paint_tf),
-#if !defined(OS_WIN)
+    : typeface_(typeface),
+#if !defined(OS_WIN) && !defined(OS_MAC)
       family_(family),
 #endif
       text_size_(text_size),
@@ -137,45 +122,33 @@ FontPlatformData::FontPlatformData(const PaintTypeface& paint_tf,
       synthetic_italic_(synthetic_italic),
       avoid_embedded_bitmaps_(false),
       orientation_(orientation),
-      is_hash_table_deleted_value_(false)
-#if defined(OS_WIN)
-      ,
-      paint_text_flags_(0)
-#endif
-{
-#if !defined(OS_WIN) && !defined(OS_MACOSX)
+      is_hash_table_deleted_value_(false) {
+#if !defined(OS_MAC)
   style_ = WebFontRenderStyle::GetDefault();
-  auto system_style = QuerySystemRenderStyle(
-      family_, text_size_, paint_typeface_.ToSkTypeface()->fontStyle());
+  auto system_style =
+#if !defined(OS_WIN)
+      QuerySystemRenderStyle(family_, text_size_, typeface_->fontStyle());
 
-  // In layout tests, ignore system preference for subpixel positioning,
+  // In web tests, ignore system preference for subpixel positioning,
   // or explicitly disable if requested.
-  if (LayoutTestSupport::IsRunningLayoutTest()) {
+  if (WebTestSupport::IsRunningWebTest()) {
     system_style.use_subpixel_positioning =
-        LayoutTestSupport::IsTextSubpixelPositioningAllowedForTest()
+        WebTestSupport::IsTextSubpixelPositioningAllowedForTest()
             ? WebFontRenderStyle::kNoPreference
             : 0;
   }
-
-  style_.OverrideWith(system_style);
+#else
+     QuerySystemForRenderStyle();
 #endif
-
-#if defined(OS_WIN)
-  QuerySystemForRenderStyle();
+  style_.OverrideWith(system_style);
 #endif
 }
 
 FontPlatformData::~FontPlatformData() = default;
 
-#if defined(OS_MACOSX)
+#if defined(OS_MAC)
 CTFontRef FontPlatformData::CtFont() const {
-  return SkTypeface_GetCTFontRef(paint_typeface_.ToSkTypeface().get());
-};
-
-CGFontRef FontPlatformData::CgFont() const {
-  if (!CtFont())
-    return nullptr;
-  return CTFontCopyGraphicsFont(CtFont(), 0);
+  return SkTypeface_GetCTFontRef(typeface_.get());
 }
 #endif
 
@@ -185,8 +158,8 @@ const FontPlatformData& FontPlatformData::operator=(
   if (this == &other)
     return *this;
 
-  paint_typeface_ = other.paint_typeface_;
-#if !defined(OS_WIN)
+  typeface_ = other.typeface_;
+#if !defined(OS_WIN) && !defined(OS_MAC)
   family_ = other.family_;
 #endif
   text_size_ = other.text_size_;
@@ -195,14 +168,10 @@ const FontPlatformData& FontPlatformData::operator=(
   avoid_embedded_bitmaps_ = other.avoid_embedded_bitmaps_;
   harfbuzz_face_ = nullptr;
   orientation_ = other.orientation_;
-#if !defined(OS_WIN) && !defined(OS_MACOSX)
+#if !defined(OS_MAC)
   style_ = other.style_;
 #endif
 
-#if defined(OS_WIN)
-  paint_text_flags_ = 0;
-#endif
-
   return *this;
 }
 
@@ -220,7 +189,7 @@ bool FontPlatformData::operator==(const FontPlatformData& a) const {
          synthetic_bold_ == a.synthetic_bold_ &&
          synthetic_italic_ == a.synthetic_italic_ &&
          avoid_embedded_bitmaps_ == a.avoid_embedded_bitmaps_
-#if !defined(OS_WIN) && !defined(OS_MACOSX)
+#if !defined(OS_MAC)
          && style_ == a.style_
 #endif
          && orientation_ == a.orientation_;
@@ -239,11 +208,12 @@ String FontPlatformData::FontFamilyName() const {
          !localized_string.fString.size()) {
   }
   font_family_iterator->unref();
-  return String::FromUTF8(localized_string.fString.c_str());
+  return String::FromUTF8(localized_string.fString.c_str(),
+                          localized_string.fString.size());
 }
 
 SkTypeface* FontPlatformData::Typeface() const {
-  return paint_typeface_.ToSkTypeface().get();
+  return typeface_.get();
 }
 
 HarfBuzzFace* FontPlatformData::GetHarfBuzzFace() const {
@@ -280,22 +250,18 @@ unsigned FontPlatformData::GetHash() const {
   return h;
 }
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MAC)
 bool FontPlatformData::FontContainsCharacter(UChar32 character) {
-  PaintFont font;
-  SetupPaintFont(&font);
-  font.SetTextEncoding(SkPaint::kUTF32_TextEncoding);
-
-  uint16_t glyph;
-  font.ToSkPaint().textToGlyphs(&character, sizeof(character), &glyph);
-  return glyph;
+  SkFont font;
+  SetupSkFont(&font);
+  return font.unicharToGlyph(character);
 }
 #endif
 
-#if !defined(OS_MACOSX) && !defined(OS_WIN)
+#if !defined(OS_MAC) && !defined(OS_WIN)
 // static
 WebFontRenderStyle FontPlatformData::QuerySystemRenderStyle(
-    const CString& family,
+    const std::string& family,
     float text_size,
     SkFontStyle font_style) {
   WebFontRenderStyle result;
@@ -315,23 +281,70 @@ WebFontRenderStyle FontPlatformData::QuerySystemRenderStyle(
   return result;
 }
 
-void FontPlatformData::SetupPaintFont(PaintFont* font,
-                                      float device_scale_factor,
-                                      const Font*) const {
-  style_.ApplyToPaintFont(*font, device_scale_factor);
+void FontPlatformData::SetupSkFont(SkFont* font,
+                                   float device_scale_factor,
+                                   const FontDescription*) const {
+  style_.ApplyToSkFont(font, device_scale_factor);
 
   const float ts = text_size_ >= 0 ? text_size_ : 12;
-  font->SetTextSize(SkFloatToScalar(ts));
-  font->SetTypeface(paint_typeface_);
-  font->SetFakeBoldText(synthetic_bold_);
-  font->SetTextSkewX(synthetic_italic_ ? -SK_Scalar1 / 4 : 0);
+  font->setSize(SkFloatToScalar(ts));
+  font->setTypeface(typeface_);
+  font->setEmbolden(synthetic_bold_);
+  font->setSkewX(synthetic_italic_ ? -SK_Scalar1 / 4 : 0);
 
-  font->SetEmbeddedBitmapText(!avoid_embedded_bitmaps_);
+  font->setEmbeddedBitmaps(!avoid_embedded_bitmaps_);
 }
 #endif
 
-const PaintTypeface& FontPlatformData::GetPaintTypeface() const {
-  return paint_typeface_;
+IdentifiableToken FontPlatformData::ComputeTypefaceDigest() const {
+  DCHECK(typeface_);
+  int table_count = typeface_->countTables();
+
+  // If no tables are found, return 0, to make it clearer that no identifiable
+  // information was available.
+  if (!table_count)
+    return 0;
+
+  IdentifiableTokenBuilder builder;
+  builder.AddValue(table_count);
+
+  Vector<SkFontTableTag> all_table_tags(table_count);
+  int tags_copied = typeface_->getTableTags(all_table_tags.data());
+  DCHECK_EQ(tags_copied, table_count);
+
+  // The tags are probably already sorted, but let's make sure.
+  std::sort(all_table_tags.begin(), all_table_tags.end());
+  for (SkFontTableTag table_tag : all_table_tags) {
+    builder.AddValue(table_tag).AddValue(typeface_->getTableSize(table_tag));
+  }
+
+  // These tables should both be small enough to compute a digest quickly and
+  // varied enough to ensure that different fonts have distinct hashes.
+  constexpr SkFontTableTag kTablesToFullyDigest[] = {
+      SkSetFourByteTag('c', 'm', 'a', 'p'),
+      SkSetFourByteTag('h', 'e', 'a', 'd'),
+      SkSetFourByteTag('n', 'a', 'm', 'e'),
+  };
+  for (SkFontTableTag table_tag : kTablesToFullyDigest) {
+    base::span<const uint8_t> table_data_span;
+    sk_sp<SkData> table_data = typeface_->copyTableData(table_tag);
+    if (table_data) {
+      table_data_span =
+          base::span<const uint8_t>(table_data->bytes(), table_data->size());
+    }
+    builder.AddAtomic(table_data_span);
+  }
+
+  return builder.GetToken();  // hasher.GetHash();
+}
+
+String FontPlatformData::GetPostScriptName() const {
+  if (!typeface_)
+    return String();
+
+  SkString postscript_name;
+  bool success = typeface_->getPostScriptName(&postscript_name);
+  return success ? postscript_name.c_str() : String();
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_platform_data.h b/third_party/blink/renderer/platform/fonts/font_platform_data.h
index df741b2668d1..af3ec2076b02 100644
--- a/third_party/blink/renderer/platform/fonts/font_platform_data.h
+++ b/third_party/blink/renderer/platform/fonts/font_platform_data.h
@@ -31,41 +31,28 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_PLATFORM_DATA_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_PLATFORM_DATA_H_
 
-#include "SkPaint.h"
-#include "SkTypeface.h"
 #include "base/memory/scoped_refptr.h"
 #include "build/build_config.h"
+#include "third_party/blink/public/common/privacy_budget/identifiable_token.h"
 #include "third_party/blink/public/platform/web_font_render_style.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
 #include "third_party/blink/renderer/platform/fonts/font_orientation.h"
 #include "third_party/blink/renderer/platform/fonts/small_caps_iterator.h"
-#include "third_party/blink/renderer/platform/graphics/paint/paint_font.h"
-#include "third_party/blink/renderer/platform/graphics/paint/paint_typeface.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/forward.h"
 #include "third_party/blink/renderer/platform/wtf/hash_table_deleted_value_type.h"
-#include "third_party/blink/renderer/platform/wtf/text/cstring.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_impl.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
+#include "third_party/skia/include/core/SkFont.h"
 #include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
 
-#if defined(OS_MACOSX)
-OBJC_CLASS NSFont;
-
-typedef struct CGFont* CGFontRef;
+#if defined(OS_MAC)
 typedef const struct __CTFont* CTFontRef;
+#endif  // defined(OS_MAC)
 
-#include <objc/objc-auto.h>
-
-inline CTFontRef toCTFontRef(NSFont* nsFont) {
-  return reinterpret_cast<CTFontRef>(nsFont);
-}
-inline NSFont* toNSFont(CTFontRef ctFontRef) {
-  return const_cast<NSFont*>(reinterpret_cast<const NSFont*>(ctFontRef));
-}
-#endif  // defined(OS_MACOSX)
-
+class SkFont;
 class SkTypeface;
 typedef uint32_t SkFontID;
 
@@ -73,7 +60,6 @@ namespace blink {
 
 class Font;
 class HarfBuzzFace;
-class FontVariationSettings;
 
 class PLATFORM_EXPORT FontPlatformData {
   USING_FAST_MALLOC(FontPlatformData);
@@ -92,29 +78,20 @@ class PLATFORM_EXPORT FontPlatformData {
                    bool synthetic_italic,
                    FontOrientation = FontOrientation::kHorizontal);
   FontPlatformData(const FontPlatformData& src, float text_size);
-#if defined(OS_MACOSX)
-  FontPlatformData(NSFont*,
-                   float size,
-                   bool synthetic_bold,
-                   bool synthetic_italic,
-                   FontOrientation,
-                   FontVariationSettings*);
-#endif
-  FontPlatformData(const PaintTypeface&,
-                   const CString& name,
+  FontPlatformData(const sk_sp<SkTypeface>,
+                   const std::string& name,
                    float text_size,
                    bool synthetic_bold,
                    bool synthetic_italic,
                    FontOrientation = FontOrientation::kHorizontal);
   ~FontPlatformData();
 
-#if defined(OS_MACOSX)
-  // These methods return a nullptr for FreeType backed SkTypefaces, compare
-  // FontCustomPlatformData, which are used for variable fonts on Mac OS <
-  // 10.12. They should not return nullptr otherwise. So they allow
-  // distinguishing which backend the SkTypeface is using.
+#if defined(OS_MAC)
+  // Returns nullptr for FreeType backed SkTypefaces, compare
+  // FontCustomPlatformData, which are used for variable fonts on Mac OS
+  // <10.12. It should not return nullptr otherwise. So it allows distinguishing
+  // which backend the SkTypeface is using.
   CTFontRef CtFont() const;
-  CGFontRef CgFont() const;
 #endif
 
   String FontFamilyName() const;
@@ -150,34 +127,42 @@ class PLATFORM_EXPORT FontPlatformData {
   bool IsHashTableDeletedValue() const { return is_hash_table_deleted_value_; }
   bool FontContainsCharacter(UChar32 character);
 
-#if !defined(OS_WIN) && !defined(OS_MACOSX)
+#if !defined(OS_WIN) && !defined(OS_MAC)
   const WebFontRenderStyle& GetFontRenderStyle() const { return style_; }
 #endif
 
-  void SetupPaintFont(PaintFont*,
-                      float device_scale_factor = 1,
-                      const Font* = nullptr) const;
-  const PaintTypeface& GetPaintTypeface() const;
+  void SetupSkFont(SkFont*,
+                   float device_scale_factor = 1,
+                   const FontDescription* = nullptr) const;
 
-#if defined(OS_WIN)
-  int PaintTextFlags() const { return paint_text_flags_; }
-#endif
+  // Computes a digest from the typeface. The digest only depends on the
+  // underlying font itself, and does not vary by the style (size, weight,
+  // italics, etc). This is aimed at discovering the fingerprinting information
+  // a particular local font may provide websites.
+  //
+  // The digest algorithm is designed for fast computation, rather than to be
+  // robust against an attacker with control of local fonts looking to attack
+  // the fingerprinting algorithm.
+  IdentifiableToken ComputeTypefaceDigest() const;
+
+  // Gets the postscript name from the typeface.
+  String GetPostScriptName() const;
 
  private:
-#if !defined(OS_WIN) && !defined(OS_MACOSX)
-  WebFontRenderStyle QuerySystemRenderStyle(const CString& family,
+#if !defined(OS_WIN) && !defined(OS_MAC)
+  WebFontRenderStyle QuerySystemRenderStyle(const std::string& family,
                                             float text_size,
                                             SkFontStyle);
 #endif
 #if defined(OS_WIN)
   // TODO(https://crbug.com/808221): Remove and use QuerySystemRenderStyle()
   // instead.
-  void QuerySystemForRenderStyle();
+  WebFontRenderStyle QuerySystemForRenderStyle();
 #endif
 
-  PaintTypeface paint_typeface_;
-#if !defined(OS_WIN)
-  CString family_;
+  sk_sp<SkTypeface> typeface_;
+#if !defined(OS_WIN) && !defined(OS_MAC)
+  std::string family_;
 #endif
 
  public:
@@ -188,16 +173,12 @@ class PLATFORM_EXPORT FontPlatformData {
   FontOrientation orientation_;
 
  private:
-#if !defined(OS_WIN) && !defined(OS_MACOSX)
+#if !defined(OS_MAC)
   WebFontRenderStyle style_;
 #endif
 
   mutable scoped_refptr<HarfBuzzFace> harfbuzz_face_;
   bool is_hash_table_deleted_value_;
-#if defined(OS_WIN)
-  // TODO(https://crbug.com/808221): Replace |paint_text_flags_| with |style_|.
-  int paint_text_flags_;
-#endif
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_platform_data_test.cc b/third_party/blink/renderer/platform/fonts/font_platform_data_test.cc
index a4ae3ba49140..fdcdbb5a8907 100644
--- a/third_party/blink/renderer/platform/fonts/font_platform_data_test.cc
+++ b/third_party/blink/renderer/platform/fonts/font_platform_data_test.cc
@@ -68,4 +68,46 @@ TEST(FontPlatformDataTest, AhemSpaceLigatureHasNoSpaceWithoutFontFeatures) {
   EXPECT_FALSE(platform_data.HasSpaceInLigaturesOrKerning(features));
 }
 
+// Two Font objects using the same underlying font (the "A" character extracted
+// from Robot-Regular) but different sizes should have the same digest.
+TEST(FontPlatformDataTest, TypefaceDigestForDifferentSizes_SameDigest) {
+  Font size_16_font =
+      CreateTestFont("robot-a", test::PlatformTestDataPath("roboto-a.ttf"), 16);
+  IdentifiableToken size_16_digest =
+      size_16_font.PrimaryFont()->PlatformData().ComputeTypefaceDigest();
+  Font size_32_font =
+      CreateTestFont("robot-a", test::PlatformTestDataPath("roboto-a.ttf"), 32);
+  IdentifiableToken size_32_digest =
+      size_32_font.PrimaryFont()->PlatformData().ComputeTypefaceDigest();
+  EXPECT_EQ(size_16_digest, size_32_digest);
+}
+
+// Two Font objects using different underlying fonts should have different
+// digests. The second font also has the "A" from Robot-Regular, but has the
+// format 12 part of the CMAP character to glyph mapping table removed.
+TEST(FontPlatformDataTest, TypefaceDigestForDifferentFonts_DifferentDigest) {
+  Font font1 =
+      CreateTestFont("robot-a", test::PlatformTestDataPath("roboto-a.ttf"), 16);
+  IdentifiableToken digest1 =
+      font1.PrimaryFont()->PlatformData().ComputeTypefaceDigest();
+  Font font2 = CreateTestFont(
+      "robot-a", test::PlatformTestDataPath("roboto-a-different-cmap.ttf"), 16);
+  IdentifiableToken digest2 =
+      font2.PrimaryFont()->PlatformData().ComputeTypefaceDigest();
+  EXPECT_NE(digest1, digest2);
+}
+
+// A Font using the same underlying font should have the same digest on
+// different platforms.
+TEST(FontPlatformDataTest, TypefaceDigestCrossPlatform_SameDigest) {
+  Font font =
+      CreateTestFont("robot-a", test::PlatformTestDataPath("roboto-a.ttf"), 16);
+  IdentifiableToken digest =
+      font.PrimaryFont()->PlatformData().ComputeTypefaceDigest();
+
+  // Calculated on Linux.
+  IdentifiableToken expected_digest(6864445319287375520);
+  EXPECT_EQ(digest, expected_digest);
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_selection_types.cc b/third_party/blink/renderer/platform/fonts/font_selection_types.cc
index fc1825943960..651aabb2392b 100644
--- a/third_party/blink/renderer/platform/fonts/font_selection_types.cc
+++ b/third_party/blink/renderer/platform/fonts/font_selection_types.cc
@@ -25,11 +25,13 @@
 
 #include "third_party/blink/renderer/platform/fonts/font_selection_types.h"
 
-#include "third_party/blink/renderer/platform/wtf/string_hasher.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_hasher.h"
 
 namespace {
 
 class IntegerHasher {
+  STACK_ALLOCATED();
+
  public:
   void add(unsigned integer) {
     m_underlyingHasher.AddCharactersAssumingAligned(integer, integer >> 16);
@@ -77,8 +79,8 @@ String FontSelectionValue::ToString() const {
 
 String FontSelectionRequest::ToString() const {
   return String::Format(
-      "weight=%s, width=%s, slope=%s", weight.ToString().Ascii().data(),
-      width.ToString().Ascii().data(), slope.ToString().Ascii().data());
+      "weight=%s, width=%s, slope=%s", weight.ToString().Ascii().c_str(),
+      width.ToString().Ascii().data(), slope.ToString().Ascii().c_str());
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_selection_types.h b/third_party/blink/renderer/platform/fonts/font_selection_types.h
index 5fb1723e2fe6..06d293f01a68 100644
--- a/third_party/blink/renderer/platform/fonts/font_selection_types.h
+++ b/third_party/blink/renderer/platform/fonts/font_selection_types.h
@@ -26,7 +26,9 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_SELECTION_TYPES_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_SELECTION_TYPES_H_
 
+#include "base/numerics/ranges.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/hash_table_deleted_value_type.h"
 #include "third_party/blink/renderer/platform/wtf/hash_traits.h"
 #include "third_party/blink/renderer/platform/wtf/math_extras.h"
@@ -40,17 +42,22 @@ namespace blink {
 // means the smallest positive representable value is 0.25, the maximum
 // representable value is 8191.75, and the minimum representable value is -8192.
 class PLATFORM_EXPORT FontSelectionValue {
+  USING_FAST_MALLOC(FontSelectionValue);
+
  public:
   FontSelectionValue() = default;
 
   // Explicit because it is lossy.
-  explicit FontSelectionValue(int x) : backing_(x * fractionalEntropy) {}
+  explicit FontSelectionValue(int x)
+      : backing_(clampTo<int16_t>(x * fractionalEntropy)) {}
 
   // Explicit because it is lossy.
-  explicit FontSelectionValue(float x) : backing_(x * fractionalEntropy) {}
+  explicit FontSelectionValue(float x)
+      : backing_(clampTo<int16_t>(x * fractionalEntropy)) {}
 
   // Explicit because it is lossy.
-  explicit FontSelectionValue(double x) : backing_(x * fractionalEntropy) {}
+  explicit FontSelectionValue(double x)
+      : backing_(clampTo<int16_t>(x * fractionalEntropy)) {}
 
   operator float() const {
     // floats have 23 fractional bits, but only 14 fractional bits are
@@ -185,6 +192,18 @@ static inline const FontSelectionValue& ItalicSlopeValue() {
   return italicValue;
 }
 
+static inline const FontSelectionValue& MaxObliqueValue() {
+  DEFINE_THREAD_SAFE_STATIC_LOCAL(const FontSelectionValue, maxObliqueValue,
+                                  (90));
+  return maxObliqueValue;
+}
+
+static inline const FontSelectionValue& MinObliqueValue() {
+  DEFINE_THREAD_SAFE_STATIC_LOCAL(const FontSelectionValue, minObliqueValue,
+                                  (-90));
+  return minObliqueValue;
+}
+
 static inline const FontSelectionValue& BoldThreshold() {
   DEFINE_THREAD_SAFE_STATIC_LOCAL(const FontSelectionValue, boldThreshold,
                                   (600));
@@ -326,11 +345,7 @@ struct FontSelectionRange {
   }
 
   FontSelectionValue clampToRange(FontSelectionValue selection_value) const {
-    if (selection_value < minimum)
-      return minimum;
-    if (selection_value > maximum)
-      return maximum;
-    return selection_value;
+    return base::ClampToRange(selection_value, minimum, maximum);
   }
 
   FontSelectionValue minimum{FontSelectionValue(1)};
diff --git a/third_party/blink/renderer/platform/fonts/font_selection_types_test.cc b/third_party/blink/renderer/platform/fonts/font_selection_types_test.cc
index dd41e1fde4b4..11480c83b8cd 100644
--- a/third_party/blink/renderer/platform/fonts/font_selection_types_test.cc
+++ b/third_party/blink/renderer/platform/fonts/font_selection_types_test.cc
@@ -10,10 +10,9 @@
 namespace blink {
 
 TEST(FontSelectionTypesTest, HashCollisions) {
-  std::vector<int> weights = {100, 200, 300, 400, 500, 600, 700, 800, 900};
-  std::vector<float> slopes = {-90, -67.5, -30, -20,  -10, 0,
-                               10,  20,    30,  67.5, 90};
-  std::vector<float> widths = {50, 67.5, 75, 100, 125, 150, 167.5, 175, 200};
+  Vector<int> weights = {100, 200, 300, 400, 500, 600, 700, 800, 900};
+  Vector<float> slopes = {-90, -67.5, -30, -20, -10, 0, 10, 20, 30, 67.5, 90};
+  Vector<float> widths = {50, 67.5, 75, 100, 125, 150, 167.5, 175, 200};
 
   HashSet<unsigned> hashes;
   for (auto weight : weights) {
diff --git a/third_party/blink/renderer/platform/fonts/font_selector.cc b/third_party/blink/renderer/platform/fonts/font_selector.cc
index 90bb107acbc5..ea54e9d8c6d9 100644
--- a/third_party/blink/renderer/platform/fonts/font_selector.cc
+++ b/third_party/blink/renderer/platform/fonts/font_selector.cc
@@ -7,6 +7,8 @@
 #include "build/build_config.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_list.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_map.h"
 #include "third_party/blink/renderer/platform/fonts/generic_font_family_settings.h"
 
 namespace blink {
@@ -18,7 +20,7 @@ AtomicString FontSelector::FamilyNameFromSettings(
 #if defined(OS_ANDROID)
   if (font_description.GenericFamily() == FontDescription::kStandardFamily) {
     return FontCache::GetGenericFamilyNameForScript(
-        FontFamilyNames::webkit_standard, font_description);
+        font_family_names::kWebkitStandard, font_description);
   }
 
   if (generic_family_name.StartsWith("-webkit-")) {
@@ -29,22 +31,35 @@ AtomicString FontSelector::FamilyNameFromSettings(
   UScriptCode script = font_description.GetScript();
   if (font_description.GenericFamily() == FontDescription::kStandardFamily)
     return settings.Standard(script);
-  if (generic_family_name == FontFamilyNames::webkit_serif)
+  if (generic_family_name == font_family_names::kWebkitSerif)
     return settings.Serif(script);
-  if (generic_family_name == FontFamilyNames::webkit_sans_serif)
+  if (generic_family_name == font_family_names::kWebkitSansSerif)
     return settings.SansSerif(script);
-  if (generic_family_name == FontFamilyNames::webkit_cursive)
+  if (generic_family_name == font_family_names::kWebkitCursive)
     return settings.Cursive(script);
-  if (generic_family_name == FontFamilyNames::webkit_fantasy)
+  if (generic_family_name == font_family_names::kWebkitFantasy)
     return settings.Fantasy(script);
-  if (generic_family_name == FontFamilyNames::webkit_monospace)
+  if (generic_family_name == font_family_names::kWebkitMonospace)
     return settings.Fixed(script);
-  if (generic_family_name == FontFamilyNames::webkit_pictograph)
+  if (generic_family_name == font_family_names::kWebkitPictograph)
     return settings.Pictograph(script);
-  if (generic_family_name == FontFamilyNames::webkit_standard)
+  if (generic_family_name == font_family_names::kWebkitStandard)
     return settings.Standard(script);
 #endif
   return g_empty_atom;
 }
 
+void FontSelector::Trace(Visitor* visitor) const {
+  visitor->Trace(font_fallback_map_);
+  FontCacheClient::Trace(visitor);
+}
+
+FontFallbackMap& FontSelector::GetFontFallbackMap() {
+  if (!font_fallback_map_) {
+    font_fallback_map_ = MakeGarbageCollected<FontFallbackMap>(this);
+    RegisterForInvalidationCallbacks(font_fallback_map_);
+  }
+  return *font_fallback_map_;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_selector.h b/third_party/blink/renderer/platform/fonts/font_selector.h
index 2940116f7824..78527192a2c8 100644
--- a/third_party/blink/renderer/platform/fonts/font_selector.h
+++ b/third_party/blink/renderer/platform/fonts/font_selector.h
@@ -28,6 +28,9 @@
 
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache_client.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
+#include "third_party/blink/renderer/platform/fonts/font_invalidation_reason.h"
+#include "third_party/blink/renderer/platform/fonts/font_matching_metrics.h"
 #include "third_party/blink/renderer/platform/fonts/segmented_font_data.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/wtf/forward.h"
@@ -39,6 +42,7 @@ class ExecutionContext;
 class FontData;
 class FontDescription;
 class FontFaceCache;
+class FontFallbackMap;
 class FontSelectorClient;
 class GenericFontFamilySettings;
 
@@ -59,12 +63,67 @@ class PLATFORM_EXPORT FontSelector : public FontCacheClient {
 
   virtual unsigned Version() const = 0;
 
+  // Called when a page attempts to match a font family, and the font family is
+  // available.
+  virtual void ReportSuccessfulFontFamilyMatch(
+      const AtomicString& font_family_name) = 0;
+
+  // Called when a page attempts to match a font family, and the font family is
+  // not available.
+  virtual void ReportFailedFontFamilyMatch(
+      const AtomicString& font_family_name) = 0;
+
+  // Called when a page attempts to match a font name via a @font-face src:local
+  // rule, and the font is available.
+  virtual void ReportSuccessfulLocalFontMatch(
+      const AtomicString& font_name) = 0;
+
+  // Called when a page attempts to match a font name via a @font-face src:local
+  // rule, and the font is not available.
+  virtual void ReportFailedLocalFontMatch(const AtomicString& font_name) = 0;
+
+  // Called whenever a page attempts to find a local font based on a name. This
+  // only includes lookups where the name is allowed to match family names,
+  // PostScript names and full font names.
+  virtual void ReportFontLookupByUniqueOrFamilyName(
+      const AtomicString& name,
+      const FontDescription& font_description,
+      SimpleFontData* resulting_font_data) = 0;
+
+  // Called whenever a page attempts to find a local font based on a name. This
+  // only includes lookups where the name is allowed to match PostScript names
+  // and full font names, but not family names.
+  virtual void ReportFontLookupByUniqueNameOnly(
+      const AtomicString& name,
+      const FontDescription& font_description,
+      SimpleFontData* resulting_font_data,
+      bool is_loading_fallback = false) = 0;
+
+  // Called whenever a page attempts to find a local font based on a fallback
+  // character.
+  virtual void ReportFontLookupByFallbackCharacter(
+      UChar32 fallback_character,
+      FontFallbackPriority fallback_priority,
+      const FontDescription& font_description,
+      SimpleFontData* resulting_font_data) = 0;
+
+  // Called whenever a page attempts to find a last-resort font.
+  virtual void ReportLastResortFallbackFontLookup(
+      const FontDescription& font_description,
+      SimpleFontData* resulting_font_data) = 0;
+
   virtual void ReportNotDefGlyph() const = 0;
 
+  // Called during text shaping of emoji presentation segments and after
+  // identifying how many clusters render as a single, non-tofu glyph.
+  virtual void ReportEmojiSegmentGlyphCoverage(
+      unsigned num_clusters,
+      unsigned num_broken_clusters) = 0;
+
   virtual void RegisterForInvalidationCallbacks(FontSelectorClient*) = 0;
   virtual void UnregisterForInvalidationCallbacks(FontSelectorClient*) = 0;
 
-  virtual void FontFaceInvalidated(){};
+  virtual void FontFaceInvalidated(FontInvalidationReason) {}
 
   virtual ExecutionContext* GetExecutionContext() const = 0;
 
@@ -74,11 +133,18 @@ class PLATFORM_EXPORT FontSelector : public FontCacheClient {
       const FontDescription&,
       const AtomicString& passed_family) = 0;
 
+  FontFallbackMap& GetFontFallbackMap();
+
+  void Trace(Visitor* visitor) const override;
+
  protected:
   static AtomicString FamilyNameFromSettings(
       const GenericFontFamilySettings&,
       const FontDescription&,
       const AtomicString& generic_family_name);
+
+ private:
+  Member<FontFallbackMap> font_fallback_map_;
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_selector_client.h b/third_party/blink/renderer/platform/fonts/font_selector_client.h
index 649b054fb680..2a0ac9286c38 100644
--- a/third_party/blink/renderer/platform/fonts/font_selector_client.h
+++ b/third_party/blink/renderer/platform/fonts/font_selector_client.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_SELECTOR_CLIENT_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_SELECTOR_CLIENT_H_
 
+#include "third_party/blink/renderer/platform/fonts/font_invalidation_reason.h"
 #include "third_party/blink/renderer/platform/heap/handle.h"
 
 namespace blink {
@@ -15,9 +16,9 @@ class FontSelectorClient : public GarbageCollectedMixin {
  public:
   virtual ~FontSelectorClient() = default;
 
-  virtual void FontsNeedUpdate(FontSelector*) = 0;
+  virtual void FontsNeedUpdate(FontSelector*, FontInvalidationReason) = 0;
 
-  void Trace(blink::Visitor* visitor) override {}
+  void Trace(Visitor* visitor) const override {}
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_test.cc b/third_party/blink/renderer/platform/fonts/font_test.cc
index ceb0542e3d98..302923ee5964 100644
--- a/third_party/blink/renderer/platform/fonts/font_test.cc
+++ b/third_party/blink/renderer/platform/fonts/font_test.cc
@@ -4,11 +4,12 @@
 
 #include "third_party/blink/renderer/platform/fonts/font.h"
 
+#include "cc/paint/paint_flags.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/renderer/platform/fonts/text_run_paint_info.h"
-#include "third_party/blink/renderer/platform/graphics/paint/paint_flags.h"
 #include "third_party/blink/renderer/platform/testing/font_test_helpers.h"
 #include "third_party/blink/renderer/platform/testing/unit_test_helpers.h"
+#include "third_party/blink/renderer/platform/text/tab_size.h"
 #include "third_party/blink/renderer/platform/text/text_run.h"
 
 using blink::test::CreateTestFont;
@@ -45,7 +46,7 @@ TEST_F(FontTest, TextIntercepts) {
                                               0x70, 0xc9, 0x70, 0xc9};
   TextRun ahem_above_below_baseline(ahem_above_below_baseline_string, 9);
   TextRunPaintInfo text_run_paint_info(ahem_above_below_baseline);
-  PaintFlags default_paint;
+  cc::PaintFlags default_paint;
   float device_scale_factor = 1;
 
   std::tuple<float, float> below_baseline_bounds = std::make_tuple(2, 4);
@@ -86,4 +87,12 @@ TEST_F(FontTest, ExpandRange) {
   EXPECT_EQ(GetExpandedRange("tneiciffe", false, 0, 9), Vector<int>({0, 9}));
 }
 
+TEST_F(FontTest, TabWidthZero) {
+  Font font =
+      CreateTestFont("Ahem", test::PlatformTestDataPath("Ahem.woff"), 0);
+  TabSize tab_size(8);
+  EXPECT_EQ(font.TabWidth(tab_size, .0f), .0f);
+  EXPECT_EQ(font.TabWidth(tab_size, LayoutUnit()), LayoutUnit());
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_unique_name_lookup.cc b/third_party/blink/renderer/platform/fonts/font_unique_name_lookup.cc
new file mode 100644
index 000000000000..6fce7e20df89
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/font_unique_name_lookup.cc
@@ -0,0 +1,35 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/font_unique_name_lookup.h"
+#include "base/macros.h"
+
+#if defined(OS_ANDROID)
+#include "third_party/blink/public/mojom/font_unique_name_lookup/font_unique_name_lookup.mojom-blink.h"
+#include "third_party/blink/renderer/platform/fonts/android/font_unique_name_lookup_android.h"
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#include "third_party/blink/renderer/platform/fonts/linux/font_unique_name_lookup_linux.h"
+#elif defined(OS_WIN)
+#include "third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h"
+#endif
+
+namespace blink {
+
+FontUniqueNameLookup::FontUniqueNameLookup() = default;
+
+// static
+std::unique_ptr<FontUniqueNameLookup>
+FontUniqueNameLookup::GetPlatformUniqueNameLookup() {
+#if defined(OS_ANDROID)
+  return std::make_unique<FontUniqueNameLookupAndroid>();
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+  return std::make_unique<FontUniqueNameLookupLinux>();
+#elif defined(OS_WIN)
+  return std::make_unique<FontUniqueNameLookupWin>();
+#else
+  return nullptr;
+#endif
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_unique_name_lookup.h b/third_party/blink/renderer/platform/fonts/font_unique_name_lookup.h
new file mode 100644
index 000000000000..772a76b22bd2
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/font_unique_name_lookup.h
@@ -0,0 +1,71 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_UNIQUE_NAME_LOOKUP_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_UNIQUE_NAME_LOOKUP_H_
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "build/build_config.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+#if defined(OS_ANDROID) || defined(OS_WIN)
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
+#endif
+
+#include <memory>
+
+namespace blink {
+
+class FontTableMatcher;
+
+class FontUniqueNameLookup {
+  USING_FAST_MALLOC(FontUniqueNameLookup);
+
+ public:
+  // Factory function to construct a platform specific font unique name lookup
+  // instance. Client must not use this directly as it is thread
+  // specific. Retrieve it from FontGlobalContext instead.
+  static std::unique_ptr<FontUniqueNameLookup> GetPlatformUniqueNameLookup();
+
+  virtual sk_sp<SkTypeface> MatchUniqueName(const String& font_unique_name) = 0;
+
+  virtual ~FontUniqueNameLookup() = default;
+
+  // Below: Methods for asynchronously retrieving the FontUniqueNameLookup
+  // table. Currently needed on Windows, on other platforms the implementation
+  // is synchronous.
+
+  // Determines whether fonts can be uniquely matched synchronously.
+  virtual bool IsFontUniqueNameLookupReadyForSyncLookup() { return true; }
+
+  // If fonts cannot be uniquely matched synchronously, send a Mojo IPC call to
+  // prepare the lookup table, and wait for the callback. Once the callback has
+  // been called, IsFontUniqueNameLookupReadyForSyncLookup() will become true.
+  // PrepareFontUniqueNameLookup() must not be called if
+  // IsFontUniqueNameLookupReadyForSyncLookup() is true already.
+  using NotifyFontUniqueNameLookupReady = base::OnceCallback<void()>;
+  virtual void PrepareFontUniqueNameLookup(
+      NotifyFontUniqueNameLookupReady callback) {
+    NOTREACHED();
+  }
+
+ protected:
+  FontUniqueNameLookup();
+
+  // Windows and Android share the concept of connecting to a Mojo service for
+  // retrieving a ReadOnlySharedMemoryRegion with the lookup table in it.
+#if defined(OS_WIN) || defined(OS_ANDROID)
+  std::unique_ptr<FontTableMatcher> font_table_matcher_;
+#endif
+
+  DISALLOW_COPY_AND_ASSIGN(FontUniqueNameLookup);
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_UNIQUE_NAME_LOOKUP_
diff --git a/third_party/blink/renderer/platform/fonts/font_variant_east_asian.cc b/third_party/blink/renderer/platform/fonts/font_variant_east_asian.cc
index 635cdb6e7242..9de5b08ecb41 100644
--- a/third_party/blink/renderer/platform/fonts/font_variant_east_asian.cc
+++ b/third_party/blink/renderer/platform/fonts/font_variant_east_asian.cc
@@ -44,8 +44,8 @@ String FontVariantEastAsian::ToString(EastAsianWidth width) {
 
 String FontVariantEastAsian::ToString() const {
   return String::Format(
-      "form=%s, width=%s, ruby=%s", ToString(Form()).Ascii().data(),
-      ToString(Width()).Ascii().data(), Ruby() ? "true" : "false");
+      "form=%s, width=%s, ruby=%s", ToString(Form()).Ascii().c_str(),
+      ToString(Width()).Ascii().c_str(), Ruby() ? "true" : "false");
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_variant_east_asian.h b/third_party/blink/renderer/platform/fonts/font_variant_east_asian.h
index 0a93008f9acd..fb545f00367f 100644
--- a/third_party/blink/renderer/platform/fonts/font_variant_east_asian.h
+++ b/third_party/blink/renderer/platform/fonts/font_variant_east_asian.h
@@ -5,7 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_VARIANT_EAST_ASIAN_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_VARIANT_EAST_ASIAN_H_
 
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/forward.h"
 
 namespace blink {
@@ -48,9 +48,9 @@ class FontVariantEastAsian {
   }
   bool Ruby() const { return fields_.ruby_; }
 
-  void SetForm(EastAsianForm form) { fields_.form_ = form; };
-  void SetWidth(EastAsianWidth width) { fields_.width_ = width; };
-  void SetRuby(bool ruby) { fields_.ruby_ = ruby; };
+  void SetForm(EastAsianForm form) { fields_.form_ = form; }
+  void SetWidth(EastAsianWidth width) { fields_.width_ = width; }
+  void SetRuby(bool ruby) { fields_.ruby_ = ruby; }
 
   bool IsAllNormal() const { return !fields_as_unsigned_; }
 
diff --git a/third_party/blink/renderer/platform/fonts/font_variant_numeric.cc b/third_party/blink/renderer/platform/fonts/font_variant_numeric.cc
index 179d2d2fc292..097c32796934 100644
--- a/third_party/blink/renderer/platform/fonts/font_variant_numeric.cc
+++ b/third_party/blink/renderer/platform/fonts/font_variant_numeric.cc
@@ -70,11 +70,11 @@ String FontVariantNumeric::ToString() const {
   return String::Format(
       "numeric_figure=%s, numeric_spacing=%s, numeric_fraction=%s, ordinal=%s, "
       "slashed_zero=%s",
-      ToString(NumericFigureValue()).Ascii().data(),
-      ToString(NumericSpacingValue()).Ascii().data(),
-      ToString(NumericFractionValue()).Ascii().data(),
-      ToString(OrdinalValue()).Ascii().data(),
-      ToString(SlashedZeroValue()).Ascii().data());
+      ToString(NumericFigureValue()).Ascii().c_str(),
+      ToString(NumericSpacingValue()).Ascii().c_str(),
+      ToString(NumericFractionValue()).Ascii().c_str(),
+      ToString(OrdinalValue()).Ascii().c_str(),
+      ToString(SlashedZeroValue()).Ascii().c_str());
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/font_variant_numeric.h b/third_party/blink/renderer/platform/fonts/font_variant_numeric.h
index c3b3a24664aa..7db96cb5eb47 100644
--- a/third_party/blink/renderer/platform/fonts/font_variant_numeric.h
+++ b/third_party/blink/renderer/platform/fonts/font_variant_numeric.h
@@ -5,7 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_VARIANT_NUMERIC_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_FONT_VARIANT_NUMERIC_H_
 
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/forward.h"
 
 namespace blink {
@@ -41,17 +41,17 @@ class FontVariantNumeric {
 
   void SetNumericFigure(NumericFigure figure) {
     fields_.numeric_figure_ = figure;
-  };
+  }
   void SetNumericSpacing(NumericSpacing spacing) {
     fields_.numeric_spacing_ = spacing;
-  };
+  }
   void SetNumericFraction(NumericFraction fraction) {
     fields_.numeric_fraction_ = fraction;
-  };
-  void SetOrdinal(Ordinal ordinal) { fields_.ordinal_ = ordinal; };
+  }
+  void SetOrdinal(Ordinal ordinal) { fields_.ordinal_ = ordinal; }
   void SetSlashedZero(SlashedZero slashed_zero) {
     fields_.slashed_zero_ = slashed_zero;
-  };
+  }
 
   NumericFigure NumericFigureValue() const {
     return static_cast<NumericFigure>(fields_.numeric_figure_);
@@ -64,7 +64,7 @@ class FontVariantNumeric {
   }
   Ordinal OrdinalValue() const {
     return static_cast<Ordinal>(fields_.ordinal_);
-  };
+  }
   SlashedZero SlashedZeroValue() const {
     return static_cast<SlashedZero>(fields_.slashed_zero_);
   }
diff --git a/third_party/blink/renderer/platform/fonts/fuchsia/font_cache_fuchsia.cc b/third_party/blink/renderer/platform/fonts/fuchsia/font_cache_fuchsia.cc
index 3bd6b1cd0616..4ce9d60a14e5 100644
--- a/third_party/blink/renderer/platform/fonts/fuchsia/font_cache_fuchsia.cc
+++ b/third_party/blink/renderer/platform/fonts/fuchsia/font_cache_fuchsia.cc
@@ -46,18 +46,29 @@ void FontCache::SetSystemFontFamily(const AtomicString& family_name) {
 
 scoped_refptr<SimpleFontData> FontCache::PlatformFallbackFontForCharacter(
     const FontDescription& font_description,
-    UChar32 c,
+    UChar32 character,
     const SimpleFontData* font_data_to_substitute,
     FontFallbackPriority fallback_priority) {
   sk_sp<SkFontMgr> font_mgr(SkFontMgr::RefDefault());
-  AtomicString family_name = GetFamilyNameForCharacter(
-      font_mgr.get(), c, font_description, fallback_priority);
-  if (family_name.IsEmpty())
-    return GetLastResortFallbackFont(font_description, kDoNotRetain);
-  return FontDataFromFontPlatformData(
-      GetFontPlatformData(font_description,
-                          FontFaceCreationParams(family_name)),
-      kDoNotRetain);
+  std::string family_name = font_description.Family().Family().Utf8();
+  Bcp47Vector locales =
+      GetBcp47LocaleForRequest(font_description, fallback_priority);
+  sk_sp<SkTypeface> typeface(font_mgr->matchFamilyStyleCharacter(
+      family_name.c_str(), font_description.SkiaFontStyle(), locales.data(),
+      locales.size(), character));
+  if (!typeface)
+    return nullptr;
+
+  bool synthetic_bold =
+      font_description.IsSyntheticBold() && !typeface->isBold();
+  bool synthetic_italic =
+      font_description.IsSyntheticItalic() && !typeface->isItalic();
+
+  auto font_data = std::make_unique<FontPlatformData>(
+      std::move(typeface), std::string(), font_description.EffectiveFontSize(),
+      synthetic_bold, synthetic_italic, font_description.Orientation());
+
+  return FontDataFromFontPlatformData(font_data.get(), kDoNotRetain);
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/generic_font_family_settings.h b/third_party/blink/renderer/platform/fonts/generic_font_family_settings.h
index f51665314291..ac58c70b7389 100644
--- a/third_party/blink/renderer/platform/fonts/generic_font_family_settings.h
+++ b/third_party/blink/renderer/platform/fonts/generic_font_family_settings.h
@@ -32,7 +32,7 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_GENERIC_FONT_FAMILY_SETTINGS_H_
 
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/hash_map.h"
 #include "third_party/blink/renderer/platform/wtf/text/atomic_string.h"
 #include "third_party/blink/renderer/platform/wtf/text/atomic_string_hash.h"
diff --git a/third_party/blink/renderer/platform/fonts/glyph.h b/third_party/blink/renderer/platform/fonts/glyph.h
index 54a1bc5a11cd..8e5e134894d0 100644
--- a/third_party/blink/renderer/platform/fonts/glyph.h
+++ b/third_party/blink/renderer/platform/fonts/glyph.h
@@ -30,9 +30,11 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_GLYPH_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_GLYPH_H_
 
+#include <cstdint>
+
 namespace blink {
 
-typedef unsigned short Glyph;
+typedef uint16_t Glyph;
 
 }  // namespace blink
 
diff --git a/third_party/blink/renderer/platform/fonts/glyph_metrics_map.h b/third_party/blink/renderer/platform/fonts/glyph_metrics_map.h
index cb98f10921ea..784461f20f29 100644
--- a/third_party/blink/renderer/platform/fonts/glyph_metrics_map.h
+++ b/third_party/blink/renderer/platform/fonts/glyph_metrics_map.h
@@ -34,7 +34,7 @@
 #include "base/memory/ptr_util.h"
 #include "third_party/blink/renderer/platform/fonts/glyph.h"
 #include "third_party/blink/renderer/platform/geometry/float_rect.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/assertions.h"
 #include "third_party/blink/renderer/platform/wtf/hash_map.h"
 #include "third_party/blink/renderer/platform/wtf/text/unicode.h"
@@ -46,7 +46,6 @@ const float kCGlyphSizeUnknown = -1;
 template <class T>
 class GlyphMetricsMap {
   USING_FAST_MALLOC(GlyphMetricsMap);
-  WTF_MAKE_NONCOPYABLE(GlyphMetricsMap);
 
  public:
   GlyphMetricsMap() : filled_primary_page_(false) {}
@@ -62,7 +61,7 @@ class GlyphMetricsMap {
  private:
   class GlyphMetricsPage {
     USING_FAST_MALLOC(GlyphMetricsPage);
-    WTF_MAKE_NONCOPYABLE(GlyphMetricsPage);
+    DISALLOW_COPY_AND_ASSIGN(GlyphMetricsPage);
 
    public:
     static const size_t kSize =
@@ -96,6 +95,8 @@ class GlyphMetricsMap {
   // We optimize for the page that contains glyph indices 0-255.
   GlyphMetricsPage primary_page_;
   std::unique_ptr<HashMap<int, std::unique_ptr<GlyphMetricsPage>>> pages_;
+
+  DISALLOW_COPY_AND_ASSIGN(GlyphMetricsMap);
 };
 
 template <>
diff --git a/third_party/blink/renderer/platform/fonts/linux/font_cache_linux.cc b/third_party/blink/renderer/platform/fonts/linux/font_cache_linux.cc
index 6d99346ee212..132f146e3323 100644
--- a/third_party/blink/renderer/platform/fonts/linux/font_cache_linux.cc
+++ b/third_party/blink/renderer/platform/fonts/linux/font_cache_linux.cc
@@ -25,12 +25,10 @@
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 
 #include "build/build_config.h"
-#include "third_party/blink/public/platform/linux/web_fallback_font.h"
 #include "third_party/blink/public/platform/linux/web_sandbox_support.h"
 #include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
-#include "third_party/blink/renderer/platform/wtf/text/cstring.h"
 #include "ui/gfx/font_fallback_linux.h"
 
 namespace blink {
@@ -51,34 +49,16 @@ void FontCache::SetSystemFontFamily(const AtomicString& family_name) {
   MutableSystemFontFamily() = family_name;
 }
 
-void FontCache::GetFontForCharacter(
-    UChar32 c,
-    const char* preferred_locale,
-    FontCache::PlatformFallbackFont* fallback_font) {
+bool FontCache::GetFontForCharacter(UChar32 c,
+                                    const char* preferred_locale,
+                                    gfx::FallbackFontData* fallback_font) {
   if (Platform::Current()->GetSandboxSupport()) {
-    WebFallbackFont web_fallback_font;
-    Platform::Current()->GetSandboxSupport()->GetFallbackFontForCharacter(
-        c, preferred_locale, &web_fallback_font);
-    fallback_font->name = web_fallback_font.name;
-    fallback_font->filename = CString(web_fallback_font.filename.Data(),
-                                      web_fallback_font.filename.size());
-    fallback_font->fontconfig_interface_id =
-        web_fallback_font.fontconfig_interface_id;
-    fallback_font->ttc_index = web_fallback_font.ttc_index;
-    fallback_font->is_bold = web_fallback_font.is_bold;
-    fallback_font->is_italic = web_fallback_font.is_italic;
+    return Platform::Current()
+        ->GetSandboxSupport()
+        ->GetFallbackFontForCharacter(c, preferred_locale, fallback_font);
   } else {
     std::string locale = preferred_locale ? preferred_locale : std::string();
-    gfx::FallbackFontData fallback_data =
-        gfx::GetFallbackFontForChar(c, locale);
-    fallback_font->name = String::FromUTF8(fallback_data.name.data(),
-                                           fallback_data.name.length());
-    fallback_font->filename =
-        CString(fallback_data.filename.data(), fallback_data.filename.length());
-    fallback_font->fontconfig_interface_id = 0;
-    fallback_font->ttc_index = fallback_data.ttc_index;
-    fallback_font->is_bold = fallback_data.is_bold;
-    fallback_font->is_italic = fallback_data.is_italic;
+    return gfx::GetFallbackFontForChar(c, locale, fallback_font);
   }
 }
 
@@ -91,7 +71,7 @@ scoped_refptr<SimpleFontData> FontCache::PlatformFallbackFontForCharacter(
   // WebFontRendering::setSkiaFontManager. This is used to emulate android fonts
   // on linux so we always request the family from the font manager and if none
   // is found, we return the LastResort fallback font and avoid using
-  // FontCache::getFontForCharacter which would use sandbox support to query the
+  // FontCache::GetFontForCharacter which would use sandbox support to query the
   // underlying system for the font family.
   if (font_manager_) {
     AtomicString family_name = GetFamilyNameForCharacter(
@@ -122,15 +102,18 @@ scoped_refptr<SimpleFontData> FontCache::PlatformFallbackFontForCharacter(
       return font_data;
   }
 
-  FontCache::PlatformFallbackFont fallback_font;
-  FontCache::GetFontForCharacter(
-      c, font_description.LocaleOrDefault().Ascii().data(), &fallback_font);
-  if (fallback_font.name.IsEmpty())
+  gfx::FallbackFontData fallback_font;
+  if (!FontCache::GetFontForCharacter(
+          c,
+          fallback_priority == FontFallbackPriority::kEmojiEmoji
+              ? kColorEmojiLocale
+              : font_description.LocaleOrDefault().Ascii().c_str(),
+          &fallback_font))
     return nullptr;
 
   FontFaceCreationParams creation_params;
   creation_params = FontFaceCreationParams(
-      fallback_font.filename, fallback_font.fontconfig_interface_id,
+      fallback_font.filepath.value(), fallback_font.fontconfig_interface_id,
       fallback_font.ttc_index);
 
   // Changes weight and/or italic of given FontDescription depends on
diff --git a/third_party/blink/renderer/platform/fonts/linux/font_unique_name_lookup_linux.cc b/third_party/blink/renderer/platform/fonts/linux/font_unique_name_lookup_linux.cc
new file mode 100644
index 000000000000..604a895c0757
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/linux/font_unique_name_lookup_linux.cc
@@ -0,0 +1,37 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/linux/font_unique_name_lookup_linux.h"
+
+#include "third_party/blink/public/platform/linux/web_sandbox_support.h"
+#include "third_party/blink/public/platform/platform.h"
+#include "third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.h"
+#include "ui/gfx/font_fallback_linux.h"
+
+namespace blink {
+
+FontUniqueNameLookupLinux::~FontUniqueNameLookupLinux() = default;
+
+sk_sp<SkTypeface> FontUniqueNameLookupLinux::MatchUniqueName(
+    const String& font_unique_name) {
+  gfx::FallbackFontData uniquely_matched_font;
+  if (!Platform::Current()->GetSandboxSupport()) {
+    LOG(ERROR) << "@font-face src: local() instantiation only available when "
+                  "connected to browser process.";
+    return nullptr;
+  }
+
+  if (!Platform::Current()
+           ->GetSandboxSupport()
+           ->MatchFontByPostscriptNameOrFullFontName(
+               font_unique_name.Utf8(WTF::kStrictUTF8Conversion).c_str(),
+               &uniquely_matched_font))
+    return nullptr;
+
+  return SkTypeface_Factory::FromFontConfigInterfaceIdAndTtcIndex(
+      uniquely_matched_font.fontconfig_interface_id,
+      uniquely_matched_font.ttc_index);
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/linux/font_unique_name_lookup_linux.h b/third_party/blink/renderer/platform/fonts/linux/font_unique_name_lookup_linux.h
new file mode 100644
index 000000000000..af255b02b906
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/linux/font_unique_name_lookup_linux.h
@@ -0,0 +1,26 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_LINUX_FONT_UNIQUE_NAME_LOOKUP_LINUX_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_LINUX_FONT_UNIQUE_NAME_LOOKUP_LINUX_H_
+
+#include "third_party/blink/renderer/platform/fonts/font_unique_name_lookup.h"
+
+#include <memory>
+
+namespace blink {
+
+class FontUniqueNameLookupLinux : public FontUniqueNameLookup {
+ public:
+  FontUniqueNameLookupLinux() = default;
+  ~FontUniqueNameLookupLinux() override;
+  sk_sp<SkTypeface> MatchUniqueName(const String& font_unique_name) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(FontUniqueNameLookupLinux);
+};
+
+}  // namespace blink
+
+#endif
diff --git a/third_party/blink/renderer/platform/fonts/mac/OWNERS b/third_party/blink/renderer/platform/fonts/mac/OWNERS
new file mode 100644
index 000000000000..a1660982293f
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/mac/OWNERS
@@ -0,0 +1,2 @@
+per-file *_type_converter*.*=set noparent
+per-file *_type_converter*.*=file://ipc/SECURITY_OWNERS
diff --git a/third_party/blink/renderer/platform/fonts/mac/attributed_string_type_converter.h b/third_party/blink/renderer/platform/fonts/mac/attributed_string_type_converter.h
new file mode 100644
index 000000000000..37a83c79cb71
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/mac/attributed_string_type_converter.h
@@ -0,0 +1,28 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_ATTRIBUTED_STRING_TYPE_CONVERTER_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_ATTRIBUTED_STRING_TYPE_CONVERTER_H_
+
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include "ui/base/mojom/attributed_string.mojom-blink.h"
+
+#if __OBJC__
+@class NSAttributedString;
+#else
+class NSAttributedString;
+#endif
+
+namespace mojo {
+
+template <>
+struct PLATFORM_EXPORT
+    TypeConverter<ui::mojom::blink::AttributedStringPtr, NSAttributedString*> {
+  static ui::mojom::blink::AttributedStringPtr Convert(
+      const NSAttributedString* ns_attributed_string);
+};
+
+}  // namespace mojo
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_ATTRIBUTED_STRING_TYPE_CONVERTER_H_
diff --git a/third_party/blink/renderer/platform/fonts/mac/attributed_string_type_converter.mm b/third_party/blink/renderer/platform/fonts/mac/attributed_string_type_converter.mm
new file mode 100644
index 000000000000..683669be3bfc
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/mac/attributed_string_type_converter.mm
@@ -0,0 +1,51 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/mac/attributed_string_type_converter.h"
+
+#include <AppKit/AppKit.h>
+
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "ui/gfx/range/range.h"
+
+namespace mojo {
+
+ui::mojom::blink::AttributedStringPtr
+TypeConverter<ui::mojom::blink::AttributedStringPtr, NSAttributedString*>::
+    Convert(const NSAttributedString* ns_attributed_string) {
+  // Create the return value.
+  ui::mojom::blink::AttributedStringPtr attributed_string =
+      ui::mojom::blink::AttributedString::New();
+  attributed_string->string = String([ns_attributed_string string]);
+
+  // Iterate over all the attributes in the string.
+  NSUInteger length = [ns_attributed_string length];
+  for (NSUInteger i = 0; i < length;) {
+    NSRange effective_range;
+    NSDictionary* ns_attributes =
+        [ns_attributed_string attributesAtIndex:i
+                                 effectiveRange:&effective_range];
+
+    NSFont* font = [ns_attributes objectForKey:NSFontAttributeName];
+    String font_name;
+    float font_point_size;
+    // Only encode the attributes if the filtered set contains font information.
+    if (font) {
+      font_name = String([font fontName]);
+      font_point_size = [font pointSize];
+      if (!font_name.IsEmpty()) {
+        // Convert the attributes.
+        ui::mojom::blink::FontAttributePtr attrs =
+            ui::mojom::blink::FontAttribute::New(font_name, font_point_size,
+                                                 gfx::Range(effective_range));
+        attributed_string->attributes.push_back(std::move(attrs));
+      }
+    }
+    // Advance the iterator to the position outside of the effective range.
+    i = NSMaxRange(effective_range);
+  }
+  return attributed_string;
+}
+
+}  // namespace mojo
diff --git a/third_party/blink/renderer/platform/fonts/mac/core_text_font_format_support.cc b/third_party/blink/renderer/platform/fonts/mac/core_text_font_format_support.cc
new file mode 100644
index 000000000000..619765def09e
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/mac/core_text_font_format_support.cc
@@ -0,0 +1,21 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/mac/core_text_font_format_support.h"
+
+#include "base/mac/mac_util.h"
+
+namespace blink {
+
+bool CoreTextVersionSupportsVariations() {
+  return base::mac::IsAtLeastOS10_14();
+}
+
+// CoreText versions below 10.13 display COLR cpal as black/foreground-color
+// glyphs and do not interpret color glyph layers correctly.
+bool CoreTextVersionSupportsColrCpal() {
+  return base::mac::IsAtLeastOS10_13();
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/mac/core_text_variations_support.h b/third_party/blink/renderer/platform/fonts/mac/core_text_font_format_support.h
similarity index 64%
rename from third_party/blink/renderer/platform/fonts/mac/core_text_variations_support.h
rename to third_party/blink/renderer/platform/fonts/mac/core_text_font_format_support.h
index f8c175a71014..b5f3ffe9738e 100644
--- a/third_party/blink/renderer/platform/fonts/mac/core_text_variations_support.h
+++ b/third_party/blink/renderer/platform/fonts/mac/core_text_font_format_support.h
@@ -2,12 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_CORE_TEXT_VARIATIONS_SUPPORT_H_
-#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_CORE_TEXT_VARIATIONS_SUPPORT_H_
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_CORE_TEXT_FONT_FORMAT_SUPPORT_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_CORE_TEXT_FONT_FORMAT_SUPPORT_H_
 
 namespace blink {
 
 bool CoreTextVersionSupportsVariations();
-}
+bool CoreTextVersionSupportsColrCpal();
 
-#endif
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_CORE_TEXT_FONT_FORMAT_SUPPORT_H_
diff --git a/third_party/blink/renderer/platform/fonts/mac/core_text_variations_support.cc b/third_party/blink/renderer/platform/fonts/mac/core_text_variations_support.cc
deleted file mode 100644
index 5b95205856b9..000000000000
--- a/third_party/blink/renderer/platform/fonts/mac/core_text_variations_support.cc
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "third_party/blink/renderer/platform/fonts/mac/core_text_variations_support.h"
-
-#include <CoreText/CoreText.h>
-
-namespace blink {
-
-// Compare CoreText.h in an up to date SDK, redefining here since we don't seem
-// to have access to this value when building against the 10.10 SDK in our
-// standard Chrome build configuration.
-static const long kBlinkLocalCTVersionNumber10_12 = 0x00090000;
-
-bool CoreTextVersionSupportsVariations() {
-  return &CTGetCoreTextVersion &&
-         CTGetCoreTextVersion() >= kBlinkLocalCTVersionNumber10_12;
-}
-}
diff --git a/third_party/blink/renderer/platform/fonts/mac/font_cache_mac.mm b/third_party/blink/renderer/platform/fonts/mac/font_cache_mac.mm
index e792e97d015b..fb5629f95968 100644
--- a/third_party/blink/renderer/platform/fonts/mac/font_cache_mac.mm
+++ b/third_party/blink/renderer/platform/fonts/mac/font_cache_mac.mm
@@ -29,18 +29,26 @@
 
 #import "third_party/blink/renderer/platform/fonts/font_cache.h"
 
-#import <AppKit/AppKit.h>
 #include <memory>
+
+#import <AppKit/AppKit.h>
+#import <CoreText/CoreText.h>
+
 #include "base/location.h"
+#include "base/mac/foundation_util.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/timer/elapsed_timer.h"
 #include "third_party/blink/public/platform/platform.h"
-#include "third_party/blink/public/platform/web_thread.h"
 #include "third_party/blink/renderer/platform/font_family_names.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
 #include "third_party/blink/renderer/platform/fonts/font_face_creation_params.h"
 #include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
-#include "third_party/blink/renderer/platform/fonts/mac/font_family_matcher_mac.h"
+#include "third_party/blink/renderer/platform/fonts/mac/font_matcher_mac.h"
+#include "third_party/blink/renderer/platform/fonts/mac/font_platform_data_mac.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
-#include "third_party/blink/renderer/platform/layout_test_support.h"
+#include "third_party/blink/renderer/platform/runtime_enabled_features.h"
+#include "third_party/blink/renderer/platform/scheduler/public/thread.h"
+#include "third_party/blink/renderer/platform/web_test_support.h"
 #include "third_party/blink/renderer/platform/wtf/functional.h"
 #include "third_party/blink/renderer/platform/wtf/std_lib_extras.h"
 
@@ -62,12 +70,12 @@ const char kColorEmojiFontMac[] = "Apple Color Emoji";
 
 // static
 const AtomicString& FontCache::LegacySystemFontFamily() {
-  return FontFamilyNames::BlinkMacSystemFont;
+  return font_family_names::kBlinkMacSystemFont;
 }
 
 static void InvalidateFontCache() {
   if (!IsMainThread()) {
-    Platform::Current()->MainThread()->GetTaskRunner()->PostTask(
+    Thread::MainThread()->GetTaskRunner()->PostTask(
         FROM_HERE, WTF::Bind(&InvalidateFontCache));
     return;
   }
@@ -86,9 +94,9 @@ static void FontCacheRegisteredFontsChangedNotificationCallback(
 }
 
 static bool UseHinting() {
-  // Enable hinting only when antialiasing is disabled in layout tests.
-  return (LayoutTestSupport::IsRunningLayoutTest() &&
-          !LayoutTestSupport::IsFontAntialiasingEnabledForTest());
+  // Enable hinting only when antialiasing is disabled in web tests.
+  return (WebTestSupport::IsRunningWebTest() &&
+          !WebTestSupport::IsFontAntialiasingEnabledForTest());
 }
 
 void FontCache::PlatformInit() {
@@ -130,18 +138,16 @@ scoped_refptr<SimpleFontData> FontCache::PlatformFallbackFontForCharacter(
 
   const FontPlatformData& platform_data =
       font_data_to_substitute->PlatformData();
-  NSFont* ns_font = toNSFont(platform_data.CtFont());
+  NSFont* ns_font = base::mac::CFToNSCast(platform_data.CtFont());
 
-  NSString* string =
-      [[NSString alloc] initWithCharactersNoCopy:code_units
-                                          length:code_units_length
-                                    freeWhenDone:NO];
+  NSString* string = [[[NSString alloc]
+      initWithCharacters:reinterpret_cast<UniChar*>(code_units)
+                  length:code_units_length] autorelease];
   NSFont* substitute_font =
       [NSFont findFontLike:ns_font
                  forString:string
                  withRange:NSMakeRange(0, code_units_length)
                 inLanguage:nil];
-  [string release];
 
   // FIXME: Remove this SPI usage: http://crbug.com/255122
   if (!substitute_font && code_units_length == 1)
@@ -214,14 +220,17 @@ scoped_refptr<SimpleFontData> FontCache::PlatformFallbackFontForCharacter(
       !IsAppKitFontWeightBold(substitute_font_weight) &&
       ![substitute_font.familyName isEqual:@"Apple Color Emoji"];
 
-  FontPlatformData alternate_font(
+  std::unique_ptr<FontPlatformData> alternate_font = FontPlatformDataFromNSFont(
       substitute_font, platform_data.size(), synthetic_bold,
       (traits & NSFontItalicTrait) &&
           !(substitute_font_traits & NSFontItalicTrait),
-      platform_data.Orientation(),
+      platform_data.Orientation(), font_description.FontOpticalSizing(),
       nullptr);  // No variation paramaters in fallback.
 
-  return FontDataFromFontPlatformData(&alternate_font, kDoNotRetain);
+  if (!alternate_font)
+    return nullptr;
+
+  return FontDataFromFontPlatformData(alternate_font.get(), kDoNotRetain);
 }
 
 scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
@@ -231,7 +240,7 @@ scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
   // For now we'll pick the default that the user would get without changing
   // any prefs.
   scoped_refptr<SimpleFontData> simple_font_data =
-      GetFontData(font_description, FontFamilyNames::Times,
+      GetFontData(font_description, font_family_names::kTimes,
                   AlternateFontName::kAllowAlternate, should_retain);
   if (simple_font_data)
     return simple_font_data;
@@ -240,7 +249,7 @@ scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
   // where the user doesn't have it, we fall back on Lucida Grande because
   // that's guaranteed to be there, according to Nathan Taylor. This is good
   // enough to avoid a crash at least.
-  return GetFontData(font_description, FontFamilyNames::Lucida_Grande,
+  return GetFontData(font_description, font_family_names::kLucidaGrande,
                      AlternateFontName::kAllowAlternate, should_retain);
 }
 
@@ -248,23 +257,29 @@ std::unique_ptr<FontPlatformData> FontCache::CreateFontPlatformData(
     const FontDescription& font_description,
     const FontFaceCreationParams& creation_params,
     float font_size,
-    AlternateFontName) {
+    AlternateFontName alternate_name) {
   NSFontTraitMask traits = font_description.Style() ? NSFontItalicTrait : 0;
   float size = font_size;
 
-  NSFont* ns_font = MatchNSFontFamily(creation_params.Family(), traits,
-                                      font_description.Weight(), size);
-  if (!ns_font)
+  NSFont* matched_font = nullptr;
+  if (alternate_name == AlternateFontName::kLocalUniqueFace &&
+      RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled()) {
+    matched_font = MatchUniqueFont(creation_params.Family(), size);
+  } else {
+    matched_font = MatchNSFontFamily(creation_params.Family(), traits,
+                                     font_description.Weight(), size);
+  }
+  if (!matched_font)
     return nullptr;
 
   NSFontManager* font_manager = [NSFontManager sharedFontManager];
   NSFontTraitMask actual_traits = 0;
   if (font_description.Style())
-    actual_traits = [font_manager traitsOfFont:ns_font];
-  NSInteger actual_weight = [font_manager weightOfFont:ns_font];
+    actual_traits = [font_manager traitsOfFont:matched_font];
+  NSInteger actual_weight = [font_manager weightOfFont:matched_font];
 
   NSFont* platform_font =
-      UseHinting() ? [ns_font screenFont] : [ns_font printerFont];
+      UseHinting() ? [matched_font screenFont] : [matched_font printerFont];
   NSInteger app_kit_weight = ToAppKitFontWeight(font_description.Weight());
 
   // TODO(eae): Remove once skia supports bold emoji. See
@@ -284,11 +299,11 @@ std::unique_ptr<FontPlatformData> FontCache::CreateFontPlatformData(
   // font loading failing.  Out-of-process loading occurs for registered fonts
   // stored in non-system locations.  When loading fails, we do not want to use
   // the returned FontPlatformData since it will not have a valid SkTypeface.
-  std::unique_ptr<FontPlatformData> platform_data =
-      std::make_unique<FontPlatformData>(
-          platform_font, size, synthetic_bold, synthetic_italic,
-          font_description.Orientation(), font_description.VariationSettings());
-  if (!platform_data->Typeface()) {
+  std::unique_ptr<FontPlatformData> platform_data = FontPlatformDataFromNSFont(
+      platform_font, size, synthetic_bold, synthetic_italic,
+      font_description.Orientation(), font_description.FontOpticalSizing(),
+      font_description.VariationSettings());
+  if (!platform_data || !platform_data->Typeface()) {
     return nullptr;
   }
   return platform_data;
diff --git a/third_party/blink/renderer/platform/fonts/mac/font_family_matcher_mac_test.mm b/third_party/blink/renderer/platform/fonts/mac/font_family_matcher_mac_test.mm
deleted file mode 100644
index 6ed8ac7dd5d8..000000000000
--- a/third_party/blink/renderer/platform/fonts/mac/font_family_matcher_mac_test.mm
+++ /dev/null
@@ -1,41 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#import "third_party/blink/renderer/platform/fonts/mac/font_family_matcher_mac.h"
-
-#include <AppKit/AppKit.h>
-
-#include "testing/gtest/include/gtest/gtest.h"
-#include "third_party/blink/renderer/platform/font_family_names.h"
-#include "third_party/blink/renderer/platform/mac/version_util_mac.h"
-
-@interface NSString (YosemiteAdditions)
-- (BOOL)containsString:(NSString*)string;
-@end
-
-namespace blink {
-
-void TestSystemFontContainsString(FontSelectionValue desired_weight,
-                                  NSString* substring) {
-  NSFont* font =
-      MatchNSFontFamily(FontFamilyNames::system_ui, 0, desired_weight, 11);
-  EXPECT_TRUE([font.description containsString:substring]);
-}
-
-TEST(FontFamilyMatcherMacTest, YosemiteFontWeights) {
-  if (!IsOS10_10())
-    return;
-
-  TestSystemFontContainsString(FontSelectionValue(100), @"-UltraLight");
-  TestSystemFontContainsString(FontSelectionValue(200), @"-Thin");
-  TestSystemFontContainsString(FontSelectionValue(300), @"-Light");
-  TestSystemFontContainsString(FontSelectionValue(400), @"-Regular");
-  TestSystemFontContainsString(FontSelectionValue(500), @"-Medium");
-  TestSystemFontContainsString(FontSelectionValue(600), @"-Bold");
-  TestSystemFontContainsString(FontSelectionValue(700), @"-Bold");
-  TestSystemFontContainsString(FontSelectionValue(800), @"-Heavy");
-  TestSystemFontContainsString(FontSelectionValue(900), @"-Heavy");
-}
-
-}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/mac/font_family_matcher_mac.h b/third_party/blink/renderer/platform/fonts/mac/font_matcher_mac.h
similarity index 88%
rename from third_party/blink/renderer/platform/fonts/mac/font_family_matcher_mac.h
rename to third_party/blink/renderer/platform/fonts/mac/font_matcher_mac.h
index 679bc3e0b7bb..23de6b6c6fe2 100644
--- a/third_party/blink/renderer/platform/fonts/mac/font_family_matcher_mac.h
+++ b/third_party/blink/renderer/platform/fonts/mac/font_matcher_mac.h
@@ -24,8 +24,8 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_FONT_FAMILY_MATCHER_MAC_H_
-#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_FONT_FAMILY_MATCHER_MAC_H_
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_FONT_MATCHER_MAC_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_FONT_MATCHER_MAC_H_
 
 #include <AppKit/NSFontManager.h>
 #include "third_party/blink/renderer/platform/fonts/font_selection_types.h"
@@ -39,9 +39,12 @@ PLATFORM_EXPORT NSFont* MatchNSFontFamily(const AtomicString& desired_family,
                                           FontSelectionValue desired_weight,
                                           float size);
 
+PLATFORM_EXPORT NSFont* MatchUniqueFont(const AtomicString& unique_font_name,
+                                        float size);
+
 // Converts ablink::FontSelectionValue to the nearest AppKit font weight if
 // possible, otherwise returns the default font weight.
 int ToAppKitFontWeight(FontSelectionValue);
-}
+}  // namespace blink
 
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_FONT_FAMILY_MATCHER_MAC_H_
diff --git a/third_party/blink/renderer/platform/fonts/mac/font_family_matcher_mac.mm b/third_party/blink/renderer/platform/fonts/mac/font_matcher_mac.mm
similarity index 72%
rename from third_party/blink/renderer/platform/fonts/mac/font_family_matcher_mac.mm
rename to third_party/blink/renderer/platform/fonts/mac/font_matcher_mac.mm
index 63b185c2bd8b..7144caba9efe 100644
--- a/third_party/blink/renderer/platform/fonts/mac/font_family_matcher_mac.mm
+++ b/third_party/blink/renderer/platform/fonts/mac/font_matcher_mac.mm
@@ -27,71 +27,44 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#import "third_party/blink/renderer/platform/fonts/mac/font_family_matcher_mac.h"
+#import "third_party/blink/renderer/platform/fonts/mac/font_matcher_mac.h"
 
 #import <AppKit/AppKit.h>
 #import <Foundation/Foundation.h>
 #import <math.h>
+
+#include "base/mac/foundation_util.h"
+#include "base/mac/scoped_cftyperef.h"
+#include "base/mac/scoped_nsobject.h"
+#include "base/stl_util.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
-#include "third_party/blink/renderer/platform/layout_test_support.h"
-#include "third_party/blink/renderer/platform/mac/version_util_mac.h"
 #import "third_party/blink/renderer/platform/wtf/hash_set.h"
 #import "third_party/blink/renderer/platform/wtf/text/atomic_string_hash.h"
 
-@interface NSFont (YosemiteAdditions)
-+ (NSFont*)systemFontOfSize:(CGFloat)size weight:(CGFloat)weight;
-@end
+namespace blink {
 
 namespace {
 
-static CGFloat toYosemiteFontWeight(blink::FontSelectionValue font_weight) {
-  static uint64_t ns_font_weights[] = {
-      0xbfe99999a0000000,  // NSFontWeightUltraLight
-      0xbfe3333340000000,  // NSFontWeightThin
-      0xbfd99999a0000000,  // NSFontWeightLight
-      0x0000000000000000,  // NSFontWeightRegular
-      0x3fcd70a3e0000000,  // NSFontWeightMedium
-      0x3fd3333340000000,  // NSFontWeightSemibold
-      0x3fd99999a0000000,  // NSFontWeightBold
-      0x3fe1eb8520000000,  // NSFontWeightHeavy
-      0x3fe3d70a40000000,  // NSFontWeightBlack
-  };
-  if (font_weight <= 50 || font_weight >= 950)
-    return ns_font_weights[3];
-
-  size_t select_weight = roundf(font_weight / 100) - 1;
-  DCHECK_GE(select_weight, 0ul);
-  DCHECK_LE(select_weight, arraysize(ns_font_weights));
-  CGFloat* return_weight =
-      reinterpret_cast<CGFloat*>(&ns_font_weights[select_weight]);
-  return *return_weight;
-}
-}
-
-namespace blink {
-
 const NSFontTraitMask SYNTHESIZED_FONT_TRAITS =
     (NSBoldFontMask | NSItalicFontMask);
 
 const NSFontTraitMask IMPORTANT_FONT_TRAITS =
     (NSCompressedFontMask | NSCondensedFontMask | NSExpandedFontMask |
-     NSItalicFontMask |
-     NSNarrowFontMask |
-     NSPosterFontMask |
+     NSItalicFontMask | NSNarrowFontMask | NSPosterFontMask |
      NSSmallCapsFontMask);
 
-static BOOL AcceptableChoice(NSFontTraitMask desired_traits,
-                             NSFontTraitMask candidate_traits) {
+BOOL AcceptableChoice(NSFontTraitMask desired_traits,
+                      NSFontTraitMask candidate_traits) {
   desired_traits &= ~SYNTHESIZED_FONT_TRAITS;
   return (candidate_traits & desired_traits) == desired_traits;
 }
 
-static BOOL BetterChoice(NSFontTraitMask desired_traits,
-                         int desired_weight,
-                         NSFontTraitMask chosen_traits,
-                         int chosen_weight,
-                         NSFontTraitMask candidate_traits,
-                         int candidate_weight) {
+BOOL BetterChoice(NSFontTraitMask desired_traits,
+                  int desired_weight,
+                  NSFontTraitMask chosen_traits,
+                  int chosen_weight,
+                  NSFontTraitMask candidate_traits,
+                  int candidate_weight) {
   if (!AcceptableChoice(desired_traits, candidate_traits))
     return NO;
 
@@ -128,6 +101,58 @@ static BOOL BetterChoice(NSFontTraitMask desired_traits,
   return candidate_weight_delta_magnitude < chosen_weight_delta_magnitude;
 }
 
+NSFontWeight ToFontWeight(blink::FontSelectionValue font_weight) {
+  if (font_weight <= 50 || font_weight >= 950)
+    return NSFontWeightRegular;
+
+  const NSFontWeight ns_font_weights[] = {
+      NSFontWeightUltraLight, NSFontWeightThin,   NSFontWeightLight,
+      NSFontWeightRegular,    NSFontWeightMedium, NSFontWeightSemibold,
+      NSFontWeightBold,       NSFontWeightHeavy,  NSFontWeightBlack,
+  };
+  size_t select_weight = roundf(font_weight / 100) - 1;
+  DCHECK_GE(select_weight, 0ul);
+  DCHECK_LE(select_weight, base::size(ns_font_weights));
+  return ns_font_weights[select_weight];
+}
+
+}  // namespace
+
+NSFont* MatchUniqueFont(const AtomicString& unique_font_name, float size) {
+  // Testing with a large list of fonts available on Mac OS shows that matching
+  // for kCTFontNameAttribute matches postscript name as well as full font name.
+  NSString* desired_name = unique_font_name;
+  NSDictionary* attributes = @{
+    (NSString*)kCTFontNameAttribute : desired_name,
+    (NSString*)kCTFontSizeAttribute : @(size)
+  };
+  base::ScopedCFTypeRef<CTFontDescriptorRef> descriptor(
+      CTFontDescriptorCreateWithAttributes(base::mac::NSToCFCast(attributes)));
+
+  base::ScopedCFTypeRef<CTFontRef> matched_font(
+      CTFontCreateWithFontDescriptor(descriptor, 0, nullptr));
+
+  // CoreText will usually give us *something* but not always an exactly
+  // matched font.
+  DCHECK(matched_font);
+  base::ScopedCFTypeRef<CFStringRef> matched_font_ps_name(
+      CTFontCopyName(matched_font, kCTFontPostScriptNameKey));
+  base::ScopedCFTypeRef<CFStringRef> matched_font_full_font_name(
+      CTFontCopyName(matched_font, kCTFontFullNameKey));
+  // If the found font does not match in postscript name or full font name, it's
+  // not the exact match that is required, so return nullptr.
+  if (kCFCompareEqualTo != CFStringCompare(matched_font_ps_name,
+                                           base::mac::NSToCFCast(desired_name),
+                                           kCFCompareCaseInsensitive) &&
+      kCFCompareEqualTo != CFStringCompare(matched_font_full_font_name,
+                                           base::mac::NSToCFCast(desired_name),
+                                           kCFCompareCaseInsensitive)) {
+    return nullptr;
+  }
+
+  return [base::mac::CFToNSCast(matched_font.release()) autorelease];
+}
+
 // Family name is somewhat of a misnomer here.  We first attempt to find an
 // exact match comparing the desiredFamily to the PostScript name of the
 // installed fonts.  If that fails we then do a search based on the family
@@ -138,18 +163,9 @@ NSFont* MatchNSFontFamily(const AtomicString& desired_family_string,
                           float size) {
   DCHECK_NE(desired_family_string, FontCache::LegacySystemFontFamily());
 
-  if (desired_family_string == FontFamilyNames::system_ui) {
-    NSFont* font = nil;
-// Normally we'd use an availability macro here, but
-// systemFontOfSize:weight: is available but not visible on macOS 10.10,
-// so it's been forward declared earlier in this file.
-// On OSX 10.10+, the default system font has more weights.
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wunguarded-availability"
-    font = [NSFont systemFontOfSize:size
-                             weight:toYosemiteFontWeight(desired_weight)];
-#pragma clang diagnostic pop
-
+  if (desired_family_string == font_family_names::kSystemUi) {
+    NSFont* font = [NSFont systemFontOfSize:size
+                                     weight:ToFontWeight(desired_weight)];
     if (desired_traits & IMPORTANT_FONT_TRAITS)
       font = [[NSFontManager sharedFontManager] convertFont:font
                                                 toHaveTrait:desired_traits];
@@ -159,16 +175,19 @@ NSFont* MatchNSFontFamily(const AtomicString& desired_family_string,
   NSString* desired_family = desired_family_string;
   NSFontManager* font_manager = [NSFontManager sharedFontManager];
 
-  // Do a simple case insensitive search for a matching font family.
-  // NSFontManager requires exact name matches.
-  // This addresses the problem of matching arial to Arial, etc., but perhaps
-  // not all the issues.
-  NSEnumerator* e = [[font_manager availableFontFamilies] objectEnumerator];
-  NSString* available_family;
-  while ((available_family = [e nextObject])) {
-    if ([desired_family caseInsensitiveCompare:available_family] ==
-        NSOrderedSame)
-      break;
+  // From Mac OS 10.15 [NSFontManager availableFonts] does not list certain
+  // fonts that availableMembersOfFontFamily actually shows results for, for
+  // example "Hiragino Kaku Gothic ProN" is not listed, only Hiragino Sans is
+  // listed. We previously enumerated availableFontFamilies and looked for a
+  // case-insensitive string match here, but instead, we can rely on
+  // availableMembersOfFontFamily here to do a case-insensitive comparison, then
+  // set available_family to desired_family if the result was not empty.
+  // See https://crbug.com/1000542
+  NSString* available_family = nil;
+  NSArray* fonts_in_family =
+      [font_manager availableMembersOfFontFamily:desired_family];
+  if (fonts_in_family && [fonts_in_family count]) {
+    available_family = desired_family;
   }
 
   int app_kit_font_weight = ToAppKitFontWeight(desired_weight);
@@ -309,7 +328,7 @@ int ToAppKitFontWeight(FontSelectionValue font_weight) {
       12,  // FontWeight900
   };
   DCHECK_GE(select_weight, 0ul);
-  DCHECK_LE(select_weight, arraysize(app_kit_font_weights));
+  DCHECK_LE(select_weight, base::size(app_kit_font_weights));
   return app_kit_font_weights[select_weight];
 }
 
diff --git a/third_party/blink/renderer/platform/fonts/mac/font_matcher_mac_test.mm b/third_party/blink/renderer/platform/fonts/mac/font_matcher_mac_test.mm
new file mode 100644
index 000000000000..c3c3e678de93
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/mac/font_matcher_mac_test.mm
@@ -0,0 +1,73 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#import "third_party/blink/renderer/platform/fonts/mac/font_matcher_mac.h"
+
+#include <AppKit/AppKit.h>
+
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/font_family_names.h"
+
+namespace blink {
+
+void TestSystemFontContainsString(FontSelectionValue desired_weight,
+                                  NSString* substring) {
+  NSFont* font =
+      MatchNSFontFamily(font_family_names::kSystemUi, 0, desired_weight, 11);
+  EXPECT_TRUE([font.description containsString:substring]);
+}
+
+TEST(FontMatcherMacTest, NoUniqueFontMatchOnUnavailableFont) {
+  NSFont* font = MatchUniqueFont(
+      "ThisFontNameDoesNotExist07F444B9-4DDF-4A41-8F30-C80D4ED4CCA2", 12);
+  EXPECT_FALSE(font);
+}
+
+// If these font names are unavaiable on future Mac OS versions, please try to
+// find replacements or remove individual lines.
+TEST(FontMatcherMacTest, MatchFullFontName) {
+  const char* font_names[] = {"American Typewriter Condensed Light",
+                              "Arial Narrow Bold Italic",
+                              "Baskerville SemiBold Italic",
+                              "Devanagari MT",
+                              "DIN Alternate Bold",
+                              "Gill Sans Light Italic",
+                              "Iowan Old Style Titling",
+                              "Malayalam Sangam MN",
+                              "Hiragino Maru Gothic Pro W4",
+                              "Hiragino Kaku Gothic StdN W8"};
+
+  for (const char* font_name : font_names) {
+    @autoreleasepool {
+      NSFont* font = MatchUniqueFont(font_name, 12);
+      EXPECT_TRUE(font);
+    }
+  }
+}
+
+// If these font names are unavaiable on future Mac OS versions, please try to
+// find replacements or remove individual lines.
+TEST(FontMatcherMacTest, MatchPostscriptName) {
+  const char* font_names[] = {
+      "AmericanTypewriter-CondensedLight",
+      "ArialNarrow-BoldItalic",
+      "Baskerville-SemiBoldItalic",
+      "DevanagariMT",
+      "DINAlternate-Bold",
+      "GillSans-LightItalic",
+      "IowanOldStyle-Titling",
+      "MalayalamSangamMN",
+      "HiraMaruPro-W4",
+      "HiraKakuStdN-W8",
+  };
+
+  for (const char* font_name : font_names) {
+    @autoreleasepool {
+      NSFont* font = MatchUniqueFont(font_name, 12);
+      EXPECT_TRUE(font);
+    }
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_cache.cc b/third_party/blink/renderer/platform/fonts/mac/font_platform_data_mac.h
similarity index 56%
rename from third_party/blink/renderer/platform/fonts/shaping/shape_cache.cc
rename to third_party/blink/renderer/platform/fonts/mac/font_platform_data_mac.h
index 3fbc1ef39784..ed3dfa6c4bd0 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/mac/font_platform_data_mac.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2017 Google Inc. All rights reserved.
+ * Copyright (c) 2019, Google Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
@@ -28,15 +28,40 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "third_party/blink/renderer/platform/fonts/shaping/shape_cache.h"
-#include "third_party/blink/renderer/platform/wtf/string_hasher.h"
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_FONT_PLATFORM_DATA_MAC_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_FONT_PLATFORM_DATA_MAC_H_
+
+#include "third_party/blink/renderer/platform/fonts/font_optical_sizing.h"
+#include "third_party/blink/renderer/platform/platform_export.h"
+
+#include <memory>
+
+@class NSFont;
+class SkTypeface;
+typedef uint32_t SkFourByteTag;
 
 namespace blink {
 
-void ShapeCache::SmallStringKey::HashString() {
-  // TODO(cavalcantii): replace this for a better hash function,
-  // see crbug.com/735674.
-  hash_ = StringHasher::ComputeHash(characters_, length_);
-}
+enum class FontOrientation;
+class FontPlatformData;
+class FontVariationSettings;
+
+// Given a typeface and a variable axis, returns whether a new value for that
+// axis isn't clamped and therefore will effect a change to the typeface if
+// applied.
+bool PLATFORM_EXPORT VariableAxisChangeEffective(SkTypeface* typeface,
+                                                 SkFourByteTag axis,
+                                                 float new_value);
+
+std::unique_ptr<FontPlatformData> FontPlatformDataFromNSFont(
+    NSFont*,
+    float size,
+    bool synthetic_bold,
+    bool synthetic_italic,
+    FontOrientation,
+    OpticalSizing,
+    FontVariationSettings*);
 
 }  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_MAC_FONT_PLATFORM_DATA_MAC_H_
diff --git a/third_party/blink/renderer/platform/fonts/mac/font_platform_data_mac.mm b/third_party/blink/renderer/platform/fonts/mac/font_platform_data_mac.mm
index 11368b4b87bb..90a09d489d76 100644
--- a/third_party/blink/renderer/platform/fonts/mac/font_platform_data_mac.mm
+++ b/third_party/blink/renderer/platform/fonts/mac/font_platform_data_mac.mm
@@ -21,56 +21,107 @@
  *
  */
 
-#import "third_party/blink/renderer/platform/fonts/font_platform_data.h"
+#import "third_party/blink/renderer/platform/fonts/mac/font_platform_data_mac.h"
 
 #import <AppKit/NSFont.h>
 #import <AvailabilityMacros.h>
-#import "third_party/blink/public/platform/mac/web_sandbox_support.h"
-#import "third_party/blink/public/platform/platform.h"
-#import "third_party/blink/renderer/platform/fonts/font.h"
-#import "third_party/blink/renderer/platform/fonts/opentype/font_settings.h"
-#import "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h"
-#import "third_party/blink/renderer/platform/graphics/skia/skia_utils.h"
-#import "third_party/blink/renderer/platform/layout_test_support.h"
-#import "third_party/blink/renderer/platform/wtf/retain_ptr.h"
-#import "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+
+#import "base/mac/foundation_util.h"
+#import "base/mac/scoped_nsobject.h"
+#include "base/stl_util.h"
+#include "third_party/blink/public/platform/mac/web_sandbox_support.h"
+#include "third_party/blink/public/platform/platform.h"
+#include "third_party/blink/renderer/platform/fonts/font.h"
+#include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
+#include "third_party/blink/renderer/platform/fonts/mac/core_text_font_format_support.h"
+#include "third_party/blink/renderer/platform/fonts/opentype/font_settings.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h"
+#include "third_party/blink/renderer/platform/web_test_support.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/blink/renderer/platform/wtf/vector.h"
+#include "third_party/skia/include/core/SkFont.h"
+#include "third_party/skia/include/core/SkStream.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+#include "third_party/skia/include/core/SkTypes.h"
 #import "third_party/skia/include/ports/SkTypeface_mac.h"
 
+namespace {
+constexpr SkFourByteTag kOpszTag = SkSetFourByteTag('o', 'p', 's', 'z');
+}
+
 namespace blink {
 
-static bool CanLoadInProcess(NSFont* ns_font) {
-  RetainPtr<CGFontRef> cg_font(kAdoptCF,
-                               CTFontCopyGraphicsFont(toCTFontRef(ns_font), 0));
-  // Toll-free bridged types CFStringRef and NSString*.
-  RetainPtr<NSString> font_name(
-      kAdoptNS, const_cast<NSString*>(reinterpret_cast<const NSString*>(
-                    CGFontCopyPostScriptName(cg_font.Get()))));
-  return ![font_name.Get() isEqualToString:@"LastResort"];
+bool VariableAxisChangeEffective(SkTypeface* typeface,
+                                 SkFourByteTag axis,
+                                 float new_value) {
+  // First clamp new value to within range of min and max of variable axis.
+  int num_axes = typeface->getVariationDesignParameters(nullptr, 0);
+  if (num_axes <= 0)
+    return false;
+
+  Vector<SkFontParameters::Variation::Axis> axes_parameters(num_axes);
+  int returned_axes =
+      typeface->getVariationDesignParameters(axes_parameters.data(), num_axes);
+  DCHECK_EQ(num_axes, returned_axes);
+  DCHECK_GE(num_axes, 0);
+
+  float clamped_new_value = new_value;
+  for (auto& axis_parameters : axes_parameters) {
+    if (axis_parameters.tag == axis) {
+      clamped_new_value = std::min(new_value, axis_parameters.max);
+      clamped_new_value = std::max(clamped_new_value, axis_parameters.min);
+    }
+  }
+
+  int num_coordinates = typeface->getVariationDesignPosition(nullptr, 0);
+  if (num_coordinates <= 0)
+    return true;  // Font has axes, but no positions, setting one would have an
+                  // effect.
+
+  // Then compare if clamped value differs from what is set on the font.
+  Vector<SkFontArguments::VariationPosition::Coordinate> coordinates(
+      num_coordinates);
+  int returned_coordinates =
+      typeface->getVariationDesignPosition(coordinates.data(), num_coordinates);
+
+  if (returned_coordinates != num_coordinates)
+    return false;  // Something went wrong in retrieving actual axis positions,
+                   // font broken?
+
+  for (auto& coordinate : coordinates) {
+    if (coordinate.axis == axis)
+      return coordinate.value != clamped_new_value;
+  }
+  return false;
 }
 
-static CTFontDescriptorRef CascadeToLastResortFontDescriptor() {
-  static CTFontDescriptorRef descriptor;
-  if (descriptor)
-    return descriptor;
+static bool CanLoadInProcess(NSFont* ns_font) {
+  base::ScopedCFTypeRef<CGFontRef> cg_font(
+      CTFontCopyGraphicsFont(base::mac::NSToCFCast(ns_font), 0));
+  // Toll-free bridged types CFStringRef and NSString*.
+  base::scoped_nsobject<NSString> font_name(
+      base::mac::CFToNSCast(CGFontCopyPostScriptName(cg_font)));
+  return ![font_name isEqualToString:@"LastResort"];
+}
 
-  RetainPtr<CTFontDescriptorRef> last_resort(
-      kAdoptCF, CTFontDescriptorCreateWithNameAndSize(CFSTR("LastResort"), 0));
-  const void* descriptors[] = {last_resort.Get()};
-  RetainPtr<CFArrayRef> values_array(
-      kAdoptCF, CFArrayCreate(kCFAllocatorDefault, descriptors,
-                              arraysize(descriptors), &kCFTypeArrayCallBacks));
+static CFDictionaryRef CascadeToLastResortFontAttributes() {
+  static CFDictionaryRef attributes;
+  if (attributes)
+    return attributes;
+
+  base::ScopedCFTypeRef<CTFontDescriptorRef> last_resort(
+      CTFontDescriptorCreateWithNameAndSize(CFSTR("LastResort"), 0));
+  const void* descriptors[] = {last_resort};
+  base::ScopedCFTypeRef<CFArrayRef> values_array(
+      CFArrayCreate(kCFAllocatorDefault, descriptors, base::size(descriptors),
+                    &kCFTypeArrayCallBacks));
 
   const void* keys[] = {kCTFontCascadeListAttribute};
-  const void* values[] = {values_array.Get()};
-  RetainPtr<CFDictionaryRef> attributes(
-      kAdoptCF,
-      CFDictionaryCreate(kCFAllocatorDefault, keys, values, arraysize(keys),
-                         &kCFTypeDictionaryKeyCallBacks,
-                         &kCFTypeDictionaryValueCallBacks));
-
-  descriptor = CTFontDescriptorCreateWithAttributes(attributes.Get());
-
-  return descriptor;
+  const void* values[] = {values_array};
+  attributes = CFDictionaryCreate(
+      kCFAllocatorDefault, keys, values, base::size(keys),
+      &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
+  return attributes;
 }
 
 static sk_sp<SkTypeface> LoadFromBrowserProcess(NSFont* ns_font,
@@ -85,23 +136,23 @@ static sk_sp<SkTypeface> LoadFromBrowserProcess(NSFont* ns_font,
     return nullptr;
   }
 
-  CGFontRef loaded_cg_font;
+  base::ScopedCFTypeRef<CTFontDescriptorRef> loaded_data_descriptor;
   uint32_t font_id;
-  if (!sandbox_support->LoadFont(toCTFontRef(ns_font), &loaded_cg_font,
-                                 &font_id)) {
+  if (!sandbox_support->LoadFont(base::mac::NSToCFCast(ns_font),
+                                 &loaded_data_descriptor, &font_id)) {
     // TODO crbug.com/461279: Make this appear in the inspector console?
     DLOG(ERROR)
         << "Loading user font \"" << [[ns_font familyName] UTF8String]
         << "\" from non system location failed. Corrupt or missing font file?";
     return nullptr;
   }
-  RetainPtr<CGFontRef> cg_font(kAdoptCF, loaded_cg_font);
-  RetainPtr<CTFontRef> ct_font(
-      kAdoptCF,
-      CTFontCreateWithGraphicsFont(cg_font.Get(), text_size, 0,
-                                   CascadeToLastResortFontDescriptor()));
-  sk_sp<SkTypeface> return_font(
-      SkCreateTypefaceFromCTFont(ct_font.Get(), cg_font.Get()));
+
+  base::ScopedCFTypeRef<CTFontDescriptorRef> data_descriptor_with_cascade(
+      CTFontDescriptorCreateCopyWithAttributes(
+          loaded_data_descriptor, CascadeToLastResortFontAttributes()));
+  base::ScopedCFTypeRef<CTFontRef> ct_font(CTFontCreateWithFontDescriptor(
+      data_descriptor_with_cascade.get(), text_size, 0));
+  sk_sp<SkTypeface> return_font = SkMakeTypefaceFromCTFont(ct_font);
 
   if (!return_font.get())
     // TODO crbug.com/461279: Make this appear in the inspector console?
@@ -111,15 +162,110 @@ static sk_sp<SkTypeface> LoadFromBrowserProcess(NSFont* ns_font,
   return return_font;
 }
 
-void FontPlatformData::SetupPaintFont(PaintFont* paint_font,
-                                      float,
-                                      const Font* font) const {
+std::unique_ptr<FontPlatformData> FontPlatformDataFromNSFont(
+    NSFont* ns_font,
+    float size,
+    bool synthetic_bold,
+    bool synthetic_italic,
+    FontOrientation orientation,
+    OpticalSizing optical_sizing,
+    FontVariationSettings* variation_settings) {
+  DCHECK(ns_font);
+  sk_sp<SkTypeface> typeface;
+  if (CanLoadInProcess(ns_font)) {
+    typeface = SkMakeTypefaceFromCTFont(base::mac::NSToCFCast(ns_font));
+  } else {
+    // In process loading fails for cases where third party font manager
+    // software registers fonts in non system locations such as /Library/Fonts
+    // and ~/Library Fonts, see crbug.com/72727 or crbug.com/108645.
+    typeface = LoadFromBrowserProcess(ns_font, size);
+  }
+
+  auto make_typeface_fontplatformdata = [&typeface, &size, &synthetic_bold,
+                                         &synthetic_italic, &orientation]() {
+    return std::make_unique<FontPlatformData>(
+        std::move(typeface), std::string(), size, synthetic_bold,
+        synthetic_italic, orientation);
+  };
+
+  wtf_size_t valid_configured_axes =
+      variation_settings && variation_settings->size() < UINT16_MAX
+          ? variation_settings->size()
+          : 0;
+
+  // No variable font requested, return static font.
+  if (!valid_configured_axes && optical_sizing == kNoneOpticalSizing)
+    return make_typeface_fontplatformdata();
+
+  if (!typeface)
+    return nullptr;
+
+  int existing_axes = typeface->getVariationDesignPosition(nullptr, 0);
+  // Don't apply variation parameters if the font does not have axes or we
+  // fail to retrieve the existing ones.
+  if (existing_axes <= 0)
+    return make_typeface_fontplatformdata();
+
+  Vector<SkFontArguments::VariationPosition::Coordinate> coordinates_to_set;
+  coordinates_to_set.resize(existing_axes);
+
+  if (typeface->getVariationDesignPosition(coordinates_to_set.data(),
+                                           existing_axes) != existing_axes) {
+    return make_typeface_fontplatformdata();
+  }
+
+  // Iterate over the font's axes and find a missing tag from variation
+  // settings, special case 'opsz', track the number of axes reconfigured.
+  bool axes_reconfigured = false;
+  for (auto& coordinate : coordinates_to_set) {
+    // Set 'opsz' to font size but allow having it overridden by
+    // font-variation-settings in case it has 'opsz'.
+    if (coordinate.axis == kOpszTag && optical_sizing == kAutoOpticalSizing) {
+      if (VariableAxisChangeEffective(typeface.get(), coordinate.axis, size)) {
+        coordinate.value = SkFloatToScalar(size);
+        axes_reconfigured = true;
+      }
+    }
+    FontVariationAxis found_variation_setting(0, 0);
+    if (variation_settings && variation_settings->FindPair(
+                                  coordinate.axis, &found_variation_setting)) {
+      if (VariableAxisChangeEffective(typeface.get(), coordinate.axis,
+                                      found_variation_setting.Value())) {
+        coordinate.value = found_variation_setting.Value();
+        axes_reconfigured = true;
+      }
+    }
+  }
+
+  if (!axes_reconfigured) {
+    // No variable axes touched, return the previous typeface.
+    return make_typeface_fontplatformdata();
+  }
+
+  SkFontArguments::VariationPosition variation_design_position{
+      coordinates_to_set.data(), coordinates_to_set.size()};
+
+  sk_sp<SkTypeface> cloned_typeface(typeface->makeClone(
+      SkFontArguments().setVariationDesignPosition(variation_design_position)));
+
+  if (!cloned_typeface) {
+    // Applying variation parameters failed, return original typeface.
+    return make_typeface_fontplatformdata();
+  }
+  typeface = cloned_typeface;
+  return make_typeface_fontplatformdata();
+}
+
+void FontPlatformData::SetupSkFont(
+    SkFont* skfont,
+    float,
+    const FontDescription* font_description) const {
   bool should_smooth_fonts = true;
   bool should_antialias = true;
   bool should_subpixel_position = true;
 
-  if (font) {
-    switch (font->GetFontDescription().FontSmoothing()) {
+  if (font_description) {
+    switch (font_description->FontSmoothing()) {
       case kAntialiased:
         should_smooth_fonts = false;
         break;
@@ -136,71 +282,41 @@ void FontPlatformData::SetupPaintFont(PaintFont* paint_font,
     }
   }
 
-  if (LayoutTestSupport::IsRunningLayoutTest()) {
+  if (WebTestSupport::IsRunningWebTest()) {
     should_smooth_fonts = false;
-    should_antialias = should_antialias &&
-                       LayoutTestSupport::IsFontAntialiasingEnabledForTest();
+    should_antialias =
+        should_antialias && WebTestSupport::IsFontAntialiasingEnabledForTest();
     should_subpixel_position =
-        LayoutTestSupport::IsTextSubpixelPositioningAllowedForTest();
+        WebTestSupport::IsTextSubpixelPositioningAllowedForTest();
   }
 
-  paint_font->SetAntiAlias(should_antialias);
-  paint_font->SetEmbeddedBitmapText(false);
+  if (should_antialias && should_smooth_fonts) {
+    skfont->setEdging(SkFont::Edging::kSubpixelAntiAlias);
+  } else if (should_antialias) {
+    skfont->setEdging(SkFont::Edging::kAntiAlias);
+  } else {
+    skfont->setEdging(SkFont::Edging::kAlias);
+  }
+  skfont->setEmbeddedBitmaps(false);
   const float ts = text_size_ >= 0 ? text_size_ : 12;
-  paint_font->SetTextSize(SkFloatToScalar(ts));
-  paint_font->SetTypeface(paint_typeface_);
-  paint_font->SetFakeBoldText(synthetic_bold_);
-  paint_font->SetTextSkewX(synthetic_italic_ ? -SK_Scalar1 / 4 : 0);
-  paint_font->SetLcdRenderText(should_smooth_fonts);
-  paint_font->SetSubpixelText(should_subpixel_position);
+  skfont->setSize(SkFloatToScalar(ts));
+  skfont->setTypeface(typeface_);
+  skfont->setEmbolden(synthetic_bold_);
+  skfont->setSkewX(synthetic_italic_ ? -SK_Scalar1 / 4 : 0);
+  skfont->setSubpixel(should_subpixel_position);
+
+  // CoreText always provides linear metrics if it can, so the linear metrics
+  // flag setting doesn't affect typefaces backed by CoreText. However, it
+  // does affect FreeType backed typefaces, so set the flag for consistency.
+  skfont->setLinearMetrics(should_subpixel_position);
 
   // When rendering using CoreGraphics, disable hinting when
   // webkit-font-smoothing:antialiased or text-rendering:geometricPrecision is
   // used.  See crbug.com/152304
-  if (font &&
-      (font->GetFontDescription().FontSmoothing() == kAntialiased ||
-       font->GetFontDescription().TextRendering() == kGeometricPrecision))
-    paint_font->SetHinting(SkPaint::kNo_Hinting);
-}
-
-FontPlatformData::FontPlatformData(NSFont* ns_font,
-                                   float size,
-                                   bool synthetic_bold,
-                                   bool synthetic_italic,
-                                   FontOrientation orientation,
-                                   FontVariationSettings* variation_settings)
-    : text_size_(size),
-      synthetic_bold_(synthetic_bold),
-      synthetic_italic_(synthetic_italic),
-      orientation_(orientation),
-      is_hash_table_deleted_value_(false) {
-  DCHECK(ns_font);
-  sk_sp<SkTypeface> typeface;
-  if (CanLoadInProcess(ns_font)) {
-    typeface.reset(SkCreateTypefaceFromCTFont(toCTFontRef(ns_font)));
-  } else {
-    // In process loading fails for cases where third party font manager
-    // software registers fonts in non system locations such as /Library/Fonts
-    // and ~/Library Fonts, see crbug.com/72727 or crbug.com/108645.
-    typeface = LoadFromBrowserProcess(ns_font, size);
-  }
-
-  if (variation_settings && variation_settings->size() < UINT16_MAX) {
-    SkFontArguments::Axis axes[variation_settings->size()];
-    for (size_t i = 0; i < variation_settings->size(); ++i) {
-      AtomicString feature_tag = variation_settings->at(i).Tag();
-      axes[i] = {AtomicStringToFourByteTag(feature_tag),
-                 SkFloatToScalar(variation_settings->at(i).Value())};
-    }
-    sk_sp<SkFontMgr> fm(SkFontMgr::RefDefault());
-    // TODO crbug.com/670246: Refactor this to a future Skia API that acccepts
-    // axis parameters on system fonts directly.
-    typeface = fm->makeFromStream(
-        typeface->openStream(nullptr)->duplicate(),
-        SkFontArguments().setAxes(axes, variation_settings->size()));
-  }
-  // TODO(vmpstr): Save the creation parameters in PaintTypeface instead.
-  paint_typeface_ = PaintTypeface::FromSkTypeface(typeface);
+  if (font_description &&
+      (font_description->FontSmoothing() == kAntialiased ||
+       font_description->TextRendering() == kGeometricPrecision))
+    skfont->setHinting(SkFontHinting::kNone);
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/mac/font_platform_data_mac_test.mm b/third_party/blink/renderer/platform/fonts/mac/font_platform_data_mac_test.mm
new file mode 100644
index 000000000000..e8a32bd8bbd8
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/mac/font_platform_data_mac_test.mm
@@ -0,0 +1,253 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/mac/font_platform_data_mac.h"
+
+#include "third_party/blink/renderer/platform/fonts/mac/font_matcher_mac.h"
+
+#include "base/mac/foundation_util.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/font_family_names.h"
+
+#include "third_party/skia/include/core/SkTypeface.h"
+#include "third_party/skia/include/ports/SkTypeface_mac.h"
+
+namespace blink {
+
+namespace {
+constexpr SkFourByteTag kOpszTag = SkSetFourByteTag('o', 'p', 's', 'z');
+constexpr SkFourByteTag kWghtTag = SkSetFourByteTag('w', 'g', 'h', 't');
+
+sk_sp<SkTypeface> MakeSystemFontOfSize(float size) {
+  return SkMakeTypefaceFromCTFont(base::mac::NSToCFCast(MatchNSFontFamily(
+      font_family_names::kSystemUi, 0, FontSelectionValue(400), size)));
+}
+}
+
+TEST(FontPlatformDataMacTest, VariableOpticalSizingThreshold) {
+  // Before macOS 10.15, the system font did not have variable optical sizing.
+  // In 10.15, the system font has two optical sizes glued together at 19.9. In
+  // 11.0, the system font has a real optical size axis with range 17-96.
+
+  // Below the 11.0 axis minimum.
+  sk_sp<SkTypeface> system_font(MakeSystemFontOfSize(12));
+  if (@available(macOS 11.0, *)) {
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 6));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 12));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 17));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 18));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 19));
+    EXPECT_TRUE(
+        VariableAxisChangeEffective(system_font.get(), kOpszTag, 19.8999));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 20));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 24));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 72));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 96));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 97));
+  } else if (@available(macOS 10.15, *)) {
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 6));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 12));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 17));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 18));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 19));
+    EXPECT_FALSE(
+        VariableAxisChangeEffective(system_font.get(), kOpszTag, 19.8999));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 20));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 24));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 72));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 96));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 97));
+  } else {
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 6));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 12));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 17));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 18));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 19));
+    EXPECT_FALSE(
+        VariableAxisChangeEffective(system_font.get(), kOpszTag, 19.8999));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 20));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 24));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 72));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 96));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 97));
+  }
+
+  // Just smaller than the switch-over size in 10.15, which is 19.9.
+  system_font = MakeSystemFontOfSize(19);
+  if (@available(macOS 11.0, *)) {
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 6));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 12));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 17));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 18));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 19));
+    EXPECT_TRUE(
+        VariableAxisChangeEffective(system_font.get(), kOpszTag, 19.8999));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 20));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 24));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 72));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 96));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 97));
+  } else if (@available(macOS 10.15, *)) {
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 6));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 12));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 17));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 18));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 19));
+    EXPECT_FALSE(
+        VariableAxisChangeEffective(system_font.get(), kOpszTag, 19.8999));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 20));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 24));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 72));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 96));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 97));
+  } else {
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 6));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 12));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 17));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 18));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 19));
+    EXPECT_FALSE(
+        VariableAxisChangeEffective(system_font.get(), kOpszTag, 19.8999));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 20));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 24));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 72));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 96));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 97));
+  }
+
+  // Just larger than the switch-over size in 10.15, which is 19.9.
+  system_font = MakeSystemFontOfSize(20);
+  if (@available(macOS 11.0, *)) {
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 6));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 12));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 17));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 18));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 19));
+    EXPECT_TRUE(
+        VariableAxisChangeEffective(system_font.get(), kOpszTag, 19.8999));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 20));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 24));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 72));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 96));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 97));
+  } else if (@available(macOS 10.15, *)) {
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 6));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 12));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 17));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 18));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 19));
+    EXPECT_TRUE(
+        VariableAxisChangeEffective(system_font.get(), kOpszTag, 19.8999));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 20));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 24));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 72));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 96));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 97));
+  } else {
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 6));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 12));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 17));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 18));
+    EXPECT_FALSE(
+        VariableAxisChangeEffective(system_font.get(), kOpszTag, 19.8999));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 19));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 20));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 24));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 72));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 96));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 97));
+  }
+
+  // Above the 11.0 axis maximum.
+  system_font = MakeSystemFontOfSize(128);
+  if (@available(macOS 11.0, *)) {
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 6));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 12));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 17));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 18));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 19));
+    EXPECT_TRUE(
+        VariableAxisChangeEffective(system_font.get(), kOpszTag, 19.8999));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 20));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 24));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 72));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 96));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 97));
+  } else if (@available(macOS 10.15, *)) {
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 6));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 12));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 17));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 18));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 19));
+    EXPECT_TRUE(
+        VariableAxisChangeEffective(system_font.get(), kOpszTag, 19.8999));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 20));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 24));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 72));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 96));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 97));
+  } else {
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 6));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 12));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 17));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 18));
+    EXPECT_FALSE(
+        VariableAxisChangeEffective(system_font.get(), kOpszTag, 19.8999));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 19));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 20));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 24));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 72));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 96));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kOpszTag, 97));
+  }
+}
+
+TEST(FontPlatformDataMacTest, VariableWeight) {
+  if (@available(macOS 10.13, *)) {
+    sk_sp<SkTypeface> system_font(MakeSystemFontOfSize(19));
+    EXPECT_FALSE(VariableAxisChangeEffective(system_font.get(), kWghtTag, 400));
+    EXPECT_TRUE(
+        VariableAxisChangeEffective(system_font.get(), kWghtTag, 400.5));
+    EXPECT_TRUE(
+        VariableAxisChangeEffective(system_font.get(), kWghtTag, 395.5));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kWghtTag, 2000));
+    EXPECT_TRUE(VariableAxisChangeEffective(system_font.get(), kWghtTag, 0));
+  }
+}
+
+TEST(FontPlatformDataMacTest, VariableWeightClamped) {
+  if (@available(macOS 10.13, *)) {
+    sk_sp<SkTypeface> system_font(MakeSystemFontOfSize(19));
+
+    SkFontArguments::VariationPosition::Coordinate coordinates[1] = {
+        {kWghtTag, 1000}};
+
+    SkFontArguments::VariationPosition variation_design_position_black{
+        coordinates, 1};
+    sk_sp<SkTypeface> black_typeface(
+        system_font->makeClone(SkFontArguments().setVariationDesignPosition(
+            variation_design_position_black)));
+
+    EXPECT_FALSE(
+        VariableAxisChangeEffective(black_typeface.get(), kWghtTag, 1001));
+    EXPECT_FALSE(
+        VariableAxisChangeEffective(black_typeface.get(), kWghtTag, 10000));
+    EXPECT_TRUE(
+        VariableAxisChangeEffective(black_typeface.get(), kWghtTag, 999));
+
+    coordinates[0].value = 1;
+    SkFontArguments::VariationPosition variation_design_position_thin{
+        coordinates, 1};
+    sk_sp<SkTypeface> thin_typeface(
+        system_font->makeClone(SkFontArguments().setVariationDesignPosition(
+            variation_design_position_thin)));
+
+    EXPECT_FALSE(VariableAxisChangeEffective(thin_typeface.get(), kWghtTag, 0));
+    EXPECT_FALSE(
+        VariableAxisChangeEffective(thin_typeface.get(), kWghtTag, -1));
+    EXPECT_TRUE(VariableAxisChangeEffective(thin_typeface.get(), kWghtTag, 2));
+  }
+}
+
+}
diff --git a/third_party/blink/renderer/platform/fonts/ng_text_fragment_paint_info.h b/third_party/blink/renderer/platform/fonts/ng_text_fragment_paint_info.h
index e4b58a8a90b3..d42fc22c15f8 100644
--- a/third_party/blink/renderer/platform/fonts/ng_text_fragment_paint_info.h
+++ b/third_party/blink/renderer/platform/fonts/ng_text_fragment_paint_info.h
@@ -10,7 +10,7 @@
 
 namespace blink {
 
-class ShapeResult;
+class ShapeResultView;
 
 // Bridge struct for painting text. Encapsulates info needed by the paint code.
 struct PLATFORM_EXPORT NGTextFragmentPaintInfo {
@@ -23,7 +23,7 @@ struct PLATFORM_EXPORT NGTextFragmentPaintInfo {
 
   // The |shape_result| may not contain all characters of the |text|, but is
   // guaranteed to contain |from| to |to|.
-  const ShapeResult* shape_result;
+  const ShapeResultView* shape_result;
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/opentype/font_format_check.cc b/third_party/blink/renderer/platform/fonts/opentype/font_format_check.cc
index 1136892fb019..e1710f6bb2a0 100644
--- a/third_party/blink/renderer/platform/fonts/opentype/font_format_check.cc
+++ b/third_party/blink/renderer/platform/fonts/opentype/font_format_check.cc
@@ -4,30 +4,65 @@
 
 #include "third_party/blink/renderer/platform/fonts/opentype/font_format_check.h"
 
-#include "SkTypeface.h"
-#include "third_party/blink/renderer/platform/wtf/vector.h"
-
 // Include HarfBuzz to have a cross-platform way to retrieve table tags without
 // having to rely on the platform being able to instantiate this font format.
 #include <hb.h>
 
+#include "base/sys_byteorder.h"
+#include "third_party/blink/renderer/platform/wtf/vector.h"
+#include "third_party/harfbuzz-ng/utils/hb_scoped.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
 namespace blink {
 
+namespace {
+
+FontFormatCheck::COLRVersion determineCOLRVersion(
+    const FontFormatCheck::TableTagsVector& table_tags,
+    const hb_face_t* face) {
+  const hb_tag_t kCOLRTag = HB_TAG('C', 'O', 'L', 'R');
+
+  // Only try to read version if header size is sufficient.
+  // https://docs.microsoft.com/en-us/typography/opentype/spec/colr#header
+  const unsigned int kMinCOLRHeaderSize = 14;
+  if (table_tags.size() && table_tags.Contains(kCOLRTag) &&
+      table_tags.Contains(HB_TAG('C', 'P', 'A', 'L'))) {
+    HbScoped<hb_blob_t> table_blob(hb_face_reference_table(face, kCOLRTag));
+    if (hb_blob_get_length(table_blob.get()) < kMinCOLRHeaderSize)
+      return FontFormatCheck::COLRVersion::kNoCOLR;
+
+    unsigned required_bytes_count = 2u;
+    const char* colr_data =
+        hb_blob_get_data(table_blob.get(), &required_bytes_count);
+    if (required_bytes_count < 2u)
+      return FontFormatCheck::COLRVersion::kNoCOLR;
+
+    uint16_t colr_version =
+        base::NetToHost16(*reinterpret_cast<const uint16_t*>(colr_data));
+
+    if (colr_version == 0)
+      return FontFormatCheck::COLRVersion::kCOLRV0;
+    else if (colr_version == 1)
+      return FontFormatCheck::COLRVersion::kCOLRV1;
+  }
+  return FontFormatCheck::COLRVersion::kNoCOLR;
+}
+
+}  // namespace
+
 FontFormatCheck::FontFormatCheck(sk_sp<SkData> sk_data) {
-  std::unique_ptr<hb_blob_t, std::function<void(hb_blob_t*)>> font_blob(
-      hb_blob_create(reinterpret_cast<const char*>(sk_data->bytes()),
-                     sk_data->size(), HB_MEMORY_MODE_READONLY, nullptr,
-                     nullptr),
-      [](hb_blob_t* blob) { hb_blob_destroy(blob); });
-  std::unique_ptr<hb_face_t, std::function<void(hb_face_t*)>> face(
-      hb_face_create(font_blob.get(), 0),
-      [](hb_face_t* face) { hb_face_destroy(face); });
+  HbScoped<hb_blob_t> font_blob(hb_blob_create(
+      reinterpret_cast<const char*>(sk_data->bytes()), sk_data->size(),
+      HB_MEMORY_MODE_READONLY, nullptr, nullptr));
+  HbScoped<hb_face_t> face(hb_face_create(font_blob.get(), 0));
 
   unsigned table_count = 0;
   table_count = hb_face_get_table_tags(face.get(), 0, nullptr, nullptr);
   table_tags_.resize(table_count);
   if (!hb_face_get_table_tags(face.get(), 0, &table_count, table_tags_.data()))
     table_tags_.resize(0);
+
+  colr_version_ = determineCOLRVersion(table_tags_, face.get());
 }
 
 bool FontFormatCheck::IsVariableFont() {
@@ -40,6 +75,14 @@ bool FontFormatCheck::IsCbdtCblcColorFont() {
          table_tags_.Contains(HB_TAG('C', 'B', 'L', 'C'));
 }
 
+bool FontFormatCheck::IsColrCpalColorFontV0() {
+  return colr_version_ == COLRVersion::kCOLRV0;
+}
+
+bool FontFormatCheck::IsColrCpalColorFontV1() {
+  return colr_version_ == COLRVersion::kCOLRV1;
+}
+
 bool FontFormatCheck::IsSbixColorFont() {
   return table_tags_.size() && table_tags_.Contains(HB_TAG('s', 'b', 'i', 'x'));
 }
@@ -48,6 +91,10 @@ bool FontFormatCheck::IsCff2OutlineFont() {
   return table_tags_.size() && table_tags_.Contains(HB_TAG('C', 'F', 'F', '2'));
 }
 
+bool FontFormatCheck::IsColorFont() {
+  return IsCbdtCblcColorFont() || IsColrCpalColorFont() || IsSbixColorFont();
+}
+
 FontFormatCheck::VariableFontSubType FontFormatCheck::ProbeVariableFont(
     sk_sp<SkTypeface> typeface) {
   if (!typeface->getTableSize(
diff --git a/third_party/blink/renderer/platform/fonts/opentype/font_format_check.h b/third_party/blink/renderer/platform/fonts/opentype/font_format_check.h
index 88ed07b45521..c4e23a7b02d5 100644
--- a/third_party/blink/renderer/platform/fonts/opentype/font_format_check.h
+++ b/third_party/blink/renderer/platform/fonts/opentype/font_format_check.h
@@ -5,6 +5,8 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_OPENTYPE_FONT_FORMAT_CHECK_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_OPENTYPE_FONT_FORMAT_CHECK_H_
 
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 #include "third_party/skia/include/core/SkData.h"
 #include "third_party/skia/include/core/SkRefCnt.h"
@@ -12,13 +14,21 @@
 
 namespace blink {
 
-class FontFormatCheck {
+class PLATFORM_EXPORT FontFormatCheck {
+  STACK_ALLOCATED();
+
  public:
-  FontFormatCheck(sk_sp<SkData>);
+  explicit FontFormatCheck(sk_sp<SkData>);
   bool IsVariableFont();
   bool IsCbdtCblcColorFont();
+  bool IsColrCpalColorFont() {
+    return IsColrCpalColorFontV0() || IsColrCpalColorFontV1();
+  }
+  bool IsColrCpalColorFontV0();
+  bool IsColrCpalColorFontV1();
   bool IsSbixColorFont();
   bool IsCff2OutlineFont();
+  bool IsColorFont();
 
   // Still needed in FontCustomPlatformData.
   enum class VariableFontSubType {
@@ -29,9 +39,14 @@ class FontFormatCheck {
 
   static VariableFontSubType ProbeVariableFont(sk_sp<SkTypeface>);
 
- private:
   // hb-common.h: typedef uint32_t hb_tag_t;
-  Vector<uint32_t> table_tags_;
+  using TableTagsVector = Vector<uint32_t>;
+
+  enum class COLRVersion { kCOLRV0, kCOLRV1, kNoCOLR };
+
+ private:
+  TableTagsVector table_tags_;
+  COLRVersion colr_version_ = COLRVersion::kNoCOLR;
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/opentype/font_format_check_test.cc b/third_party/blink/renderer/platform/fonts/opentype/font_format_check_test.cc
new file mode 100644
index 000000000000..3f343773477c
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/opentype/font_format_check_test.cc
@@ -0,0 +1,45 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/opentype/font_format_check.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/testing/unit_test_helpers.h"
+
+namespace blink {
+
+class FontFormatCheckTest : public testing::Test {
+ protected:
+  void EnsureFontData(String font_file_name) {
+    sk_sp<SkData> font_file_data(SkData::MakeFromFileName(
+        test::PlatformTestDataPath(font_file_name).Utf8().data()));
+    ASSERT_FALSE(font_file_data->isEmpty());
+    font_data_ = font_file_data;
+  }
+
+  sk_sp<SkData> font_data_;
+};
+
+TEST_F(FontFormatCheckTest, NoCOLR) {
+  EnsureFontData("roboto-a.ttf");
+  FontFormatCheck format_check(font_data_);
+  ASSERT_FALSE(format_check.IsColrCpalColorFontV0());
+  ASSERT_FALSE(format_check.IsColrCpalColorFontV1());
+}
+
+TEST_F(FontFormatCheckTest, COLRV1) {
+  EnsureFontData("colrv1_test.ttf");
+  FontFormatCheck format_check(font_data_);
+  ASSERT_TRUE(format_check.IsColrCpalColorFontV1());
+  ASSERT_FALSE(format_check.IsColrCpalColorFontV0());
+}
+
+TEST_F(FontFormatCheckTest, COLRV0) {
+  EnsureFontData("colrv0_test.ttf");
+  FontFormatCheck format_check(font_data_);
+  ASSERT_TRUE(format_check.IsColrCpalColorFontV0());
+  ASSERT_FALSE(format_check.IsColrCpalColorFontV1());
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/opentype/font_settings.cc b/third_party/blink/renderer/platform/fonts/opentype/font_settings.cc
index d8208acb87b5..c4f27cad2967 100644
--- a/third_party/blink/renderer/platform/fonts/opentype/font_settings.cc
+++ b/third_party/blink/renderer/platform/fonts/opentype/font_settings.cc
@@ -5,9 +5,10 @@
 #include "third_party/blink/renderer/platform/fonts/opentype/font_settings.h"
 
 #include "third_party/blink/renderer/platform/wtf/hash_functions.h"
-#include "third_party/blink/renderer/platform/wtf/string_hasher.h"
+#include "third_party/blink/renderer/platform/wtf/text/atomic_string.h"
 #include "third_party/blink/renderer/platform/wtf/text/atomic_string_hash.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_hasher.h"
 
 namespace blink {
 
@@ -16,16 +17,18 @@ uint32_t AtomicStringToFourByteTag(AtomicString tag) {
   return (((tag[0]) << 24) | ((tag[1]) << 16) | ((tag[2]) << 8) | (tag[3]));
 }
 
+AtomicString FourByteTagToAtomicString(uint32_t tag) {
+  constexpr size_t tag_size = 4;
+  LChar tag_string[tag_size] = {(tag >> 24) & 0xFF, (tag >> 16) & 0xFF,
+                                (tag >> 8) & 0xFF, tag & 0xFF};
+  return AtomicString(tag_string, tag_size);
+}
+
 unsigned FontVariationSettings::GetHash() const {
   unsigned computed_hash = size() ? 5381 : 0;
   unsigned num_features = size();
   for (unsigned i = 0; i < num_features; ++i) {
-    StringHasher string_hasher;
-    const AtomicString& tag = at(i).Tag();
-    for (unsigned j = 0; j < tag.length(); j++) {
-      string_hasher.AddCharacter(tag[j]);
-    }
-    WTF::AddIntToHash(computed_hash, string_hasher.GetHash());
+    WTF::AddIntToHash(computed_hash, at(i).Tag());
     WTF::AddFloatToHash(computed_hash, at(i).Value());
   }
   return computed_hash;
diff --git a/third_party/blink/renderer/platform/fonts/opentype/font_settings.h b/third_party/blink/renderer/platform/fonts/opentype/font_settings.h
index fdf9ff8a4989..d5f69315f474 100644
--- a/third_party/blink/renderer/platform/fonts/opentype/font_settings.h
+++ b/third_party/blink/renderer/platform/fonts/opentype/font_settings.h
@@ -8,7 +8,7 @@
 #include "base/macros.h"
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/ref_counted.h"
 #include "third_party/blink/renderer/platform/wtf/text/atomic_string.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
@@ -16,51 +16,87 @@
 
 namespace blink {
 
-uint32_t AtomicStringToFourByteTag(AtomicString tag);
+PLATFORM_EXPORT uint32_t AtomicStringToFourByteTag(AtomicString tag);
+PLATFORM_EXPORT AtomicString FourByteTagToAtomicString(uint32_t tag);
 
 template <typename T>
 class FontTagValuePair {
-  DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
+  DISALLOW_NEW();
 
  public:
+  FontTagValuePair(uint32_t tag, T value) : tag_(tag), value_(value) {
+    // ensure tag is either valid or zero
+    DCHECK(tag == 0 ||
+           (tag & 0xff000000) < 0x7f000000 &&
+               (tag & 0xff000000) >= 0x20000000 &&
+               (tag & 0xff0000) < 0x7f0000 && (tag & 0xff0000) >= 0x200000 &&
+               (tag & 0xff00) < 0x7f00 && (tag & 0xff00) >= 0x2000 &&
+               (tag & 0xff) < 0x7f && (tag & 0xff) >= 0x20);
+  }
   FontTagValuePair(const AtomicString& tag, T value)
-      : tag_(tag), value_(value){};
+      : tag_(AtomicStringToFourByteTag(tag)), value_(value) {
+    // ensure tag is valid
+    DCHECK((tag_ & 0xff000000) < 0x7f000000 &&
+           (tag_ & 0xff000000) >= 0x20000000 && (tag_ & 0xff0000) < 0x7f0000 &&
+           (tag_ & 0xff0000) >= 0x200000 && (tag_ & 0xff00) < 0x7f00 &&
+           (tag_ & 0xff00) >= 0x2000 && (tag_ & 0xff) < 0x7f &&
+           (tag_ & 0xff) >= 0x20);
+  }
   bool operator==(const FontTagValuePair& other) const {
     return tag_ == other.tag_ && value_ == other.value_;
-  };
+  }
 
-  const AtomicString& Tag() const { return tag_; }
+  uint32_t Tag() const { return tag_; }
+  AtomicString TagString() const { return FourByteTagToAtomicString(tag_); }
   T Value() const { return value_; }
 
  private:
-  AtomicString tag_;
-  const T value_;
+  uint32_t tag_;
+  T value_;
 };
 
 template <typename T>
 class FontSettings {
  public:
   void Append(const T& feature) { list_.push_back(feature); }
-  size_t size() const { return list_.size(); }
-  const T& operator[](int index) const { return list_[index]; }
-  const T& at(size_t index) const { return list_.at(index); }
+  wtf_size_t size() const { return list_.size(); }
+  const T& operator[](wtf_size_t index) const { return list_[index]; }
+  const T& at(wtf_size_t index) const { return list_.at(index); }
   bool operator==(const FontSettings& other) const {
     return list_ == other.list_;
-  };
+  }
+  bool operator!=(const FontSettings& other) const { return !(*this == other); }
   String ToString() const {
     StringBuilder builder;
-    size_t num_features = size();
-    for (size_t i = 0; i < num_features; ++i) {
+    wtf_size_t num_features = size();
+    for (wtf_size_t i = 0; i < num_features; ++i) {
       if (i > 0)
         builder.Append(",");
-      const AtomicString& tag = at(i).Tag();
-      builder.Append(tag);
+      builder.Append(at(i).TagString());
       builder.Append("=");
       builder.AppendNumber(at(i).Value());
     }
     return builder.ToString();
   }
 
+  bool FindPair(uint32_t tag, T* found_pair) const {
+    if (!found_pair)
+      return false;
+
+    for (auto& pair : list_) {
+      if (pair.Tag() == tag) {
+        *found_pair = pair;
+        return true;
+      }
+    }
+    return false;
+  }
+
+  const T* begin() const { return list_.begin(); }
+  const T* end() const { return list_.end(); }
+  T* begin() { return list_.begin(); }
+  T* end() { return list_.end(); }
+
  protected:
   FontSettings() = default;
 
diff --git a/third_party/blink/renderer/platform/fonts/opentype/font_settings_test.cc b/third_party/blink/renderer/platform/fonts/opentype/font_settings_test.cc
index bf748bf1b961..34b53c82f752 100644
--- a/third_party/blink/renderer/platform/fonts/opentype/font_settings_test.cc
+++ b/third_party/blink/renderer/platform/fonts/opentype/font_settings_test.cc
@@ -44,21 +44,45 @@ TEST(FontSettingsTest, HashTest) {
   CHECK_NE(one_axis_a->GetHash(), two_axes_different_value->GetHash());
   CHECK_NE(empty_variation_settings->GetHash(), one_axis_a->GetHash());
   CHECK_EQ(empty_variation_settings->GetHash(), 0u);
-};
+}
 
 TEST(FontSettingsTest, ToString) {
   {
     scoped_refptr<FontVariationSettings> settings =
         MakeSettings<FontVariationSettings, FontVariationAxis>(
-            {FontVariationAxis{"a", 42}, FontVariationAxis{"b", 8118}});
-    EXPECT_EQ("a=42,b=8118", settings->ToString());
+            {FontVariationAxis{"aaaa", 42}, FontVariationAxis{"bbbb", 8118}});
+    EXPECT_EQ("aaaa=42,bbbb=8118", settings->ToString());
   }
   {
     scoped_refptr<FontFeatureSettings> settings =
         MakeSettings<FontFeatureSettings, FontFeature>(
-            {FontFeature{"a", 42}, FontFeature{"b", 8118}});
-    EXPECT_EQ("a=42,b=8118", settings->ToString());
+            {FontFeature{"aaaa", 42}, FontFeature{"bbbb", 8118}});
+    EXPECT_EQ("aaaa=42,bbbb=8118", settings->ToString());
+  }
+}
+TEST(FontSettingsTest, FindTest) {
+  {
+    scoped_refptr<FontVariationSettings> settings =
+        MakeSettings<FontVariationSettings, FontVariationAxis>(
+            {FontVariationAxis{"abcd", 42}, FontVariationAxis{"efgh", 8118}});
+    FontVariationAxis found_axis(0, 0);
+    ASSERT_FALSE(settings->FindPair('aaaa', &found_axis));
+    ASSERT_FALSE(settings->FindPair('bbbb', &found_axis));
+    ASSERT_EQ(found_axis.Value(), 0);
+    ASSERT_TRUE(settings->FindPair('abcd', &found_axis));
+    ASSERT_EQ(found_axis.TagString(), AtomicString("abcd"));
+    ASSERT_EQ(found_axis.Value(), 42);
+    ASSERT_TRUE(settings->FindPair('efgh', &found_axis));
+    ASSERT_EQ(found_axis.TagString(), AtomicString("efgh"));
+    ASSERT_EQ(found_axis.Value(), 8118);
   }
 }
 
+TEST(FontSettingsTest, FindTestEmpty) {
+  scoped_refptr<FontVariationSettings> settings =
+      MakeSettings<FontVariationSettings, FontVariationAxis>({});
+  FontVariationAxis found_axis(0, 0);
+  ASSERT_FALSE(settings->FindPair('aaaa', &found_axis));
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support.cc b/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support.cc
index 3365749c7592..84024bbecdad 100644
--- a/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support.cc
+++ b/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support.cc
@@ -2,15 +2,48 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+// clang-format off
+#include <hb.h>
+#include <hb-aat.h>
+// clang-format on
+
 #include "third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support.h"
+#include "third_party/harfbuzz-ng/utils/hb_scoped.h"
 
 namespace blink {
 
+namespace {
+
+bool activationSelectorPresent(
+    hb_face_t* hb_face,
+    const hb_aat_layout_feature_type_t feature_type,
+    const hb_aat_layout_feature_selector_t enabled_selector_expectation) {
+  Vector<hb_aat_layout_feature_selector_info_t> feature_selectors;
+  unsigned num_feature_selectors = 0;
+  unsigned default_index = 0;
+  num_feature_selectors = hb_aat_layout_feature_type_get_selector_infos(
+      hb_face, feature_type, 0, nullptr, nullptr, nullptr);
+  feature_selectors.resize(num_feature_selectors);
+  if (!hb_aat_layout_feature_type_get_selector_infos(
+          hb_face, feature_type, 0, &num_feature_selectors,
+          feature_selectors.data(), &default_index)) {
+    return false;
+  }
+  for (hb_aat_layout_feature_selector_info_t selector_info :
+       feature_selectors) {
+    if (selector_info.enable == enabled_selector_expectation)
+      return true;
+  }
+  return false;
+}
+}  // namespace
+
 OpenTypeCapsSupport::OpenTypeCapsSupport()
     : harfbuzz_face_(nullptr),
       requested_caps_(FontDescription::kCapsNormal),
       font_support_(FontSupport::kFull),
-      caps_synthesis_(CapsSynthesis::kNone) {}
+      caps_synthesis_(CapsSynthesis::kNone),
+      font_format_(FontFormat::kUndetermined) {}
 
 OpenTypeCapsSupport::OpenTypeCapsSupport(
     const HarfBuzzFace* harfbuzz_face,
@@ -19,7 +52,8 @@ OpenTypeCapsSupport::OpenTypeCapsSupport(
     : harfbuzz_face_(harfbuzz_face),
       requested_caps_(requested_caps),
       font_support_(FontSupport::kFull),
-      caps_synthesis_(CapsSynthesis::kNone) {
+      caps_synthesis_(CapsSynthesis::kNone),
+      font_format_(FontFormat::kUndetermined) {
   if (requested_caps != FontDescription::kCapsNormal)
     DetermineFontSupport(script);
 }
@@ -102,24 +136,111 @@ CaseMapIntend OpenTypeCapsSupport::NeedsCaseChange(
   return case_map_intend;
 }
 
+OpenTypeCapsSupport::FontFormat OpenTypeCapsSupport::GetFontFormat() const {
+  if (font_format_ == FontFormat::kUndetermined) {
+    hb_face_t* hb_face = hb_font_get_face(
+        harfbuzz_face_->GetScaledFont(nullptr, HarfBuzzFace::NoVerticalLayout));
+
+    HbScoped<hb_blob_t> morx_blob(
+        hb_face_reference_table(hb_face, HB_TAG('m', 'o', 'r', 'x')));
+    HbScoped<hb_blob_t> mort_blob(
+        hb_face_reference_table(hb_face, HB_TAG('m', 'o', 'r', 't')));
+
+    // TODO(crbug.com/911149): Use hb_aat_layout_has_substitution() for
+    // has_morx_or_mort and hb_ot_layout_has_substitution() for has_gsub once is
+    // exposed in HarfBuzz.
+    bool has_morx_or_mort = hb_blob_get_length(morx_blob.get()) ||
+                            hb_blob_get_length(mort_blob.get());
+    bool has_gsub = hb_ot_layout_has_substitution(hb_face);
+    font_format_ = has_morx_or_mort && !has_gsub ? FontFormat::kAat
+                                                 : FontFormat::kOpenType;
+  }
+  return font_format_;
+}
+
+bool OpenTypeCapsSupport::SupportsFeature(hb_script_t script,
+                                          uint32_t tag) const {
+  if (GetFontFormat() == FontFormat::kAat)
+    return SupportsAatFeature(tag);
+  return SupportsOpenTypeFeature(script, tag);
+}
+
+bool OpenTypeCapsSupport::SupportsAatFeature(uint32_t tag) const {
+  // We only want to detect small-caps and capitals-to-small-capitals features
+  // for aat-fonts, any other requests are returned as not supported.
+  if (tag != HB_TAG('s', 'm', 'c', 'p') && tag != HB_TAG('c', '2', 's', 'c')) {
+    return false;
+  }
+
+  hb_face_t* hb_face = hb_font_get_face(
+      harfbuzz_face_->GetScaledFont(nullptr, HarfBuzzFace::NoVerticalLayout));
+
+  Vector<hb_aat_layout_feature_type_t> aat_features;
+  unsigned feature_count =
+      hb_aat_layout_get_feature_types(hb_face, 0, nullptr, nullptr);
+  aat_features.resize(feature_count);
+  if (!hb_aat_layout_get_feature_types(hb_face, 0, &feature_count,
+                                       aat_features.data()))
+    return false;
+
+  if (tag == HB_TAG('s', 'm', 'c', 'p')) {
+    // Check for presence of new style (feature id 38) or old style (letter
+    // case, feature id 3) small caps feature presence, then check for the
+    // specific required activation selectors.
+    if (!aat_features.Contains(HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE) &&
+        !aat_features.Contains(HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE))
+      return false;
+
+    // Check for new style small caps, feature id 38.
+    if (aat_features.Contains(HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE)) {
+      if (activationSelectorPresent(
+              hb_face, HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE,
+              HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_SMALL_CAPS))
+        return true;
+    }
+
+    // Check for old style small caps enabling selector, feature id 3.
+    if (aat_features.Contains(HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE)) {
+      if (activationSelectorPresent(hb_face,
+                                    HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE,
+                                    HB_AAT_LAYOUT_FEATURE_SELECTOR_SMALL_CAPS))
+        return true;
+    }
+
+    // Neither old or new style small caps present.
+    return false;
+  }
+
+  if (tag == HB_TAG('c', '2', 's', 'c')) {
+    if (!aat_features.Contains(HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE))
+      return false;
+
+    return activationSelectorPresent(
+        hb_face, HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE,
+        HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_SMALL_CAPS);
+  }
+
+  return false;
+}
+
 void OpenTypeCapsSupport::DetermineFontSupport(hb_script_t script) {
   switch (requested_caps_) {
     case FontDescription::kSmallCaps:
-      if (!SupportsOpenTypeFeature(script, HB_TAG('s', 'm', 'c', 'p'))) {
+      if (!SupportsFeature(script, HB_TAG('s', 'm', 'c', 'p'))) {
         font_support_ = FontSupport::kNone;
         caps_synthesis_ = CapsSynthesis::kLowerToSmallCaps;
       }
       break;
     case FontDescription::kAllSmallCaps:
-      if (!(SupportsOpenTypeFeature(script, HB_TAG('s', 'm', 'c', 'p')) &&
-            SupportsOpenTypeFeature(script, HB_TAG('c', '2', 's', 'c')))) {
+      if (!(SupportsFeature(script, HB_TAG('s', 'm', 'c', 'p')) &&
+            SupportsFeature(script, HB_TAG('c', '2', 's', 'c')))) {
         font_support_ = FontSupport::kNone;
         caps_synthesis_ = CapsSynthesis::kBothToSmallCaps;
       }
       break;
     case FontDescription::kPetiteCaps:
-      if (!SupportsOpenTypeFeature(script, HB_TAG('p', 'c', 'a', 'p'))) {
-        if (SupportsOpenTypeFeature(script, HB_TAG('s', 'm', 'c', 'p'))) {
+      if (!SupportsFeature(script, HB_TAG('p', 'c', 'a', 'p'))) {
+        if (SupportsFeature(script, HB_TAG('s', 'm', 'c', 'p'))) {
           font_support_ = FontSupport::kFallback;
         } else {
           font_support_ = FontSupport::kNone;
@@ -128,10 +249,10 @@ void OpenTypeCapsSupport::DetermineFontSupport(hb_script_t script) {
       }
       break;
     case FontDescription::kAllPetiteCaps:
-      if (!(SupportsOpenTypeFeature(script, HB_TAG('p', 'c', 'a', 'p')) &&
-            SupportsOpenTypeFeature(script, HB_TAG('c', '2', 'p', 'c')))) {
-        if (SupportsOpenTypeFeature(script, HB_TAG('s', 'm', 'c', 'p')) &&
-            SupportsOpenTypeFeature(script, HB_TAG('c', '2', 's', 'c'))) {
+      if (!(SupportsFeature(script, HB_TAG('p', 'c', 'a', 'p')) &&
+            SupportsFeature(script, HB_TAG('c', '2', 'p', 'c')))) {
+        if (SupportsFeature(script, HB_TAG('s', 'm', 'c', 'p')) &&
+            SupportsFeature(script, HB_TAG('c', '2', 's', 'c'))) {
           font_support_ = FontSupport::kFallback;
         } else {
           font_support_ = FontSupport::kNone;
@@ -140,9 +261,9 @@ void OpenTypeCapsSupport::DetermineFontSupport(hb_script_t script) {
       }
       break;
     case FontDescription::kUnicase:
-      if (!SupportsOpenTypeFeature(script, HB_TAG('u', 'n', 'i', 'c'))) {
+      if (!SupportsFeature(script, HB_TAG('u', 'n', 'i', 'c'))) {
         caps_synthesis_ = CapsSynthesis::kUpperToSmallCaps;
-        if (SupportsOpenTypeFeature(script, HB_TAG('s', 'm', 'c', 'p'))) {
+        if (SupportsFeature(script, HB_TAG('s', 'm', 'c', 'p'))) {
           font_support_ = FontSupport::kFallback;
         } else {
           font_support_ = FontSupport::kNone;
@@ -150,7 +271,7 @@ void OpenTypeCapsSupport::DetermineFontSupport(hb_script_t script) {
       }
       break;
     case FontDescription::kTitlingCaps:
-      if (!SupportsOpenTypeFeature(script, HB_TAG('t', 'i', 't', 'l'))) {
+      if (!SupportsFeature(script, HB_TAG('t', 'i', 't', 'l'))) {
         font_support_ = FontSupport::kNone;
       }
       break;
diff --git a/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support.h b/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support.h
index 841e465c8a10..4fd0db3c634f 100644
--- a/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support.h
+++ b/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support.h
@@ -10,12 +10,15 @@
 #include "third_party/blink/renderer/platform/fonts/shaping/case_mapping_harfbuzz_buffer_filler.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h"
 #include "third_party/blink/renderer/platform/fonts/small_caps_iterator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
 #include <hb.h>
 
 namespace blink {
 
 class PLATFORM_EXPORT OpenTypeCapsSupport {
+  STACK_ALLOCATED();
+
  public:
   OpenTypeCapsSupport();
   OpenTypeCapsSupport(const HarfBuzzFace*,
@@ -29,7 +32,13 @@ class PLATFORM_EXPORT OpenTypeCapsSupport {
   CaseMapIntend NeedsCaseChange(SmallCapsIterator::SmallCapsBehavior run_case);
 
  private:
+  enum class FontFormat { kUndetermined, kOpenType, kAat };
+  // Lazily intializes font_format_ when needed and returns the format of the
+  // underlying HarfBuzzFace/Font.
+  FontFormat GetFontFormat() const;
   void DetermineFontSupport(hb_script_t);
+  bool SupportsFeature(hb_script_t, uint32_t tag) const;
+  bool SupportsAatFeature(uint32_t tag) const;
   bool SupportsOpenTypeFeature(hb_script_t, uint32_t tag) const;
 
   const HarfBuzzFace* harfbuzz_face_;
@@ -50,8 +59,9 @@ class PLATFORM_EXPORT OpenTypeCapsSupport {
 
   FontSupport font_support_;
   CapsSynthesis caps_synthesis_;
+  mutable FontFormat font_format_;
 };
 
-};  // namespace blink
+}  // namespace blink
 
 #endif
diff --git a/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support_mpl.cc b/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support_mpl.cc
index 0e0a808ac1c1..f04b91d087bb 100644
--- a/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support_mpl.cc
+++ b/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support_mpl.cc
@@ -6,6 +6,7 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
+#include "base/stl_util.h"
 #include "third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support.h"
 
 #include <hb-ot.h>
@@ -29,17 +30,18 @@ bool OpenTypeCapsSupport::SupportsOpenTypeFeature(hb_script_t script,
     return false;
 
   // Get the OpenType tag(s) that match this script code
-  hb_tag_t script_tags[] = {
-      HB_TAG_NONE, HB_TAG_NONE, HB_TAG_NONE,
-  };
-  hb_ot_tags_from_script(static_cast<hb_script_t>(script), &script_tags[0],
-                         &script_tags[1]);
+  DCHECK_EQ(HB_TAG_NONE, 0u);
+  hb_tag_t script_tags[2] = {};
+  unsigned num_returned_script_tags = base::size(script_tags);
+  hb_ot_tags_from_script_and_language(
+      static_cast<hb_script_t>(script), HB_LANGUAGE_INVALID,
+      &num_returned_script_tags, script_tags, nullptr, nullptr);
 
   const hb_tag_t kGSUB = HB_TAG('G', 'S', 'U', 'B');
   unsigned script_index = 0;
   // Identify for which script a GSUB table is available.
-  hb_ot_layout_table_choose_script(face, kGSUB, script_tags, &script_index,
-                                   nullptr);
+  hb_ot_layout_table_select_script(face, kGSUB, num_returned_script_tags,
+                                   script_tags, &script_index, nullptr);
 
   if (hb_ot_layout_language_find_feature(face, kGSUB, script_index,
                                          HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX,
diff --git a/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support_test.mm b/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support_test.mm
new file mode 100644
index 000000000000..14035eeba90a
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support_test.mm
@@ -0,0 +1,60 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support.h"
+
+#import <Cocoa/Cocoa.h>
+
+#include "base/mac/mac_util.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/fonts/font_description.h"
+#include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace blink {
+
+void ensureHasNativeSmallCaps(const String& font_family_name) {
+  sk_sp<SkTypeface> test_typeface =
+      SkTypeface::MakeFromName(font_family_name.Utf8().c_str(), SkFontStyle());
+  FontPlatformData font_platform_data(test_typeface, font_family_name.Utf8(),
+                                      16, false, false);
+  // System font names are magical. The family name of the system font in the
+  // test below yields ".AppleSystemUIFont", which seems to be a generic role
+  // name, because when it's actually instantiated with SkTypeface it ends up as
+  // ".SF NS Text" or ".SF NS", depending on the system version. So if we try to
+  // instantiate a magical system font, at least ensure that the resulting font
+  // is magical as well.
+  if (font_family_name[0] == '.')
+    ASSERT_TRUE(font_platform_data.FontFamilyName()[0] == '.');
+  else
+    ASSERT_EQ(font_platform_data.FontFamilyName(), font_family_name);
+
+  OpenTypeCapsSupport caps_support(font_platform_data.GetHarfBuzzFace(),
+                                   FontDescription::FontVariantCaps::kSmallCaps,
+                                   HB_SCRIPT_LATIN);
+  // If caps_support.NeedsRunCaseSplitting() is true, this means that synthetic
+  // upper-casing / lower-casing is required and the run needs to be segmented
+  // by upper-case, lower-case properties. If it is false, it means that the
+  // font feature can be used and no synthetic case-changing is needed.
+  ASSERT_FALSE(caps_support.NeedsRunCaseSplitting());
+}
+
+TEST(OpenTypeCapsSupportTest, SmallCapsForMacAATFonts) {
+  // The AAT fonts for testing are only available on macOS 10.13.
+  if (!base::mac::IsAtLeastOS10_13())
+    return;
+
+  Vector<String> test_fonts = {
+      [[NSFont systemFontOfSize:12] familyName],  // has OpenType small-caps
+      "Apple Chancery",  // has old-style (feature id 3,"Letter Case")
+                         // small-caps
+      "Baskerville"};    // has new-style (feature id 38, "Upper Case")
+                         // small-case.
+  for (const auto& test_font : test_fonts)
+    ensureHasNativeSmallCaps(test_font);
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/opentype/open_type_math_stretch_data.h b/third_party/blink/renderer/platform/fonts/opentype/open_type_math_stretch_data.h
new file mode 100644
index 000000000000..af3cc0599035
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/opentype/open_type_math_stretch_data.h
@@ -0,0 +1,45 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_OPENTYPE_OPEN_TYPE_MATH_STRETCH_DATA_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_OPENTYPE_OPEN_TYPE_MATH_STRETCH_DATA_H_
+
+#include "base/optional.h"
+#include "third_party/blink/renderer/platform/fonts/glyph.h"
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/wtf/vector.h"
+
+namespace blink {
+
+class PLATFORM_EXPORT OpenTypeMathStretchData {
+ public:
+  enum StretchAxis : uint8_t { Horizontal = 0, Vertical = 1 };
+
+  // https://docs.microsoft.com/en-us/typography/opentype/spec/math#mathGlyphVariantRecordFormat
+  // Note: Only variantGlyph is considered as using advanceMeasurement can lead
+  // to inconsistent values compared to what SimpleFontData returns.
+  using GlyphVariantRecord = Glyph;
+
+  // https://docs.microsoft.com/en-us/typography/opentype/spec/math#glyphPartRecord
+  struct GlyphPartRecord {
+    Glyph glyph;
+    float start_connector_length;
+    float end_connector_length;
+    float full_advance;
+    bool is_extender;
+  };
+
+  // https://mathml-refresh.github.io/mathml-core/#the-glyphassembly-table
+  struct AssemblyParameters {
+    float connector_overlap{0};
+    unsigned repetition_count{0};
+    unsigned glyph_count{0};
+    float stretch_size{0};
+    Vector<GlyphPartRecord> parts;
+  };
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_OPENTYPE_OPEN_TYPE_MATH_STRETCH_DATA_H_
diff --git a/third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.cc b/third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.cc
new file mode 100644
index 000000000000..80d94665ab7a
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.cc
@@ -0,0 +1,258 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.h"
+
+// clang-format off
+#include <hb.h>
+#include <hb-ot.h>
+// clang-format on
+
+#include "base/bind.h"
+#include "base/callback.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h"
+
+namespace {
+// HarfBuzz' hb_position_t is a 16.16 fixed-point value.
+float HarfBuzzUnitsToFloat(hb_position_t value) {
+  static const float kFloatToHbRatio = 1.0f / (1 << 16);
+  return kFloatToHbRatio * value;
+}
+
+// Latin Modern, STIX Two, XITS, Asana, Deja Vu, Libertinus and TeX Gyre fonts
+// provide at most 13 size variant and 5 assembly parts.
+// See https://chromium-review.googlesource.com/c/chromium/src/+/2074678
+unsigned kMaxHarfBuzzRecords = 20;
+
+hb_direction_t HarfBuzzDirection(
+    blink::OpenTypeMathStretchData::StretchAxis stretch_axis) {
+  return stretch_axis == blink::OpenTypeMathStretchData::StretchAxis::Horizontal
+             ? HB_DIRECTION_LTR
+             : HB_DIRECTION_BTT;
+}
+
+}  // namespace
+
+namespace blink {
+
+bool OpenTypeMathSupport::HasMathData(const HarfBuzzFace* harfbuzz_face) {
+  if (!harfbuzz_face)
+    return false;
+
+  hb_font_t* font =
+      harfbuzz_face->GetScaledFont(nullptr, HarfBuzzFace::NoVerticalLayout);
+  DCHECK(font);
+  hb_face_t* face = hb_font_get_face(font);
+  DCHECK(face);
+
+  return hb_ot_math_has_data(face);
+}
+
+base::Optional<float> OpenTypeMathSupport::MathConstant(
+    const HarfBuzzFace* harfbuzz_face,
+    MathConstants constant) {
+  if (!HasMathData(harfbuzz_face))
+    return base::nullopt;
+
+  hb_font_t* font =
+      harfbuzz_face->GetScaledFont(nullptr, HarfBuzzFace::NoVerticalLayout);
+  DCHECK(font);
+
+  hb_position_t harfbuzz_value = hb_ot_math_get_constant(
+      font, static_cast<hb_ot_math_constant_t>(constant));
+
+  switch (constant) {
+    case kScriptPercentScaleDown:
+    case kScriptScriptPercentScaleDown:
+    case kRadicalDegreeBottomRaisePercent:
+      return base::Optional<float>(harfbuzz_value / 100.0);
+    case kDelimitedSubFormulaMinHeight:
+    case kDisplayOperatorMinHeight:
+    case kMathLeading:
+    case kAxisHeight:
+    case kAccentBaseHeight:
+    case kFlattenedAccentBaseHeight:
+    case kSubscriptShiftDown:
+    case kSubscriptTopMax:
+    case kSubscriptBaselineDropMin:
+    case kSuperscriptShiftUp:
+    case kSuperscriptShiftUpCramped:
+    case kSuperscriptBottomMin:
+    case kSuperscriptBaselineDropMax:
+    case kSubSuperscriptGapMin:
+    case kSuperscriptBottomMaxWithSubscript:
+    case kSpaceAfterScript:
+    case kUpperLimitGapMin:
+    case kUpperLimitBaselineRiseMin:
+    case kLowerLimitGapMin:
+    case kLowerLimitBaselineDropMin:
+    case kStackTopShiftUp:
+    case kStackTopDisplayStyleShiftUp:
+    case kStackBottomShiftDown:
+    case kStackBottomDisplayStyleShiftDown:
+    case kStackGapMin:
+    case kStackDisplayStyleGapMin:
+    case kStretchStackTopShiftUp:
+    case kStretchStackBottomShiftDown:
+    case kStretchStackGapAboveMin:
+    case kStretchStackGapBelowMin:
+    case kFractionNumeratorShiftUp:
+    case kFractionNumeratorDisplayStyleShiftUp:
+    case kFractionDenominatorShiftDown:
+    case kFractionDenominatorDisplayStyleShiftDown:
+    case kFractionNumeratorGapMin:
+    case kFractionNumDisplayStyleGapMin:
+    case kFractionRuleThickness:
+    case kFractionDenominatorGapMin:
+    case kFractionDenomDisplayStyleGapMin:
+    case kSkewedFractionHorizontalGap:
+    case kSkewedFractionVerticalGap:
+    case kOverbarVerticalGap:
+    case kOverbarRuleThickness:
+    case kOverbarExtraAscender:
+    case kUnderbarVerticalGap:
+    case kUnderbarRuleThickness:
+    case kUnderbarExtraDescender:
+    case kRadicalVerticalGap:
+    case kRadicalDisplayStyleVerticalGap:
+    case kRadicalRuleThickness:
+    case kRadicalExtraAscender:
+    case kRadicalKernBeforeDegree:
+    case kRadicalKernAfterDegree:
+      return base::Optional<float>(HarfBuzzUnitsToFloat(harfbuzz_value));
+    default:
+      NOTREACHED();
+  }
+  return base::nullopt;
+}
+
+base::Optional<float> OpenTypeMathSupport::MathItalicCorrection(
+    const HarfBuzzFace* harfbuzz_face,
+    Glyph glyph) {
+  if (!harfbuzz_face)
+    return base::nullopt;
+
+  hb_font_t* font =
+      harfbuzz_face->GetScaledFont(nullptr, HarfBuzzFace::NoVerticalLayout);
+
+  return base::Optional<float>(HarfBuzzUnitsToFloat(
+      hb_ot_math_get_glyph_italics_correction(font, glyph)));
+}
+
+template <typename HarfBuzzRecordType>
+using GetHarfBuzzMathRecordGetter =
+    base::OnceCallback<unsigned int(hb_font_t* font,
+                                    hb_codepoint_t glyph,
+                                    hb_direction_t direction,
+                                    unsigned int start_offset,
+                                    unsigned int* record_count,
+                                    HarfBuzzRecordType* record_array)>;
+
+template <typename HarfBuzzRecordType, typename RecordType>
+using HarfBuzzMathRecordConverter =
+    base::RepeatingCallback<RecordType(HarfBuzzRecordType)>;
+
+template <typename HarfBuzzRecordType, typename RecordType>
+Vector<RecordType> GetHarfBuzzMathRecord(
+    const HarfBuzzFace* harfbuzz_face,
+    Glyph base_glyph,
+    OpenTypeMathStretchData::StretchAxis stretch_axis,
+    GetHarfBuzzMathRecordGetter<HarfBuzzRecordType> getter,
+    HarfBuzzMathRecordConverter<HarfBuzzRecordType, RecordType> converter,
+    base::Optional<RecordType> prepended_record) {
+  hb_font_t* hb_font =
+      harfbuzz_face->GetScaledFont(nullptr, HarfBuzzFace::NoVerticalLayout);
+  DCHECK(hb_font);
+
+  hb_direction_t hb_stretch_axis = HarfBuzzDirection(stretch_axis);
+
+  // In practice, math fonts have, for a given base glyph and stretch axis only
+  // provide a few GlyphVariantRecords (size variants of increasing sizes) and
+  // GlyphPartRecords (parts of a glyph assembly) so it is safe to truncate
+  // the result vector to a small size.
+  HarfBuzzRecordType chunk[kMaxHarfBuzzRecords];
+  unsigned int count = kMaxHarfBuzzRecords;
+  std::move(getter).Run(hb_font, base_glyph, hb_stretch_axis,
+                        0 /* start_offset */, &count, chunk);
+
+  // Create the vector to the determined size and initialize it with the results
+  // converted from HarfBuzz's ones, prepending any optional record.
+  Vector<RecordType> result;
+  result.ReserveInitialCapacity(prepended_record ? count + 1 : count);
+  if (prepended_record)
+    result.push_back(*prepended_record);
+  for (unsigned i = 0; i < count; i++) {
+    result.push_back(converter.Run(chunk[i]));
+  }
+  return result;
+}
+
+Vector<OpenTypeMathStretchData::GlyphVariantRecord>
+OpenTypeMathSupport::GetGlyphVariantRecords(
+    const HarfBuzzFace* harfbuzz_face,
+    Glyph base_glyph,
+    OpenTypeMathStretchData::StretchAxis stretch_axis) {
+  DCHECK(harfbuzz_face);
+  DCHECK(base_glyph);
+
+  auto getter = base::BindOnce(&hb_ot_math_get_glyph_variants);
+  auto converter =
+      base::BindRepeating([](hb_ot_math_glyph_variant_t record)
+                              -> OpenTypeMathStretchData::GlyphVariantRecord {
+        return record.glyph;
+      });
+  return GetHarfBuzzMathRecord(
+      harfbuzz_face, base_glyph, stretch_axis, std::move(getter),
+      std::move(converter),
+      base::Optional<OpenTypeMathStretchData::GlyphVariantRecord>(base_glyph));
+}
+
+Vector<OpenTypeMathStretchData::GlyphPartRecord>
+OpenTypeMathSupport::GetGlyphPartRecords(
+    const HarfBuzzFace* harfbuzz_face,
+    Glyph base_glyph,
+    OpenTypeMathStretchData::StretchAxis stretch_axis,
+    float* italic_correction) {
+  DCHECK(harfbuzz_face);
+  DCHECK(base_glyph);
+
+  auto getter = base::BindOnce(
+      [](hb_font_t* font, hb_codepoint_t glyph, hb_direction_t direction,
+         unsigned int start_offset, unsigned int* parts_count,
+         hb_ot_math_glyph_part_t* parts) {
+        hb_position_t italic_correction;
+        return hb_ot_math_get_glyph_assembly(font, glyph, direction,
+                                             start_offset, parts_count, parts,
+                                             &italic_correction);
+      });
+  auto converter =
+      base::BindRepeating([](hb_ot_math_glyph_part_t record)
+                              -> OpenTypeMathStretchData::GlyphPartRecord {
+        return {record.glyph,
+                HarfBuzzUnitsToFloat(record.start_connector_length),
+                HarfBuzzUnitsToFloat(record.end_connector_length),
+                HarfBuzzUnitsToFloat(record.full_advance),
+                record.flags & HB_MATH_GLYPH_PART_FLAG_EXTENDER};
+      });
+  Vector<OpenTypeMathStretchData::GlyphPartRecord> parts =
+      GetHarfBuzzMathRecord(
+          harfbuzz_face, base_glyph, stretch_axis, std::move(getter),
+          std::move(converter),
+          base::Optional<OpenTypeMathStretchData::GlyphPartRecord>());
+  if (italic_correction && !parts.IsEmpty()) {
+    hb_font_t* hb_font =
+        harfbuzz_face->GetScaledFont(nullptr, HarfBuzzFace::NoVerticalLayout);
+    // A GlyphAssembly subtable exists for the specified font, glyph and stretch
+    // axis since it has been possible to retrieve the GlyphPartRecords. This
+    // means that the following call is guaranteed to get an italic correction.
+    hb_position_t harfbuzz_italic_correction;
+    hb_ot_math_get_glyph_assembly(hb_font, base_glyph,
+                                  HarfBuzzDirection(stretch_axis), 0, nullptr,
+                                  nullptr, &harfbuzz_italic_correction);
+    *italic_correction = HarfBuzzUnitsToFloat(harfbuzz_italic_correction);
+  }
+  return parts;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.h b/third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.h
new file mode 100644
index 000000000000..633a4d11f2be
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.h
@@ -0,0 +1,120 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_OPENTYPE_OPEN_TYPE_MATH_SUPPORT_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_OPENTYPE_OPEN_TYPE_MATH_SUPPORT_H_
+
+#include "base/optional.h"
+#include "third_party/blink/renderer/platform/fonts/opentype/open_type_math_stretch_data.h"
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/wtf/vector.h"
+
+namespace blink {
+
+class HarfBuzzFace;
+
+class PLATFORM_EXPORT OpenTypeMathSupport {
+ public:
+  static bool HasMathData(const HarfBuzzFace*);
+
+  // These constants are defined in the OpenType MATH table:
+  // https://docs.microsoft.com/en-us/typography/opentype/spec/math#mathconstants-table
+  // Their values match the indices in the MathConstants subtable.
+  enum MathConstants {
+    kScriptPercentScaleDown = 0,
+    kScriptScriptPercentScaleDown = 1,
+    kDelimitedSubFormulaMinHeight = 2,
+    kDisplayOperatorMinHeight = 3,
+    kMathLeading = 4,
+    kAxisHeight = 5,
+    kAccentBaseHeight = 6,
+    kFlattenedAccentBaseHeight = 7,
+    kSubscriptShiftDown = 8,
+    kSubscriptTopMax = 9,
+    kSubscriptBaselineDropMin = 10,
+    kSuperscriptShiftUp = 11,
+    kSuperscriptShiftUpCramped = 12,
+    kSuperscriptBottomMin = 13,
+    kSuperscriptBaselineDropMax = 14,
+    kSubSuperscriptGapMin = 15,
+    kSuperscriptBottomMaxWithSubscript = 16,
+    kSpaceAfterScript = 17,
+    kUpperLimitGapMin = 18,
+    kUpperLimitBaselineRiseMin = 19,
+    kLowerLimitGapMin = 20,
+    kLowerLimitBaselineDropMin = 21,
+    kStackTopShiftUp = 22,
+    kStackTopDisplayStyleShiftUp = 23,
+    kStackBottomShiftDown = 24,
+    kStackBottomDisplayStyleShiftDown = 25,
+    kStackGapMin = 26,
+    kStackDisplayStyleGapMin = 27,
+    kStretchStackTopShiftUp = 28,
+    kStretchStackBottomShiftDown = 29,
+    kStretchStackGapAboveMin = 30,
+    kStretchStackGapBelowMin = 31,
+    kFractionNumeratorShiftUp = 32,
+    kFractionNumeratorDisplayStyleShiftUp = 33,
+    kFractionDenominatorShiftDown = 34,
+    kFractionDenominatorDisplayStyleShiftDown = 35,
+    kFractionNumeratorGapMin = 36,
+    kFractionNumDisplayStyleGapMin = 37,
+    kFractionRuleThickness = 38,
+    kFractionDenominatorGapMin = 39,
+    kFractionDenomDisplayStyleGapMin = 40,
+    kSkewedFractionHorizontalGap = 41,
+    kSkewedFractionVerticalGap = 42,
+    kOverbarVerticalGap = 43,
+    kOverbarRuleThickness = 44,
+    kOverbarExtraAscender = 45,
+    kUnderbarVerticalGap = 46,
+    kUnderbarRuleThickness = 47,
+    kUnderbarExtraDescender = 48,
+    kRadicalVerticalGap = 49,
+    kRadicalDisplayStyleVerticalGap = 50,
+    kRadicalRuleThickness = 51,
+    kRadicalExtraAscender = 52,
+    kRadicalKernBeforeDegree = 53,
+    kRadicalKernAfterDegree = 54,
+    kRadicalDegreeBottomRaisePercent = 55
+  };
+
+  // Returns the value of the requested math constant or null if the font does
+  // not have any OpenType MATH table. All values are 16.16 fixed-point values
+  // converted to float except percentages (kScriptPercentScaleDown,
+  // kScriptScriptPercentScaleDown and kRadicalDegreeBottomRaisePercent) which
+  // are represented by a number between 0 and 1.
+  // https://docs.microsoft.com/en-us/typography/opentype/spec/math#mathconstants-table
+  static base::Optional<float> MathConstant(const HarfBuzzFace*, MathConstants);
+
+  // Returns the italic correction corresponding to the specified glyph or null
+  // if the font does not have any OpenType MATH table. This value provides an
+  // estimation of how much the glyph is slanted, which can be used e.g. when
+  // attaching scripts to the glyph.
+  // https://docs.microsoft.com/en-us/typography/opentype/spec/math#mathitalicscorrectioninfo-table
+  static base::Optional<float> MathItalicCorrection(const HarfBuzzFace*, Glyph);
+
+  // Returns a vector of GlyphVariantRecords corresponding to the specified
+  // glyph and stretch axis. The base glyph is always added as the first item.
+  // https://docs.microsoft.com/en-us/typography/opentype/spec/math#mathvariants-table
+  static Vector<OpenTypeMathStretchData::GlyphVariantRecord>
+  GetGlyphVariantRecords(const HarfBuzzFace*,
+                         Glyph base_glyph,
+                         OpenTypeMathStretchData::StretchAxis);
+
+  // Returns a vector of GlyphPartRecords corresponding to the specified
+  // glyph and stretch axis or an empty vector if there is no such construction.
+  // If the italic_correction parameter is specified and a construction is
+  // available, then it is set to the italic correction of the glyph assembly.
+  // https://docs.microsoft.com/en-us/typography/opentype/spec/math#mathvariants-table
+  static Vector<OpenTypeMathStretchData::GlyphPartRecord> GetGlyphPartRecords(
+      const HarfBuzzFace*,
+      Glyph base_glyph,
+      OpenTypeMathStretchData::StretchAxis,
+      float* italic_correction = nullptr);
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_OPENTYPE_OPEN_TYPE_MATH_SUPPORT_H_
diff --git a/third_party/blink/renderer/platform/fonts/opentype/open_type_math_support_test.cc b/third_party/blink/renderer/platform/fonts/opentype/open_type_math_support_test.cc
new file mode 100644
index 000000000000..542eeef30f73
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/opentype/open_type_math_support_test.cc
@@ -0,0 +1,466 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.h"
+#include "base/memory/scoped_refptr.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/fonts/font.h"
+#include "third_party/blink/renderer/platform/fonts/opentype/open_type_types.h"
+#include "third_party/blink/renderer/platform/testing/font_test_helpers.h"
+#include "third_party/blink/renderer/platform/testing/unit_test_helpers.h"
+
+namespace {
+const UChar32 kLeftBraceCodePoint = '{';
+const UChar32 kOverBraceCodePoint = 0x23DE;
+const UChar32 kRightwardsFrontTiltedShadowedWhiteArrowCodePoint = 0x1F8AB;
+const UChar32 kNAryWhiteVerticalBarCodePoint = 0x2AFF;
+}  // namespace
+
+namespace blink {
+
+class OpenTypeMathSupportTest : public testing::Test {
+ protected:
+  void SetUp() override {
+    font_description.SetComputedSize(10.0);
+    font = Font(font_description);
+  }
+
+  void TearDown() override {}
+
+  Font CreateMathFont(const String& name, float size = 1000) {
+    FontDescription::VariantLigatures ligatures;
+    return blink::test::CreateTestFont(
+        "MathTestFont",
+        blink::test::BlinkWebTestsFontsTestDataPath(String("math/") + name),
+        size, &ligatures);
+  }
+
+  bool HasMathData(const String& name) {
+    return OpenTypeMathSupport::HasMathData(
+        CreateMathFont(name).PrimaryFont()->PlatformData().GetHarfBuzzFace());
+  }
+
+  base::Optional<float> MathConstant(
+      const String& name,
+      OpenTypeMathSupport::MathConstants constant) {
+    Font math = CreateMathFont(name);
+    return OpenTypeMathSupport::MathConstant(
+        math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), constant);
+  }
+
+  FontDescription font_description;
+  Font font;
+};
+
+TEST_F(OpenTypeMathSupportTest, HasMathData) {
+  // Null parameter.
+  EXPECT_FALSE(OpenTypeMathSupport::HasMathData(nullptr));
+
+  // Font without a MATH table.
+  EXPECT_FALSE(HasMathData("math-text.woff"));
+
+  // Font with a MATH table.
+  EXPECT_TRUE(HasMathData("axisheight5000-verticalarrow14000.woff"));
+}
+
+TEST_F(OpenTypeMathSupportTest, MathConstantNullOpt) {
+  Font math_text = CreateMathFont("math-text.woff");
+
+  for (int i = OpenTypeMathSupport::MathConstants::kScriptPercentScaleDown;
+       i <=
+       OpenTypeMathSupport::MathConstants::kRadicalDegreeBottomRaisePercent;
+       i++) {
+    auto math_constant = static_cast<OpenTypeMathSupport::MathConstants>(i);
+
+    // Null parameter.
+    EXPECT_FALSE(OpenTypeMathSupport::MathConstant(nullptr, math_constant));
+
+    // Font without a MATH table.
+    EXPECT_FALSE(OpenTypeMathSupport::MathConstant(
+        math_text.PrimaryFont()->PlatformData().GetHarfBuzzFace(),
+        math_constant));
+  }
+}
+
+// See third_party/blink/web_tests/external/wpt/mathml/tools/percentscaledown.py
+TEST_F(OpenTypeMathSupportTest, MathConstantPercentScaleDown) {
+  {
+    auto result = MathConstant(
+        "scriptpercentscaledown80-scriptscriptpercentscaledown0.woff",
+        OpenTypeMathSupport::MathConstants::kScriptPercentScaleDown);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, .8);
+  }
+
+  {
+    auto result = MathConstant(
+        "scriptpercentscaledown0-scriptscriptpercentscaledown40.woff",
+        OpenTypeMathSupport::MathConstants::kScriptScriptPercentScaleDown);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, .4);
+  }
+}
+
+// See third_party/blink/web_tests/external/wpt/mathml/tools/fractions.py
+TEST_F(OpenTypeMathSupportTest, MathConstantFractions) {
+  {
+    auto result = MathConstant(
+        "fraction-numeratorshiftup11000-axisheight1000-rulethickness1000.woff",
+        OpenTypeMathSupport::MathConstants::kFractionNumeratorShiftUp);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 11000);
+  }
+
+  {
+    auto result = MathConstant(
+        "fraction-numeratordisplaystyleshiftup2000-axisheight1000-"
+        "rulethickness1000.woff",
+        OpenTypeMathSupport::MathConstants::
+            kFractionNumeratorDisplayStyleShiftUp);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 2000);
+  }
+
+  {
+    auto result = MathConstant(
+        "fraction-denominatorshiftdown3000-axisheight1000-rulethickness1000."
+        "woff",
+        OpenTypeMathSupport::MathConstants::kFractionDenominatorShiftDown);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 3000);
+  }
+
+  {
+    auto result = MathConstant(
+        "fraction-denominatordisplaystyleshiftdown6000-axisheight1000-"
+        "rulethickness1000.woff",
+        OpenTypeMathSupport::MathConstants::
+            kFractionDenominatorDisplayStyleShiftDown);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 6000);
+  }
+
+  {
+    auto result = MathConstant(
+        "fraction-numeratorgapmin9000-rulethickness1000.woff",
+        OpenTypeMathSupport::MathConstants::kFractionNumeratorGapMin);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 9000);
+  }
+
+  {
+    auto result = MathConstant(
+        "fraction-numeratordisplaystylegapmin8000-rulethickness1000.woff",
+        OpenTypeMathSupport::MathConstants::kFractionNumDisplayStyleGapMin);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 8000);
+  }
+
+  {
+    auto result = MathConstant(
+        "fraction-rulethickness10000.woff",
+        OpenTypeMathSupport::MathConstants::kFractionRuleThickness);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 10000);
+  }
+
+  {
+    auto result = MathConstant(
+        "fraction-denominatorgapmin4000-rulethickness1000.woff",
+        OpenTypeMathSupport::MathConstants::kFractionDenominatorGapMin);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 4000);
+  }
+
+  {
+    auto result = MathConstant(
+        "fraction-denominatordisplaystylegapmin5000-rulethickness1000.woff",
+        OpenTypeMathSupport::MathConstants::kFractionDenomDisplayStyleGapMin);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 5000);
+  }
+}
+
+// See third_party/blink/web_tests/external/wpt/mathml/tools/radicals.py
+TEST_F(OpenTypeMathSupportTest, MathConstantRadicals) {
+  {
+    auto result = MathConstant(
+        "radical-degreebottomraisepercent25-rulethickness1000.woff",
+        OpenTypeMathSupport::MathConstants::kRadicalDegreeBottomRaisePercent);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, .25);
+  }
+
+  {
+    auto result =
+        MathConstant("radical-verticalgap6000-rulethickness1000.woff",
+                     OpenTypeMathSupport::MathConstants::kRadicalVerticalGap);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 6000);
+  }
+
+  {
+    auto result = MathConstant(
+        "radical-displaystyleverticalgap7000-rulethickness1000.woff",
+        OpenTypeMathSupport::MathConstants::kRadicalDisplayStyleVerticalGap);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 7000);
+  }
+
+  {
+    auto result =
+        MathConstant("radical-rulethickness8000.woff",
+                     OpenTypeMathSupport::MathConstants::kRadicalRuleThickness);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 8000);
+  }
+
+  {
+    auto result =
+        MathConstant("radical-extraascender3000-rulethickness1000.woff",
+                     OpenTypeMathSupport::MathConstants::kRadicalExtraAscender);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 3000);
+  }
+
+  {
+    auto result = MathConstant(
+        "radical-kernbeforedegree4000-rulethickness1000.woff",
+        OpenTypeMathSupport::MathConstants::kRadicalKernBeforeDegree);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, 4000);
+  }
+
+  {
+    auto result = MathConstant(
+        "radical-kernafterdegreeminus5000-rulethickness1000.woff",
+        OpenTypeMathSupport::MathConstants::kRadicalKernAfterDegree);
+    EXPECT_TRUE(result);
+    EXPECT_FLOAT_EQ(*result, -5000);
+  }
+}
+
+TEST_F(OpenTypeMathSupportTest, MathVariantsWithoutTable) {
+  Font math = CreateMathFont("math-text.woff");
+  auto glyph = math.PrimaryFont()->GlyphForCharacter('A');
+
+  // Horizontal variants.
+  {
+    auto variants = OpenTypeMathSupport::GetGlyphVariantRecords(
+        math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), glyph,
+        OpenTypeMathStretchData::StretchAxis::Horizontal);
+    EXPECT_EQ(variants.size(), 1u);
+    EXPECT_EQ(variants[0], glyph);
+  }
+
+  // Vertical variants.
+  {
+    auto variants = OpenTypeMathSupport::GetGlyphVariantRecords(
+        math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), glyph,
+        OpenTypeMathStretchData::StretchAxis::Vertical);
+    EXPECT_EQ(variants.size(), 1u);
+    EXPECT_EQ(variants[0], glyph);
+  }
+
+  // Horizontal parts.
+  {
+    auto parts = OpenTypeMathSupport::GetGlyphPartRecords(
+        math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), glyph,
+        OpenTypeMathStretchData::StretchAxis::Horizontal);
+    EXPECT_TRUE(parts.IsEmpty());
+  }
+
+  // // Vertical parts.
+  {
+    auto parts = OpenTypeMathSupport::GetGlyphPartRecords(
+        math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), glyph,
+        OpenTypeMathStretchData::StretchAxis::Vertical);
+    EXPECT_TRUE(parts.IsEmpty());
+  }
+}
+
+TEST_F(OpenTypeMathSupportTest, MathVariantsWithTable) {
+  // operators.woff contains stretchy operators from the MathML operator
+  // dictionary (including left and over braces) represented by squares.
+  // It also contains glyphs h0, h1, h2, h3 and v0, v1, v2, v3 that are
+  // respectively horizontal and vertical rectangles of increasing size.
+  // The MathVariants table contains the following data for horizontal
+  // (respectively vertical) operators:
+  // - Glyph variants: h0, h1, h2, h3 (respectively v0, v1, v2, v3).
+  // - Glyph parts: non-extender h2 and extender h1 (respectively v2 and v1).
+  // For details, see createSizeVariants() and createStretchy() from
+  // third_party/blink/web_tests/external/wpt/mathml/tools/operator-dictionary.py
+
+  Font math = CreateMathFont("operators.woff");
+  auto left_brace = math.PrimaryFont()->GlyphForCharacter(kLeftBraceCodePoint);
+  auto over_brace = math.PrimaryFont()->GlyphForCharacter(kOverBraceCodePoint);
+
+  // Calculate glyph indices from the last unicode character in the font.
+  // TODO(https://crbug.com/1057596): Find a better way to access these glyph
+  // indices.
+  auto v0 = math.PrimaryFont()->GlyphForCharacter(
+                kRightwardsFrontTiltedShadowedWhiteArrowCodePoint) +
+            1;
+  auto h0 = v0 + 1;
+  auto v1 = h0 + 1;
+  auto h1 = v1 + 1;
+  auto v2 = h1 + 1;
+  auto h2 = v2 + 1;
+  auto v3 = h2 + 1;
+  auto h3 = v3 + 1;
+
+  // Vertical variants for vertical operator.
+  {
+    auto variants = OpenTypeMathSupport::GetGlyphVariantRecords(
+        math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), left_brace,
+        OpenTypeMathStretchData::StretchAxis::Vertical);
+    EXPECT_EQ(variants.size(), 5u);
+    EXPECT_EQ(variants[0], left_brace);
+    EXPECT_EQ(variants[1], v0);
+    EXPECT_EQ(variants[2], v1);
+    EXPECT_EQ(variants[3], v2);
+    EXPECT_EQ(variants[4], v3);
+  }
+
+  // Horizontal variants for vertical operator.
+  {
+    auto variants = OpenTypeMathSupport::GetGlyphVariantRecords(
+        math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), left_brace,
+        OpenTypeMathStretchData::StretchAxis::Horizontal);
+    EXPECT_EQ(variants.size(), 1u);
+    EXPECT_EQ(variants[0], left_brace);
+  }
+
+  // Horizontal variants for horizontal operator.
+  {
+    auto variants = OpenTypeMathSupport::GetGlyphVariantRecords(
+        math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), over_brace,
+        OpenTypeMathStretchData::StretchAxis::Horizontal);
+    EXPECT_EQ(variants.size(), 5u);
+    EXPECT_EQ(variants[0], over_brace);
+    EXPECT_EQ(variants[1], h0);
+    EXPECT_EQ(variants[2], h1);
+    EXPECT_EQ(variants[3], h2);
+    EXPECT_EQ(variants[4], h3);
+  }
+
+  // Vertical variants for horizontal operator.
+  {
+    auto variants = OpenTypeMathSupport::GetGlyphVariantRecords(
+        math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), over_brace,
+        OpenTypeMathStretchData::StretchAxis::Vertical);
+    EXPECT_EQ(variants.size(), 1u);
+    EXPECT_EQ(variants[0], over_brace);
+  }
+
+  // Vertical parts for vertical operator.
+  {
+    auto parts = OpenTypeMathSupport::GetGlyphPartRecords(
+        math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), left_brace,
+        OpenTypeMathStretchData::StretchAxis::Vertical);
+    EXPECT_EQ(parts.size(), 2u);
+    EXPECT_EQ(parts[0].glyph, v2);
+    EXPECT_FLOAT_EQ(parts[0].start_connector_length, 0);
+    EXPECT_FLOAT_EQ(parts[0].end_connector_length, 1000);
+    EXPECT_FLOAT_EQ(parts[0].full_advance, 3000);
+    EXPECT_EQ(parts[0].is_extender, false);
+    EXPECT_EQ(parts[1].glyph, v1);
+    EXPECT_FLOAT_EQ(parts[1].start_connector_length, 1000);
+    EXPECT_FLOAT_EQ(parts[1].end_connector_length, 1000);
+    EXPECT_FLOAT_EQ(parts[1].full_advance, 2000);
+    EXPECT_EQ(parts[1].is_extender, true);
+  }
+
+  // Horizontal parts for vertical operator.
+  {
+    auto parts = OpenTypeMathSupport::GetGlyphPartRecords(
+        math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), left_brace,
+        OpenTypeMathStretchData::StretchAxis::Horizontal);
+    EXPECT_TRUE(parts.IsEmpty());
+  }
+
+  // Horizontal parts for horizontal operator.
+  {
+    auto parts = OpenTypeMathSupport::GetGlyphPartRecords(
+        math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), over_brace,
+        OpenTypeMathStretchData::StretchAxis::Horizontal);
+
+    EXPECT_EQ(parts.size(), 2u);
+    EXPECT_EQ(parts[0].glyph, h2);
+    EXPECT_FLOAT_EQ(parts[0].start_connector_length, 0);
+    EXPECT_FLOAT_EQ(parts[0].end_connector_length, 1000);
+    EXPECT_FLOAT_EQ(parts[0].full_advance, 3000);
+    EXPECT_EQ(parts[0].is_extender, false);
+
+    EXPECT_EQ(parts[1].glyph, h1);
+    EXPECT_FLOAT_EQ(parts[1].start_connector_length, 1000);
+    EXPECT_FLOAT_EQ(parts[1].end_connector_length, 1000);
+    EXPECT_FLOAT_EQ(parts[1].full_advance, 2000);
+    EXPECT_EQ(parts[1].is_extender, true);
+  }
+
+  // Vertical parts for horizontal operator.
+  {
+    auto parts = OpenTypeMathSupport::GetGlyphPartRecords(
+        math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), over_brace,
+        OpenTypeMathStretchData::StretchAxis::Vertical);
+    EXPECT_TRUE(parts.IsEmpty());
+  }
+}
+
+// See third_party/blink/web_tests/external/wpt/mathml/tools/largeop.py
+TEST_F(OpenTypeMathSupportTest, MathItalicCorrection) {
+  {
+    Font math = CreateMathFont(
+        "largeop-displayoperatorminheight2000-2AFF-italiccorrection3000.woff");
+    Glyph base_glyph =
+        math.PrimaryFont()->GlyphForCharacter(kNAryWhiteVerticalBarCodePoint);
+
+    // Retrieve the glyph with italic correction.
+    Vector<OpenTypeMathStretchData::GlyphVariantRecord> variants =
+        OpenTypeMathSupport::GetGlyphVariantRecords(
+            math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), base_glyph,
+            OpenTypeMathStretchData::StretchAxis::Vertical);
+    EXPECT_EQ(variants.size(), 3u);
+    EXPECT_EQ(variants[0], base_glyph);
+    EXPECT_EQ(variants[1], base_glyph);
+    Glyph glyph_with_italic_correction = variants[2];
+
+    // MathItalicCorrection with a value.
+    base::Optional<float> glyph_with_italic_correction_value =
+        OpenTypeMathSupport::MathItalicCorrection(
+            math.PrimaryFont()->PlatformData().GetHarfBuzzFace(),
+            glyph_with_italic_correction);
+    EXPECT_TRUE(glyph_with_italic_correction_value);
+    EXPECT_FLOAT_EQ(*glyph_with_italic_correction_value, 3000);
+
+    // GetGlyphPartRecords does not set italic correction when there is no
+    // construction available.
+    float italic_correction = -1000;
+    Vector<OpenTypeMathStretchData::GlyphPartRecord> parts =
+        OpenTypeMathSupport::GetGlyphPartRecords(
+            math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), base_glyph,
+            OpenTypeMathStretchData::StretchAxis::Vertical, &italic_correction);
+    EXPECT_TRUE(parts.IsEmpty());
+    EXPECT_FLOAT_EQ(italic_correction, -1000);
+  }
+
+  {
+    Font math = CreateMathFont(
+        "largeop-displayoperatorminheight7000-2AFF-italiccorrection5000.woff");
+    Glyph base_glyph =
+        math.PrimaryFont()->GlyphForCharacter(kNAryWhiteVerticalBarCodePoint);
+
+    // OpenTypeMathSupport::GetGlyphPartRecords sets italic correction.
+    float italic_correction = -1000;
+    Vector<OpenTypeMathStretchData::GlyphPartRecord> parts =
+        OpenTypeMathSupport::GetGlyphPartRecords(
+            math.PrimaryFont()->PlatformData().GetHarfBuzzFace(), base_glyph,
+            OpenTypeMathStretchData::StretchAxis::Vertical, &italic_correction);
+    EXPECT_EQ(parts.size(), 3u);
+    EXPECT_FLOAT_EQ(italic_correction, 5000);
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/opentype/open_type_types.h b/third_party/blink/renderer/platform/fonts/opentype/open_type_types.h
index d605c1768973..12c90c9b1741 100644
--- a/third_party/blink/renderer/platform/fonts/opentype/open_type_types.h
+++ b/third_party/blink/renderer/platform/fonts/opentype/open_type_types.h
@@ -29,7 +29,7 @@
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 
 namespace blink {
-namespace OpenType {
+namespace open_type {
 
 struct Int16 {
   DISALLOW_NEW();
@@ -101,6 +101,6 @@ struct TableBase {
   }
 };
 
-}  // namespace OpenType
+}  // namespace open_type
 }  // namespace blink
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_OPENTYPE_OPEN_TYPE_TYPES_H_
diff --git a/third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data.cc b/third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data.cc
index 6acc43a187dc..611775a5d528 100644
--- a/third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data.cc
+++ b/third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data.cc
@@ -24,15 +24,16 @@
 
 #include "third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data.h"
 
-#include "SkTypeface.h"
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/platform/fonts/opentype/open_type_types.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
 #include "third_party/blink/renderer/platform/fonts/skia/skia_text_metrics.h"
 #include "third_party/blink/renderer/platform/geometry/float_rect.h"
+#include "third_party/blink/renderer/platform/wtf/std_lib_extras.h"
+#include "third_party/skia/include/core/SkTypeface.h"
 
 namespace blink {
-namespace OpenType {
+namespace open_type {
 
 // The input characters are big-endian (first is most significant).
 #define OT_MAKE_TAG(ch1, ch2, ch3, ch4)                    \
@@ -49,46 +50,46 @@ const SkFontTableTag kVORGTag = OT_MAKE_TAG('V', 'O', 'R', 'G');
 
 struct HheaTable {
   DISALLOW_NEW();
-  OpenType::Fixed version;
-  OpenType::Int16 ascender;
-  OpenType::Int16 descender;
-  OpenType::Int16 line_gap;
-  OpenType::Int16 advance_width_max;
-  OpenType::Int16 min_left_side_bearing;
-  OpenType::Int16 min_right_side_bearing;
-  OpenType::Int16 x_max_extent;
-  OpenType::Int16 caret_slope_rise;
-  OpenType::Int16 caret_slope_run;
-  OpenType::Int16 caret_offset;
-  OpenType::Int16 reserved[4];
-  OpenType::Int16 metric_data_format;
-  OpenType::UInt16 number_of_h_metrics;
+  open_type::Fixed version;
+  open_type::Int16 ascender;
+  open_type::Int16 descender;
+  open_type::Int16 line_gap;
+  open_type::Int16 advance_width_max;
+  open_type::Int16 min_left_side_bearing;
+  open_type::Int16 min_right_side_bearing;
+  open_type::Int16 x_max_extent;
+  open_type::Int16 caret_slope_rise;
+  open_type::Int16 caret_slope_run;
+  open_type::Int16 caret_offset;
+  open_type::Int16 reserved[4];
+  open_type::Int16 metric_data_format;
+  open_type::UInt16 number_of_h_metrics;
 };
 
 struct VheaTable {
   DISALLOW_NEW();
-  OpenType::Fixed version;
-  OpenType::Int16 ascent;
-  OpenType::Int16 descent;
-  OpenType::Int16 line_gap;
-  OpenType::Int16 advance_height_max;
-  OpenType::Int16 min_top_side_bearing;
-  OpenType::Int16 min_bottom_side_bearing;
-  OpenType::Int16 y_max_extent;
-  OpenType::Int16 caret_slope_rise;
-  OpenType::Int16 caret_slope_run;
-  OpenType::Int16 caret_offset;
-  OpenType::Int16 reserved[4];
-  OpenType::Int16 metric_data_format;
-  OpenType::UInt16 num_of_long_ver_metrics;
+  open_type::Fixed version;
+  open_type::Int16 ascent;
+  open_type::Int16 descent;
+  open_type::Int16 line_gap;
+  open_type::Int16 advance_height_max;
+  open_type::Int16 min_top_side_bearing;
+  open_type::Int16 min_bottom_side_bearing;
+  open_type::Int16 y_max_extent;
+  open_type::Int16 caret_slope_rise;
+  open_type::Int16 caret_slope_run;
+  open_type::Int16 caret_offset;
+  open_type::Int16 reserved[4];
+  open_type::Int16 metric_data_format;
+  open_type::UInt16 num_of_long_ver_metrics;
 };
 
 struct HmtxTable {
   DISALLOW_NEW();
   struct Entry {
     DISALLOW_NEW();
-    OpenType::UInt16 advance_width;
-    OpenType::Int16 lsb;
+    open_type::UInt16 advance_width;
+    open_type::Int16 lsb;
   } entries[1];
 };
 
@@ -96,21 +97,21 @@ struct VmtxTable {
   DISALLOW_NEW();
   struct Entry {
     DISALLOW_NEW();
-    OpenType::UInt16 advance_height;
-    OpenType::Int16 top_side_bearing;
+    open_type::UInt16 advance_height;
+    open_type::Int16 top_side_bearing;
   } entries[1];
 };
 
 struct VORGTable {
   DISALLOW_NEW();
-  OpenType::UInt16 major_version;
-  OpenType::UInt16 minor_version;
-  OpenType::Int16 default_vert_origin_y;
-  OpenType::UInt16 num_vert_origin_y_metrics;
+  open_type::UInt16 major_version;
+  open_type::UInt16 minor_version;
+  open_type::Int16 default_vert_origin_y;
+  open_type::UInt16 num_vert_origin_y_metrics;
   struct VertOriginYMetrics {
     DISALLOW_NEW();
-    OpenType::UInt16 glyph_index;
-    OpenType::Int16 vert_origin_y;
+    open_type::UInt16 glyph_index;
+    open_type::Int16 vert_origin_y;
   } vert_origin_y_metrics[1];
 
   size_t RequiredSize() const {
@@ -121,7 +122,7 @@ struct VORGTable {
 
 #pragma pack()
 
-}  // namespace OpenType
+}  // namespace open_type
 
 OpenTypeVerticalData::OpenTypeVerticalData(sk_sp<SkTypeface> typeface)
     : default_vert_origin_y_(0),
@@ -135,7 +136,7 @@ static void CopyOpenTypeTable(sk_sp<SkTypeface> typeface,
                               SkFontTableTag tag,
                               Vector<char>& destination) {
   const size_t table_size = typeface->getTableSize(tag);
-  destination.resize(table_size);
+  destination.resize(SafeCast<wtf_size_t>(table_size));
   if (table_size) {
     typeface->getTableData(tag, 0, table_size, destination.data());
   }
@@ -145,9 +146,9 @@ void OpenTypeVerticalData::LoadMetrics(sk_sp<SkTypeface> typeface) {
   // Load hhea and hmtx to get x-component of vertical origins.
   // If these tables are missing, it's not an OpenType font.
   Vector<char> buffer;
-  CopyOpenTypeTable(typeface, OpenType::kHheaTag, buffer);
-  const OpenType::HheaTable* hhea =
-      OpenType::ValidateTable<OpenType::HheaTable>(buffer);
+  CopyOpenTypeTable(typeface, open_type::kHheaTag, buffer);
+  const open_type::HheaTable* hhea =
+      open_type::ValidateTable<open_type::HheaTable>(buffer);
   if (!hhea)
     return;
   uint16_t count_hmtx_entries = hhea->number_of_h_metrics;
@@ -156,9 +157,10 @@ void OpenTypeVerticalData::LoadMetrics(sk_sp<SkTypeface> typeface) {
     return;
   }
 
-  CopyOpenTypeTable(typeface, OpenType::kHmtxTag, buffer);
-  const OpenType::HmtxTable* hmtx =
-      OpenType::ValidateTable<OpenType::HmtxTable>(buffer, count_hmtx_entries);
+  CopyOpenTypeTable(typeface, open_type::kHmtxTag, buffer);
+  const open_type::HmtxTable* hmtx =
+      open_type::ValidateTable<open_type::HmtxTable>(buffer,
+                                                     count_hmtx_entries);
   if (!hmtx) {
     DLOG(ERROR) << "hhea exists but hmtx does not (or broken)";
     return;
@@ -169,9 +171,9 @@ void OpenTypeVerticalData::LoadMetrics(sk_sp<SkTypeface> typeface) {
 
   // Load vhea first. This table is required for fonts that support vertical
   // flow.
-  CopyOpenTypeTable(typeface, OpenType::kVheaTag, buffer);
-  const OpenType::VheaTable* vhea =
-      OpenType::ValidateTable<OpenType::VheaTable>(buffer);
+  CopyOpenTypeTable(typeface, open_type::kVheaTag, buffer);
+  const open_type::VheaTable* vhea =
+      open_type::ValidateTable<open_type::VheaTable>(buffer);
   if (!vhea)
     return;
   uint16_t count_vmtx_entries = vhea->num_of_long_ver_metrics;
@@ -181,9 +183,9 @@ void OpenTypeVerticalData::LoadMetrics(sk_sp<SkTypeface> typeface) {
   }
 
   // Load VORG. This table is optional.
-  CopyOpenTypeTable(typeface, OpenType::kVORGTag, buffer);
-  const OpenType::VORGTable* vorg =
-      OpenType::ValidateTable<OpenType::VORGTable>(buffer);
+  CopyOpenTypeTable(typeface, open_type::kVORGTag, buffer);
+  const open_type::VORGTable* vorg =
+      open_type::ValidateTable<open_type::VORGTable>(buffer);
   if (vorg && buffer.size() >= vorg->RequiredSize()) {
     default_vert_origin_y_ = vorg->default_vert_origin_y;
     uint16_t count_vert_origin_y_metrics = vorg->num_vert_origin_y_metrics;
@@ -192,7 +194,7 @@ void OpenTypeVerticalData::LoadMetrics(sk_sp<SkTypeface> typeface) {
       vert_origin_y_.Set(0, default_vert_origin_y_);
     } else {
       for (uint16_t i = 0; i < count_vert_origin_y_metrics; ++i) {
-        const OpenType::VORGTable::VertOriginYMetrics& metrics =
+        const open_type::VORGTable::VertOriginYMetrics& metrics =
             vorg->vert_origin_y_metrics[i];
         vert_origin_y_.Set(metrics.glyph_index, metrics.vert_origin_y);
       }
@@ -201,9 +203,10 @@ void OpenTypeVerticalData::LoadMetrics(sk_sp<SkTypeface> typeface) {
 
   // Load vmtx then. This table is required for fonts that support vertical
   // flow.
-  CopyOpenTypeTable(typeface, OpenType::kVmtxTag, buffer);
-  const OpenType::VmtxTable* vmtx =
-      OpenType::ValidateTable<OpenType::VmtxTable>(buffer, count_vmtx_entries);
+  CopyOpenTypeTable(typeface, open_type::kVmtxTag, buffer);
+  const open_type::VmtxTable* vmtx =
+      open_type::ValidateTable<open_type::VmtxTable>(buffer,
+                                                     count_vmtx_entries);
   if (!vmtx) {
     DLOG(ERROR) << "vhea exists but vmtx does not (or broken)";
     return;
@@ -217,21 +220,21 @@ void OpenTypeVerticalData::LoadMetrics(sk_sp<SkTypeface> typeface) {
   if (HasVORG())
     return;
 
-  size_t size_extra =
-      buffer.size() - sizeof(OpenType::VmtxTable::Entry) * count_vmtx_entries;
-  if (size_extra % sizeof(OpenType::Int16)) {
+  wtf_size_t size_extra =
+      buffer.size() - sizeof(open_type::VmtxTable::Entry) * count_vmtx_entries;
+  if (size_extra % sizeof(open_type::Int16)) {
     DLOG(ERROR) << "vmtx has incorrect tsb count";
     return;
   }
-  size_t count_top_side_bearings =
-      count_vmtx_entries + size_extra / sizeof(OpenType::Int16);
+  wtf_size_t count_top_side_bearings =
+      count_vmtx_entries + size_extra / sizeof(open_type::Int16);
   top_side_bearings_.resize(count_top_side_bearings);
-  size_t i;
+  wtf_size_t i;
   for (i = 0; i < count_vmtx_entries; ++i)
     top_side_bearings_[i] = vmtx->entries[i].top_side_bearing;
   if (i < count_top_side_bearings) {
-    const OpenType::Int16* p_top_side_bearings_extra =
-        reinterpret_cast<const OpenType::Int16*>(
+    const open_type::Int16* p_top_side_bearings_extra =
+        reinterpret_cast<const open_type::Int16*>(
             &vmtx->entries[count_vmtx_entries]);
     for (; i < count_top_side_bearings; ++i, ++p_top_side_bearings_extra)
       top_side_bearings_[i] = *p_top_side_bearings_extra;
@@ -247,7 +250,7 @@ void OpenTypeVerticalData::SetScaleAndFallbackMetrics(float size_per_unit,
 }
 
 float OpenTypeVerticalData::AdvanceHeight(Glyph glyph) const {
-  size_t count_heights = advance_heights_.size();
+  wtf_size_t count_heights = advance_heights_.size();
   if (count_heights) {
     uint16_t advance_f_unit =
         advance_heights_[glyph < count_heights ? glyph : count_heights - 1];
@@ -260,14 +263,14 @@ float OpenTypeVerticalData::AdvanceHeight(Glyph glyph) const {
 }
 
 void OpenTypeVerticalData::GetVerticalTranslationsForGlyphs(
-    const SkPaint& paint,
+    const SkFont& font,
     const Glyph* glyphs,
     size_t count,
     float* out_xy_array) const {
-  size_t count_widths = advance_widths_.size();
+  wtf_size_t count_widths = advance_widths_.size();
   DCHECK_GT(count_widths, 0u);
   bool use_vorg = HasVORG();
-  size_t count_top_side_bearings = top_side_bearings_.size();
+  wtf_size_t count_top_side_bearings = top_side_bearings_.size();
   float default_vert_origin_y = std::numeric_limits<float>::quiet_NaN();
   for (float *end = &(out_xy_array[count * 2]); out_xy_array != end;
        ++glyphs, out_xy_array += 2) {
@@ -301,7 +304,7 @@ void OpenTypeVerticalData::GetVerticalTranslationsForGlyphs(
       float top_side_bearing = top_side_bearing_f_unit * size_per_unit_;
 
       SkRect skiaBounds;
-      SkiaTextMetrics(&paint).GetSkiaBoundsForGlyph(glyph, &skiaBounds);
+      SkFontGetBoundsForGlyph(font, glyph, &skiaBounds);
       FloatRect bounds(skiaBounds);
       out_xy_array[1] = bounds.Y() - top_side_bearing;
       continue;
diff --git a/third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data.h b/third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data.h
index 109609279dff..84b6ff362930 100644
--- a/third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data.h
+++ b/third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data.h
@@ -28,19 +28,21 @@
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/platform/fonts/glyph.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/hash_map.h"
 #include "third_party/blink/renderer/platform/wtf/ref_counted.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
 
-#include <SkPaint.h>
-#include <SkRefCnt.h>
-#include <SkTypeface.h>
+class SkFont;
 
 namespace blink {
 
 class PLATFORM_EXPORT OpenTypeVerticalData
     : public RefCounted<OpenTypeVerticalData> {
+  USING_FAST_MALLOC(OpenTypeVerticalData);
+
  public:
   static scoped_refptr<OpenTypeVerticalData> CreateUnscaled(
       sk_sp<SkTypeface> typeface) {
@@ -55,7 +57,7 @@ class PLATFORM_EXPORT OpenTypeVerticalData
   bool HasVerticalMetrics() const { return !advance_heights_.IsEmpty(); }
   float AdvanceHeight(Glyph) const;
 
-  void GetVerticalTranslationsForGlyphs(const SkPaint&,
+  void GetVerticalTranslationsForGlyphs(const SkFont&,
                                         const Glyph*,
                                         size_t,
                                         float* out_xy_array) const;
diff --git a/third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data_test.cc b/third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data_test.cc
index cd03dc5d3490..bdb7d7bc8456 100644
--- a/third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data_test.cc
+++ b/third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data_test.cc
@@ -28,9 +28,9 @@
 
 namespace blink {
 
-struct TestTable : OpenType::TableBase {
-  OpenType::Fixed version;
-  OpenType::Int16 ascender;
+struct TestTable : open_type::TableBase {
+  open_type::Fixed version;
+  open_type::Int16 ascender;
 
   template <typename T>
   const T* ValidateOffset(const Vector<char>& buffer, uint16_t offset) const {
@@ -40,21 +40,21 @@ struct TestTable : OpenType::TableBase {
 
 TEST(OpenTypeVerticalDataTest, ValidateTableTest) {
   Vector<char> buffer(sizeof(TestTable));
-  const TestTable* table = OpenType::ValidateTable<TestTable>(buffer);
+  const TestTable* table = open_type::ValidateTable<TestTable>(buffer);
   EXPECT_TRUE(table);
 
   buffer = Vector<char>(sizeof(TestTable) - 1);
-  table = OpenType::ValidateTable<TestTable>(buffer);
+  table = open_type::ValidateTable<TestTable>(buffer);
   EXPECT_FALSE(table);
 
   buffer = Vector<char>(sizeof(TestTable) + 1);
-  table = OpenType::ValidateTable<TestTable>(buffer);
+  table = open_type::ValidateTable<TestTable>(buffer);
   EXPECT_TRUE(table);
 }
 
 TEST(OpenTypeVerticalDataTest, ValidateOffsetTest) {
   Vector<char> buffer(sizeof(TestTable));
-  const TestTable* table = OpenType::ValidateTable<TestTable>(buffer);
+  const TestTable* table = open_type::ValidateTable<TestTable>(buffer);
   ASSERT_TRUE(table);
 
   // Test overflow
diff --git a/third_party/blink/renderer/platform/fonts/opentype/variable_axes_names.cc b/third_party/blink/renderer/platform/fonts/opentype/variable_axes_names.cc
new file mode 100644
index 000000000000..e237bddd9d2b
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/opentype/variable_axes_names.cc
@@ -0,0 +1,67 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/opentype/variable_axes_names.h"
+
+#include "third_party/harfbuzz-ng/utils/hb_scoped.h"
+#include "third_party/skia/include/core/SkStream.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+// clang-format off
+#include <hb.h>
+#include <hb-ot.h>
+// clang-format on
+
+namespace blink {
+
+Vector<VariationAxis> VariableAxesNames::GetVariationAxes(
+    sk_sp<SkTypeface> typeface) {
+  Vector<VariationAxis> output;
+  std::unique_ptr<SkStreamAsset> stream = typeface->openStream(nullptr);
+  if (!stream)
+    return output;
+  sk_sp<SkData> sk_data =
+      SkData::MakeFromStream(stream.get(), stream->getLength());
+  HbScoped<hb_blob_t> blob(hb_blob_create(
+      reinterpret_cast<const char*>(sk_data->bytes()), sk_data->size(),
+      HB_MEMORY_MODE_READONLY, nullptr, nullptr));
+  HbScoped<hb_face_t> face(hb_face_create(blob.get(), 0));
+  unsigned axes_count = hb_ot_var_get_axis_count(face.get());
+  std::unique_ptr<hb_ot_var_axis_info_t[]> axes =
+      std::make_unique<hb_ot_var_axis_info_t[]>(axes_count);
+  hb_ot_var_get_axis_infos(face.get(), 0, &axes_count, axes.get());
+
+  for (unsigned i = 0; i < axes_count; i++) {
+    VariationAxis axis;
+
+    // HB_LANGUAGE_INVALID fetches the default English string according
+    // to HarfBuzz documentation. If the buffer is nullptr, it returns
+    // the length of the name without writing to the buffer.
+    unsigned name_length = hb_ot_name_get_utf16(
+        face.get(), axes[i].name_id, HB_LANGUAGE_INVALID, nullptr, nullptr);
+
+    axis.name = "";
+    if (name_length) {
+      unsigned buffer_length = name_length + 1;
+      std::unique_ptr<char16_t[]> buffer =
+          std::make_unique<char16_t[]>(buffer_length);
+      hb_ot_name_get_utf16(face.get(), axes[i].name_id, HB_LANGUAGE_INVALID,
+                           &buffer_length,
+                           reinterpret_cast<uint16_t*>(buffer.get()));
+      axis.name = String(buffer.get());
+    }
+
+    std::array<char, 4> tag = {HB_UNTAG(axes[i].tag)};
+
+    axis.tag = String(tag.data(), tag.size());
+    axis.minValue = axes[i].min_value;
+    axis.maxValue = axes[i].max_value;
+    axis.defaultValue = axes[i].default_value;
+
+    output.push_back(axis);
+  }
+  return output;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/opentype/variable_axes_names.h b/third_party/blink/renderer/platform/fonts/opentype/variable_axes_names.h
new file mode 100644
index 000000000000..f15008cf940f
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/opentype/variable_axes_names.h
@@ -0,0 +1,33 @@
+
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_OPENTYPE_VARIABLE_AXES_NAMES_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_OPENTYPE_VARIABLE_AXES_NAMES_H_
+
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+class SkTypeface;
+
+namespace blink {
+
+struct VariationAxis {
+  String tag;
+  String name;
+  double minValue;
+  double maxValue;
+  double defaultValue;
+};
+
+class PLATFORM_EXPORT VariableAxesNames {
+ public:
+  static Vector<VariationAxis> GetVariationAxes(sk_sp<SkTypeface> typeface);
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_OPENTYPE_VARIABLE_AXES_NAMES_H_
diff --git a/third_party/blink/renderer/platform/fonts/opentype/variable_axes_names_test.cc b/third_party/blink/renderer/platform/fonts/opentype/variable_axes_names_test.cc
new file mode 100644
index 000000000000..deb310b72a0d
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/opentype/variable_axes_names_test.cc
@@ -0,0 +1,35 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/opentype/variable_axes_names.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/testing/unit_test_helpers.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace blink {
+
+TEST(VariableAxesNamesTest, TestVariableAxes) {
+  String file_path = blink::test::BlinkWebTestsDir() +
+                     "/third_party/Homecomputer/Sixtyfour.ttf";
+  sk_sp<SkTypeface> typeface =
+      SkTypeface::MakeFromFile(file_path.Utf8().c_str(), 0);
+  Vector<VariationAxis> axes = VariableAxesNames::GetVariationAxes(typeface);
+  EXPECT_EQ(axes.size(), (unsigned)2);
+  VariationAxis axis1 = axes.at(0);
+  EXPECT_EQ(axis1.name, "Weight");
+  EXPECT_EQ(axis1.tag, "wght");
+  EXPECT_EQ(axis1.minValue, 200);
+  EXPECT_EQ(axis1.maxValue, 900);
+  EXPECT_EQ(axis1.defaultValue, 200);
+  VariationAxis axis2 = axes.at(1);
+  EXPECT_EQ(axis2.name, "Width");
+  EXPECT_EQ(axis2.tag, "wdth");
+  EXPECT_EQ(axis2.minValue, 100);
+  EXPECT_EQ(axis2.maxValue, 200);
+  EXPECT_EQ(axis2.defaultValue, 100);
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/orientation_iterator.h b/third_party/blink/renderer/platform/fonts/orientation_iterator.h
index 4ec912cfbc5e..f0a6de872b6d 100644
--- a/third_party/blink/renderer/platform/fonts/orientation_iterator.h
+++ b/third_party/blink/renderer/platform/fonts/orientation_iterator.h
@@ -6,17 +6,17 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_ORIENTATION_ITERATOR_H_
 
 #include <memory>
+
+#include "base/macros.h"
 #include "third_party/blink/renderer/platform/fonts/font_orientation.h"
 #include "third_party/blink/renderer/platform/fonts/script_run_iterator.h"
 #include "third_party/blink/renderer/platform/fonts/utf16_text_iterator.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
-#include "third_party/blink/renderer/platform/wtf/noncopyable.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
 namespace blink {
 
 class PLATFORM_EXPORT OrientationIterator {
   USING_FAST_MALLOC(OrientationIterator);
-  WTF_MAKE_NONCOPYABLE(OrientationIterator);
 
  public:
   enum RenderOrientation {
@@ -35,6 +35,8 @@ class PLATFORM_EXPORT OrientationIterator {
   std::unique_ptr<UTF16TextIterator> utf16_iterator_;
   unsigned buffer_size_;
   bool at_end_;
+
+  DISALLOW_COPY_AND_ASSIGN(OrientationIterator);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/orientation_iterator_test.cc b/third_party/blink/renderer/platform/fonts/orientation_iterator_test.cc
index 52753c29b4e3..23f34ddf77dc 100644
--- a/third_party/blink/renderer/platform/fonts/orientation_iterator_test.cc
+++ b/third_party/blink/renderer/platform/fonts/orientation_iterator_test.cc
@@ -5,12 +5,13 @@
 #include "third_party/blink/renderer/platform/fonts/orientation_iterator.h"
 
 #include "testing/gtest/include/gtest/gtest.h"
-#include <string>
+
+#include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
 
 namespace blink {
 
 struct OrientationTestRun {
-  std::string text;
+  const char* const text;
   OrientationIterator::RenderOrientation code;
 };
 
@@ -27,10 +28,11 @@ struct OrientationExpectedRun {
 class OrientationIteratorTest : public testing::Test {
  protected:
   void CheckRuns(const Vector<OrientationTestRun>& runs) {
-    String text(g_empty_string16_bit);
+    StringBuilder text;
+    text.Ensure16Bit();
     Vector<OrientationExpectedRun> expect;
     for (auto& run : runs) {
-      text.append(String::FromUTF8(run.text.c_str()));
+      text.Append(String::FromUTF8(run.text));
       expect.push_back(OrientationExpectedRun(text.length(), run.code));
     }
     OrientationIterator orientation_iterator(text.Characters16(), text.length(),
@@ -42,7 +44,7 @@ class OrientationIteratorTest : public testing::Test {
                   const Vector<OrientationExpectedRun>& expect) {
     unsigned limit;
     OrientationIterator::RenderOrientation render_orientation;
-    unsigned long run_count = 0;
+    size_t run_count = 0;
     while (orientation_iterator->Consume(&limit, &render_orientation)) {
       ASSERT_LT(run_count, expect.size());
       ASSERT_EQ(expect[run_count].limit, limit);
diff --git a/third_party/blink/renderer/platform/fonts/script_run_iterator.cc b/third_party/blink/renderer/platform/fonts/script_run_iterator.cc
index ca054ad8f380..1ce5e3d3af3b 100644
--- a/third_party/blink/renderer/platform/fonts/script_run_iterator.cc
+++ b/third_party/blink/renderer/platform/fonts/script_run_iterator.cc
@@ -10,6 +10,26 @@
 
 namespace blink {
 
+namespace {
+
+// UScriptCode and OpenType script are not 1:1; specifically, both Hiragana and
+// Katakana map to 'kana' in OpenType. They will be mapped correctly in
+// HarfBuzz, but normalizing earlier helps to reduce splitting runs between
+// these scripts.
+// https://docs.microsoft.com/en-us/typography/opentype/spec/scripttags
+inline UScriptCode getScriptForOpenType(UChar32 ch, UErrorCode* status) {
+  UScriptCode script = uscript_getScript(ch, status);
+  if (UNLIKELY(U_FAILURE(*status)))
+    return script;
+  if (UNLIKELY(script == USCRIPT_KATAKANA ||
+               script == USCRIPT_KATAKANA_OR_HIRAGANA)) {
+    return USCRIPT_HIRAGANA;
+  }
+  return script;
+}
+
+}  // namespace
+
 typedef ScriptData::PairedBracketType PairedBracketType;
 
 constexpr int ScriptRunIterator::kMaxScriptCount;
@@ -27,6 +47,10 @@ void ICUScriptData::GetScripts(UChar32 ch, UScriptCodeList& dst) const {
   // regardless of the capacity passed to the call. So count can be greater
   // than dst->size(), if a later version of the unicode data has more
   // than kMaxScriptCount items.
+
+  // |uscript_getScriptExtensions| do not need to be collated to
+  // USCRIPT_HIRAGANA because when ScriptExtensions contains Kana, it contains
+  // Hira as well, and Hira is always before Kana.
   int count = uscript_getScriptExtensions(ch, &dst[0], dst.size(), &status);
   if (status == U_BUFFER_OVERFLOW_ERROR) {
     // Allow this, we'll just use what we have.
@@ -35,7 +59,7 @@ void ICUScriptData::GetScripts(UChar32 ch, UScriptCodeList& dst) const {
     count = dst.size();
     status = U_ZERO_ERROR;
   }
-  UScriptCode primary_script = uscript_getScript(ch, &status);
+  UScriptCode primary_script = getScriptForOpenType(ch, &status);
 
   if (U_FAILURE(status)) {
     DLOG(ERROR) << "Could not get icu script data: " << status << " for 0x"
@@ -76,7 +100,7 @@ void ICUScriptData::GetScripts(UChar32 ch, UScriptCodeList& dst) const {
     // Ignore common. Find the preferred script of the multiple scripts that
     // remain, and ensure it is at the head. Just keep swapping them in,
     // there aren't likely to be many.
-    for (size_t i = 1; i < dst.size(); ++i) {
+    for (wtf_size_t i = 1; i < dst.size(); ++i) {
       if (dst.at(0) == USCRIPT_LATIN || dst.at(i) < dst.at(0)) {
         std::swap(dst.at(0), dst.at(i));
       }
@@ -92,7 +116,7 @@ void ICUScriptData::GetScripts(UChar32 ch, UScriptCodeList& dst) const {
   // just sorted in alphabetic order.
   dst.push_back(dst.at(0));
   dst.at(0) = primary_script;
-  for (size_t i = 2; i < dst.size(); ++i) {
+  for (wtf_size_t i = 2; i < dst.size(); ++i) {
     if (dst.at(1) == USCRIPT_LATIN || dst.at(i) < dst.at(1)) {
       std::swap(dst.at(1), dst.at(i));
     }
@@ -115,7 +139,7 @@ const ICUScriptData* ICUScriptData::Instance() {
 }
 
 ScriptRunIterator::ScriptRunIterator(const UChar* text,
-                                     size_t length,
+                                     wtf_size_t length,
                                      const ScriptData* data)
     : text_(text),
       length_(length),
@@ -141,15 +165,15 @@ ScriptRunIterator::ScriptRunIterator(const UChar* text,
   }
 }
 
-ScriptRunIterator::ScriptRunIterator(const UChar* text, size_t length)
+ScriptRunIterator::ScriptRunIterator(const UChar* text, wtf_size_t length)
     : ScriptRunIterator(text, length, ICUScriptData::Instance()) {}
 
-bool ScriptRunIterator::Consume(unsigned& limit, UScriptCode& script) {
+bool ScriptRunIterator::Consume(unsigned* limit, UScriptCode* script) {
   if (current_set_.IsEmpty()) {
     return false;
   }
 
-  size_t pos;
+  wtf_size_t pos;
   UChar32 ch;
   while (Fetch(&pos, &ch)) {
     PairedBracketType paired_type = script_data_->GetPairedBracketType(ch);
@@ -164,16 +188,20 @@ bool ScriptRunIterator::Consume(unsigned& limit, UScriptCode& script) {
         break;
     }
     if (!MergeSets()) {
-      limit = pos;
-      script = ResolveCurrentScript();
-      FixupStack(script);
+      *limit = pos;
+      *script = ResolveCurrentScript();
+      // If the current character is an open bracket, do not assign the resolved
+      // script to it yet because it will belong to the next run.
+      const bool exclude_last =
+          paired_type == PairedBracketType::kBracketTypeOpen;
+      FixupStack(*script, exclude_last);
       current_set_ = *next_set_;
       return true;
     }
   }
 
-  limit = length_;
-  script = ResolveCurrentScript();
+  *limit = length_;
+  *script = ResolveCurrentScript();
   current_set_.clear();
   return true;
 }
@@ -190,22 +218,25 @@ void ScriptRunIterator::OpenBracket(UChar32 ch) {
 }
 
 void ScriptRunIterator::CloseBracket(UChar32 ch) {
-  if (brackets_.size() > 0) {
+  if (!brackets_.empty()) {
     UChar32 target = script_data_->GetPairedBracket(ch);
     for (auto it = brackets_.rbegin(); it != brackets_.rend(); ++it) {
       if (it->ch == target) {
         // Have a match, use open paren's resolved script.
         UScriptCode script = it->script;
-        next_set_->clear();
-        next_set_->push_back(script);
+        if (script != USCRIPT_COMMON) {
+          next_set_->clear();
+          next_set_->push_back(script);
+        }
 
         // And pop stack to this point.
-        int num_popped = std::distance(brackets_.rbegin(), it);
+        int num_popped =
+            static_cast<int>(std::distance(brackets_.rbegin(), it));
         // TODO: No resize operation in WTF::Deque?
         for (int i = 0; i < num_popped; ++i)
           brackets_.pop_back();
-        brackets_fixup_depth_ = std::max(static_cast<size_t>(0),
-                                         brackets_fixup_depth_ - num_popped);
+        brackets_fixup_depth_ = static_cast<wtf_size_t>(
+            std::max(0, static_cast<int>(brackets_fixup_depth_) - num_popped));
         return;
       }
     }
@@ -291,7 +322,8 @@ bool ScriptRunIterator::MergeSets() {
   }
 
   // Only change current if the run continues.
-  int written = std::distance(current_set_.begin(), current_write_it);
+  int written =
+      static_cast<int>(std::distance(current_set_.begin(), current_write_it));
   if (written > 0) {
     current_set_.resize(written);
     return true;
@@ -306,23 +338,30 @@ bool ScriptRunIterator::MergeSets() {
 // adjust it if the stack got overfull and open brackets were pushed off
 // the bottom. This sets the script of the fixup_depth topmost entries of the
 // stack to the resolved script.
-void ScriptRunIterator::FixupStack(UScriptCode resolved_script) {
-  if (brackets_fixup_depth_ > 0) {
-    if (brackets_fixup_depth_ > brackets_.size()) {
-      // Should never happen unless someone breaks the code.
-      DLOG(ERROR) << "Brackets fixup depth exceeds size of bracket vector.";
-      brackets_fixup_depth_ = brackets_.size();
-    }
-    auto it = brackets_.rbegin();
-    for (size_t i = 0; i < brackets_fixup_depth_; ++i) {
-      it->script = resolved_script;
-      ++it;
-    }
+void ScriptRunIterator::FixupStack(UScriptCode resolved_script,
+                                   bool exclude_last) {
+  wtf_size_t count = brackets_fixup_depth_;
+  if (count <= 0)
+    return;
+  if (count > brackets_.size()) {
+    // Should never happen unless someone breaks the code.
+    DLOG(ERROR) << "Brackets fixup depth exceeds size of bracket vector.";
+    count = brackets_.size();
+  }
+  auto it = brackets_.rbegin();
+  // Do not assign the script to the last one if |exclude_last|.
+  if (exclude_last) {
+    ++it;
+    --count;
+    brackets_fixup_depth_ = 1;
+  } else {
     brackets_fixup_depth_ = 0;
   }
+  for (; count; ++it, --count)
+    it->script = resolved_script;
 }
 
-bool ScriptRunIterator::Fetch(size_t* pos, UChar32* ch) {
+bool ScriptRunIterator::Fetch(wtf_size_t* pos, UChar32* ch) {
   if (ahead_pos_ > length_) {
     return false;
   }
diff --git a/third_party/blink/renderer/platform/fonts/script_run_iterator.h b/third_party/blink/renderer/platform/fonts/script_run_iterator.h
index 6fc60952c875..eac287501056 100644
--- a/third_party/blink/renderer/platform/fonts/script_run_iterator.h
+++ b/third_party/blink/renderer/platform/fonts/script_run_iterator.h
@@ -5,11 +5,10 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SCRIPT_RUN_ITERATOR_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SCRIPT_RUN_ITERATOR_H_
 
+#include "base/macros.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/deque.h"
-#include "third_party/blink/renderer/platform/wtf/dtoa/utils.h"
-#include "third_party/blink/renderer/platform/wtf/noncopyable.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 
 #include <unicode/uchar.h>
@@ -21,40 +20,39 @@ class ScriptData;
 
 class PLATFORM_EXPORT ScriptRunIterator {
   USING_FAST_MALLOC(ScriptRunIterator);
-  WTF_MAKE_NONCOPYABLE(ScriptRunIterator);
 
  public:
-  ScriptRunIterator(const UChar* text, size_t length);
+  ScriptRunIterator(const UChar* text, wtf_size_t length);
 
   // This maintains a reference to data. It must exist for the lifetime of
   // this object. Typically data is a singleton that exists for the life of
   // the process.
-  ScriptRunIterator(const UChar* text, size_t length, const ScriptData*);
+  ScriptRunIterator(const UChar* text, wtf_size_t length, const ScriptData*);
 
-  bool Consume(unsigned& limit, UScriptCode&);
+  bool Consume(unsigned* limit, UScriptCode*);
 
-  static constexpr int kMaxScriptCount = 20;
+  static constexpr int kMaxScriptCount = 32;
   using UScriptCodeList = Vector<UScriptCode, kMaxScriptCount>;
 
  private:
   struct BracketRec {
-    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
+    DISALLOW_NEW();
     UChar32 ch;
     UScriptCode script;
   };
   void OpenBracket(UChar32);
   void CloseBracket(UChar32);
   bool MergeSets();
-  void FixupStack(UScriptCode resolved_script);
-  bool Fetch(size_t* pos, UChar32*);
+  void FixupStack(UScriptCode resolved_script, bool exclude_last);
+  bool Fetch(wtf_size_t* pos, UChar32*);
 
   UScriptCode ResolveCurrentScript() const;
 
   const UChar* text_;
-  const size_t length_;
+  const wtf_size_t length_;
 
   Deque<BracketRec> brackets_;
-  size_t brackets_fixup_depth_;
+  wtf_size_t brackets_fixup_depth_;
   // Limit max brackets so that the bracket tracking buffer does not grow
   // excessively large when processing long runs of text.
   static const int kMaxBrackets = 32;
@@ -67,11 +65,13 @@ class PLATFORM_EXPORT ScriptRunIterator {
   std::unique_ptr<UScriptCodeList> ahead_set_;
 
   UChar32 ahead_character_;
-  size_t ahead_pos_;
+  wtf_size_t ahead_pos_;
 
   UScriptCode common_preferred_;
 
   const ScriptData* script_data_;
+
+  DISALLOW_COPY_AND_ASSIGN(ScriptRunIterator);
 };
 
 // ScriptData is a wrapper which returns a set of scripts for a particular
@@ -81,7 +81,6 @@ class PLATFORM_EXPORT ScriptRunIterator {
 // method to work correctly.
 class PLATFORM_EXPORT ScriptData {
   USING_FAST_MALLOC(ScriptData);
-  WTF_MAKE_NONCOPYABLE(ScriptData);
 
  protected:
   ScriptData() = default;
@@ -104,6 +103,9 @@ class PLATFORM_EXPORT ScriptData {
   virtual UChar32 GetPairedBracket(UChar32) const = 0;
 
   virtual PairedBracketType GetPairedBracketType(UChar32) const = 0;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ScriptData);
 };
 
 class PLATFORM_EXPORT ICUScriptData : public ScriptData {
diff --git a/third_party/blink/renderer/platform/fonts/script_run_iterator_test.cc b/third_party/blink/renderer/platform/fonts/script_run_iterator_test.cc
index a8ffd210ca16..592f73c5af2b 100644
--- a/third_party/blink/renderer/platform/fonts/script_run_iterator_test.cc
+++ b/third_party/blink/renderer/platform/fonts/script_run_iterator_test.cc
@@ -4,16 +4,16 @@
 
 #include "third_party/blink/renderer/platform/fonts/script_run_iterator.h"
 
-#include <string>
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/renderer/platform/wtf/assertions.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 #include "third_party/blink/renderer/platform/wtf/threading.h"
 
 namespace blink {
 
 struct ScriptTestRun {
-  std::string text;
+  const char* const text;
   UScriptCode code;
 };
 
@@ -108,7 +108,8 @@ class MockScriptData : public ScriptData {
   }
 
   static String ToTestString(const std::string& input) {
-    String result(g_empty_string16_bit);
+    StringBuilder result;
+    result.Ensure16Bit();
     bool in_set = false;
     int seen = 0;
     int code = 0;
@@ -169,7 +170,7 @@ class MockScriptData : public ScriptData {
           case '>':
             DCHECK_NE(seen, 0);
             code |= TableLookup(list);
-            result.append(static_cast<UChar>(kMockCharMin + code));
+            result.Append(static_cast<UChar>(kMockCharMin + code));
             in_set = false;
             break;
           default:
@@ -222,10 +223,10 @@ class MockScriptData : public ScriptData {
           DLOG(ERROR) << "Illegal mock string set char: '" << c << "'";
       }
       if (!in_set) {
-        result.append(static_cast<UChar>(kMockCharMin + code));
+        result.Append(static_cast<UChar>(kMockCharMin + code));
       }
     }
-    return result;
+    return result.ToString();
   }
 
   // We determine properties based on the offset from kMockCharMin:
@@ -287,10 +288,11 @@ const int MockScriptData::kTable[] = {
 class ScriptRunIteratorTest : public testing::Test {
  protected:
   void CheckRuns(const Vector<ScriptTestRun>& runs) {
-    String text(g_empty_string16_bit);
+    StringBuilder text;
+    text.Ensure16Bit();
     Vector<ScriptExpectedRun> expect;
     for (auto& run : runs) {
-      text.append(String::FromUTF8(run.text.c_str()));
+      text.Append(String::FromUTF8(run.text));
       expect.push_back(ScriptExpectedRun(text.length(), run.code));
     }
     ScriptRunIterator script_run_iterator(text.Characters16(), text.length());
@@ -300,10 +302,11 @@ class ScriptRunIteratorTest : public testing::Test {
   // FIXME crbug.com/527329 - CheckMockRuns should be replaced by finding
   // suitable equivalent real codepoint sequences instead.
   void CheckMockRuns(const Vector<ScriptTestRun>& runs) {
-    String text(g_empty_string16_bit);
+    StringBuilder text;
+    text.Ensure16Bit();
     Vector<ScriptExpectedRun> expect;
     for (const ScriptTestRun& run : runs) {
-      text.append(MockScriptData::ToTestString(run.text));
+      text.Append(MockScriptData::ToTestString(run.text));
       expect.push_back(ScriptExpectedRun(text.length(), run.code));
     }
 
@@ -316,8 +319,8 @@ class ScriptRunIteratorTest : public testing::Test {
                   const Vector<ScriptExpectedRun>& expect) {
     unsigned limit;
     UScriptCode code;
-    unsigned long run_count = 0;
-    while (script_run_iterator->Consume(limit, code)) {
+    size_t run_count = 0;
+    while (script_run_iterator->Consume(&limit, &code)) {
       ASSERT_LT(run_count, expect.size());
       ASSERT_EQ(expect[run_count].limit, limit);
       ASSERT_EQ(expect[run_count].code, code);
@@ -332,7 +335,7 @@ TEST_F(ScriptRunIteratorTest, Empty) {
   ScriptRunIterator script_run_iterator(empty.Characters16(), empty.length());
   unsigned limit = 0;
   UScriptCode code = USCRIPT_INVALID_CODE;
-  DCHECK(!script_run_iterator.Consume(limit, code));
+  DCHECK(!script_run_iterator.Consume(&limit, &code));
   ASSERT_EQ(limit, 0u);
   ASSERT_EQ(code, USCRIPT_INVALID_CODE);
 }
@@ -371,6 +374,50 @@ TEST_F(ScriptRunIteratorTest, Chinese) {
   CHECK_SCRIPT_RUNS({{"", USCRIPT_HAN}});
 }
 
+struct JapaneseMixedScript {
+  const char* string;
+  // The expected primary_script when the string alone was evaluated.
+  UScriptCode script;
+} japanese_mixed_scripts[] = {{"", USCRIPT_HIRAGANA},
+                              // Katakana should be normalized to Hiragana
+                              {"", USCRIPT_HIRAGANA},
+                              // Script_Extensions=Hira Kana
+                              {"\u30FC", USCRIPT_HIRAGANA},
+                              // Script_Extensions=Hani Hira Kana
+                              {"\u303C", USCRIPT_HAN},
+                              // Script_Extensions=Bopo Hang Hani Hira Kana
+                              {"\u3003", USCRIPT_BOPOMOFO},
+                              // Script_Extensions=Bopo Hang Hani Hira Kana Yiii
+                              {"\u3001", USCRIPT_BOPOMOFO}};
+
+class JapaneseMixedScriptTest
+    : public ScriptRunIteratorTest,
+      public testing::WithParamInterface<JapaneseMixedScript> {};
+
+INSTANTIATE_TEST_SUITE_P(ScriptRunIteratorTest,
+                         JapaneseMixedScriptTest,
+                         testing::ValuesIn(japanese_mixed_scripts));
+
+TEST_P(JapaneseMixedScriptTest, Data) {
+  const auto& data = GetParam();
+  std::string string(data.string);
+
+  CheckRuns({{string.data(), data.script}});
+
+  // If the string follows Hiragana or Katakana, or is followed by Hiragnaa or
+  // Katakana, it should be normalized as Hiragana.
+  std::string hiragana("");
+  std::string katakana("");
+  CheckRuns({{(hiragana + string).data(), USCRIPT_HIRAGANA}});
+  CheckRuns({{(string + hiragana).data(), USCRIPT_HIRAGANA}});
+
+  CheckRuns({{(katakana + string).data(), USCRIPT_HIRAGANA}});
+  CheckRuns({{(string + katakana).data(), USCRIPT_HIRAGANA}});
+
+  CheckRuns({{(hiragana + string + katakana).data(), USCRIPT_HIRAGANA}});
+  CheckRuns({{(katakana + string + hiragana).data(), USCRIPT_HIRAGANA}});
+}
+
 // Close bracket without matching open is ignored
 TEST_F(ScriptRunIteratorTest, UnbalancedParens1) {
   CHECK_SCRIPT_RUNS(
diff --git a/third_party/blink/renderer/platform/fonts/segmented_font_data.cc b/third_party/blink/renderer/platform/fonts/segmented_font_data.cc
index f68af86ee420..1b91c17df010 100644
--- a/third_party/blink/renderer/platform/fonts/segmented_font_data.cc
+++ b/third_party/blink/renderer/platform/fonts/segmented_font_data.cc
@@ -86,4 +86,13 @@ bool SegmentedFontData::ShouldSkipDrawing() const {
   return false;
 }
 
+bool SegmentedFontData::HasAdvanceOverride() const {
+  auto* end = faces_.end();
+  for (auto* it = faces_.begin(); it != end; ++it) {
+    if ((*it)->FontData()->HasAdvanceOverride())
+      return true;
+  }
+  return false;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/segmented_font_data.h b/third_party/blink/renderer/platform/fonts/segmented_font_data.h
index 61b2872c97b1..a26131816027 100644
--- a/third_party/blink/renderer/platform/fonts/segmented_font_data.h
+++ b/third_party/blink/renderer/platform/fonts/segmented_font_data.h
@@ -29,6 +29,7 @@
 #include "third_party/blink/renderer/platform/fonts/font_data.h"
 #include "third_party/blink/renderer/platform/fonts/font_data_for_range_set.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/wtf/casting.h"
 
 class SimpleFontData;
 
@@ -57,11 +58,17 @@ class PLATFORM_EXPORT SegmentedFontData : public FontData {
   bool IsLoadingFallback() const override;
   bool IsSegmented() const override;
   bool ShouldSkipDrawing() const override;
+  bool HasAdvanceOverride() const override;
 
   Vector<scoped_refptr<FontDataForRangeSet>, 1> faces_;
 };
 
-DEFINE_FONT_DATA_TYPE_CASTS(SegmentedFontData, true);
+template <>
+struct DowncastTraits<SegmentedFontData> {
+  static bool AllowFrom(const FontData& fontData) {
+    return fontData.IsSegmented();
+  }
+};
 
 }  // namespace blink
 
diff --git a/third_party/blink/renderer/platform/fonts/shaping/caching_word_shape_iterator.cc b/third_party/blink/renderer/platform/fonts/shaping/caching_word_shape_iterator.cc
index 939164e1199a..a9886bcd9284 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/caching_word_shape_iterator.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/caching_word_shape_iterator.cc
@@ -5,15 +5,16 @@
 #include "third_party/blink/renderer/platform/fonts/shaping/caching_word_shape_iterator.h"
 
 #include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result.h"
 
 namespace blink {
 
-scoped_refptr<const ShapeResult> CachingWordShapeIterator::ShapeWordWithoutSpacing(
-    const TextRun& word_run,
-    const Font* font) {
+scoped_refptr<const ShapeResult>
+CachingWordShapeIterator::ShapeWordWithoutSpacing(const TextRun& word_run,
+                                                  const Font* font) {
   ShapeCacheEntry* cache_entry = shape_cache_->Add(word_run, ShapeCacheEntry());
-  if (cache_entry && cache_entry->shape_result_)
-    return cache_entry->shape_result_;
+  if (cache_entry && *cache_entry)
+    return *cache_entry;
 
   const String word_text = word_run.NormalizedUTF16();
   HarfBuzzShaper shaper(word_text);
@@ -22,10 +23,49 @@ scoped_refptr<const ShapeResult> CachingWordShapeIterator::ShapeWordWithoutSpaci
   if (!shape_result)
     return nullptr;
 
+  shape_result->SetDeprecatedInkBounds(shape_result->ComputeInkBounds());
   if (cache_entry)
-    cache_entry->shape_result_ = shape_result;
+    *cache_entry = shape_result;
 
   return shape_result;
 }
 
+scoped_refptr<const ShapeResult> CachingWordShapeIterator::ShapeWord(
+    const TextRun& word_run,
+    const Font* font) {
+  scoped_refptr<const ShapeResult> result =
+      ShapeWordWithoutSpacing(word_run, font);
+  if (LIKELY(!spacing_.HasSpacing()))
+    return result;
+
+  scoped_refptr<const ShapeResult> spacing_result =
+      result->ApplySpacingToCopy(spacing_, word_run);
+  FloatRect ink_bounds = spacing_result->ComputeInkBounds();
+
+  // Return bounds as is because glyph bounding box is in logical space.
+  if (spacing_result->Width() >= 0 && ink_bounds.Width() >= 0) {
+    spacing_result->SetDeprecatedInkBounds(ink_bounds);
+    return spacing_result;
+  }
+
+  // Negative word-spacing and/or letter-spacing may cause some glyphs to
+  // overflow the left boundary and result negative measured width. Adjust glyph
+  // bounds accordingly to cover the overflow.
+  // The negative width should be clamped to 0 in CSS box model, but it's up to
+  // caller's responsibility.
+  float left = std::min(spacing_result->Width(), ink_bounds.Width());
+  if (left < ink_bounds.X()) {
+    // The right edge should be the width of the first character in most cases,
+    // but computing it requires re-measuring bounding box of each glyph. Leave
+    // it unchanged, which gives an excessive right edge but assures it covers
+    // all glyphs.
+    ink_bounds.ShiftXEdgeTo(left);
+  } else {
+    ink_bounds.SetWidth(ink_bounds.Width());
+  }
+
+  spacing_result->SetDeprecatedInkBounds(ink_bounds);
+  return spacing_result;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/caching_word_shape_iterator.h b/third_party/blink/renderer/platform/fonts/shaping/caching_word_shape_iterator.h
index 1fb7b8d921e4..b969549b9054 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/caching_word_shape_iterator.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/caching_word_shape_iterator.h
@@ -31,14 +31,13 @@
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_cache.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/text/character_names.h"
 
 namespace blink {
 
 class PLATFORM_EXPORT CachingWordShapeIterator final {
   STACK_ALLOCATED();
-  WTF_MAKE_NONCOPYABLE(CachingWordShapeIterator);
 
  public:
   CachingWordShapeIterator(ShapeCache* cache,
@@ -59,7 +58,7 @@ class PLATFORM_EXPORT CachingWordShapeIterator final {
 
     // SVG sets SpacingDisabled because it handles spacing by themselves.
     if (!run.SpacingDisabled())
-      spacing_.SetSpacingAndExpansion(font->GetFontDescription());
+      spacing_.SetSpacingAndExpansion(*font);
   }
 
   bool Next(scoped_refptr<const ShapeResult>* word_result) {
@@ -78,17 +77,11 @@ class PLATFORM_EXPORT CachingWordShapeIterator final {
   }
 
  private:
-  scoped_refptr<const ShapeResult> ShapeWordWithoutSpacing(const TextRun&,
-                                                    const Font*);
+  scoped_refptr<const ShapeResult>
+  ShapeWordWithoutSpacing(const TextRun&, const Font*);
 
-  scoped_refptr<const ShapeResult> ShapeWord(const TextRun& word_run,
-                                      const Font* font) {
-    if (LIKELY(!spacing_.HasSpacing()))
-      return ShapeWordWithoutSpacing(word_run, font);
-
-    scoped_refptr<const ShapeResult> result = ShapeWordWithoutSpacing(word_run, font);
-    return result->ApplySpacingToCopy(spacing_, word_run);
-  }
+  scoped_refptr<const ShapeResult> ShapeWord(const TextRun&,
+                                             const Font*);
 
   bool NextWord(scoped_refptr<const ShapeResult>* word_result) {
     return ShapeToEndIndex(word_result, NextWordEndIndex());
@@ -132,10 +125,10 @@ class PLATFORM_EXPORT CachingWordShapeIterator final {
     bool has_any_script = !Character::IsCommonOrInheritedScript(ch);
     for (unsigned next_end = end; end < length; end = next_end) {
       ch = text_run_.CodepointAtAndNext(next_end);
-      // ZWJ and modifier check in order not to split those Emoji sequences.
+      // Modifier check in order not to split Emoji sequences.
       if (U_GET_GC_MASK(ch) & (U_GC_M_MASK | U_GC_LM_MASK | U_GC_SK_MASK) ||
-          ch == kZeroWidthJoinerCharacter || Character::IsModifier(ch) ||
-          Character::IsEmojiFlagSequenceTag(ch))
+          ch == kZeroWidthJoinerCharacter || Character::IsEmojiComponent(ch) ||
+          Character::IsExtendedPictographic(ch))
         continue;
       // Avoid delimiting COMMON/INHERITED alone, which makes harder to
       // identify the script.
@@ -152,7 +145,8 @@ class PLATFORM_EXPORT CachingWordShapeIterator final {
     return length;
   }
 
-  bool ShapeToEndIndex(scoped_refptr<const ShapeResult>* result, unsigned end_index) {
+  bool ShapeToEndIndex(scoped_refptr<const ShapeResult>* result,
+                       unsigned end_index) {
     if (!end_index || end_index <= start_index_)
       return false;
 
@@ -211,6 +205,8 @@ class PLATFORM_EXPORT CachingWordShapeIterator final {
   float width_so_far_;  // Used only when allowTabs()
   unsigned start_index_ : 31;
   unsigned shape_by_word_ : 1;
+
+  DISALLOW_COPY_AND_ASSIGN(CachingWordShapeIterator);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper.cc b/third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper.cc
index aab219b6acfc..68972169da91 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper.cc
@@ -37,9 +37,11 @@
 namespace blink {
 
 ShapeCache* CachingWordShaper::GetShapeCache() const {
-  return font_.font_fallback_list_->GetShapeCache(font_.font_description_);
+  return font_.GetShapeCache();
 }
 
+// Returns the total advance width of the TextRun run. If glyph_bounds
+// is specified it constructs on it the smallest bounding box covering all ink.
 float CachingWordShaper::Width(const TextRun& run,
                                HashSet<const SimpleFontData*>* fallback_fonts,
                                FloatRect* glyph_bounds) {
@@ -48,19 +50,33 @@ float CachingWordShaper::Width(const TextRun& run,
   CachingWordShapeIterator iterator(GetShapeCache(), run, &font_);
   while (iterator.Next(&word_result)) {
     if (word_result) {
+      // For every word_result we need to accumulate its width to adjust the
+      // glyph_bounds. When the word_result is in RTL we accumulate in the
+      // opposite direction (negative).
+      if (run.Rtl())
+        width -= word_result->Width();
       if (glyph_bounds) {
-        FloatRect adjusted_bounds = word_result->Bounds();
+        FloatRect adjusted_bounds = word_result->DeprecatedInkBounds();
         // Translate glyph bounds to the current glyph position which
         // is the total width before this glyph.
         adjusted_bounds.SetX(adjusted_bounds.X() + width);
         glyph_bounds->Unite(adjusted_bounds);
       }
-      width += word_result->Width();
+      if (!run.Rtl())
+        width += word_result->Width();
       if (fallback_fonts)
         word_result->FallbackFonts(fallback_fonts);
     }
   }
 
+  if (run.Rtl()) {
+    // Finally, convert width back to positive if run is RTL.
+    width = -width;
+    if (glyph_bounds) {
+      glyph_bounds->SetX(glyph_bounds->X() + width);
+    }
+  }
+
   return width;
 }
 
@@ -103,14 +119,14 @@ CharacterRange CachingWordShaper::GetCharacterRange(const TextRun& run,
   ShapeResultBuffer buffer;
   float total_width = ShapeResultsForRun(GetShapeCache(), &font_, run, &buffer);
 
-  return buffer.GetCharacterRange(total_width, run.Direction(), from, to);
+  return buffer.GetCharacterRange(run.ToStringView(), run.Direction(),
+                                  total_width, from, to);
 }
 
 Vector<CharacterRange> CachingWordShaper::IndividualCharacterRanges(
     const TextRun& run) {
   ShapeResultBuffer buffer;
   float total_width = ShapeResultsForRun(GetShapeCache(), &font_, run, &buffer);
-
   auto ranges = buffer.IndividualCharacterRanges(run.Direction(), total_width);
   // The shaper can fail to return glyph metrics for all characters (see
   // crbug.com/613915 and crbug.com/615661) so add empty ranges to ensure all
@@ -120,6 +136,14 @@ Vector<CharacterRange> CachingWordShaper::IndividualCharacterRanges(
   return ranges;
 }
 
+Vector<double> CachingWordShaper::IndividualCharacterAdvances(
+    const TextRun& run) {
+  ShapeResultBuffer buffer;
+  float total_width = ShapeResultsForRun(GetShapeCache(), &font_, run, &buffer);
+  return buffer.IndividualCharacterAdvances(run.ToStringView(), run.Direction(),
+                                            total_width);
+}
+
 Vector<ShapeResult::RunFontData> CachingWordShaper::GetRunFontData(
     const TextRun& run) const {
   ShapeResultBuffer buffer;
@@ -133,7 +157,7 @@ GlyphData CachingWordShaper::EmphasisMarkGlyphData(
   ShapeResultBuffer buffer;
   ShapeResultsForRun(GetShapeCache(), &font_, emphasis_mark_run, &buffer);
 
-  return buffer.EmphasisMarkGlyphData(font_.font_description_);
+  return buffer.EmphasisMarkGlyphData(font_.GetFontDescription());
 }
 
-};  // namespace blink
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper.h b/third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper.h
index 1adfe2208e0e..df8e43525e0c 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper.h
@@ -30,7 +30,7 @@
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_buffer.h"
 #include "third_party/blink/renderer/platform/geometry/float_rect.h"
 #include "third_party/blink/renderer/platform/text/text_run.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 
 namespace blink {
@@ -44,7 +44,6 @@ struct TextRunPaintInfo;
 
 class PLATFORM_EXPORT CachingWordShaper final {
   STACK_ALLOCATED();
-  WTF_MAKE_NONCOPYABLE(CachingWordShaper);
 
  public:
   explicit CachingWordShaper(const Font& font) : font_(font) {}
@@ -61,6 +60,7 @@ class PLATFORM_EXPORT CachingWordShaper final {
   void FillResultBuffer(const TextRunPaintInfo&, ShapeResultBuffer*);
   CharacterRange GetCharacterRange(const TextRun&, unsigned from, unsigned to);
   Vector<CharacterRange> IndividualCharacterRanges(const TextRun&);
+  Vector<double> IndividualCharacterAdvances(const TextRun&);
 
   Vector<ShapeResult::RunFontData> GetRunFontData(const TextRun&) const;
 
@@ -70,6 +70,8 @@ class PLATFORM_EXPORT CachingWordShaper final {
   ShapeCache* GetShapeCache() const;
 
   const Font& font_;
+
+  DISALLOW_COPY_AND_ASSIGN(CachingWordShaper);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper_test.cc b/third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper_test.cc
index 2183a6ccd12d..6ab2024741d5 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper_test.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper_test.cc
@@ -5,6 +5,9 @@
 #include "third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper.h"
 
 #include <memory>
+
+#include "base/stl_util.h"
+#include "base/test/task_environment.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/caching_word_shape_iterator.h"
@@ -21,12 +24,12 @@ class CachingWordShaperTest : public testing::Test {
     font_description.SetGenericFamily(FontDescription::kStandardFamily);
 
     font = Font(font_description);
-    font.Update(nullptr);
     ASSERT_TRUE(font.CanShapeWordByWord());
     fallback_fonts = nullptr;
     cache = std::make_unique<ShapeCache>();
   }
 
+  base::test::TaskEnvironment task_environment_;
   FontCachePurgePreventer font_cache_purge_preventer;
   FontDescription font_description;
   Font font;
@@ -210,67 +213,36 @@ TEST_F(CachingWordShaperTest, SegmentCJKAndNonCJKCommon) {
   ASSERT_FALSE(iterator.Next(&word_result));
 }
 
-TEST_F(CachingWordShaperTest, SegmentEmojiZWJCommon) {
-  // A family followed by a couple with heart emoji sequence,
-  // the latter including a variation selector.
-  const UChar kStr[] = {0xD83D, 0xDC68, 0x200D, 0xD83D, 0xDC69, 0x200D,
-                        0xD83D, 0xDC67, 0x200D, 0xD83D, 0xDC66, 0xD83D,
-                        0xDC69, 0x200D, 0x2764, 0xFE0F, 0x200D, 0xD83D,
-                        0xDC8B, 0x200D, 0xD83D, 0xDC68, 0x0};
-  TextRun text_run(kStr, 22);
+TEST_F(CachingWordShaperTest, SegmentEmojiSequences) {
+  std::vector<std::string> test_strings = {
+      // A family followed by a couple with heart emoji sequence,
+      // the latter including a variation selector.
+      u8"\U0001f468\u200D\U0001f469\u200D\U0001f467\u200D\U0001f466\U0001f469"
+      u8"\u200D\u2764\uFE0F\u200D\U0001f48b\u200D\U0001f468",
+      // Pirate flag
+      u8"\U0001F3F4\u200D\u2620\uFE0F",
+      // Pilot, judge sequence
+      u8"\U0001f468\U0001f3fb\u200D\u2696\uFE0F\U0001f468\U0001f3fb\u200D\u2708"
+      u8"\uFE0F",
+      // Woman, Kiss, Man sequence
+      u8"\U0001f469\u200D\u2764\uFE0F\u200D\U0001f48b\u200D\U0001f468",
+      // Signs of horns with skin tone modifier
+      u8"\U0001f918\U0001f3fb",
+      // Man, dark skin tone, red hair
+      u8"\U0001f468\U0001f3ff\u200D\U0001f9b0"};
 
-  scoped_refptr<const ShapeResult> word_result;
-  CachingWordShapeIterator iterator(cache.get(), text_run, &font);
+  for (auto test_string : test_strings) {
+    String emoji_string = String::FromUTF8(test_string);
+    TextRun text_run(emoji_string);
+    scoped_refptr<const ShapeResult> word_result;
+    CachingWordShapeIterator iterator(cache.get(), text_run, &font);
 
-  ASSERT_TRUE(iterator.Next(&word_result));
-  EXPECT_EQ(22u, word_result->NumCharacters());
+    ASSERT_TRUE(iterator.Next(&word_result));
+    EXPECT_EQ(emoji_string.length(), word_result->NumCharacters())
+        << " Length mismatch for sequence: " << test_string;
 
-  ASSERT_FALSE(iterator.Next(&word_result));
-}
-
-TEST_F(CachingWordShaperTest, SegmentEmojiPilotJudgeSequence) {
-  // A family followed by a couple with heart emoji sequence,
-  // the latter including a variation selector.
-  const UChar kStr[] = {0xD83D, 0xDC68, 0xD83C, 0xDFFB, 0x200D, 0x2696, 0xFE0F,
-                        0xD83D, 0xDC68, 0xD83C, 0xDFFB, 0x200D, 0x2708, 0xFE0F};
-  TextRun text_run(kStr, ARRAY_SIZE(kStr));
-
-  scoped_refptr<const ShapeResult> word_result;
-  CachingWordShapeIterator iterator(cache.get(), text_run, &font);
-
-  ASSERT_TRUE(iterator.Next(&word_result));
-  EXPECT_EQ(ARRAY_SIZE(kStr), word_result->NumCharacters());
-
-  ASSERT_FALSE(iterator.Next(&word_result));
-}
-
-TEST_F(CachingWordShaperTest, SegmentEmojiHeartZWJSequence) {
-  // A ZWJ, followed by two family ZWJ Sequences.
-  const UChar kStr[] = {0xD83D, 0xDC69, 0x200D, 0x2764, 0xFE0F, 0x200D,
-                        0xD83D, 0xDC8B, 0x200D, 0xD83D, 0xDC68, 0x0};
-  TextRun text_run(kStr, 11);
-
-  scoped_refptr<const ShapeResult> word_result;
-  CachingWordShapeIterator iterator(cache.get(), text_run, &font);
-
-  ASSERT_TRUE(iterator.Next(&word_result));
-  EXPECT_EQ(11u, word_result->NumCharacters());
-
-  ASSERT_FALSE(iterator.Next(&word_result));
-}
-
-TEST_F(CachingWordShaperTest, SegmentEmojiSignsOfHornsModifier) {
-  // A Sign of the Horns emoji, followed by a fitzpatrick modifer
-  const UChar kStr[] = {0xD83E, 0xDD18, 0xD83C, 0xDFFB, 0x0};
-  TextRun text_run(kStr, 4);
-
-  scoped_refptr<const ShapeResult> word_result;
-  CachingWordShapeIterator iterator(cache.get(), text_run, &font);
-
-  ASSERT_TRUE(iterator.Next(&word_result));
-  EXPECT_EQ(4u, word_result->NumCharacters());
-
-  ASSERT_FALSE(iterator.Next(&word_result));
+    ASSERT_FALSE(iterator.Next(&word_result));
+  }
 }
 
 TEST_F(CachingWordShaperTest, SegmentEmojiExtraZWJPrefix) {
@@ -301,7 +273,7 @@ TEST_F(CachingWordShaperTest, SegmentEmojiSubdivisionFlags) {
                         0xDC73, 0xDB40, 0xDC63, 0xDB40, 0xDC74, 0xDB40, 0xDC7F,
                         0xD83C, 0xDFF4, 0xDB40, 0xDC67, 0xDB40, 0xDC62, 0xDB40,
                         0xDC65, 0xDB40, 0xDC6E, 0xDB40, 0xDC67, 0xDB40, 0xDC7F};
-  TextRun text_run(kStr, ARRAY_SIZE(kStr));
+  TextRun text_run(kStr, base::size(kStr));
 
   scoped_refptr<const ShapeResult> word_result;
   CachingWordShapeIterator iterator(cache.get(), text_run, &font);
@@ -386,7 +358,6 @@ TEST_F(CachingWordShaperTest, TextOrientationFallbackShouldNotInFallbackList) {
 
   font_description.SetOrientation(FontOrientation::kVerticalMixed);
   Font vertical_mixed_font = Font(font_description);
-  vertical_mixed_font.Update(nullptr);
   ASSERT_TRUE(vertical_mixed_font.CanShapeWordByWord());
 
   CachingWordShaper shaper(vertical_mixed_font);
diff --git a/third_party/blink/renderer/platform/fonts/shaping/case_mapping_harfbuzz_buffer_filler.cc b/third_party/blink/renderer/platform/fonts/shaping/case_mapping_harfbuzz_buffer_filler.cc
index 2ab8d8c22be1..86d0e71d5b94 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/case_mapping_harfbuzz_buffer_filler.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/case_mapping_harfbuzz_buffer_filler.cc
@@ -4,6 +4,8 @@
 
 #include "third_party/blink/renderer/platform/fonts/shaping/case_mapping_harfbuzz_buffer_filler.h"
 
+#include "third_party/blink/renderer/platform/wtf/text/case_map.h"
+
 namespace blink {
 
 static const uint16_t* ToUint16(const UChar* src) {
@@ -32,14 +34,17 @@ CaseMappingHarfBuzzBufferFiller::CaseMappingHarfBuzzBufferFiller(
                           text.length(), start_index, num_characters);
     }
   } else {
+    CaseMap case_map(locale);
     String case_mapped_text = case_map_intend == CaseMapIntend::kUpperCase
-                                  ? text.UpperUnicode(locale)
-                                  : text.LowerUnicode(locale);
+                                  ? case_map.ToUpper(text)
+                                  : case_map.ToLower(text);
     case_mapped_text.Ensure16Bit();
 
     if (case_mapped_text.length() != text.length()) {
-      FillSlowCase(case_map_intend, locale, text.Characters16(), text.length(),
-                   start_index, num_characters);
+      String original_text = text;
+      original_text.Ensure16Bit();
+      FillSlowCase(case_map_intend, locale, original_text.Characters16(),
+                   original_text.length(), start_index, num_characters);
       return;
     }
 
@@ -64,6 +69,7 @@ void CaseMappingHarfBuzzBufferFiller::FillSlowCase(
   hb_buffer_add_utf16(harfbuzz_buffer_, ToUint16(buffer), buffer_length,
                       start_index, 0);
 
+  CaseMap case_map(locale);
   for (unsigned char_index = start_index;
        char_index < start_index + num_characters;) {
     unsigned new_char_index = char_index;
@@ -71,9 +77,9 @@ void CaseMappingHarfBuzzBufferFiller::FillSlowCase(
     String char_by_char(&buffer[char_index], new_char_index - char_index);
     String case_mapped_char;
     if (case_map_intend == CaseMapIntend::kUpperCase)
-      case_mapped_char = char_by_char.UpperUnicode(locale);
+      case_mapped_char = case_map.ToUpper(char_by_char);
     else
-      case_mapped_char = char_by_char.LowerUnicode(locale);
+      case_mapped_char = case_map.ToLower(char_by_char);
 
     for (unsigned j = 0; j < case_mapped_char.length();) {
       UChar32 codepoint = 0;
diff --git a/third_party/blink/renderer/platform/fonts/shaping/case_mapping_harfbuzz_buffer_filler.h b/third_party/blink/renderer/platform/fonts/shaping/case_mapping_harfbuzz_buffer_filler.h
index e67c7704fbd0..6468f6c140ff 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/case_mapping_harfbuzz_buffer_filler.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/case_mapping_harfbuzz_buffer_filler.h
@@ -5,7 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_CASE_MAPPING_HARFBUZZ_BUFFER_FILLER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_CASE_MAPPING_HARFBUZZ_BUFFER_FILLER_H_
 
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/text/atomic_string.h"
 #include "third_party/blink/renderer/platform/wtf/text/unicode.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
diff --git a/third_party/blink/renderer/platform/fonts/shaping/font_features.cc b/third_party/blink/renderer/platform/fonts/shaping/font_features.cc
new file mode 100644
index 000000000000..99ae1df8fa52
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/font_features.cc
@@ -0,0 +1,227 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/shaping/font_features.h"
+
+#include "third_party/blink/renderer/platform/fonts/font.h"
+
+namespace blink {
+
+namespace {
+
+constexpr hb_feature_t CreateFeature(hb_tag_t tag, uint32_t value = 0) {
+  return {tag, value, 0 /* start */, static_cast<unsigned>(-1) /* end */};
+}
+
+constexpr hb_feature_t CreateFeature(char c1,
+                                     char c2,
+                                     char c3,
+                                     char c4,
+                                     uint32_t value = 0) {
+  return CreateFeature(HB_TAG(c1, c2, c3, c4), value);
+}
+
+}  // namespace
+
+base::Optional<unsigned> FontFeatures::FindValueForTesting(hb_tag_t tag) const {
+  for (const hb_feature_t& feature : features_) {
+    if (feature.tag == tag)
+      return feature.value;
+  }
+  return base::nullopt;
+}
+
+void FontFeatures::Initialize(const FontDescription& description) {
+  DCHECK(IsEmpty());
+  const bool is_horizontal = !description.IsVerticalAnyUpright();
+
+  constexpr hb_feature_t no_kern = CreateFeature('k', 'e', 'r', 'n');
+  constexpr hb_feature_t no_vkrn = CreateFeature('v', 'k', 'r', 'n');
+  switch (description.GetKerning()) {
+    case FontDescription::kNormalKerning:
+      // kern/vkrn are enabled by default in HarfBuzz
+      break;
+    case FontDescription::kNoneKerning:
+      Append(is_horizontal ? no_kern : no_vkrn);
+      break;
+    case FontDescription::kAutoKerning:
+      break;
+  }
+
+  {
+    bool default_is_off = description.TextRendering() == blink::kOptimizeSpeed;
+    bool letter_spacing = description.LetterSpacing() != 0;
+    constexpr auto normal = FontDescription::kNormalLigaturesState;
+    constexpr auto enabled = FontDescription::kEnabledLigaturesState;
+    constexpr auto disabled = FontDescription::kDisabledLigaturesState;
+
+    // clig and liga are on by default in HarfBuzz
+    constexpr hb_feature_t no_clig = CreateFeature('c', 'l', 'i', 'g');
+    constexpr hb_feature_t no_liga = CreateFeature('l', 'i', 'g', 'a');
+    auto common = description.CommonLigaturesState();
+    if (letter_spacing ||
+        (common == disabled || (common == normal && default_is_off))) {
+      Append(no_liga);
+      Append(no_clig);
+    }
+    // dlig is off by default in HarfBuzz
+    constexpr hb_feature_t dlig = CreateFeature('d', 'l', 'i', 'g', 1);
+    auto discretionary = description.DiscretionaryLigaturesState();
+    if (!letter_spacing && discretionary == enabled) {
+      Append(dlig);
+    }
+    // hlig is off by default in HarfBuzz
+    constexpr hb_feature_t hlig = CreateFeature('h', 'l', 'i', 'g', 1);
+    auto historical = description.HistoricalLigaturesState();
+    if (!letter_spacing && historical == enabled) {
+      Append(hlig);
+    }
+    // calt is on by default in HarfBuzz
+    constexpr hb_feature_t no_calt = CreateFeature('c', 'a', 'l', 't');
+    auto contextual = description.ContextualLigaturesState();
+    if (letter_spacing ||
+        (contextual == disabled || (contextual == normal && default_is_off))) {
+      Append(no_calt);
+    }
+  }
+
+  static constexpr hb_feature_t hwid = CreateFeature('h', 'w', 'i', 'd', 1);
+  static constexpr hb_feature_t twid = CreateFeature('t', 'w', 'i', 'd', 1);
+  static constexpr hb_feature_t qwid = CreateFeature('q', 'w', 'i', 'd', 1);
+  switch (description.WidthVariant()) {
+    case kHalfWidth:
+      Append(hwid);
+      break;
+    case kThirdWidth:
+      Append(twid);
+      break;
+    case kQuarterWidth:
+      Append(qwid);
+      break;
+    case kRegularWidth:
+      break;
+  }
+
+  // font-variant-east-asian:
+  const FontVariantEastAsian east_asian = description.VariantEastAsian();
+  if (UNLIKELY(!east_asian.IsAllNormal())) {
+    static constexpr hb_feature_t jp78 = CreateFeature('j', 'p', '7', '8', 1);
+    static constexpr hb_feature_t jp83 = CreateFeature('j', 'p', '8', '3', 1);
+    static constexpr hb_feature_t jp90 = CreateFeature('j', 'p', '9', '0', 1);
+    static constexpr hb_feature_t jp04 = CreateFeature('j', 'p', '0', '4', 1);
+    static constexpr hb_feature_t smpl = CreateFeature('s', 'm', 'p', 'l', 1);
+    static constexpr hb_feature_t trad = CreateFeature('t', 'r', 'a', 'd', 1);
+    switch (east_asian.Form()) {
+      case FontVariantEastAsian::kNormalForm:
+        break;
+      case FontVariantEastAsian::kJis78:
+        Append(jp78);
+        break;
+      case FontVariantEastAsian::kJis83:
+        Append(jp83);
+        break;
+      case FontVariantEastAsian::kJis90:
+        Append(jp90);
+        break;
+      case FontVariantEastAsian::kJis04:
+        Append(jp04);
+        break;
+      case FontVariantEastAsian::kSimplified:
+        Append(smpl);
+        break;
+      case FontVariantEastAsian::kTraditional:
+        Append(trad);
+        break;
+      default:
+        NOTREACHED();
+    }
+    static constexpr hb_feature_t fwid = CreateFeature('f', 'w', 'i', 'd', 1);
+    static constexpr hb_feature_t pwid = CreateFeature('p', 'w', 'i', 'd', 1);
+    switch (east_asian.Width()) {
+      case FontVariantEastAsian::kNormalWidth:
+        break;
+      case FontVariantEastAsian::kFullWidth:
+        Append(fwid);
+        break;
+      case FontVariantEastAsian::kProportionalWidth:
+        Append(pwid);
+        break;
+      default:
+        NOTREACHED();
+    }
+    static constexpr hb_feature_t ruby = CreateFeature('r', 'u', 'b', 'y', 1);
+    if (east_asian.Ruby())
+      Append(ruby);
+  }
+
+  // font-variant-numeric:
+  static constexpr hb_feature_t lnum = CreateFeature('l', 'n', 'u', 'm', 1);
+  if (description.VariantNumeric().NumericFigureValue() ==
+      FontVariantNumeric::kLiningNums)
+    Append(lnum);
+
+  static constexpr hb_feature_t onum = CreateFeature('o', 'n', 'u', 'm', 1);
+  if (description.VariantNumeric().NumericFigureValue() ==
+      FontVariantNumeric::kOldstyleNums)
+    Append(onum);
+
+  static constexpr hb_feature_t pnum = CreateFeature('p', 'n', 'u', 'm', 1);
+  if (description.VariantNumeric().NumericSpacingValue() ==
+      FontVariantNumeric::kProportionalNums)
+    Append(pnum);
+  static constexpr hb_feature_t tnum = CreateFeature('t', 'n', 'u', 'm', 1);
+  if (description.VariantNumeric().NumericSpacingValue() ==
+      FontVariantNumeric::kTabularNums)
+    Append(tnum);
+
+  static constexpr hb_feature_t afrc = CreateFeature('a', 'f', 'r', 'c', 1);
+  if (description.VariantNumeric().NumericFractionValue() ==
+      FontVariantNumeric::kStackedFractions)
+    Append(afrc);
+  static constexpr hb_feature_t frac = CreateFeature('f', 'r', 'a', 'c', 1);
+  if (description.VariantNumeric().NumericFractionValue() ==
+      FontVariantNumeric::kDiagonalFractions)
+    Append(frac);
+
+  static constexpr hb_feature_t ordn = CreateFeature('o', 'r', 'd', 'n', 1);
+  if (description.VariantNumeric().OrdinalValue() ==
+      FontVariantNumeric::kOrdinalOn)
+    Append(ordn);
+
+  static constexpr hb_feature_t zero = CreateFeature('z', 'e', 'r', 'o', 1);
+  if (description.VariantNumeric().SlashedZeroValue() ==
+      FontVariantNumeric::kSlashedZeroOn)
+    Append(zero);
+
+  const hb_tag_t chws_or_vchw =
+      is_horizontal ? HB_TAG('c', 'h', 'w', 's') : HB_TAG('v', 'c', 'h', 'w');
+  bool default_enable_chws = true;
+
+  const FontFeatureSettings* settings = description.FeatureSettings();
+  if (UNLIKELY(settings)) {
+    // TODO(drott): crbug.com/450619 Implement feature resolution instead of
+    // just appending the font-feature-settings.
+    const hb_tag_t halt_or_vhal =
+        is_horizontal ? HB_TAG('h', 'a', 'l', 't') : HB_TAG('v', 'h', 'a', 'l');
+    const hb_tag_t palt_or_vpal =
+        is_horizontal ? HB_TAG('p', 'a', 'l', 't') : HB_TAG('v', 'p', 'a', 'l');
+    for (const FontFeature& setting : *settings) {
+      const hb_feature_t feature =
+          CreateFeature(setting.Tag(), setting.Value());
+      Append(feature);
+
+      // `chws` should not be appended if other glyph-width GPOS feature exists.
+      if (default_enable_chws &&
+          (feature.tag == chws_or_vchw ||
+           (feature.value &&
+            (feature.tag == halt_or_vhal || feature.tag == palt_or_vpal))))
+        default_enable_chws = false;
+    }
+  }
+
+  if (default_enable_chws)
+    Append(CreateFeature(chws_or_vchw, 1));
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/font_features.h b/third_party/blink/renderer/platform/fonts/shaping/font_features.h
new file mode 100644
index 000000000000..e3411186185e
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/font_features.h
@@ -0,0 +1,47 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_FONT_FEATURES_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_FONT_FEATURES_H_
+
+#include <hb.h>
+
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/vector.h"
+
+namespace blink {
+
+class Font;
+class FontDescription;
+
+// Represents a list of OpenType font feature settings.
+class PLATFORM_EXPORT FontFeatures {
+  STACK_ALLOCATED();
+
+ public:
+  // Initialize the list from |Font|.
+  void Initialize(const FontDescription&);
+
+  wtf_size_t size() const { return features_.size(); }
+  bool IsEmpty() const { return features_.IsEmpty(); }
+
+  const hb_feature_t* data() const { return features_.data(); }
+
+  base::Optional<unsigned> FindValueForTesting(hb_tag_t tag) const;
+
+  void Append(const hb_feature_t& feature) { features_.push_back(feature); }
+  void Insert(const hb_feature_t& feature) { features_.push_front(feature); }
+
+  void EraseAt(wtf_size_t position, wtf_size_t length) {
+    features_.EraseAt(position, length);
+  }
+
+ private:
+  Vector<hb_feature_t, 6> features_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_FONT_FEATURES_H_
diff --git a/third_party/blink/renderer/platform/fonts/shaping/font_features_test.cc b/third_party/blink/renderer/platform/fonts/shaping/font_features_test.cc
new file mode 100644
index 000000000000..200cbb343f28
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/font_features_test.cc
@@ -0,0 +1,122 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/shaping/font_features.h"
+
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/fonts/font_description.h"
+
+namespace blink {
+
+namespace {
+
+class FontFeaturesTest : public testing::Test {};
+
+static const FontOrientation orientations[] = {
+    FontOrientation::kHorizontal,
+    FontOrientation::kVerticalRotated,
+    FontOrientation::kVerticalMixed,
+    FontOrientation::kVerticalUpright,
+};
+
+class FontFeaturesByOrientationTest
+    : public FontFeaturesTest,
+      public testing::WithParamInterface<FontOrientation> {
+ public:
+  FontOrientation GetOrientation() const { return GetParam(); }
+  bool IsHorizontal() const { return !IsVerticalAnyUpright(GetOrientation()); }
+};
+
+INSTANTIATE_TEST_SUITE_P(FontFeaturesTest,
+                         FontFeaturesByOrientationTest,
+                         testing::ValuesIn(orientations));
+
+// Test 'chws' or 'vchw' is on by default.
+TEST_P(FontFeaturesByOrientationTest, EastAsianContextualSpacingOnByDefault) {
+  constexpr hb_tag_t chws = HB_TAG('c', 'h', 'w', 's');
+  constexpr hb_tag_t vchw = HB_TAG('v', 'c', 'h', 'w');
+  FontDescription font_description;
+  font_description.SetOrientation(GetOrientation());
+  FontFeatures features;
+  features.Initialize(font_description);
+  if (IsHorizontal()) {
+    EXPECT_EQ(features.FindValueForTesting(chws), 1u);
+    EXPECT_EQ(features.FindValueForTesting(vchw), base::nullopt);
+  } else {
+    EXPECT_EQ(features.FindValueForTesting(chws), base::nullopt);
+    EXPECT_EQ(features.FindValueForTesting(vchw), 1u);
+  }
+}
+
+// If author opted-in or opted-out, it should be honored.
+TEST_P(FontFeaturesByOrientationTest,
+       EastAsianContextualSpacingHonorsFontFeatureSettings) {
+  constexpr hb_tag_t chws = HB_TAG('c', 'h', 'w', 's');
+  constexpr hb_tag_t vchw = HB_TAG('v', 'c', 'h', 'w');
+  for (unsigned value = 0; value <= 1; ++value) {
+    scoped_refptr<FontFeatureSettings> settings = FontFeatureSettings::Create();
+    settings->Append({IsHorizontal() ? chws : vchw, value});
+    FontDescription font_description;
+    font_description.SetOrientation(GetOrientation());
+    font_description.SetFeatureSettings(settings);
+    FontFeatures features;
+    features.Initialize(font_description);
+    if (IsHorizontal()) {
+      EXPECT_EQ(features.FindValueForTesting(chws), value);
+      EXPECT_EQ(features.FindValueForTesting(vchw), base::nullopt);
+    } else {
+      EXPECT_EQ(features.FindValueForTesting(chws), base::nullopt);
+      EXPECT_EQ(features.FindValueForTesting(vchw), value);
+    }
+  }
+}
+
+// Test glyph-width GPOS features that should not enable 'chws'/'vchw'.
+TEST_P(FontFeaturesByOrientationTest,
+       EastAsianContextualSpacingOffByFeatureSettings) {
+  constexpr hb_tag_t chws = HB_TAG('c', 'h', 'w', 's');
+  constexpr hb_tag_t vchw = HB_TAG('v', 'c', 'h', 'w');
+  const hb_tag_t tags[] = {
+      IsHorizontal() ? HB_TAG('h', 'a', 'l', 't') : HB_TAG('v', 'h', 'a', 'l'),
+      IsHorizontal() ? HB_TAG('p', 'a', 'l', 't') : HB_TAG('v', 'p', 'a', 'l'),
+  };
+  for (const hb_tag_t tag : tags) {
+    scoped_refptr<FontFeatureSettings> settings = FontFeatureSettings::Create();
+    settings->Append({tag, 1});
+    FontDescription font_description;
+    font_description.SetOrientation(GetOrientation());
+    font_description.SetFeatureSettings(settings);
+    FontFeatures features;
+    features.Initialize(font_description);
+    EXPECT_EQ(features.FindValueForTesting(chws), base::nullopt);
+    EXPECT_EQ(features.FindValueForTesting(vchw), base::nullopt);
+  }
+}
+
+// Test the current behavior when multiple glyph-width GPOS features are set via
+// `FontFeatureSettings`. Current |FontFeatures| does not resolve conflicts,
+// just pass them all as specified to HarfBuzz.
+TEST_P(FontFeaturesByOrientationTest, MultipleGlyphWidthGPOS) {
+  const hb_tag_t tags[] = {
+      HB_TAG('c', 'h', 'w', 's'), HB_TAG('v', 'c', 'h', 'w'),
+      HB_TAG('h', 'a', 'l', 't'), HB_TAG('v', 'h', 'a', 'l'),
+      HB_TAG('p', 'a', 'l', 't'), HB_TAG('v', 'p', 'a', 'l'),
+  };
+  scoped_refptr<FontFeatureSettings> settings = FontFeatureSettings::Create();
+  for (const hb_tag_t tag : tags)
+    settings->Append({tag, 1});
+  FontDescription font_description;
+  font_description.SetOrientation(GetOrientation());
+  font_description.SetFeatureSettings(settings);
+  FontFeatures features;
+  features.Initialize(font_description);
+  // Check all features are enabled.
+  for (const hb_tag_t tag : tags)
+    EXPECT_EQ(features.FindValueForTesting(tag), 1u);
+}
+
+}  // namespace
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/glyph_bounds_accumulator.h b/third_party/blink/renderer/platform/fonts/shaping/glyph_bounds_accumulator.h
new file mode 100644
index 000000000000..10d4f23588a9
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/glyph_bounds_accumulator.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2012 Google Inc. All rights reserved.
+ * Copyright (C) 2013 BlackBerry Limited. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_GLYPH_BOUNDS_ACCUMULATOR_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_GLYPH_BOUNDS_ACCUMULATOR_H_
+
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h"
+#include "third_party/blink/renderer/platform/geometry/float_rect.h"
+
+namespace blink {
+
+// Helper class to accumulate glyph bounding box.
+//
+// Glyph positions and bounding boxes from HarfBuzz and fonts are in physical
+// coordinate, while ShapeResult::glyph_bounding_box_ is in logical coordinate.
+// To minimize the number of conversions, this class accumulates the bounding
+// boxes in physical coordinate, and convert the accumulated box to logical.
+struct GlyphBoundsAccumulator {
+  // Construct an accumulator with the logical glyph origin.
+  explicit GlyphBoundsAccumulator(float origin) : origin(origin) {}
+
+  // The accumulated glyph bounding box in physical coordinate, until
+  // ConvertVerticalRunToLogical().
+  FloatRect bounds;
+  // The current origin, in logical coordinate.
+  float origin;
+
+  // Unite a glyph bounding box to |bounds|.
+  template <bool is_horizontal_run>
+  void Unite(FloatRect bounds_for_glyph,
+             ShapeResult::GlyphOffset glyph_offset) {
+    if (UNLIKELY(bounds_for_glyph.IsEmpty()))
+      return;
+
+    // Glyphs are drawn at |origin + offset|. Move glyph_bounds to that point.
+    // All positions in hb_glyph_position_t are relative to the current point.
+    // https://behdad.github.io/harfbuzz/harfbuzz-Buffers.html#hb-glyph-position-t-struct
+    if (is_horizontal_run)
+      bounds_for_glyph.SetX(bounds_for_glyph.X() + origin);
+    else
+      bounds_for_glyph.SetY(bounds_for_glyph.Y() + origin);
+    bounds_for_glyph.Move(glyph_offset);
+
+    bounds.Unite(bounds_for_glyph);
+  }
+
+  // Non-template version of |Unite()|, see above.
+  void Unite(bool is_horizontal_run,
+             FloatRect bounds_for_glyph,
+             ShapeResult::GlyphOffset glyph_offset) {
+    is_horizontal_run ? Unite<true>(bounds_for_glyph, glyph_offset)
+                      : Unite<false>(bounds_for_glyph, glyph_offset);
+  }
+
+  // Convert vertical run glyph bounding box to logical. Horizontal runs do not
+  // need conversions because physical and logical are the same.
+  void ConvertVerticalRunToLogical(const FontMetrics& font_metrics) {
+    // Convert physical glyph_bounding_box to logical.
+    bounds = bounds.TransposedRect();
+
+    // The glyph bounding box of a vertical run uses ideographic baseline.
+    // Adjust the box Y position because the bounding box of a ShapeResult uses
+    // alphabetic baseline.
+    // See diagrams of base lines at
+    // https://drafts.csswg.org/css-writing-modes-3/#intro-baselines
+    int baseline_adjust = font_metrics.Ascent(kIdeographicBaseline) -
+                          font_metrics.Ascent(kAlphabeticBaseline);
+    bounds.SetY(bounds.Y() + baseline_adjust);
+  }
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_GLYPH_BOUNDS_ACCUMULATOR_H_
diff --git a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.cc b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.cc
index 264a94398a98..f8cff9f1d2d3 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.cc
@@ -30,6 +30,11 @@
 
 #include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h"
 
+// clang-format off
+#include <hb.h>
+#include <hb-ot.h>
+// clang-format on
+
 #include <memory>
 
 #include "build/build_config.h"
@@ -37,58 +42,59 @@
 #include "third_party/blink/renderer/platform/fonts/font_global_context.h"
 #include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_cache.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_data.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
 #include "third_party/blink/renderer/platform/fonts/skia/skia_text_metrics.h"
 #include "third_party/blink/renderer/platform/fonts/unicode_range_set.h"
-#include "third_party/blink/renderer/platform/histogram.h"
 #include "third_party/blink/renderer/platform/resolution_units.h"
 #include "third_party/blink/renderer/platform/wtf/hash_map.h"
 #include "third_party/blink/renderer/platform/wtf/math_extras.h"
-
-#include <hb-ot.h>
-#include <hb.h>
-#if defined(OS_MACOSX)
-#include <hb-coretext.h>
-#endif
-
-#include <SkPaint.h>
-#include <SkPath.h>
-#include <SkPoint.h>
-#include <SkRect.h>
-#include <SkStream.h>
-#include <SkTypeface.h>
+#include "third_party/blink/renderer/platform/wtf/std_lib_extras.h"
+#include "third_party/harfbuzz-ng/utils/hb_scoped.h"
+#include "third_party/skia/include/core/SkPaint.h"
+#include "third_party/skia/include/core/SkPath.h"
+#include "third_party/skia/include/core/SkPoint.h"
+#include "third_party/skia/include/core/SkRect.h"
+#include "third_party/skia/include/core/SkStream.h"
+#include "third_party/skia/include/core/SkTypeface.h"
 
 namespace blink {
 
-void HbFontDeleter::operator()(hb_font_t* font) {
-  if (font)
-    hb_font_destroy(font);
-}
+namespace {
 
-void HbFaceDeleter::operator()(hb_face_t* face) {
-  if (face)
-    hb_face_destroy(face);
-}
+#if defined(OS_MAC)
+void DetermineTrakSbix(SkTypeface* typeface, bool* has_trak, bool* has_sbix) {
+  int num_tags = typeface->countTables();
 
-struct HbSetDeleter {
-  void operator()(hb_set_t* set) {
-    if (set)
-      hb_set_destroy(set);
+  SkFontTableTag tags[num_tags];
+
+  int returned_tags = typeface->getTableTags(tags);
+  DCHECK_EQ(num_tags, returned_tags);
+
+  for (auto& tag : tags) {
+    if (tag == SkSetFourByteTag('t', 'r', 'a', 'k'))
+      *has_trak = true;
+    if (tag == SkSetFourByteTag('s', 'b', 'i', 'x'))
+      *has_sbix = true;
   }
-};
+}
+#endif
 
-using HbSetUniquePtr = std::unique_ptr<hb_set_t, HbSetDeleter>;
+}  // namespace
 
-static scoped_refptr<HbFontCacheEntry> CreateHbFontCacheEntry(hb_face_t*);
+static scoped_refptr<HbFontCacheEntry> CreateHbFontCacheEntry(
+    hb_face_t*,
+    SkTypeface* typefaces);
 
 HarfBuzzFace::HarfBuzzFace(FontPlatformData* platform_data, uint64_t unique_id)
     : platform_data_(platform_data), unique_id_(unique_id) {
   HarfBuzzFontCache::AddResult result =
-      FontGlobalContext::GetHarfBuzzFontCache().insert(unique_id_, nullptr);
+      FontGlobalContext::GetHarfBuzzFontCache()->insert(unique_id_, nullptr);
   if (result.is_new_entry) {
-    HbFaceUniquePtr face(CreateFace());
-    result.stored_value->value = CreateHbFontCacheEntry(face.get());
+    HbScoped<hb_face_t> face(CreateFace());
+    result.stored_value->value =
+        CreateHbFontCacheEntry(face.get(), platform_data->Typeface());
   }
   result.stored_value->value->AddRef();
   unscaled_font_ = result.stored_value->value->HbFont();
@@ -96,13 +102,14 @@ HarfBuzzFace::HarfBuzzFace(FontPlatformData* platform_data, uint64_t unique_id)
 }
 
 HarfBuzzFace::~HarfBuzzFace() {
-  HarfBuzzFontCache::iterator result =
-      FontGlobalContext::GetHarfBuzzFontCache().find(unique_id_);
-  SECURITY_DCHECK(result != FontGlobalContext::GetHarfBuzzFontCache().end());
+  HarfBuzzFontCache* harfbuzz_font_cache =
+      FontGlobalContext::GetHarfBuzzFontCache();
+  HarfBuzzFontCache::iterator result = harfbuzz_font_cache->find(unique_id_);
+  SECURITY_DCHECK(result != harfbuzz_font_cache->end());
   DCHECK(!result.Get()->value->HasOneRef());
   result.Get()->value->Release();
   if (result.Get()->value->HasOneRef())
-    FontGlobalContext::GetHarfBuzzFontCache().erase(unique_id_);
+    harfbuzz_font_cache->erase(unique_id_);
 }
 
 static hb_bool_t HarfBuzzGetGlyph(hb_font_t* hb_font,
@@ -122,6 +129,14 @@ static hb_bool_t HarfBuzzGetGlyph(hb_font_t* hb_font,
                            variation_selector, glyph);
 }
 
+static hb_bool_t HarfBuzzGetNominalGlyph(hb_font_t* hb_font,
+                                         void* font_data,
+                                         hb_codepoint_t unicode,
+                                         hb_codepoint_t* glyph,
+                                         void* user_data) {
+  return HarfBuzzGetGlyph(hb_font, font_data, unicode, 0, glyph, user_data);
+}
+
 static hb_position_t HarfBuzzGetGlyphHorizontalAdvance(hb_font_t* hb_font,
                                                        void* font_data,
                                                        hb_codepoint_t glyph,
@@ -130,11 +145,25 @@ static hb_position_t HarfBuzzGetGlyphHorizontalAdvance(hb_font_t* hb_font,
       reinterpret_cast<HarfBuzzFontData*>(font_data);
   hb_position_t advance = 0;
 
-  SkiaTextMetrics(&hb_font_data->paint_)
-      .GetGlyphWidthForHarfBuzz(glyph, &advance);
+  SkFontGetGlyphWidthForHarfBuzz(hb_font_data->font_, glyph, &advance);
   return advance;
 }
 
+static void HarfBuzzGetGlyphHorizontalAdvances(
+    hb_font_t* font,
+    void* font_data,
+    unsigned count,
+    const hb_codepoint_t* first_glyph,
+    unsigned int glyph_stride,
+    hb_position_t* first_advance,
+    unsigned int advance_stride,
+    void* user_data) {
+  HarfBuzzFontData* hb_font_data =
+      reinterpret_cast<HarfBuzzFontData*>(font_data);
+  SkFontGetGlyphWidthForHarfBuzz(hb_font_data->font_, count, first_glyph,
+                                 glyph_stride, first_advance, advance_stride);
+}
+
 static hb_bool_t HarfBuzzGetGlyphVerticalOrigin(hb_font_t* hb_font,
                                                 void* font_data,
                                                 hb_codepoint_t glyph,
@@ -150,10 +179,10 @@ static hb_bool_t HarfBuzzGetGlyphVerticalOrigin(hb_font_t* hb_font,
 
   float result[] = {0, 0};
   Glyph the_glyph = glyph;
-  vertical_data->GetVerticalTranslationsForGlyphs(hb_font_data->paint_,
+  vertical_data->GetVerticalTranslationsForGlyphs(hb_font_data->font_,
                                                   &the_glyph, 1, result);
-  *x = SkiaTextMetrics::SkiaScalarToHarfBuzzPosition(-result[0]);
-  *y = SkiaTextMetrics::SkiaScalarToHarfBuzzPosition(-result[1]);
+  *x = SkiaScalarToHarfBuzzPosition(-result[0]);
+  *y = SkiaScalarToHarfBuzzPosition(-result[1]);
   return true;
 }
 
@@ -166,43 +195,12 @@ static hb_position_t HarfBuzzGetGlyphVerticalAdvance(hb_font_t* hb_font,
   scoped_refptr<OpenTypeVerticalData> vertical_data =
       hb_font_data->VerticalData();
   if (!vertical_data) {
-    return SkiaTextMetrics::SkiaScalarToHarfBuzzPosition(
-        hb_font_data->height_fallback_);
+    return SkiaScalarToHarfBuzzPosition(hb_font_data->height_fallback_);
   }
 
   Glyph the_glyph = glyph;
   float advance_height = -vertical_data->AdvanceHeight(the_glyph);
-  return SkiaTextMetrics::SkiaScalarToHarfBuzzPosition(
-      SkFloatToScalar(advance_height));
-}
-
-static hb_position_t HarfBuzzGetGlyphHorizontalKerning(
-    hb_font_t*,
-    void* font_data,
-    hb_codepoint_t left_glyph,
-    hb_codepoint_t right_glyph,
-    void*) {
-  HarfBuzzFontData* hb_font_data =
-      reinterpret_cast<HarfBuzzFontData*>(font_data);
-  if (hb_font_data->paint_.isVerticalText()) {
-    // We don't support cross-stream kerning
-    return 0;
-  }
-
-  SkTypeface* typeface = hb_font_data->paint_.getTypeface();
-
-  const uint16_t glyphs[2] = {static_cast<uint16_t>(left_glyph),
-                              static_cast<uint16_t>(right_glyph)};
-  int32_t kerning_adjustments[1] = {0};
-
-  if (typeface->getKerningPairAdjustments(glyphs, 2, kerning_adjustments)) {
-    SkScalar upm = SkIntToScalar(typeface->getUnitsPerEm());
-    SkScalar size = hb_font_data->paint_.getTextSize();
-    return SkiaTextMetrics::SkiaScalarToHarfBuzzPosition(
-        SkIntToScalar(kerning_adjustments[0]) * size / upm);
-  }
-
-  return 0;
+  return SkiaScalarToHarfBuzzPosition(SkFloatToScalar(advance_height));
 }
 
 static hb_bool_t HarfBuzzGetGlyphExtents(hb_font_t* hb_font,
@@ -213,8 +211,7 @@ static hb_bool_t HarfBuzzGetGlyphExtents(hb_font_t* hb_font,
   HarfBuzzFontData* hb_font_data =
       reinterpret_cast<HarfBuzzFontData*>(font_data);
 
-  SkiaTextMetrics(&hb_font_data->paint_)
-      .GetGlyphExtentsForHarfBuzz(glyph, extents);
+  SkFontGetGlyphExtentsForHarfBuzz(hb_font_data->font_, glyph, extents);
   return true;
 }
 
@@ -240,7 +237,7 @@ bool HarfBuzzFace::HasSpaceInLigaturesOrKerning(TypesettingFeatures features) {
   const hb_codepoint_t kInvalidCodepoint = static_cast<hb_codepoint_t>(-1);
   hb_codepoint_t space = kInvalidCodepoint;
 
-  HbSetUniquePtr glyphs(hb_set_create());
+  HbScoped<hb_set_t> glyphs(hb_set_create());
 
   // Check whether computing is needed and compute for gpos/gsub.
   if (features & kKerning &&
@@ -289,29 +286,46 @@ unsigned HarfBuzzFace::UnitsPerEmFromHeadTable() {
 }
 
 bool HarfBuzzFace::ShouldSubpixelPosition() {
-  return harfbuzz_font_data_->paint_.isSubpixelText();
+  return harfbuzz_font_data_->font_.isSubpixel();
 }
 
-static hb_font_funcs_t* HarfBuzzSkiaGetFontFuncs() {
-  hb_font_funcs_t* funcs = FontGlobalContext::GetHarfBuzzFontFuncs();
+static hb_font_funcs_t* create_populated_hb_font_funcs(
+    FontGlobalContext::HorizontalAdvanceSource horizontal_advance_source) {
+  hb_font_funcs_t* funcs = hb_font_funcs_create();
+
+  if (horizontal_advance_source == FontGlobalContext::kSkiaHorizontalAdvances) {
+    hb_font_funcs_set_glyph_h_advance_func(
+        funcs, HarfBuzzGetGlyphHorizontalAdvance, nullptr, nullptr);
+    hb_font_funcs_set_glyph_h_advances_func(
+        funcs, HarfBuzzGetGlyphHorizontalAdvances, nullptr, nullptr);
+  }
+  hb_font_funcs_set_variation_glyph_func(funcs, HarfBuzzGetGlyph, nullptr,
+                                         nullptr);
+  hb_font_funcs_set_nominal_glyph_func(funcs, HarfBuzzGetNominalGlyph, nullptr,
+                                       nullptr);
+  // TODO(https://crbug.com/899718): Replace vertical metrics callbacks with
+  // HarfBuzz VORG/VMTX internal implementation by deregistering those.
+  hb_font_funcs_set_glyph_v_advance_func(funcs, HarfBuzzGetGlyphVerticalAdvance,
+                                         nullptr, nullptr);
+  hb_font_funcs_set_glyph_v_origin_func(funcs, HarfBuzzGetGlyphVerticalOrigin,
+                                        nullptr, nullptr);
+  hb_font_funcs_set_glyph_extents_func(funcs, HarfBuzzGetGlyphExtents, nullptr,
+                                       nullptr);
+
+  hb_font_funcs_make_immutable(funcs);
+  return funcs;
+}
+
+static hb_font_funcs_t* HarfBuzzSkiaGetFontFuncs(
+    FontGlobalContext::HorizontalAdvanceSource advance_source) {
+  hb_font_funcs_t* funcs =
+      FontGlobalContext::GetHarfBuzzFontFuncs(advance_source);
 
   // We don't set callback functions which we can't support.
   // HarfBuzz will use the fallback implementation if they aren't set.
   if (!funcs) {
-    funcs = hb_font_funcs_create();
-    hb_font_funcs_set_glyph_func(funcs, HarfBuzzGetGlyph, nullptr, nullptr);
-    hb_font_funcs_set_glyph_h_advance_func(
-        funcs, HarfBuzzGetGlyphHorizontalAdvance, nullptr, nullptr);
-    hb_font_funcs_set_glyph_h_kerning_func(
-        funcs, HarfBuzzGetGlyphHorizontalKerning, nullptr, nullptr);
-    hb_font_funcs_set_glyph_v_advance_func(
-        funcs, HarfBuzzGetGlyphVerticalAdvance, nullptr, nullptr);
-    hb_font_funcs_set_glyph_v_origin_func(funcs, HarfBuzzGetGlyphVerticalOrigin,
-                                          nullptr, nullptr);
-    hb_font_funcs_set_glyph_extents_func(funcs, HarfBuzzGetGlyphExtents,
-                                         nullptr, nullptr);
-    hb_font_funcs_make_immutable(funcs);
-    FontGlobalContext::SetHarfBuzzFontFuncs(funcs);
+    funcs = create_populated_hb_font_funcs(advance_source);
+    FontGlobalContext::SetHarfBuzzFontFuncs(advance_source, funcs);
   }
   DCHECK(funcs);
   return funcs;
@@ -322,7 +336,8 @@ static hb_blob_t* HarfBuzzSkiaGetTable(hb_face_t* face,
                                        void* user_data) {
   SkTypeface* typeface = reinterpret_cast<SkTypeface*>(user_data);
 
-  const size_t table_size = typeface->getTableSize(tag);
+  const wtf_size_t table_size =
+      SafeCast<wtf_size_t>(typeface->getTableSize(tag));
   if (!table_size) {
     return nullptr;
   }
@@ -341,64 +356,80 @@ static hb_blob_t* HarfBuzzSkiaGetTable(hb_face_t* face,
                         WTF::Partitions::FastFree);
 }
 
+#if !defined(OS_MAC)
 static void DeleteTypefaceStream(void* stream_asset_ptr) {
   SkStreamAsset* stream_asset =
       reinterpret_cast<SkStreamAsset*>(stream_asset_ptr);
   delete stream_asset;
 }
+#endif
 
 hb_face_t* HarfBuzzFace::CreateFace() {
-#if defined(OS_MACOSX)
-  // hb_face_t needs to be instantiated using the CoreText constructor for
-  // compatibility with AAT font, in which case HarfBuzz' CoreText backend is
-  // used. If we encounter a FreeType backed SkTypeface, for variable fonts on
-  // Mac OS < 10.12, follow the regular OpenType-only codepath below.
-  if (platform_data_->CgFont()) {
-    hb_face_t* face = hb_coretext_face_create(platform_data_->CgFont());
-    DCHECK(face);
-    return face;
-  }
-#endif
   hb_face_t* face = nullptr;
 
-  DEFINE_THREAD_SAFE_STATIC_LOCAL(BooleanHistogram, zero_copy_success_histogram,
-                                  ("Blink.Fonts.HarfBuzzFaceZeroCopyAccess"));
   SkTypeface* typeface = platform_data_->Typeface();
   CHECK(typeface);
+  // The attempt of doing zero copy-mmaped memory access to the font blobs does
+  // not work efficiently on Mac, since what is returned from
+  // typeface->openStream is a synthesized font assembled from copying all font
+  // tables on Mac. See the implementation of SkTypeface_Mac::onOpenStream.
+#if !defined(OS_MAC)
   int ttc_index = 0;
-  SkStreamAsset* typeface_stream = typeface->openStream(&ttc_index);
-  if (typeface_stream && typeface_stream->getMemoryBase()) {
-    std::unique_ptr<hb_blob_t, void (*)(hb_blob_t*)> face_blob(
-        hb_blob_create(
-            reinterpret_cast<const char*>(typeface_stream->getMemoryBase()),
-            typeface_stream->getLength(), HB_MEMORY_MODE_READONLY,
-            typeface_stream, DeleteTypefaceStream),
-        hb_blob_destroy);
+  std::unique_ptr<SkStreamAsset> tf_stream(typeface->openStream(&ttc_index));
+  if (tf_stream && tf_stream->getMemoryBase()) {
+    const void* tf_memory = tf_stream->getMemoryBase();
+    size_t tf_size = tf_stream->getLength();
+    HbScoped<hb_blob_t> face_blob(
+        hb_blob_create(reinterpret_cast<const char*>(tf_memory),
+                       SafeCast<unsigned int>(tf_size), HB_MEMORY_MODE_READONLY,
+                       tf_stream.release(), DeleteTypefaceStream));
     face = hb_face_create(face_blob.get(), ttc_index);
   }
+#endif
 
   // Fallback to table copies if there is no in-memory access.
   if (!face) {
     face = hb_face_create_for_tables(HarfBuzzSkiaGetTable,
                                      platform_data_->Typeface(), nullptr);
-    zero_copy_success_histogram.Count(false);
-  } else {
-    zero_copy_success_histogram.Count(true);
   }
 
   DCHECK(face);
   return face;
 }
 
-scoped_refptr<HbFontCacheEntry> CreateHbFontCacheEntry(hb_face_t* face) {
-  HbFontUniquePtr ot_font(hb_font_create(face));
+scoped_refptr<HbFontCacheEntry> CreateHbFontCacheEntry(hb_face_t* face,
+                                                       SkTypeface* typeface) {
+  HbScoped<hb_font_t> ot_font(hb_font_create(face));
   hb_ot_font_set_funcs(ot_font.get());
+
+  int axis_count = typeface->getVariationDesignPosition(nullptr, 0);
+  if (axis_count > 0) {
+    Vector<SkFontArguments::VariationPosition::Coordinate> axis_values;
+    axis_values.resize(axis_count);
+    if (typeface->getVariationDesignPosition(axis_values.data(),
+                                             axis_values.size()) > 0) {
+      hb_font_set_variations(
+          ot_font.get(), reinterpret_cast<hb_variation_t*>(axis_values.data()),
+          axis_values.size());
+    }
+  }
+
   // Creating a sub font means that non-available functions
   // are found from the parent.
   hb_font_t* unscaled_font = hb_font_create_sub_font(ot_font.get());
   scoped_refptr<HbFontCacheEntry> cache_entry =
       HbFontCacheEntry::Create(unscaled_font);
-  hb_font_set_funcs(unscaled_font, HarfBuzzSkiaGetFontFuncs(),
+
+  FontGlobalContext::HorizontalAdvanceSource advance_source =
+      FontGlobalContext::kSkiaHorizontalAdvances;
+#if defined(OS_MAC)
+  bool has_trak = false;
+  bool has_sbix = false;
+  DetermineTrakSbix(typeface, &has_trak, &has_sbix);
+  if (has_trak && !has_sbix)
+    advance_source = FontGlobalContext::kHarfBuzzHorizontalAdvances;
+#endif
+  hb_font_set_funcs(unscaled_font, HarfBuzzSkiaGetFontFuncs(advance_source),
                     cache_entry->HbFontData(), nullptr);
   return cache_entry;
 }
@@ -417,30 +448,19 @@ static_assert(
 hb_font_t* HarfBuzzFace::GetScaledFont(
     scoped_refptr<UnicodeRangeSet> range_set,
     VerticalLayoutCallbacks vertical_layout) const {
-  PaintFont paint_font;
-  platform_data_->SetupPaintFont(&paint_font);
-  paint_font.SetTextEncoding(SkPaint::kGlyphID_TextEncoding);
   harfbuzz_font_data_->range_set_ = std::move(range_set);
-  harfbuzz_font_data_->UpdateFallbackMetricsAndScale(
-      *platform_data_, paint_font.ToSkPaint(), vertical_layout);
+  harfbuzz_font_data_->UpdateFallbackMetricsAndScale(*platform_data_,
+                                                     vertical_layout);
 
-  int scale =
-      SkiaTextMetrics::SkiaScalarToHarfBuzzPosition(platform_data_->size());
+  int scale = SkiaScalarToHarfBuzzPosition(platform_data_->size());
   hb_font_set_scale(unscaled_font_, scale, scale);
-  hb_font_set_ptem(unscaled_font_, platform_data_->size() / kCssPixelsPerPoint);
-
-  SkTypeface* typeface = harfbuzz_font_data_->paint_.getTypeface();
-  int axis_count = typeface->getVariationDesignPosition(nullptr, 0);
-  if (axis_count > 0) {
-    Vector<SkFontArguments::VariationPosition::Coordinate> axis_values;
-    axis_values.resize(axis_count);
-    if (typeface->getVariationDesignPosition(axis_values.data(),
-                                             axis_values.size()) > 0) {
-      hb_font_set_variations(
-          unscaled_font_, reinterpret_cast<hb_variation_t*>(axis_values.data()),
-          axis_values.size());
-    }
-  }
+  // See contended discussion in https://github.com/harfbuzz/harfbuzz/pull/1484
+  // Setting ptem here is critical for HarfBuzz to know where to lookup spacing
+  // offset in the AAT trak table, the unit pt in ptem here means "CoreText"
+  // points. After discussion on the pull request and with Apple developers, the
+  // meaning of HarfBuzz' hb_font_set_ptem API was changed to expect the
+  // equivalent of CSS pixels here.
+  hb_font_set_ptem(unscaled_font_, platform_data_->size());
 
   return unscaled_font_;
 }
diff --git a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h
index a2343852a90e..64437e3bafa6 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h
@@ -31,12 +31,12 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_HARFBUZZ_FACE_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_HARFBUZZ_FACE_H_
 
+#include "base/macros.h"
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/platform/fonts/typesetting_features.h"
 #include "third_party/blink/renderer/platform/fonts/unicode_range_set.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/hash_map.h"
-#include "third_party/blink/renderer/platform/wtf/noncopyable.h"
 #include "third_party/blink/renderer/platform/wtf/ref_counted.h"
 #include "third_party/blink/renderer/platform/wtf/text/character_names.h"
 
@@ -48,8 +48,6 @@ class FontPlatformData;
 struct HarfBuzzFontData;
 
 class HarfBuzzFace : public RefCounted<HarfBuzzFace> {
-  WTF_MAKE_NONCOPYABLE(HarfBuzzFace);
-
  public:
   static scoped_refptr<HarfBuzzFace> Create(FontPlatformData* platform_data,
                                             uint64_t unique_id) {
@@ -80,6 +78,8 @@ class HarfBuzzFace : public RefCounted<HarfBuzzFace> {
   uint64_t unique_id_;
   hb_font_t* unscaled_font_;
   HarfBuzzFontData* harfbuzz_font_data_;
+
+  DISALLOW_COPY_AND_ASSIGN(HarfBuzzFace);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_cache.cc b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_cache.cc
new file mode 100644
index 000000000000..40ad779aaeda
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_cache.cc
@@ -0,0 +1,20 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_cache.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_data.h"
+
+namespace blink {
+
+HbFontCacheEntry::HbFontCacheEntry(hb_font_t* font)
+    : hb_font_(HbScoped<hb_font_t>(font)),
+      hb_font_data_(std::make_unique<HarfBuzzFontData>()) {}
+
+HbFontCacheEntry::~HbFontCacheEntry() = default;
+
+scoped_refptr<HbFontCacheEntry> HbFontCacheEntry::Create(hb_font_t* hb_font) {
+  DCHECK(hb_font);
+  return base::AdoptRef(new HbFontCacheEntry(hb_font));
+}
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_cache.h b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_cache.h
index 83865f784bba..d8526a9352ab 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_cache.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_cache.h
@@ -5,114 +5,17 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_HARFBUZZ_FONT_CACHE_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_HARFBUZZ_FONT_CACHE_H_
 
-#include <memory>
-#include "third_party/blink/renderer/platform/fonts/font_metrics.h"
-#include "third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data.h"
-#include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h"
-#include "third_party/blink/renderer/platform/fonts/unicode_range_set.h"
-#include "third_party/blink/renderer/platform/wtf/assertions.h"
+#include <hb.h>
 
-struct hb_font_t;
-struct hb_face_t;
+#include <memory>
+
+#include "third_party/blink/renderer/platform/fonts/font_metrics.h"
+#include "third_party/blink/renderer/platform/fonts/unicode_range_set.h"
+#include "third_party/harfbuzz-ng/utils/hb_scoped.h"
 
 namespace blink {
 
-struct HbFontDeleter {
-  void operator()(hb_font_t* font);
-};
-
-using HbFontUniquePtr = std::unique_ptr<hb_font_t, HbFontDeleter>;
-
-struct HbFaceDeleter {
-  void operator()(hb_face_t* face);
-};
-
-using HbFaceUniquePtr = std::unique_ptr<hb_face_t, HbFaceDeleter>;
-
-const unsigned kInvalidFallbackMetricsValue = static_cast<unsigned>(-1);
-
-// struct to carry user-pointer data for hb_font_t callback
-// functions/operations, that require information related to a font scaled to a
-// particular size.
-struct HarfBuzzFontData {
-  USING_FAST_MALLOC(HarfBuzzFontData);
-  WTF_MAKE_NONCOPYABLE(HarfBuzzFontData);
-
- public:
-  HarfBuzzFontData()
-      : paint_(),
-        space_in_gpos_(SpaceGlyphInOpenTypeTables::Unknown),
-        space_in_gsub_(SpaceGlyphInOpenTypeTables::Unknown),
-        vertical_data_(nullptr),
-        range_set_(nullptr) {}
-
-  // The vertical origin and vertical advance functions in HarfBuzzFace require
-  // the ascent and height metrics as fallback in case no specific vertical
-  // layout information is found from the font.
-  void UpdateFallbackMetricsAndScale(
-      const FontPlatformData& platform_data,
-      const SkPaint& paint,
-      HarfBuzzFace::VerticalLayoutCallbacks vertical_layout) {
-    float ascent = 0;
-    float descent = 0;
-    unsigned dummy_ascent_inflation = 0;
-    unsigned dummy_descent_inflation = 0;
-
-    paint_ = paint;
-
-    if (UNLIKELY(vertical_layout == HarfBuzzFace::PrepareForVerticalLayout)) {
-      FontMetrics::AscentDescentWithHacks(
-          ascent, descent, dummy_ascent_inflation, dummy_descent_inflation,
-          platform_data, paint);
-      ascent_fallback_ = ascent;
-      // Simulate the rounding that FontMetrics does so far for returning the
-      // integer Height()
-      height_fallback_ = lroundf(ascent) + lroundf(descent);
-
-      int units_per_em =
-          platform_data.GetHarfBuzzFace()->UnitsPerEmFromHeadTable();
-      if (!units_per_em) {
-        DLOG(ERROR)
-            << "Units per EM is 0 for font used in vertical writing mode.";
-      }
-      size_per_unit_ = platform_data.size() / (units_per_em ? units_per_em : 1);
-    } else {
-      ascent_fallback_ = kInvalidFallbackMetricsValue;
-      height_fallback_ = kInvalidFallbackMetricsValue;
-      size_per_unit_ = kInvalidFallbackMetricsValue;
-    }
-  }
-
-  scoped_refptr<OpenTypeVerticalData> VerticalData() {
-    if (!vertical_data_) {
-      DCHECK_NE(ascent_fallback_, kInvalidFallbackMetricsValue);
-      DCHECK_NE(height_fallback_, kInvalidFallbackMetricsValue);
-      DCHECK_NE(size_per_unit_, kInvalidFallbackMetricsValue);
-
-      vertical_data_ =
-          OpenTypeVerticalData::CreateUnscaled(paint_.refTypeface());
-    }
-    vertical_data_->SetScaleAndFallbackMetrics(size_per_unit_, ascent_fallback_,
-                                               height_fallback_);
-    return vertical_data_;
-  }
-
-  SkPaint paint_;
-
-  // Capture these scaled fallback metrics from FontPlatformData so that a
-  // OpenTypeVerticalData object can be constructed from them when needed.
-  float size_per_unit_;
-  float ascent_fallback_;
-  float height_fallback_;
-
-  enum class SpaceGlyphInOpenTypeTables { Unknown, Present, NotPresent };
-
-  SpaceGlyphInOpenTypeTables space_in_gpos_;
-  SpaceGlyphInOpenTypeTables space_in_gsub_;
-
-  scoped_refptr<OpenTypeVerticalData> vertical_data_;
-  scoped_refptr<UnicodeRangeSet> range_set_;
-};
+struct HarfBuzzFontData;
 
 // Though we have FontCache class, which provides the cache mechanism for
 // WebKit's font objects, we also need additional caching layer for HarfBuzz to
@@ -122,29 +25,30 @@ struct HarfBuzzFontData {
 // FIXME, crbug.com/609099: We should fix the FontCache to only keep one
 // FontPlatformData object independent of size, then consider using this here.
 class HbFontCacheEntry : public RefCounted<HbFontCacheEntry> {
+  USING_FAST_MALLOC(HbFontCacheEntry);
+
  public:
-  static scoped_refptr<HbFontCacheEntry> Create(hb_font_t* hb_font) {
-    DCHECK(hb_font);
-    return base::AdoptRef(new HbFontCacheEntry(hb_font));
-  }
+  static scoped_refptr<HbFontCacheEntry> Create(hb_font_t* hb_font);
 
   hb_font_t* HbFont() { return hb_font_.get(); }
   HarfBuzzFontData* HbFontData() { return hb_font_data_.get(); }
 
- private:
-  explicit HbFontCacheEntry(hb_font_t* font)
-      : hb_font_(HbFontUniquePtr(font)),
-        hb_font_data_(std::make_unique<HarfBuzzFontData>()){};
+  ~HbFontCacheEntry();
 
-  HbFontUniquePtr hb_font_;
+ private:
+  explicit HbFontCacheEntry(hb_font_t* font);
+
+  HbScoped<hb_font_t> hb_font_;
   std::unique_ptr<HarfBuzzFontData> hb_font_data_;
 };
 
-typedef HashMap<uint64_t,
-                scoped_refptr<HbFontCacheEntry>,
-                WTF::IntHash<uint64_t>,
-                WTF::UnsignedWithZeroKeyHashTraits<uint64_t>>
-    HarfBuzzFontCache;
+// Declare as derived class in order to be able to forward-declare it as class
+// in FontGlobalContext.
+class HarfBuzzFontCache
+    : public HashMap<uint64_t,
+                     scoped_refptr<HbFontCacheEntry>,
+                     WTF::IntHash<uint64_t>,
+                     WTF::UnsignedWithZeroKeyHashTraits<uint64_t>> {};
 
 }  // namespace blink
 
diff --git a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_data.h b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_data.h
new file mode 100644
index 000000000000..b1e5bb07ef2b
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_font_data.h
@@ -0,0 +1,115 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_HARFBUZZ_FONT_DATA_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_HARFBUZZ_FONT_DATA_H_
+
+#include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
+#include "third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h"
+#include "third_party/blink/renderer/platform/wtf/assertions.h"
+#include "third_party/skia/include/core/SkFont.h"
+
+struct hb_font_t;
+
+namespace blink {
+
+const unsigned kInvalidFallbackMetricsValue = static_cast<unsigned>(-1);
+
+// The HarfBuzzFontData struct carries user-pointer data for hb_font_t callback
+// functions/operations. It contains metrics and OpenType layout information
+// related to a font scaled to a particular size.
+struct HarfBuzzFontData {
+  USING_FAST_MALLOC(HarfBuzzFontData);
+
+ public:
+  HarfBuzzFontData()
+      : font_(),
+        space_in_gpos_(SpaceGlyphInOpenTypeTables::Unknown),
+        space_in_gsub_(SpaceGlyphInOpenTypeTables::Unknown),
+        vertical_data_(nullptr),
+        range_set_(nullptr) {}
+
+  // The vertical origin and vertical advance functions in HarfBuzzFace require
+  // the ascent and height metrics as fallback in case no specific vertical
+  // layout information is found from the font.
+  void UpdateFallbackMetricsAndScale(
+      const FontPlatformData& platform_data,
+      HarfBuzzFace::VerticalLayoutCallbacks vertical_layout) {
+    float ascent = 0;
+    float descent = 0;
+    unsigned dummy_ascent_inflation = 0;
+    unsigned dummy_descent_inflation = 0;
+
+    font_ = SkFont();
+    platform_data.SetupSkFont(&font_);
+
+    if (UNLIKELY(vertical_layout == HarfBuzzFace::PrepareForVerticalLayout)) {
+      FontMetrics::AscentDescentWithHacks(
+          ascent, descent, dummy_ascent_inflation, dummy_descent_inflation,
+          platform_data, font_);
+      ascent_fallback_ = ascent;
+      // Simulate the rounding that FontMetrics does so far for returning the
+      // integer Height()
+      height_fallback_ = lroundf(ascent) + lroundf(descent);
+
+      int units_per_em =
+          platform_data.GetHarfBuzzFace()->UnitsPerEmFromHeadTable();
+      if (!units_per_em) {
+        DLOG(ERROR)
+            << "Units per EM is 0 for font used in vertical writing mode.";
+      }
+      size_per_unit_ = platform_data.size() / (units_per_em ? units_per_em : 1);
+    } else {
+      ascent_fallback_ = kInvalidFallbackMetricsValue;
+      height_fallback_ = kInvalidFallbackMetricsValue;
+      size_per_unit_ = kInvalidFallbackMetricsValue;
+    }
+  }
+
+  float SizePerUnit(const SkTypeface& typeface) const {
+    if (size_per_unit_ != kInvalidFallbackMetricsValue)
+      return size_per_unit_;
+    int units_per_em = typeface.getUnitsPerEm();
+    size_per_unit_ = font_.getSize() / units_per_em;
+    return size_per_unit_;
+  }
+
+  scoped_refptr<OpenTypeVerticalData> VerticalData() {
+    if (!vertical_data_) {
+      DCHECK_NE(ascent_fallback_, kInvalidFallbackMetricsValue);
+      DCHECK_NE(height_fallback_, kInvalidFallbackMetricsValue);
+      DCHECK_NE(size_per_unit_, kInvalidFallbackMetricsValue);
+
+      vertical_data_ =
+          OpenTypeVerticalData::CreateUnscaled(font_.refTypeface());
+    }
+    vertical_data_->SetScaleAndFallbackMetrics(size_per_unit_, ascent_fallback_,
+                                               height_fallback_);
+    return vertical_data_;
+  }
+
+  SkFont font_;
+
+  // Capture these scaled fallback metrics from FontPlatformData so that a
+  // OpenTypeVerticalData object can be constructed from them when needed.
+  mutable float size_per_unit_;
+  float ascent_fallback_;
+  float height_fallback_;
+
+  enum class SpaceGlyphInOpenTypeTables { Unknown, Present, NotPresent };
+
+  SpaceGlyphInOpenTypeTables space_in_gpos_;
+  SpaceGlyphInOpenTypeTables space_in_gsub_;
+
+  scoped_refptr<OpenTypeVerticalData> vertical_data_;
+  scoped_refptr<UnicodeRangeSet> range_set_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(HarfBuzzFontData);
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_HARFBUZZ_FONT_DATA_H_
diff --git a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.cc b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.cc
index 1666578e0dc7..5975506785ff 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.cc
@@ -39,17 +39,18 @@
 #include <utility>
 
 #include "base/memory/ptr_util.h"
+#include "build/build_config.h"
 #include "third_party/blink/renderer/platform/fonts/font.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
 #include "third_party/blink/renderer/platform/fonts/font_fallback_iterator.h"
 #include "third_party/blink/renderer/platform/fonts/opentype/open_type_caps_support.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/case_mapping_harfbuzz_buffer_filler.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/font_features.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h"
 #include "third_party/blink/renderer/platform/fonts/small_caps_iterator.h"
 #include "third_party/blink/renderer/platform/fonts/utf16_text_iterator.h"
 #include "third_party/blink/renderer/platform/text/text_break_iterator.h"
-#include "third_party/blink/renderer/platform/wtf/compiler.h"
 #include "third_party/blink/renderer/platform/wtf/deque.h"
 #include "third_party/blink/renderer/platform/wtf/math_extras.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
@@ -59,6 +60,15 @@ namespace blink {
 
 namespace {
 
+constexpr hb_feature_t CreateFeature(char c1,
+                                     char c2,
+                                     char c3,
+                                     char c4,
+                                     uint32_t value = 0) {
+  return {HB_TAG(c1, c2, c3, c4), value, 0 /* start */,
+          static_cast<unsigned>(-1) /* end */};
+}
+
 #if DCHECK_IS_ON()
 // Check if the ShapeResult has the specified range.
 // |text| and |font| are only for logging.
@@ -70,8 +80,7 @@ void CheckShapeResultRange(const ShapeResult* result,
   DCHECK_LE(start, end);
   unsigned length = end - start;
   if (length == result->NumCharacters() &&
-      (!length || (start == result->StartIndexForResult() &&
-                   end == result->EndIndexForResult())))
+      (!length || (start == result->StartIndex() && end == result->EndIndex())))
     return;
 
   // Log font-family/size as specified.
@@ -85,7 +94,7 @@ void CheckShapeResultRange(const ShapeResult* result,
       break;
     log.Append(", ");
   }
-  log.Append(String::Format("', %f", font_description.ComputedSize()));
+  log.AppendFormat("', %f", font_description.ComputedSize());
 
   // Log the primary font with its family name in the font file.
   const SimpleFontData* font_data = font->PrimaryFont();
@@ -98,11 +107,10 @@ void CheckShapeResultRange(const ShapeResult* result,
   }
 
   // Log the text to shape.
-  log.Append(String::Format(": %u-%u -> %u-%u:", start, end,
-                            result->StartIndexForResult(),
-                            result->EndIndexForResult()));
+  log.AppendFormat(": %u-%u -> %u-%u:", start, end, result->StartIndex(),
+                   result->EndIndex());
   for (unsigned i = start; i < end; ++i)
-    log.Append(String::Format(" %02X", text[i]));
+    log.AppendFormat(" %02X", text[i]);
 
   log.Append(", result=");
   result->ToString(&log);
@@ -111,23 +119,85 @@ void CheckShapeResultRange(const ShapeResult* result,
 }
 #endif
 
+struct TrackEmoji {
+  bool is_start;
+  unsigned tracked_cluster_index;
+  bool cluster_broken;
+
+  unsigned num_broken_clusters;
+  unsigned num_clusters;
+};
+
+// The algorithm is relying on the following assumption: If an emoji is shaped
+// correctly it will present as only one glyph. This definitely holds for
+// NotoColorEmoji. So if one sequence (which HarfBuzz groups as a cluster)
+// presents as multiple glyphs, it means an emoji is rendered as sequence that
+// the font did not understand and did not shape into only one glyph. If it
+// renders as only one glyph but that glyph is .notdef/Tofu, it also means it's
+// broken.  Due to the way flags work (pairs of regional indicators), broken
+// flags cannot be correctly identified with this method - as each regional
+// indicator will display as one emoji with Noto Color Emoji.
+void IdentifyBrokenEmoji(void* context,
+                         unsigned character_index,
+                         Glyph glyph,
+                         FloatSize,
+                         float,
+                         bool,
+                         CanvasRotationInVertical,
+                         const SimpleFontData*) {
+  DCHECK(context);
+  TrackEmoji* track_emoji = reinterpret_cast<TrackEmoji*>(context);
+
+  if (character_index != track_emoji->tracked_cluster_index ||
+      track_emoji->is_start) {
+    // We have reached the next cluster and can decide for the previous cluster
+    // whether it was broken or not.
+    track_emoji->num_clusters++;
+    track_emoji->is_start = false;
+    track_emoji->tracked_cluster_index = character_index;
+    if (track_emoji->cluster_broken) {
+      track_emoji->num_broken_clusters++;
+    }
+    track_emoji->cluster_broken = glyph == 0;
+  } else {
+    // We have reached an additional glyph for the same cluster, which means the
+    // sequence was not identified by the font and is showing as multiple
+    // glyphs.
+    track_emoji->cluster_broken = true;
+  }
+}
+
+struct EmojiCorrectness {
+  unsigned num_clusters = 0;
+  unsigned num_broken_clusters = 0;
+};
+
+EmojiCorrectness ComputeBrokenEmojiPercentage(ShapeResult* shape_result,
+                                              unsigned start_index,
+                                              unsigned end_index) {
+  TrackEmoji track_emoji = {true, 0, false, 0, 0};
+  shape_result->ForEachGlyph(0.f, start_index, end_index, 0 /* index_offset */,
+                             IdentifyBrokenEmoji, &track_emoji);
+  track_emoji.num_broken_clusters += track_emoji.cluster_broken ? 1 : 0;
+  return {track_emoji.num_clusters, track_emoji.num_broken_clusters};
+}
+
 }  // namespace
 
 enum ReshapeQueueItemAction { kReshapeQueueNextFont, kReshapeQueueRange };
 
 struct ReshapeQueueItem {
-  DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
+  DISALLOW_NEW();
   ReshapeQueueItemAction action_;
   unsigned start_index_;
   unsigned num_characters_;
   ReshapeQueueItem(ReshapeQueueItemAction action, unsigned start, unsigned num)
-      : action_(action), start_index_(start), num_characters_(num){};
+      : action_(action), start_index_(start), num_characters_(num) {}
 };
 
 template <typename T>
 class HarfBuzzScopedPtr {
   STACK_ALLOCATED();
-  WTF_MAKE_NONCOPYABLE(HarfBuzzScopedPtr);
 
  public:
   typedef void (*DestroyFunction)(T*);
@@ -147,26 +217,27 @@ class HarfBuzzScopedPtr {
  private:
   T* ptr_;
   DestroyFunction destroy_;
+
+  DISALLOW_COPY_AND_ASSIGN(HarfBuzzScopedPtr);
 };
 
-HarfBuzzShaper::HarfBuzzShaper(const String& text) : text_(text) {}
-
-using FeaturesVector = Vector<hb_feature_t, 6>;
 struct RangeData {
+  STACK_ALLOCATED();
+
+ public:
   hb_buffer_t* buffer;
   const Font* font;
   TextDirection text_direction;
   unsigned start;
   unsigned end;
-  FeaturesVector font_features;
+  FontFeatures font_features;
   Deque<ReshapeQueueItem> reshape_queue;
 
   hb_direction_t HarfBuzzDirection(CanvasRotationInVertical canvas_rotation) {
     FontOrientation orientation = font->GetFontDescription().Orientation();
     hb_direction_t direction =
         IsVerticalAnyUpright(orientation) &&
-                (canvas_rotation ==
-                 CanvasRotationInVertical::kRotateCanvasUpright)
+                IsCanvasRotationInVerticalUpright(canvas_rotation)
             ? HB_DIRECTION_TTB
             : HB_DIRECTION_LTR;
     return text_direction == TextDirection::kRtl
@@ -216,7 +287,7 @@ void RoundHarfBuzzBufferPositions(hb_buffer_t* buffer) {
 }
 
 inline bool ShapeRange(hb_buffer_t* buffer,
-                       hb_feature_t* font_features,
+                       const hb_feature_t* font_features,
                        unsigned font_features_size,
                        const SimpleFontData* current_font,
                        scoped_refptr<UnicodeRangeSet> current_font_range_set,
@@ -240,14 +311,6 @@ inline bool ShapeRange(hb_buffer_t* buffer,
                               ? HarfBuzzFace::PrepareForVerticalLayout
                               : HarfBuzzFace::NoVerticalLayout);
   hb_shape(hb_font, buffer, font_features, font_features_size);
-
-  // We cannot round all glyph positions during hb_shape because the
-  // hb_font_funcs_set_glyph_h_kerning_func only works for legacy kerning.
-  // OpenType uses gpos tables for kerning and harfbuzz does not call
-  // the callback to let us round as we go.
-  // Without this rounding, we get inconsistent spacing between kern points
-  // if subpixel positioning is disabled.
-  // See http://crbug.com/740385.
   if (!face->ShouldSubpixelPosition())
     RoundHarfBuzzBufferPositions(buffer);
 
@@ -316,11 +379,25 @@ void QueueCharacters(RangeData* range_data,
 
 CanvasRotationInVertical CanvasRotationForRun(
     FontOrientation font_orientation,
-    OrientationIterator::RenderOrientation render_orientation) {
-  if (font_orientation == FontOrientation::kVerticalUpright ||
-      (font_orientation == FontOrientation::kVerticalMixed &&
-       render_orientation == OrientationIterator::kOrientationKeep))
-    return CanvasRotationInVertical::kRotateCanvasUpright;
+    OrientationIterator::RenderOrientation render_orientation,
+    const FontDescription& font_description) {
+  if (font_orientation == FontOrientation::kVerticalUpright) {
+    return font_description.IsSyntheticOblique()
+               ? CanvasRotationInVertical::kRotateCanvasUprightOblique
+               : CanvasRotationInVertical::kRotateCanvasUpright;
+  }
+
+  if (font_orientation == FontOrientation::kVerticalMixed) {
+    if (render_orientation == OrientationIterator::kOrientationKeep) {
+      return font_description.IsSyntheticOblique()
+                 ? CanvasRotationInVertical::kRotateCanvasUprightOblique
+                 : CanvasRotationInVertical::kRotateCanvasUpright;
+    }
+    return font_description.IsSyntheticOblique()
+               ? CanvasRotationInVertical::kOblique
+               : CanvasRotationInVertical::kRegular;
+  }
+
   return CanvasRotationInVertical::kRegular;
 }
 
@@ -330,7 +407,7 @@ void HarfBuzzShaper::CommitGlyphs(RangeData* range_data,
                                   const SimpleFontData* current_font,
                                   UScriptCode current_run_script,
                                   CanvasRotationInVertical canvas_rotation,
-                                  bool is_last_resort,
+                                  bool is_last_font,
                                   const BufferSlice& slice,
                                   ShapeResult* shape_result) const {
   hb_direction_t direction = range_data->HarfBuzzDirection(canvas_rotation);
@@ -338,15 +415,11 @@ void HarfBuzzShaper::CommitGlyphs(RangeData* range_data,
   // Here we need to specify glyph positions.
   BufferSlice next_slice;
   for (const BufferSlice* current_slice = &slice;;) {
-    Vector<unsigned> graphemes;
-    GraphemesClusterList(text_, current_slice->start_character_index,
-                         current_slice->num_characters, &graphemes);
-    ShapeResult::RunInfo* run = new ShapeResult::RunInfo(
+    auto run = ShapeResult::RunInfo::Create(
         current_font, direction, canvas_rotation, script,
         current_slice->start_character_index, current_slice->num_glyphs,
-        current_slice->num_characters, graphemes);
-    shape_result->InsertRun(base::WrapUnique(run),
-                            current_slice->start_glyph_index,
+        current_slice->num_characters);
+    shape_result->InsertRun(run, current_slice->start_glyph_index,
                             current_slice->num_glyphs, range_data->buffer);
     unsigned num_glyphs_inserted = run->NumGlyphs();
     if (num_glyphs_inserted == current_slice->num_glyphs)
@@ -361,7 +434,7 @@ void HarfBuzzShaper::CommitGlyphs(RangeData* range_data,
                   current_slice->num_glyphs - num_glyphs_inserted};
     current_slice = &next_slice;
   }
-  if (is_last_resort)
+  if (is_last_font)
     range_data->font->ReportNotDefGlyph();
 }
 
@@ -372,7 +445,7 @@ void HarfBuzzShaper::ExtractShapeResults(
     const SimpleFontData* current_font,
     UScriptCode current_run_script,
     CanvasRotationInVertical canvas_rotation,
-    bool is_last_resort,
+    bool is_last_font,
     ShapeResult* shape_result) const {
   enum ClusterResult { kShaped, kNotDef, kUnknown };
   ClusterResult current_cluster_result = kUnknown;
@@ -412,7 +485,7 @@ void HarfBuzzShaper::ExtractShapeResults(
         // If the most recent cluster is shaped and there is a state change,
         // it means the previous ones were unshaped, so we queue them, unless
         // we're using the last resort font.
-        if (current_cluster_result == kShaped && !is_last_resort) {
+        if (current_cluster_result == kShaped && !is_last_font) {
           QueueCharacters(range_data, current_font, font_cycle_queued, slice);
         } else {
           // If the most recent cluster is unshaped and there is a state
@@ -420,7 +493,7 @@ void HarfBuzzShaper::ExtractShapeResults(
           // the glyphs. We also commit when we've reached the last resort
           // font.
           CommitGlyphs(range_data, current_font, current_run_script,
-                       canvas_rotation, is_last_resort, slice, shape_result);
+                       canvas_rotation, is_last_font, slice, shape_result);
         }
         last_change_glyph_index = previous_cluster_start_glyph_index;
       }
@@ -442,7 +515,7 @@ void HarfBuzzShaper::ExtractShapeResults(
 
   // End of the run.
   if (current_cluster_result != previous_cluster_result &&
-      previous_cluster_result != kUnknown && !is_last_resort) {
+      previous_cluster_result != kUnknown && !is_last_font) {
     // The last cluster in the run still had shaping status different from
     // the cluster(s) before it, we need to submit one shaped and one
     // unshaped segment.
@@ -455,13 +528,13 @@ void HarfBuzzShaper::ExtractShapeResults(
           ComputeSlice(range_data, current_queue_item, glyph_info, num_glyphs,
                        previous_cluster_start_glyph_index, num_glyphs);
       CommitGlyphs(range_data, current_font, current_run_script,
-                   canvas_rotation, is_last_resort, slice, shape_result);
+                   canvas_rotation, is_last_font, slice, shape_result);
     } else {
       BufferSlice slice = ComputeSlice(
           range_data, current_queue_item, glyph_info, num_glyphs,
           last_change_glyph_index, previous_cluster_start_glyph_index);
       CommitGlyphs(range_data, current_font, current_run_script,
-                   canvas_rotation, is_last_resort, slice, shape_result);
+                   canvas_rotation, is_last_font, slice, shape_result);
       slice =
           ComputeSlice(range_data, current_queue_item, glyph_info, num_glyphs,
                        previous_cluster_start_glyph_index, num_glyphs);
@@ -473,19 +546,20 @@ void HarfBuzzShaper::ExtractShapeResults(
     BufferSlice slice =
         ComputeSlice(range_data, current_queue_item, glyph_info, num_glyphs,
                      last_change_glyph_index, num_glyphs);
-    if (current_cluster_result == kNotDef && !is_last_resort) {
+    if (current_cluster_result == kNotDef && !is_last_font) {
       QueueCharacters(range_data, current_font, font_cycle_queued, slice);
     } else {
       CommitGlyphs(range_data, current_font, current_run_script,
-                   canvas_rotation, is_last_resort, slice, shape_result);
+                   canvas_rotation, is_last_font, slice, shape_result);
     }
   }
 }
 
 bool HarfBuzzShaper::CollectFallbackHintChars(
     const Deque<ReshapeQueueItem>& reshape_queue,
+    bool needs_hint_list,
     Vector<UChar32>& hint) const {
-  if (!reshape_queue.size())
+  if (reshape_queue.empty())
     return false;
 
   // Clear without releasing the capacity to avoid reallocations.
@@ -501,16 +575,32 @@ bool HarfBuzzShaper::CollectFallbackHintChars(
       for (unsigned i = 0; i < it->num_characters_; i++) {
         hint.push_back(text_[it->start_index_ + i]);
         num_chars_added++;
+        // Determine if we can take a shortcut and not fill the hint list
+        // further: We can do that if we do not need a hint list, and we have
+        // managed to find a character with a definite script since
+        // FontFallbackIterator needs a character with a determined script to
+        // perform meaningful system fallback.
+        if (!needs_hint_list &&
+            Character::HasDefiniteScript(text_[it->start_index_ + i]))
+          return true;
       }
       continue;
     }
 
+    // !text_.Is8Bit()...
     UChar32 hint_char;
     UTF16TextIterator iterator(text_.Characters16() + it->start_index_,
                                it->num_characters_);
     while (iterator.Consume(hint_char)) {
       hint.push_back(hint_char);
       num_chars_added++;
+      // Determine if we can take a shortcut and not fill the hint list
+      // further: We can do that if we do not need a hint list, and we have
+      // managed to find a character with a definite script since
+      // FontFallbackIterator needs a character with a determined script to
+      // perform meaningful system fallback.
+      if (!needs_hint_list && Character::HasDefiniteScript(hint_char))
+        return true;
       iterator.Advance();
     }
   }
@@ -551,207 +641,22 @@ void SplitUntilNextCaseChange(
   }
 }
 
-hb_feature_t CreateFeature(hb_tag_t tag, uint32_t value = 0) {
-  return {tag, value, 0 /* start */, static_cast<unsigned>(-1) /* end */};
-}
-
-// TODO(kojii): crbug.com/762493 This list is getting long enough to extract out
-// of HarfBuzzShaper.cpp.
-void SetFontFeatures(const Font* font, FeaturesVector* features) {
-  const FontDescription& description = font->GetFontDescription();
-
-  static hb_feature_t no_kern = CreateFeature(HB_TAG('k', 'e', 'r', 'n'));
-  static hb_feature_t no_vkrn = CreateFeature(HB_TAG('v', 'k', 'r', 'n'));
-  switch (description.GetKerning()) {
-    case FontDescription::kNormalKerning:
-      // kern/vkrn are enabled by default
-      break;
-    case FontDescription::kNoneKerning:
-      features->push_back(description.IsVerticalAnyUpright() ? no_vkrn
-                                                             : no_kern);
-      break;
-    case FontDescription::kAutoKerning:
-      break;
-  }
-
-  static hb_feature_t no_clig = CreateFeature(HB_TAG('c', 'l', 'i', 'g'));
-  static hb_feature_t no_liga = CreateFeature(HB_TAG('l', 'i', 'g', 'a'));
-  switch (description.CommonLigaturesState()) {
-    case FontDescription::kDisabledLigaturesState:
-      features->push_back(no_liga);
-      features->push_back(no_clig);
-      break;
-    case FontDescription::kEnabledLigaturesState:
-      // liga and clig are on by default
-      break;
-    case FontDescription::kNormalLigaturesState:
-      break;
-  }
-  static hb_feature_t dlig = CreateFeature(HB_TAG('d', 'l', 'i', 'g'), 1);
-  switch (description.DiscretionaryLigaturesState()) {
-    case FontDescription::kDisabledLigaturesState:
-      // dlig is off by default
-      break;
-    case FontDescription::kEnabledLigaturesState:
-      features->push_back(dlig);
-      break;
-    case FontDescription::kNormalLigaturesState:
-      break;
-  }
-  static hb_feature_t hlig = CreateFeature(HB_TAG('h', 'l', 'i', 'g'), 1);
-  switch (description.HistoricalLigaturesState()) {
-    case FontDescription::kDisabledLigaturesState:
-      // hlig is off by default
-      break;
-    case FontDescription::kEnabledLigaturesState:
-      features->push_back(hlig);
-      break;
-    case FontDescription::kNormalLigaturesState:
-      break;
-  }
-  static hb_feature_t no_calt = CreateFeature(HB_TAG('c', 'a', 'l', 't'));
-  switch (description.ContextualLigaturesState()) {
-    case FontDescription::kDisabledLigaturesState:
-      features->push_back(no_calt);
-      break;
-    case FontDescription::kEnabledLigaturesState:
-      // calt is on by default
-      break;
-    case FontDescription::kNormalLigaturesState:
-      break;
-  }
-
-  static hb_feature_t hwid = CreateFeature(HB_TAG('h', 'w', 'i', 'd'), 1);
-  static hb_feature_t twid = CreateFeature(HB_TAG('t', 'w', 'i', 'd'), 1);
-  static hb_feature_t qwid = CreateFeature(HB_TAG('q', 'w', 'i', 'd'), 1);
-  switch (description.WidthVariant()) {
-    case kHalfWidth:
-      features->push_back(hwid);
-      break;
-    case kThirdWidth:
-      features->push_back(twid);
-      break;
-    case kQuarterWidth:
-      features->push_back(qwid);
-      break;
-    case kRegularWidth:
-      break;
-  }
-
-  // font-variant-east-asian:
-  const FontVariantEastAsian east_asian = description.VariantEastAsian();
-  if (UNLIKELY(!east_asian.IsAllNormal())) {
-    static hb_feature_t jp78 = CreateFeature(HB_TAG('j', 'p', '7', '8'), 1);
-    static hb_feature_t jp83 = CreateFeature(HB_TAG('j', 'p', '8', '3'), 1);
-    static hb_feature_t jp90 = CreateFeature(HB_TAG('j', 'p', '9', '0'), 1);
-    static hb_feature_t jp04 = CreateFeature(HB_TAG('j', 'p', '0', '4'), 1);
-    static hb_feature_t smpl = CreateFeature(HB_TAG('s', 'm', 'p', 'l'), 1);
-    static hb_feature_t trad = CreateFeature(HB_TAG('t', 'r', 'a', 'd'), 1);
-    switch (east_asian.Form()) {
-      case FontVariantEastAsian::kNormalForm:
-        break;
-      case FontVariantEastAsian::kJis78:
-        features->push_back(jp78);
-        break;
-      case FontVariantEastAsian::kJis83:
-        features->push_back(jp83);
-        break;
-      case FontVariantEastAsian::kJis90:
-        features->push_back(jp90);
-        break;
-      case FontVariantEastAsian::kJis04:
-        features->push_back(jp04);
-        break;
-      case FontVariantEastAsian::kSimplified:
-        features->push_back(smpl);
-        break;
-      case FontVariantEastAsian::kTraditional:
-        features->push_back(trad);
-        break;
-      default:
-        NOTREACHED();
-    }
-    static hb_feature_t fwid = CreateFeature(HB_TAG('f', 'w', 'i', 'd'), 1);
-    static hb_feature_t pwid = CreateFeature(HB_TAG('p', 'w', 'i', 'd'), 1);
-    switch (east_asian.Width()) {
-      case FontVariantEastAsian::kNormalWidth:
-        break;
-      case FontVariantEastAsian::kFullWidth:
-        features->push_back(fwid);
-        break;
-      case FontVariantEastAsian::kProportionalWidth:
-        features->push_back(pwid);
-        break;
-      default:
-        NOTREACHED();
-    }
-    static hb_feature_t ruby = CreateFeature(HB_TAG('r', 'u', 'b', 'y'), 1);
-    if (east_asian.Ruby())
-      features->push_back(ruby);
-  }
-
-  // font-variant-numeric:
-  static hb_feature_t lnum = CreateFeature(HB_TAG('l', 'n', 'u', 'm'), 1);
-  if (description.VariantNumeric().NumericFigureValue() ==
-      FontVariantNumeric::kLiningNums)
-    features->push_back(lnum);
-
-  static hb_feature_t onum = CreateFeature(HB_TAG('o', 'n', 'u', 'm'), 1);
-  if (description.VariantNumeric().NumericFigureValue() ==
-      FontVariantNumeric::kOldstyleNums)
-    features->push_back(onum);
-
-  static hb_feature_t pnum = CreateFeature(HB_TAG('p', 'n', 'u', 'm'), 1);
-  if (description.VariantNumeric().NumericSpacingValue() ==
-      FontVariantNumeric::kProportionalNums)
-    features->push_back(pnum);
-  static hb_feature_t tnum = CreateFeature(HB_TAG('t', 'n', 'u', 'm'), 1);
-  if (description.VariantNumeric().NumericSpacingValue() ==
-      FontVariantNumeric::kTabularNums)
-    features->push_back(tnum);
-
-  static hb_feature_t afrc = CreateFeature(HB_TAG('a', 'f', 'r', 'c'), 1);
-  if (description.VariantNumeric().NumericFractionValue() ==
-      FontVariantNumeric::kStackedFractions)
-    features->push_back(afrc);
-  static hb_feature_t frac = CreateFeature(HB_TAG('f', 'r', 'a', 'c'), 1);
-  if (description.VariantNumeric().NumericFractionValue() ==
-      FontVariantNumeric::kDiagonalFractions)
-    features->push_back(frac);
-
-  static hb_feature_t ordn = CreateFeature(HB_TAG('o', 'r', 'd', 'n'), 1);
-  if (description.VariantNumeric().OrdinalValue() ==
-      FontVariantNumeric::kOrdinalOn)
-    features->push_back(ordn);
-
-  static hb_feature_t zero = CreateFeature(HB_TAG('z', 'e', 'r', 'o'), 1);
-  if (description.VariantNumeric().SlashedZeroValue() ==
-      FontVariantNumeric::kSlashedZeroOn)
-    features->push_back(zero);
-
-  FontFeatureSettings* settings = description.FeatureSettings();
-  if (!settings)
-    return;
-
-  // TODO(drott): crbug.com/450619 Implement feature resolution instead of
-  // just appending the font-feature-settings.
-  unsigned num_features = settings->size();
-  for (unsigned i = 0; i < num_features; ++i) {
-    hb_feature_t feature;
-    const AtomicString& tag = settings->at(i).Tag();
-    feature.tag = HB_TAG(tag[0], tag[1], tag[2], tag[3]);
-    feature.value = settings->at(i).Value();
-    feature.start = 0;
-    feature.end = static_cast<unsigned>(-1);
-    features->push_back(feature);
-  }
+inline RangeData CreateRangeData(const Font* font,
+                                 TextDirection direction,
+                                 hb_buffer_t* buffer) {
+  RangeData range_data;
+  range_data.buffer = buffer;
+  range_data.font = font;
+  range_data.text_direction = direction;
+  range_data.font_features.Initialize(font->GetFontDescription());
+  return range_data;
 }
 
 class CapsFeatureSettingsScopedOverlay final {
   STACK_ALLOCATED();
 
  public:
-  CapsFeatureSettingsScopedOverlay(FeaturesVector*,
+  CapsFeatureSettingsScopedOverlay(FontFeatures*,
                                    FontDescription::FontVariantCaps);
   CapsFeatureSettingsScopedOverlay() = delete;
   ~CapsFeatureSettingsScopedOverlay();
@@ -759,12 +664,12 @@ class CapsFeatureSettingsScopedOverlay final {
  private:
   void OverlayCapsFeatures(FontDescription::FontVariantCaps);
   void PrependCounting(const hb_feature_t&);
-  FeaturesVector* features_;
-  size_t count_features_;
+  FontFeatures* features_;
+  wtf_size_t count_features_;
 };
 
 CapsFeatureSettingsScopedOverlay::CapsFeatureSettingsScopedOverlay(
-    FeaturesVector* features,
+    FontFeatures* features,
     FontDescription::FontVariantCaps variant_caps)
     : features_(features), count_features_(0) {
   OverlayCapsFeatures(variant_caps);
@@ -772,12 +677,12 @@ CapsFeatureSettingsScopedOverlay::CapsFeatureSettingsScopedOverlay(
 
 void CapsFeatureSettingsScopedOverlay::OverlayCapsFeatures(
     FontDescription::FontVariantCaps variant_caps) {
-  static hb_feature_t smcp = CreateFeature(HB_TAG('s', 'm', 'c', 'p'), 1);
-  static hb_feature_t pcap = CreateFeature(HB_TAG('p', 'c', 'a', 'p'), 1);
-  static hb_feature_t c2sc = CreateFeature(HB_TAG('c', '2', 's', 'c'), 1);
-  static hb_feature_t c2pc = CreateFeature(HB_TAG('c', '2', 'p', 'c'), 1);
-  static hb_feature_t unic = CreateFeature(HB_TAG('u', 'n', 'i', 'c'), 1);
-  static hb_feature_t titl = CreateFeature(HB_TAG('t', 'i', 't', 'l'), 1);
+  static constexpr hb_feature_t smcp = CreateFeature('s', 'm', 'c', 'p', 1);
+  static constexpr hb_feature_t pcap = CreateFeature('p', 'c', 'a', 'p', 1);
+  static constexpr hb_feature_t c2sc = CreateFeature('c', '2', 's', 'c', 1);
+  static constexpr hb_feature_t c2pc = CreateFeature('c', '2', 'p', 'c', 1);
+  static constexpr hb_feature_t unic = CreateFeature('u', 'n', 'i', 'c', 1);
+  static constexpr hb_feature_t titl = CreateFeature('t', 'i', 't', 'l', 1);
   if (variant_caps == FontDescription::kSmallCaps ||
       variant_caps == FontDescription::kAllSmallCaps) {
     PrependCounting(smcp);
@@ -802,7 +707,7 @@ void CapsFeatureSettingsScopedOverlay::OverlayCapsFeatures(
 
 void CapsFeatureSettingsScopedOverlay::PrependCounting(
     const hb_feature_t& feature) {
-  features_->push_front(feature);
+  features_->Insert(feature);
   count_features_++;
 }
 
@@ -818,7 +723,6 @@ void HarfBuzzShaper::ShapeSegment(
     ShapeResult* result) const {
   DCHECK(result);
   DCHECK(range_data->buffer);
-
   const Font* font = range_data->font;
   const FontDescription& font_description = font->GetFontDescription();
   const hb_language_t language =
@@ -827,8 +731,8 @@ void HarfBuzzShaper::ShapeSegment(
       font_description.VariantCaps() != FontDescription::kCapsNormal;
   OpenTypeCapsSupport caps_support;
 
-  scoped_refptr<FontFallbackIterator> fallback_iterator =
-      font->CreateFontFallbackIterator(segment.font_fallback_priority);
+  FontFallbackIterator fallback_iterator(
+      font->CreateFontFallbackIterator(segment.font_fallback_priority));
 
   range_data->reshape_queue.push_back(
       ReshapeQueueItem(kReshapeQueueNextFont, 0, 0));
@@ -837,23 +741,19 @@ void HarfBuzzShaper::ShapeSegment(
 
   bool font_cycle_queued = false;
   Vector<UChar32> fallback_chars_hint;
-  // Reserve enough capacity to avoid multiple reallocations.
-  // TODO(kojii): Should review if we really need to collect all characters.
-  // crbug.com/848295
-  fallback_chars_hint.ReserveInitialCapacity(range_data->end -
-                                             range_data->start);
+  // Reserve sufficient capacity to avoid multiple reallocations, only when a
+  // full hint list is needed.
+  if (fallback_iterator.NeedsHintList()) {
+    fallback_chars_hint.ReserveInitialCapacity(range_data->end -
+                                               range_data->start);
+  }
   scoped_refptr<FontDataForRangeSet> current_font_data_for_range_set;
-  while (range_data->reshape_queue.size()) {
+  while (!range_data->reshape_queue.empty()) {
     ReshapeQueueItem current_queue_item = range_data->reshape_queue.TakeFirst();
 
     if (current_queue_item.action_ == kReshapeQueueNextFont) {
-      // For now, we're building a character list with which we probe
-      // for needed fonts depending on the declared unicode-range of a
-      // segmented CSS font. Alternatively, we can build a fake font
-      // for the shaper and check whether any glyphs were found, or
-      // define a new API on the shaper which will give us coverage
-      // information?
       if (!CollectFallbackHintChars(range_data->reshape_queue,
+                                    fallback_iterator.NeedsHintList(),
                                     fallback_chars_hint)) {
         // Give up shaping since we cannot retrieve a font fallback
         // font without a hintlist.
@@ -862,9 +762,9 @@ void HarfBuzzShaper::ShapeSegment(
       }
 
       current_font_data_for_range_set =
-          fallback_iterator->Next(fallback_chars_hint);
+          fallback_iterator.Next(fallback_chars_hint);
       if (!current_font_data_for_range_set->FontData()) {
-        DCHECK(!range_data->reshape_queue.size());
+        DCHECK(range_data->reshape_queue.empty());
         break;
       }
       font_cycle_queued = false;
@@ -917,7 +817,7 @@ void HarfBuzzShaper::ShapeSegment(
 
     CanvasRotationInVertical canvas_rotation =
         CanvasRotationForRun(adjusted_font->PlatformData().Orientation(),
-                             segment.render_orientation);
+                             segment.render_orientation, font_description);
 
     CapsFeatureSettingsScopedOverlay caps_overlay(
         &range_data->font_features,
@@ -935,40 +835,43 @@ void HarfBuzzShaper::ShapeSegment(
 
     ExtractShapeResults(range_data, font_cycle_queued, current_queue_item,
                         adjusted_font, segment.script, canvas_rotation,
-                        !fallback_iterator->HasNext(), result);
+                        !fallback_iterator.HasNext(), result);
 
     hb_buffer_reset(range_data->buffer);
   }
+
+  if (segment.font_fallback_priority == FontFallbackPriority::kEmojiEmoji) {
+    EmojiCorrectness emoji_correctness =
+        ComputeBrokenEmojiPercentage(result, segment.start, segment.end);
+    if (emoji_metrics_reporter_for_testing_) {
+      emoji_metrics_reporter_for_testing_.Run(
+          emoji_correctness.num_clusters,
+          emoji_correctness.num_broken_clusters);
+    } else {
+      range_data->font->ReportEmojiSegmentGlyphCoverage(
+          emoji_correctness.num_clusters,
+          emoji_correctness.num_broken_clusters);
+    }
+  }
 }
 
-scoped_refptr<ShapeResult> HarfBuzzShaper::Shape(
-    const Font* font,
-    TextDirection direction,
-    unsigned start,
-    unsigned end,
-    const RunSegmenter::RunSegmenterRange* pre_segmented) const {
+scoped_refptr<ShapeResult> HarfBuzzShaper::Shape(const Font* font,
+                                                 TextDirection direction,
+                                                 unsigned start,
+                                                 unsigned end) const {
   DCHECK_GE(end, start);
   DCHECK_LE(end, text_.length());
-  DCHECK(!pre_segmented ||
-         (start >= pre_segmented->start && end <= pre_segmented->end));
 
   unsigned length = end - start;
   scoped_refptr<ShapeResult> result =
-      ShapeResult::Create(font, length, direction);
-  HarfBuzzScopedPtr<hb_buffer_t> buffer(hb_buffer_create(), hb_buffer_destroy);
+      ShapeResult::Create(font, start, length, direction);
 
-  RangeData range_data;
-  range_data.buffer = buffer.Get();
-  range_data.font = font;
-  range_data.text_direction = direction;
+  HarfBuzzScopedPtr<hb_buffer_t> buffer(hb_buffer_create(), hb_buffer_destroy);
+  RangeData range_data = CreateRangeData(font, direction, buffer.Get());
   range_data.start = start;
   range_data.end = end;
-  SetFontFeatures(font, &range_data.font_features);
 
-  if (pre_segmented) {
-    ShapeSegment(&range_data, *pre_segmented, result.get());
-
-  } else if (text_.Is8Bit()) {
+  if (text_.Is8Bit()) {
     // 8-bit text is guaranteed to horizontal latin-1.
     RunSegmenter::RunSegmenterRange segment_range = {
         start, end, USCRIPT_LATIN, OrientationIterator::kOrientationKeep,
@@ -996,9 +899,72 @@ scoped_refptr<ShapeResult> HarfBuzzShaper::Shape(
     }
   }
 
-  // Ensure we have at least one run for StartIndexForResult().
-  if (UNLIKELY(result->runs_.IsEmpty() && start))
-    result->InsertRunForIndex(start);
+#if DCHECK_IS_ON()
+  if (result)
+    CheckShapeResultRange(result.get(), start, end, text_, font);
+#endif
+
+  return result;
+}
+
+scoped_refptr<ShapeResult> HarfBuzzShaper::Shape(
+    const Font* font,
+    TextDirection direction,
+    unsigned start,
+    unsigned end,
+    const Vector<RunSegmenter::RunSegmenterRange>& ranges) const {
+  DCHECK_GE(end, start);
+  DCHECK_LE(end, text_.length());
+  DCHECK_GT(ranges.size(), 0u);
+  DCHECK_EQ(start, ranges[0].start);
+  DCHECK_EQ(end, ranges[ranges.size() - 1].end);
+
+  unsigned length = end - start;
+  scoped_refptr<ShapeResult> result =
+      ShapeResult::Create(font, start, length, direction);
+
+  HarfBuzzScopedPtr<hb_buffer_t> buffer(hb_buffer_create(), hb_buffer_destroy);
+  RangeData range_data = CreateRangeData(font, direction, buffer.Get());
+
+  for (const RunSegmenter::RunSegmenterRange& segmented_range : ranges) {
+    DCHECK_GE(segmented_range.end, segmented_range.start);
+    DCHECK_GE(segmented_range.start, start);
+    DCHECK_LE(segmented_range.end, end);
+
+    range_data.start = segmented_range.start;
+    range_data.end = segmented_range.end;
+    ShapeSegment(&range_data, segmented_range, result.get());
+  }
+
+#if DCHECK_IS_ON()
+  if (result)
+    CheckShapeResultRange(result.get(), start, end, text_, font);
+#endif
+
+  return result;
+}
+
+scoped_refptr<ShapeResult> HarfBuzzShaper::Shape(
+    const Font* font,
+    TextDirection direction,
+    unsigned start,
+    unsigned end,
+    const RunSegmenter::RunSegmenterRange pre_segmented) const {
+  DCHECK_GE(end, start);
+  DCHECK_LE(end, text_.length());
+  DCHECK_GE(start, pre_segmented.start);
+  DCHECK_LE(end, pre_segmented.end);
+
+  unsigned length = end - start;
+  scoped_refptr<ShapeResult> result =
+      ShapeResult::Create(font, start, length, direction);
+
+  HarfBuzzScopedPtr<hb_buffer_t> buffer(hb_buffer_create(), hb_buffer_destroy);
+  RangeData range_data = CreateRangeData(font, direction, buffer.Get());
+  range_data.start = start;
+  range_data.end = end;
+
+  ShapeSegment(&range_data, pre_segmented, result.get());
 
 #if DCHECK_IS_ON()
   if (result)
diff --git a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.h b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.h
index a65259f230dd..d05fc342088f 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.h
@@ -31,9 +31,11 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_HARFBUZZ_SHAPER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_HARFBUZZ_SHAPER_H_
 
+#include "base/callback.h"
+
 #include "third_party/blink/renderer/platform/fonts/shaping/run_segmenter.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 
@@ -47,8 +49,21 @@ struct RangeData;
 struct BufferSlice;
 
 class PLATFORM_EXPORT HarfBuzzShaper final {
+  DISALLOW_NEW();
+
+  using EmojiMetricsCallback =
+      base::RepeatingCallback<void(unsigned, unsigned)>;
+
  public:
-  HarfBuzzShaper(const String&);
+  // The optional emoji_metrics_callback argument is a mock metrics reporting
+  // function used during tests. Otherwise successful and unsuccessful emoji
+  // clusters are reported per Document / WorkerGlobalContext to
+  // FontMatchingMetrics.
+  explicit HarfBuzzShaper(
+      const String& text,
+      EmojiMetricsCallback emoji_metrics_callback = EmojiMetricsCallback())
+      : text_(text),
+        emoji_metrics_reporter_for_testing_(emoji_metrics_callback) {}
 
   // Shape a range, defined by the start and end parameters, of the string
   // supplied to the constructor.
@@ -56,15 +71,27 @@ class PLATFORM_EXPORT HarfBuzzShaper final {
   // occur, such as at the beginning or end of lines or at element boundaries.
   // If given arbitrary positions the results are not guaranteed to be correct.
   // May be called multiple times; font and direction may vary between calls.
-  //
-  // If |pre_segmented| is given, it is assumed that the string is already
-  // segmented. Otherwise the string is segmented into runs before shaping.
+  scoped_refptr<ShapeResult> Shape(const Font*,
+                                   TextDirection,
+                                   unsigned start,
+                                   unsigned end) const;
+
+  // Shape a range that has already been pre-segmented. Start and end positions
+  // must match the positions defined by the ranges and must be at valid break
+  // positions.
   scoped_refptr<ShapeResult> Shape(
       const Font*,
       TextDirection,
       unsigned start,
       unsigned end,
-      const RunSegmenter::RunSegmenterRange* pre_segmented = nullptr) const;
+      const Vector<RunSegmenter::RunSegmenterRange>&) const;
+
+  // Shape a single range. Start and end positions defined by the range.
+  scoped_refptr<ShapeResult> Shape(const Font*,
+                                   TextDirection,
+                                   unsigned start,
+                                   unsigned end,
+                                   const RunSegmenter::RunSegmenterRange) const;
 
   // Shape the entire string with a single font and direction.
   // Equivalent to calling the range version with a start offset of zero and an
@@ -91,21 +118,23 @@ class PLATFORM_EXPORT HarfBuzzShaper final {
                            const SimpleFontData*,
                            UScriptCode,
                            CanvasRotationInVertical,
-                           bool is_last_resort,
+                           bool is_last_font,
                            ShapeResult*) const;
 
   bool CollectFallbackHintChars(const Deque<ReshapeQueueItem>&,
+                                bool needs_hint_list,
                                 Vector<UChar32>& hint) const;
 
   void CommitGlyphs(RangeData*,
                     const SimpleFontData* current_font,
                     UScriptCode current_run_script,
                     CanvasRotationInVertical,
-                    bool is_last_resort,
+                    bool is_last_font,
                     const BufferSlice&,
                     ShapeResult*) const;
 
   const String text_;
+  EmojiMetricsCallback emoji_metrics_reporter_for_testing_;
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper_fuzzer.cc b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper_fuzzer.cc
index 186cb357c9cf..843329b3ef10 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper_fuzzer.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper_fuzzer.cc
@@ -2,9 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/command_line.h"
 #include "third_party/blink/renderer/platform/fonts/font.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
+#include "third_party/blink/renderer/platform/fonts/ng_text_fragment_paint_info.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h"
+#include "third_party/blink/renderer/platform/fonts/text_run_paint_info.h"
 #include "third_party/blink/renderer/platform/testing/blink_fuzzer_test_support.h"
 
 #include <stddef.h>
@@ -19,29 +25,65 @@ constexpr size_t kMaxInputLength = 256;
 // custom fontconfig configuration that we use for content_shell.
 int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
   static BlinkFuzzerTestSupport fuzzer_support = BlinkFuzzerTestSupport();
-  constexpr int32_t kDestinationCapacity = 2 * kMaxInputLength;
-  int32_t converted_length = 0;
-  UChar converted_input_buffer[kDestinationCapacity] = {0};
-  UErrorCode error_code = U_ZERO_ERROR;
 
-  // Discard trailing bytes.
-  u_strFromUTF32(converted_input_buffer, kDestinationCapacity,
-                 &converted_length, reinterpret_cast<const UChar32*>(data),
-                 size / sizeof(UChar32), &error_code);
-  if (U_FAILURE(error_code))
-    return 0;
+  if (false) {
+    // The fuzzer driver does not pass along command line arguments, so add any
+    // useful debugging command line arguments manually here.
+    base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+    if (!command_line->HasSwitch("vmodule")) {
+      command_line->AppendSwitchASCII("vmodule", "shape_result_bloberizer=4");
+      logging::InitLogging(logging::LoggingSettings());
+    }
+  }
 
   FontCachePurgePreventer font_cache_purge_preventer;
   FontDescription font_description;
   Font font(font_description);
   // Set font size to something other than the default 0 size in
   // FontDescription, 16 matches the default text size in HTML.
+  // We don't use a FontSelector here. Only look for system fonts for now.
   font_description.SetComputedSize(16.0f);
-  // Only look for system fonts for now.
-  font.Update(nullptr);
 
-  HarfBuzzShaper shaper(String(converted_input_buffer, converted_length));
+  String string(reinterpret_cast<const UChar*>(data),
+                std::min(kMaxInputLength, size / sizeof(UChar)));
+  HarfBuzzShaper shaper(string);
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, TextDirection::kLtr);
+
+  // BloberizeNG
+  scoped_refptr<ShapeResultView> result_view =
+      ShapeResultView::Create(result.get());
+  NGTextFragmentPaintInfo text_info{StringView(string), 0, string.length(),
+                                    result_view.get()};
+  ShapeResultBloberizer::FillGlyphsNG bloberizer_ng(
+      font.GetFontDescription(), 1, text_info.text, text_info.from,
+      text_info.to, text_info.shape_result,
+      ShapeResultBloberizer::Type::kEmitText);
+  bloberizer_ng.Blobs();
+
+  // Bloberize
+  CachingWordShaper word_shaper(font);
+  TextRun text_run(string);
+  constexpr unsigned word_length = 7;
+  unsigned state = 0;
+  for (unsigned from = 0; from < text_run.length(); from += word_length) {
+    unsigned to = std::min(from + word_length, text_run.length());
+    bool is_rtl = state & 0x2;
+    bool is_override = state & 0x4;
+    ++state;
+
+    TextRun subrun = text_run.SubRun(from, to - from);
+    subrun.SetDirection(is_rtl ? TextDirection::kRtl : TextDirection::kLtr);
+    subrun.SetDirectionalOverride(is_override);
+
+    TextRunPaintInfo subrun_info(subrun);
+    ShapeResultBuffer buffer;
+    word_shaper.FillResultBuffer(subrun_info, &buffer);
+    ShapeResultBloberizer::FillGlyphs bloberizer(
+        font.GetFontDescription(), 1, subrun_info, buffer,
+        ShapeResultBloberizer::Type::kEmitText);
+    bloberizer.Blobs();
+  }
+
   return 0;
 }
 
diff --git a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper_test.cc b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper_test.cc
index 8c96a9bbd526..a7e1d1d379f1 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper_test.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper_test.cc
@@ -7,7 +7,10 @@
 #include <unicode/uscript.h>
 
 #include "base/stl_util.h"
+#include "base/test/bind.h"
+#include "base/test/task_environment.h"
 #include "build/build_config.h"
+#include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/renderer/platform/fonts/font.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
@@ -15,25 +18,95 @@
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.h"
-#include "third_party/blink/renderer/platform/layout_test_support.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h"
 #include "third_party/blink/renderer/platform/testing/font_test_helpers.h"
 #include "third_party/blink/renderer/platform/testing/unit_test_helpers.h"
 #include "third_party/blink/renderer/platform/text/text_break_iterator.h"
 #include "third_party/blink/renderer/platform/text/text_run.h"
+#include "third_party/blink/renderer/platform/web_test_support.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 
+#if defined(OS_ANDROID)
+#include "base/android/build_info.h"
+#endif
+
+using testing::ElementsAre;
+
 namespace blink {
 
+namespace {
+
+ShapeResultTestInfo* TestInfo(const scoped_refptr<ShapeResult>& result) {
+  return static_cast<ShapeResultTestInfo*>(result.get());
+}
+
+// Test helper to compare all RunInfo with the expected array.
+struct ShapeResultRunData {
+  unsigned start_index;
+  unsigned num_characters;
+  unsigned num_glyphs;
+  hb_script_t script;
+
+  static Vector<ShapeResultRunData> Get(
+      const scoped_refptr<ShapeResult>& result) {
+    const ShapeResultTestInfo* test_info = TestInfo(result);
+    const unsigned num_runs = test_info->NumberOfRunsForTesting();
+    Vector<ShapeResultRunData> runs(num_runs);
+    for (unsigned i = 0; i < num_runs; i++) {
+      ShapeResultRunData& run = runs[i];
+      test_info->RunInfoForTesting(i, run.start_index, run.num_characters,
+                                   run.num_glyphs, run.script);
+    }
+    return runs;
+  }
+};
+
+bool operator==(const ShapeResultRunData& x, const ShapeResultRunData& y) {
+  return x.start_index == y.start_index &&
+         x.num_characters == y.num_characters && x.num_glyphs == y.num_glyphs &&
+         x.script == y.script;
+}
+
+void operator<<(std::ostream& output, const ShapeResultRunData& x) {
+  output << "{ start_index=" << x.start_index
+         << ", num_characters=" << x.num_characters
+         << ", num_glyphs=" << x.num_glyphs << ", script=" << x.script << " }";
+}
+
+// Create a string of the specified length, filled with |ch|.
+String CreateStringOf(UChar ch, unsigned length) {
+  UChar* data;
+  String string(StringImpl::CreateUninitialized(length, data));
+  string.Fill(ch);
+  return string;
+}
+
+}  // namespace
+
 class HarfBuzzShaperTest : public testing::Test {
  protected:
   void SetUp() override {
     font_description.SetComputedSize(12.0);
     font = Font(font_description);
-    font.Update(nullptr);
   }
 
   void TearDown() override {}
 
+  void SelectDevanagariFont() {
+    FontFamily devanagari_family;
+    // Windows 10
+    devanagari_family.SetFamily("Nirmala UI");
+    // Windows 7
+    devanagari_family.AppendFamily("Mangal");
+    // Linux
+    devanagari_family.AppendFamily("Lohit Devanagari");
+    // Mac
+    devanagari_family.AppendFamily("ITF Devanagari");
+
+    font_description.SetFamily(devanagari_family);
+    font = Font(font_description);
+  }
+
   Font CreateAhem(float size) {
     FontDescription::VariantLigatures ligatures;
     return blink::test::CreateTestFont(
@@ -41,6 +114,14 @@ class HarfBuzzShaperTest : public testing::Test {
         &ligatures);
   }
 
+  Font CreateNotoColorEmoji() {
+    return blink::test::CreateTestFont(
+        "NotoColorEmoji",
+        blink::test::BlinkRootDir() +
+            "/web_tests/third_party/NotoColorEmoji/NotoColorEmoji.ttf",
+        12);
+  }
+
   scoped_refptr<ShapeResult> SplitRun(scoped_refptr<ShapeResult> shape_result,
                                       unsigned offset) {
     unsigned length = shape_result->NumCharacters();
@@ -50,6 +131,17 @@ class HarfBuzzShaperTest : public testing::Test {
     return shape_result;
   }
 
+  scoped_refptr<ShapeResult> CreateMissingRunResult(TextDirection direction) {
+    scoped_refptr<ShapeResult> result =
+        ShapeResult::Create(&font, 2, 8, direction);
+    result->InsertRunForTesting(2, 1, direction, {0});
+    result->InsertRunForTesting(3, 3, direction, {0, 1});
+    // The character index 6 and 7 is missing.
+    result->InsertRunForTesting(8, 2, direction, {0});
+    return result;
+  }
+
+  base::test::TaskEnvironment task_environment_;
   FontCachePurgePreventer font_cache_purge_preventer;
   FontDescription font_description;
   Font font;
@@ -62,40 +154,40 @@ class HarfBuzzShaperTest : public testing::Test {
 class ScopedSubpixelOverride {
  public:
   ScopedSubpixelOverride(bool b) {
-    prev_layout_test_ = LayoutTestSupport::IsRunningLayoutTest();
+    prev_web_test_ = WebTestSupport::IsRunningWebTest();
     prev_subpixel_allowed_ =
-        LayoutTestSupport::IsTextSubpixelPositioningAllowedForTest();
-    prev_antialias_ = LayoutTestSupport::IsFontAntialiasingEnabledForTest();
+        WebTestSupport::IsTextSubpixelPositioningAllowedForTest();
+    prev_antialias_ = WebTestSupport::IsFontAntialiasingEnabledForTest();
     prev_fd_subpixel_ = FontDescription::SubpixelPositioning();
 
-    // This is required for all LayoutTestSupport settings to have effects.
-    LayoutTestSupport::SetIsRunningLayoutTest(true);
+    // This is required for all WebTestSupport settings to have effects.
+    WebTestSupport::SetIsRunningWebTest(true);
 
     if (b) {
       // Allow subpixel positioning.
-      LayoutTestSupport::SetTextSubpixelPositioningAllowedForTest(true);
+      WebTestSupport::SetTextSubpixelPositioningAllowedForTest(true);
 
       // Now, enable subpixel positioning in platform-specific ways.
 
       // Mac always enables subpixel positioning.
 
       // On Windows, subpixel positioning also requires antialiasing.
-      LayoutTestSupport::SetFontAntialiasingEnabledForTest(true);
+      WebTestSupport::SetFontAntialiasingEnabledForTest(true);
 
       // On platforms other than Windows and Mac this needs to be set as
       // well.
       FontDescription::SetSubpixelPositioning(true);
     } else {
       // Explicitly disallow all subpixel positioning.
-      LayoutTestSupport::SetTextSubpixelPositioningAllowedForTest(false);
+      WebTestSupport::SetTextSubpixelPositioningAllowedForTest(false);
     }
   }
   ~ScopedSubpixelOverride() {
     FontDescription::SetSubpixelPositioning(prev_fd_subpixel_);
-    LayoutTestSupport::SetFontAntialiasingEnabledForTest(prev_antialias_);
-    LayoutTestSupport::SetTextSubpixelPositioningAllowedForTest(
+    WebTestSupport::SetFontAntialiasingEnabledForTest(prev_antialias_);
+    WebTestSupport::SetTextSubpixelPositioningAllowedForTest(
         prev_subpixel_allowed_);
-    LayoutTestSupport::SetIsRunningLayoutTest(prev_layout_test_);
+    WebTestSupport::SetIsRunningWebTest(prev_web_test_);
 
     // Fonts cached with a different subpixel positioning state are not
     // automatically invalidated and need to be cleared between test
@@ -104,7 +196,7 @@ class ScopedSubpixelOverride {
   }
 
  private:
-  bool prev_layout_test_;
+  bool prev_web_test_;
   bool prev_subpixel_allowed_;
   bool prev_antialias_;
   bool prev_fd_subpixel_;
@@ -119,31 +211,10 @@ class ShapeParameterTest : public HarfBuzzShaperTest,
   }
 };
 
-INSTANTIATE_TEST_CASE_P(HarfBuzzShaperTest,
-                        ShapeParameterTest,
-                        testing::Values(TextDirection::kLtr,
-                                        TextDirection::kRtl));
-
-static inline ShapeResultTestInfo* TestInfo(
-    scoped_refptr<ShapeResult>& result) {
-  return static_cast<ShapeResultTestInfo*>(result.get());
-}
-
-TEST_F(HarfBuzzShaperTest, MutableUnique) {
-  scoped_refptr<ShapeResult> result =
-      ShapeResult::Create(&font, 0, TextDirection::kLtr);
-  EXPECT_TRUE(result->HasOneRef());
-
-  // At this point, |result| has only one ref count.
-  scoped_refptr<ShapeResult> result2 = result->MutableUnique();
-  EXPECT_EQ(result.get(), result2.get());
-  EXPECT_FALSE(result2->HasOneRef());
-
-  // Since |result| has 2 ref counts, it should return a clone.
-  scoped_refptr<ShapeResult> result3 = result->MutableUnique();
-  EXPECT_NE(result.get(), result3.get());
-  EXPECT_TRUE(result3->HasOneRef());
-}
+INSTANTIATE_TEST_SUITE_P(HarfBuzzShaperTest,
+                         ShapeParameterTest,
+                         testing::Values(TextDirection::kLtr,
+                                         TextDirection::kRtl));
 
 TEST_F(HarfBuzzShaperTest, ResolveCandidateRunsLatin) {
   String latin_common = To16Bit("ABC DEF.", 8);
@@ -198,11 +269,9 @@ TEST_F(HarfBuzzShaperTest, ResolveCandidateRunsUnicodeVariants) {
 // If the specified VS is not in the font, it's mapped to .notdef.
 // then hb_ot_hide_default_ignorables() swaps it to a space with zero-advance.
 // http://lists.freedesktop.org/archives/harfbuzz/2015-May/004888.html
-#if !defined(OS_MACOSX)
       EXPECT_EQ(TestInfo(result)->FontDataForTesting(0)->SpaceGlyph(),
                 TestInfo(result)->GlyphForTesting(0, 1))
           << test.name;
-#endif
       EXPECT_EQ(0.f, TestInfo(result)->AdvanceForTesting(0, 1)) << test.name;
     } else {
       EXPECT_EQ(1u, num_glyphs) << test.name;
@@ -212,49 +281,44 @@ TEST_F(HarfBuzzShaperTest, ResolveCandidateRunsUnicodeVariants) {
 }
 
 TEST_F(HarfBuzzShaperTest, ResolveCandidateRunsDevanagariCommon) {
+  SelectDevanagariFont();
   UChar devanagari_common_string[] = {0x915, 0x94d, 0x930, 0x28, 0x20, 0x29};
   String devanagari_common_latin(devanagari_common_string, 6);
   HarfBuzzShaper shaper(devanagari_common_latin);
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, TextDirection::kLtr);
 
-  EXPECT_EQ(2u, TestInfo(result)->NumberOfRunsForTesting());
-  ASSERT_TRUE(
-      TestInfo(result)->RunInfoForTesting(0, start_index, num_glyphs, script));
-  EXPECT_EQ(0u, start_index);
-  EXPECT_EQ(1u, num_glyphs);
-  EXPECT_EQ(HB_SCRIPT_DEVANAGARI, script);
+  // Depending on font coverage we cannot assume that all text is in one
+  // run, the parenthesis U+0029 may be in a separate font.
+  EXPECT_GT(TestInfo(result)->NumberOfRunsForTesting(), 0u);
+  EXPECT_LE(TestInfo(result)->NumberOfRunsForTesting(), 2u);
 
-  ASSERT_TRUE(
-      TestInfo(result)->RunInfoForTesting(1, start_index, num_glyphs, script));
-  EXPECT_EQ(3u, start_index);
-  EXPECT_EQ(3u, num_glyphs);
-  EXPECT_EQ(HB_SCRIPT_DEVANAGARI, script);
+  // Common part of the run must be resolved as Devanagari.
+  for (unsigned i = 0; i < TestInfo(result)->NumberOfRunsForTesting(); ++i) {
+    ASSERT_TRUE(TestInfo(result)->RunInfoForTesting(i, start_index, num_glyphs,
+                                                    script));
+    EXPECT_EQ(HB_SCRIPT_DEVANAGARI, script);
+  }
 }
 
 TEST_F(HarfBuzzShaperTest, ResolveCandidateRunsDevanagariCommonLatinCommon) {
+  SelectDevanagariFont();
   UChar devanagari_common_latin_string[] = {0x915, 0x94d, 0x930, 0x20,
                                             0x61,  0x62,  0x2E};
   HarfBuzzShaper shaper(String(devanagari_common_latin_string, 7));
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, TextDirection::kLtr);
 
-  EXPECT_EQ(3u, TestInfo(result)->NumberOfRunsForTesting());
-  ASSERT_TRUE(
-      TestInfo(result)->RunInfoForTesting(0, start_index, num_glyphs, script));
-  EXPECT_EQ(0u, start_index);
-  EXPECT_EQ(1u, num_glyphs);
-  EXPECT_EQ(HB_SCRIPT_DEVANAGARI, script);
+  // Ensure that there are only two scripts, Devanagari first, then Latin.
+  EXPECT_GT(TestInfo(result)->NumberOfRunsForTesting(), 0u);
+  EXPECT_LE(TestInfo(result)->NumberOfRunsForTesting(), 3u);
 
-  ASSERT_TRUE(
-      TestInfo(result)->RunInfoForTesting(1, start_index, num_glyphs, script));
-  EXPECT_EQ(3u, start_index);
-  EXPECT_EQ(1u, num_glyphs);
-  EXPECT_EQ(HB_SCRIPT_DEVANAGARI, script);
-
-  ASSERT_TRUE(
-      TestInfo(result)->RunInfoForTesting(2, start_index, num_glyphs, script));
-  EXPECT_EQ(4u, start_index);
-  EXPECT_EQ(3u, num_glyphs);
-  EXPECT_EQ(HB_SCRIPT_LATIN, script);
+  bool finished_devanagari = false;
+  for (unsigned i = 0; i < TestInfo(result)->NumberOfRunsForTesting(); ++i) {
+    ASSERT_TRUE(TestInfo(result)->RunInfoForTesting(i, start_index, num_glyphs,
+                                                    script));
+    finished_devanagari = finished_devanagari | (script == HB_SCRIPT_LATIN);
+    EXPECT_EQ(script,
+              finished_devanagari ? HB_SCRIPT_LATIN : HB_SCRIPT_DEVANAGARI);
+  }
 }
 
 TEST_F(HarfBuzzShaperTest, ResolveCandidateRunsArabicThaiHanLatin) {
@@ -366,10 +430,15 @@ TEST_F(HarfBuzzShaperTest, ShapeLatinSegment) {
 }
 
 // Represents the case where a part of a cluster has a different color.
-// <div>0x647<span style="color: red;">0x64A</span></div>
-// This test requires context-aware shaping which hasn't been implemented yet.
-// See crbug.com/689155
-TEST_F(HarfBuzzShaperTest, DISABLED_ShapeArabicWithContext) {
+// <div>0x647<span style="color: red;">0x64A</span></
+// Cannot be enabled on Mac yet, compare
+// https:// https://github.com/harfbuzz/harfbuzz/issues/1415
+#if defined(OS_MAC)
+#define MAYBE_ShapeArabicWithContext DISABLED_ShapeArabicWithContext
+#else
+#define MAYBE_ShapeArabicWithContext ShapeArabicWithContext
+#endif
+TEST_F(HarfBuzzShaperTest, MAYBE_ShapeArabicWithContext) {
   UChar arabic_string[] = {0x647, 0x64A};
   HarfBuzzShaper shaper(String(arabic_string, 2));
 
@@ -386,10 +455,18 @@ TEST_F(HarfBuzzShaperTest, DISABLED_ShapeArabicWithContext) {
   ASSERT_NEAR(combined->Width(), first->Width() + second->Width(), 0.1);
 }
 
+TEST_F(HarfBuzzShaperTest, ShapeTabulationCharacters) {
+  const unsigned length = HarfBuzzRunGlyphData::kMaxGlyphs * 2 + 1;
+  scoped_refptr<ShapeResult> result =
+      ShapeResult::CreateForTabulationCharacters(&font, TextDirection::kLtr,
+                                                 TabSize(8), 0.f, 0, length);
+  EXPECT_EQ(result->NumCharacters(), length);
+  EXPECT_EQ(result->NumGlyphs(), length);
+}
+
 TEST_F(HarfBuzzShaperTest, ShapeVerticalUpright) {
   font_description.SetOrientation(FontOrientation::kVerticalUpright);
   font = Font(font_description);
-  font.Update(nullptr);
 
   // This string should create 2 runs, ideographic and Latin, both in upright.
   String string(u"\u65E5\u65E5\u65E5lllll");
@@ -397,20 +474,42 @@ TEST_F(HarfBuzzShaperTest, ShapeVerticalUpright) {
   HarfBuzzShaper shaper(string);
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
 
-  // Check width and bounds are not too much different. ".1" is heuristic.
-  EXPECT_NEAR(result->Width(), result->Bounds().Width(), result->Width() * .1);
-
-  // Shape each run and merge them using CopyRange. Bounds() should match.
+  // Shape each run and merge them using CopyRange. Width() should match.
   scoped_refptr<ShapeResult> result1 = shaper.Shape(&font, direction, 0, 3);
   scoped_refptr<ShapeResult> result2 =
       shaper.Shape(&font, direction, 3, string.length());
 
   scoped_refptr<ShapeResult> composite_result =
-      ShapeResult::Create(&font, 0, direction);
+      ShapeResult::Create(&font, 0, 0, direction);
   result1->CopyRange(0, 3, composite_result.get());
   result2->CopyRange(3, string.length(), composite_result.get());
 
-  EXPECT_EQ(result->Bounds(), composite_result->Bounds());
+  EXPECT_EQ(result->Width(), composite_result->Width());
+}
+
+TEST_F(HarfBuzzShaperTest, ShapeVerticalUprightIdeograph) {
+  font_description.SetOrientation(FontOrientation::kVerticalUpright);
+  font = Font(font_description);
+
+  // This string should create one ideograph run.
+  String string(u"\u65E5\u65E6\u65E0\u65D3\u65D0");
+  TextDirection direction = TextDirection::kLtr;
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
+
+  // Shape each run and merge them using CopyRange. Width() should match.
+  scoped_refptr<ShapeResult> result1 = shaper.Shape(&font, direction, 0, 3);
+  scoped_refptr<ShapeResult> result2 =
+      shaper.Shape(&font, direction, 3, string.length());
+
+  scoped_refptr<ShapeResult> composite_result =
+      ShapeResult::Create(&font, 0, 0, direction);
+  result1->CopyRange(0, 3, composite_result.get());
+  result2->CopyRange(3, string.length(), composite_result.get());
+
+  // Rounding of x and width may be off by ~0.1 on Mac.
+  float tolerance = 0.1f;
+  EXPECT_NEAR(result->Width(), composite_result->Width(), tolerance);
 }
 
 TEST_F(HarfBuzzShaperTest, RangeShapeSmallCaps) {
@@ -421,7 +520,6 @@ TEST_F(HarfBuzzShaperTest, RangeShapeSmallCaps) {
   font_description.SetVariantCaps(FontDescription::kSmallCaps);
   font_description.SetComputedSize(12.0);
   Font font(font_description);
-  font.Update(nullptr);
 
   // Shaping index 2 to 3 means that case splitting for small caps splits before
   // character index 2 since the initial 'a' needs to be uppercased, but the
@@ -457,7 +555,6 @@ TEST_F(HarfBuzzShaperTest, RangeShapeSmallCaps) {
 TEST_F(HarfBuzzShaperTest, ShapeVerticalMixed) {
   font_description.SetOrientation(FontOrientation::kVerticalMixed);
   font = Font(font_description);
-  font.Update(nullptr);
 
   // This string should create 2 runs, ideographic in upright and Latin in
   // rotated horizontal.
@@ -466,31 +563,124 @@ TEST_F(HarfBuzzShaperTest, ShapeVerticalMixed) {
   HarfBuzzShaper shaper(string);
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
 
-  // Check width and bounds are not too much different. ".1" is heuristic.
-  EXPECT_NEAR(result->Width(), result->Bounds().Width(), result->Width() * .1);
-
-  // Shape each run and merge them using CopyRange. Bounds() should match.
+  // Shape each run and merge them using CopyRange. Width() should match.
   scoped_refptr<ShapeResult> result1 = shaper.Shape(&font, direction, 0, 3);
   scoped_refptr<ShapeResult> result2 =
       shaper.Shape(&font, direction, 3, string.length());
 
   scoped_refptr<ShapeResult> composite_result =
-      ShapeResult::Create(&font, 0, direction);
+      ShapeResult::Create(&font, 0, 0, direction);
   result1->CopyRange(0, 3, composite_result.get());
   result2->CopyRange(3, string.length(), composite_result.get());
 
-  EXPECT_EQ(result->Bounds(), composite_result->Bounds());
+  EXPECT_EQ(result->Width(), composite_result->Width());
 }
 
-TEST_P(ShapeParameterTest, MissingGlyph) {
-  // U+FFF0 is not assigned as of Unicode 10.0.
-  String string(
-      u"\uFFF0"
-      u"Hello");
+class ShapeStringTest : public HarfBuzzShaperTest,
+                        public testing::WithParamInterface<const char16_t*> {};
+
+INSTANTIATE_TEST_SUITE_P(HarfBuzzShaperTest,
+                         ShapeStringTest,
+                         testing::Values(
+                             // U+FFF0 is not assigned as of Unicode 10.0.
+                             u"\uFFF0",
+                             u"\uFFF0Hello",
+                             // U+00AD SOFT HYPHEN often does not have glyphs.
+                             u"\u00AD"));
+
+TEST_P(ShapeStringTest, MissingGlyph) {
+  String string(GetParam());
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> result = shaper.Shape(&font, TextDirection::kLtr);
+  EXPECT_EQ(0u, result->StartIndex());
+  EXPECT_EQ(string.length(), result->EndIndex());
+}
+
+// Test splitting runs by kMaxCharacterIndex using a simple string that has code
+// point:glyph:cluster are all 1:1.
+TEST_P(ShapeParameterTest, MaxGlyphsSimple) {
+  const unsigned length = HarfBuzzRunGlyphData::kMaxCharacterIndex + 2;
+  String string = CreateStringOf('X', length);
   HarfBuzzShaper shaper(string);
   scoped_refptr<ShapeResult> result = ShapeWithParameter(&shaper);
-  EXPECT_EQ(0u, result->StartIndexForResult());
-  EXPECT_EQ(string.length(), result->EndIndexForResult());
+  EXPECT_EQ(length, result->NumCharacters());
+  EXPECT_EQ(length, result->NumGlyphs());
+  Vector<ShapeResultRunData> runs = ShapeResultRunData::Get(result);
+  if (IsRtl(GetParam()))
+    runs.Reverse();
+  EXPECT_THAT(
+      runs, testing::ElementsAre(
+                ShapeResultRunData{0, length - 1, length - 1, HB_SCRIPT_LATIN},
+                ShapeResultRunData{length - 1, 1, 1, HB_SCRIPT_LATIN}));
+}
+
+// 'X' + U+0300 COMBINING GRAVE ACCENT is a cluster, but most fonts do not have
+// a pre-composed glyph for it, so code points and glyphs are 1:1. Because the
+// length is "+1" and the last character is combining, this string does not hit
+// kMaxCharacterIndex but hits kMaxGlyphs.
+TEST_P(ShapeParameterTest, MaxGlyphsClusterLatin) {
+  const unsigned length = HarfBuzzRunGlyphData::kMaxGlyphs + 1;
+  String string = CreateStringOf('X', length);
+  string.replace(1, 1, u"\u0300");
+  string.replace(length - 2, 2, u"Z\u0300");
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> result = ShapeWithParameter(&shaper);
+  EXPECT_EQ(length, result->NumCharacters());
+  EXPECT_EQ(length, result->NumGlyphs());
+  Vector<ShapeResultRunData> runs = ShapeResultRunData::Get(result);
+  if (IsRtl(GetParam()))
+    runs.Reverse();
+  EXPECT_THAT(
+      runs, testing::ElementsAre(
+                ShapeResultRunData{0, length - 2, length - 2, HB_SCRIPT_LATIN},
+                ShapeResultRunData{length - 2, 2u, 2u, HB_SCRIPT_LATIN}));
+}
+
+// Same as MaxGlyphsClusterLatin, but by making the length "+2", this string
+// hits kMaxCharacterIndex.
+TEST_P(ShapeParameterTest, MaxGlyphsClusterLatin2) {
+  const unsigned length = HarfBuzzRunGlyphData::kMaxGlyphs + 2;
+  String string = CreateStringOf('X', length);
+  string.replace(1, 1, u"\u0300");
+  string.replace(length - 2, 2, u"Z\u0300");
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> result = ShapeWithParameter(&shaper);
+  EXPECT_EQ(length, result->NumCharacters());
+  EXPECT_EQ(length, result->NumGlyphs());
+  Vector<ShapeResultRunData> runs = ShapeResultRunData::Get(result);
+  if (IsRtl(GetParam()))
+    runs.Reverse();
+  EXPECT_THAT(
+      runs, testing::ElementsAre(
+                ShapeResultRunData{0, length - 2, length - 2, HB_SCRIPT_LATIN},
+                ShapeResultRunData{length - 2, 2u, 2u, HB_SCRIPT_LATIN}));
+}
+
+TEST_P(ShapeParameterTest, MaxGlyphsClusterDevanagari) {
+  const unsigned length = HarfBuzzRunGlyphData::kMaxCharacterIndex + 2;
+  String string = CreateStringOf(0x930, length);
+  string.replace(0, 3, u"\u0930\u093F\u0902");
+  string.replace(length - 3, 3, u"\u0930\u093F\u0902");
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> result = ShapeWithParameter(&shaper);
+  EXPECT_EQ(length, result->NumCharacters());
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+  // Linux and Fuchsia use Lohit Devanagari. When using that font the shaper
+  // returns 32767 glyphs instead of 32769.
+  // TODO(crbug.com/933551): Add Noto Sans Devanagari to
+  // //third_party/test_fonts and use it here.
+  if (result->NumGlyphs() != length)
+    return;
+#endif
+  EXPECT_EQ(length, result->NumGlyphs());
+  Vector<ShapeResultRunData> runs = ShapeResultRunData::Get(result);
+  if (IsRtl(GetParam()))
+    runs.Reverse();
+  EXPECT_THAT(
+      runs,
+      testing::ElementsAre(
+          ShapeResultRunData{0, length - 3, length - 3, HB_SCRIPT_DEVANAGARI},
+          ShapeResultRunData{length - 3, 3u, 3u, HB_SCRIPT_DEVANAGARI}));
 }
 
 TEST_P(ShapeParameterTest, ZeroWidthSpace) {
@@ -505,8 +695,8 @@ TEST_P(ShapeParameterTest, ZeroWidthSpace) {
   const unsigned length = base::size(string);
   HarfBuzzShaper shaper(String(string, length));
   scoped_refptr<ShapeResult> result = ShapeWithParameter(&shaper);
-  EXPECT_EQ(0u, result->StartIndexForResult());
-  EXPECT_EQ(length, result->EndIndexForResult());
+  EXPECT_EQ(0u, result->StartIndex());
+  EXPECT_EQ(length, result->EndIndex());
 #if DCHECK_IS_ON()
   result->CheckConsistency();
 #endif
@@ -517,16 +707,14 @@ TEST_F(HarfBuzzShaperTest, NegativeLetterSpacing) {
   HarfBuzzShaper shaper(string);
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, TextDirection::kLtr);
   float width = result->Width();
-  FloatRect bounds = result->Bounds();
 
   ShapeResultSpacing<String> spacing(string);
   FontDescription font_description;
   font_description.SetLetterSpacing(-5);
-  spacing.SetSpacing(font_description);
+  spacing.SetSpacing(Font(font_description));
   result->ApplySpacing(spacing);
 
   EXPECT_EQ(5 * 5, width - result->Width());
-  EXPECT_EQ(5 * 4 - 1, bounds.Width() - result->Bounds().Width());
 }
 
 TEST_F(HarfBuzzShaperTest, NegativeLetterSpacingTo0) {
@@ -538,15 +726,10 @@ TEST_F(HarfBuzzShaperTest, NegativeLetterSpacingTo0) {
   ShapeResultSpacing<String> spacing(string);
   FontDescription font_description;
   font_description.SetLetterSpacing(-char_width);
-  spacing.SetSpacing(font_description);
+  spacing.SetSpacing(Font(font_description));
   result->ApplySpacing(spacing);
 
   // EXPECT_EQ(0.0f, result->Width());
-  EXPECT_NEAR(0.0f, result->Bounds().X(), 1);
-  // Because all characters are at 0, the glyph bounds must be the char_width.
-  // Allow being larger because accurate width requires re-measuring each glyph.
-  EXPECT_GE(result->Bounds().MaxX(), char_width);
-  EXPECT_LE(result->Bounds().MaxX(), char_width * 1.2);
 }
 
 TEST_F(HarfBuzzShaperTest, NegativeLetterSpacingToNegative) {
@@ -558,15 +741,11 @@ TEST_F(HarfBuzzShaperTest, NegativeLetterSpacingToNegative) {
   ShapeResultSpacing<String> spacing(string);
   FontDescription font_description;
   font_description.SetLetterSpacing(-2 * char_width);
-  spacing.SetSpacing(font_description);
+  spacing.SetSpacing(Font(font_description));
   result->ApplySpacing(spacing);
 
   // CSS does not allow negative width, it should be clampled to 0.
   // EXPECT_EQ(0.0f, result->Width());
-  // Glyph bounding box should overflow to the left.
-  EXPECT_EQ(-char_width * string.length(), result->Bounds().X());
-  // MaxX() should be char_width. Allow being larger.
-  EXPECT_GE(result->Bounds().MaxX(), char_width);
 }
 
 static struct GlyphDataRangeTestData {
@@ -582,17 +761,14 @@ static struct GlyphDataRangeTestData {
     // The two code points form a grapheme cluster, which produces two glyphs.
     // Character index array should be [0, 0].
     {u"\u05E9\u05B0", TextDirection::kRtl, 0, 0, 1, 0, 2},
-#if !defined(OS_MACOSX)
     // ZWJ tests taken from fast/text/international/zerowidthjoiner.html
     // Character index array should be [6, 3, 3, 3, 0, 0, 0].
-    // Mac shapes differently and that glyph index expectations do not match.
     {u"\u0639\u200D\u200D\u0639\u200D\u200D\u0639", TextDirection::kRtl, 0, 0,
      1, 4, 7},
     {u"\u0639\u200D\u200D\u0639\u200D\u200D\u0639", TextDirection::kRtl, 0, 2,
      5, 1, 4},
     {u"\u0639\u200D\u200D\u0639\u200D\u200D\u0639", TextDirection::kRtl, 0, 4,
      7, 0, 1},
-#endif
 };
 
 std::ostream& operator<<(std::ostream& ostream,
@@ -604,9 +780,9 @@ class GlyphDataRangeTest
     : public HarfBuzzShaperTest,
       public testing::WithParamInterface<GlyphDataRangeTestData> {};
 
-INSTANTIATE_TEST_CASE_P(HarfBuzzShaperTest,
-                        GlyphDataRangeTest,
-                        testing::ValuesIn(glyph_data_range_test_data));
+INSTANTIATE_TEST_SUITE_P(HarfBuzzShaperTest,
+                         GlyphDataRangeTest,
+                         testing::ValuesIn(glyph_data_range_test_data));
 
 TEST_P(GlyphDataRangeTest, Data) {
   auto data = GetParam();
@@ -614,7 +790,7 @@ TEST_P(GlyphDataRangeTest, Data) {
   HarfBuzzShaper shaper(string);
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, data.direction);
 
-  auto& run = TestInfo(result)->RunInfoForTesting(data.run_index);
+  const auto& run = TestInfo(result)->RunInfoForTesting(data.run_index);
   auto glyphs = run.FindGlyphDataRange(data.start_offset, data.end_offset);
   unsigned start_glyph = std::distance(run.glyph_data_.begin(), glyphs.begin);
   EXPECT_EQ(data.start_glyph, start_glyph);
@@ -666,7 +842,7 @@ class OffsetForPositionTest
     : public HarfBuzzShaperTest,
       public testing::WithParamInterface<OffsetForPositionTestData> {};
 
-INSTANTIATE_TEST_CASE_P(
+INSTANTIATE_TEST_SUITE_P(
     HarfBuzzShaperTest,
     OffsetForPositionTest,
     testing::ValuesIn(offset_for_position_fixed_pitch_test_data));
@@ -679,11 +855,9 @@ TEST_P(OffsetForPositionTest, Data) {
   scoped_refptr<ShapeResult> result =
       SplitRun(shaper.Shape(&ahem, TextDirection::kLtr), 2);
   EXPECT_EQ(data.offset_ltr,
-            result->OffsetForPosition(data.position, OnlyFullGlyphs,
-                                      DontBreakGlyphs));
-  EXPECT_EQ(data.hit_test_ltr,
-            result->OffsetForPosition(data.position, IncludePartialGlyphs,
-                                      DontBreakGlyphs));
+            result->OffsetForPosition(data.position, DontBreakGlyphs));
+  EXPECT_EQ(data.hit_test_ltr, result->CaretOffsetForHitTest(
+                                   data.position, string, DontBreakGlyphs));
   EXPECT_EQ(data.fit_ltr_ltr,
             result->OffsetToFit(data.position, TextDirection::kLtr));
   EXPECT_EQ(data.fit_ltr_rtl,
@@ -691,11 +865,9 @@ TEST_P(OffsetForPositionTest, Data) {
 
   result = SplitRun(shaper.Shape(&ahem, TextDirection::kRtl), 3);
   EXPECT_EQ(data.offset_rtl,
-            result->OffsetForPosition(data.position, OnlyFullGlyphs,
-                                      DontBreakGlyphs));
-  EXPECT_EQ(data.hit_test_rtl,
-            result->OffsetForPosition(data.position, IncludePartialGlyphs,
-                                      DontBreakGlyphs));
+            result->OffsetForPosition(data.position, DontBreakGlyphs));
+  EXPECT_EQ(data.hit_test_rtl, result->CaretOffsetForHitTest(
+                                   data.position, string, DontBreakGlyphs));
   EXPECT_EQ(data.fit_rtl_ltr,
             result->OffsetToFit(data.position, TextDirection::kLtr));
   EXPECT_EQ(data.fit_rtl_rtl,
@@ -743,12 +915,15 @@ TEST_F(HarfBuzzShaperTest, EmojiZWJSequence) {
 
 // A Value-Parameterized Test class to test OffsetForPosition() with
 // |include_partial_glyphs| parameter.
-class IncludePartialGlyphsTest : public HarfBuzzShaperTest,
-                                 public ::testing::WithParamInterface<bool> {};
+class IncludePartialGlyphsTest
+    : public HarfBuzzShaperTest,
+      public ::testing::WithParamInterface<IncludePartialGlyphsOption> {};
 
-INSTANTIATE_TEST_CASE_P(OffsetForPositionTest,
-                        IncludePartialGlyphsTest,
-                        ::testing::Bool());
+INSTANTIATE_TEST_SUITE_P(
+    HarfBuzzShaperTest,
+    IncludePartialGlyphsTest,
+    ::testing::Values(IncludePartialGlyphsOption::OnlyFullGlyphs,
+                      IncludePartialGlyphsOption::IncludePartialGlyphs));
 
 TEST_P(IncludePartialGlyphsTest,
        OffsetForPositionMatchesPositionForOffsetLatin) {
@@ -758,84 +933,77 @@ TEST_P(IncludePartialGlyphsTest,
   HarfBuzzShaper shaper(string);
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
 
-  bool include_partial_glyphs = GetParam();
-  IncludePartialGlyphsOption partial =
-      include_partial_glyphs ? IncludePartialGlyphs : OnlyFullGlyphs;
-
-  EXPECT_EQ(0u, result->OffsetForPosition(result->PositionForOffset(0), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(1u, result->OffsetForPosition(result->PositionForOffset(1), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(2u, result->OffsetForPosition(result->PositionForOffset(2), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(3u, result->OffsetForPosition(result->PositionForOffset(3), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(4u, result->OffsetForPosition(result->PositionForOffset(4), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(5u, result->OffsetForPosition(result->PositionForOffset(5), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(6u, result->OffsetForPosition(result->PositionForOffset(6), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(7u, result->OffsetForPosition(result->PositionForOffset(7), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(8u, result->OffsetForPosition(result->PositionForOffset(8), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(9u, result->OffsetForPosition(result->PositionForOffset(9), partial,
-                                          DontBreakGlyphs));
+  IncludePartialGlyphsOption partial = GetParam();
+  EXPECT_EQ(0u, result->OffsetForPosition(result->PositionForOffset(0), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(1u, result->OffsetForPosition(result->PositionForOffset(1), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(2u, result->OffsetForPosition(result->PositionForOffset(2), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(3u, result->OffsetForPosition(result->PositionForOffset(3), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(4u, result->OffsetForPosition(result->PositionForOffset(4), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(5u, result->OffsetForPosition(result->PositionForOffset(5), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(6u, result->OffsetForPosition(result->PositionForOffset(6), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(7u, result->OffsetForPosition(result->PositionForOffset(7), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(8u, result->OffsetForPosition(result->PositionForOffset(8), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(9u, result->OffsetForPosition(result->PositionForOffset(9), string,
+                                          partial, DontBreakGlyphs));
   EXPECT_EQ(10u, result->OffsetForPosition(result->PositionForOffset(10),
-                                           partial, DontBreakGlyphs));
+                                           string, partial, DontBreakGlyphs));
   EXPECT_EQ(11u, result->OffsetForPosition(result->PositionForOffset(11),
-                                           partial, DontBreakGlyphs));
+                                           string, partial, DontBreakGlyphs));
   EXPECT_EQ(12u, result->OffsetForPosition(result->PositionForOffset(12),
-                                           partial, DontBreakGlyphs));
+                                           string, partial, DontBreakGlyphs));
 }
 
 TEST_P(IncludePartialGlyphsTest,
        OffsetForPositionMatchesPositionForOffsetArabic) {
   UChar arabic_string[] = {0x628, 0x64A, 0x629};
+  String string(arabic_string, 3);
   TextDirection direction = TextDirection::kRtl;
 
-  HarfBuzzShaper shaper(String(arabic_string, 3));
+  HarfBuzzShaper shaper(string);
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
 
-  bool include_partial_glyphs = GetParam();
-  IncludePartialGlyphsOption partial =
-      include_partial_glyphs ? IncludePartialGlyphs : OnlyFullGlyphs;
-
-  EXPECT_EQ(0u, result->OffsetForPosition(result->PositionForOffset(0), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(1u, result->OffsetForPosition(result->PositionForOffset(1), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(2u, result->OffsetForPosition(result->PositionForOffset(2), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(3u, result->OffsetForPosition(result->PositionForOffset(3), partial,
-                                          DontBreakGlyphs));
+  IncludePartialGlyphsOption partial = GetParam();
+  EXPECT_EQ(0u, result->OffsetForPosition(result->PositionForOffset(0), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(1u, result->OffsetForPosition(result->PositionForOffset(1), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(2u, result->OffsetForPosition(result->PositionForOffset(2), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(3u, result->OffsetForPosition(result->PositionForOffset(3), string,
+                                          partial, DontBreakGlyphs));
 }
 
 TEST_P(IncludePartialGlyphsTest,
        OffsetForPositionMatchesPositionForOffsetMixed) {
   UChar mixed_string[] = {0x628, 0x64A, 0x629, 0xE20, 0x65E5, 0x62};
-  HarfBuzzShaper shaper(String(mixed_string, 6));
+  String string(mixed_string, 6);
+  HarfBuzzShaper shaper(string);
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, TextDirection::kLtr);
 
-  bool include_partial_glyphs = GetParam();
-  IncludePartialGlyphsOption partial =
-      include_partial_glyphs ? IncludePartialGlyphs : OnlyFullGlyphs;
-
-  EXPECT_EQ(0u, result->OffsetForPosition(result->PositionForOffset(0), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(1u, result->OffsetForPosition(result->PositionForOffset(1), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(2u, result->OffsetForPosition(result->PositionForOffset(2), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(3u, result->OffsetForPosition(result->PositionForOffset(3), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(4u, result->OffsetForPosition(result->PositionForOffset(4), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(5u, result->OffsetForPosition(result->PositionForOffset(5), partial,
-                                          DontBreakGlyphs));
-  EXPECT_EQ(6u, result->OffsetForPosition(result->PositionForOffset(6), partial,
-                                          DontBreakGlyphs));
+  IncludePartialGlyphsOption partial = GetParam();
+  EXPECT_EQ(0u, result->OffsetForPosition(result->PositionForOffset(0), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(1u, result->OffsetForPosition(result->PositionForOffset(1), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(2u, result->OffsetForPosition(result->PositionForOffset(2), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(3u, result->OffsetForPosition(result->PositionForOffset(3), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(4u, result->OffsetForPosition(result->PositionForOffset(4), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(5u, result->OffsetForPosition(result->PositionForOffset(5), string,
+                                          partial, DontBreakGlyphs));
+  EXPECT_EQ(6u, result->OffsetForPosition(result->PositionForOffset(6), string,
+                                          partial, DontBreakGlyphs));
 }
 
 TEST_F(HarfBuzzShaperTest, CachedOffsetPositionMappingForOffsetLatin) {
@@ -890,6 +1058,46 @@ TEST_F(HarfBuzzShaperTest, CachedOffsetPositionMappingMixed) {
   EXPECT_EQ(6u, sr->CachedOffsetForPosition(sr->CachedPositionForOffset(6)));
 }
 
+TEST_F(HarfBuzzShaperTest, PositionForOffsetMultiGlyphClusterLtr) {
+  // In this Hindi text, each code unit produces a glyph, and the first 3 glyphs
+  // form a grapheme cluster, and the last 2 glyphs form another.
+  String string(u"\u0930\u093F\u0902\u0926\u0940");
+  TextDirection direction = TextDirection::kLtr;
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> sr = shaper.Shape(&font, direction);
+  sr->EnsurePositionData();
+
+  // The first 3 code units should be at position 0.
+  EXPECT_EQ(0, sr->CachedPositionForOffset(0));
+  EXPECT_EQ(0, sr->CachedPositionForOffset(1));
+  EXPECT_EQ(0, sr->CachedPositionForOffset(2));
+  // The last 2 code units should be > 0, and the same position.
+  EXPECT_GT(sr->CachedPositionForOffset(3), 0);
+  EXPECT_EQ(sr->CachedPositionForOffset(3), sr->CachedPositionForOffset(4));
+}
+
+TEST_F(HarfBuzzShaperTest, PositionForOffsetMultiGlyphClusterRtl) {
+  // In this Hindi text, each code unit produces a glyph, and the first 3 glyphs
+  // form a grapheme cluster, and the last 2 glyphs form another.
+  String string(u"\u0930\u093F\u0902\u0926\u0940");
+  TextDirection direction = TextDirection::kRtl;
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> sr = shaper.Shape(&font, direction);
+  sr->EnsurePositionData();
+
+  // The first 3 code units should be at position 0, but since this is RTL, the
+  // position is the right edgef of the character, and thus > 0.
+  float pos0 = sr->CachedPositionForOffset(0);
+  EXPECT_GT(pos0, 0);
+  EXPECT_EQ(pos0, sr->CachedPositionForOffset(1));
+  EXPECT_EQ(pos0, sr->CachedPositionForOffset(2));
+  // The last 2 code units should be > 0, and the same position.
+  float pos3 = sr->CachedPositionForOffset(3);
+  EXPECT_GT(pos3, 0);
+  EXPECT_LT(pos3, pos0);
+  EXPECT_EQ(pos3, sr->CachedPositionForOffset(4));
+}
+
 TEST_F(HarfBuzzShaperTest, PositionForOffsetMissingGlyph) {
   String string(u"\u0633\u0644\u0627\u0645");
   HarfBuzzShaper shaper(string);
@@ -922,9 +1130,9 @@ class ShapeResultCopyRangeTest
     : public HarfBuzzShaperTest,
       public testing::WithParamInterface<ShapeResultCopyRangeTestData> {};
 
-INSTANTIATE_TEST_CASE_P(HarfBuzzShaperTest,
-                        ShapeResultCopyRangeTest,
-                        testing::ValuesIn(shape_result_copy_range_test_data));
+INSTANTIATE_TEST_SUITE_P(HarfBuzzShaperTest,
+                         ShapeResultCopyRangeTest,
+                         testing::ValuesIn(shape_result_copy_range_test_data));
 
 // Split a ShapeResult and combine them should match to the original result.
 TEST_P(ShapeResultCopyRangeTest, Split) {
@@ -936,21 +1144,23 @@ TEST_P(ShapeResultCopyRangeTest, Split) {
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
 
   // Split the result.
-  scoped_refptr<ShapeResult> result1 = ShapeResult::Create(&font, 0, direction);
+  scoped_refptr<ShapeResult> result1 =
+      ShapeResult::Create(&font, 0, 0, direction);
   result->CopyRange(0, test_data.break_point, result1.get());
   EXPECT_EQ(test_data.break_point, result1->NumCharacters());
-  EXPECT_EQ(0u, result1->StartIndexForResult());
-  EXPECT_EQ(test_data.break_point, result1->EndIndexForResult());
+  EXPECT_EQ(0u, result1->StartIndex());
+  EXPECT_EQ(test_data.break_point, result1->EndIndex());
 
-  scoped_refptr<ShapeResult> result2 = ShapeResult::Create(&font, 0, direction);
+  scoped_refptr<ShapeResult> result2 =
+      ShapeResult::Create(&font, 0, 0, direction);
   result->CopyRange(test_data.break_point, string.length(), result2.get());
   EXPECT_EQ(string.length() - test_data.break_point, result2->NumCharacters());
-  EXPECT_EQ(test_data.break_point, result2->StartIndexForResult());
-  EXPECT_EQ(string.length(), result2->EndIndexForResult());
+  EXPECT_EQ(test_data.break_point, result2->StartIndex());
+  EXPECT_EQ(string.length(), result2->EndIndex());
 
   // Combine them.
   scoped_refptr<ShapeResult> composite_result =
-      ShapeResult::Create(&font, 0, direction);
+      ShapeResult::Create(&font, 0, 0, direction);
   result1->CopyRange(0, test_data.break_point, composite_result.get());
   result2->CopyRange(0, string.length(), composite_result.get());
   EXPECT_EQ(string.length(), composite_result->NumCharacters());
@@ -983,7 +1193,7 @@ TEST_P(ShapeResultCopyRangeTest, ShapeRange) {
 
   // Combine them.
   scoped_refptr<ShapeResult> composite_result =
-      ShapeResult::Create(&font, 0, direction);
+      ShapeResult::Create(&font, 0, 0, direction);
   result1->CopyRange(0, test_data.break_point, composite_result.get());
   result2->CopyRange(0, string.length(), composite_result.get());
   EXPECT_EQ(string.length(), composite_result->NumCharacters());
@@ -1004,7 +1214,7 @@ TEST_F(HarfBuzzShaperTest, ShapeResultCopyRangeIntoLatin) {
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
 
   scoped_refptr<ShapeResult> composite_result =
-      ShapeResult::Create(&font, 0, direction);
+      ShapeResult::Create(&font, 0, 0, direction);
   result->CopyRange(0, 10, composite_result.get());
   result->CopyRange(10, 20, composite_result.get());
   result->CopyRange(20, 30, composite_result.get());
@@ -1012,7 +1222,11 @@ TEST_F(HarfBuzzShaperTest, ShapeResultCopyRangeIntoLatin) {
 
   EXPECT_EQ(result->NumCharacters(), composite_result->NumCharacters());
   EXPECT_EQ(result->SnappedWidth(), composite_result->SnappedWidth());
-  EXPECT_EQ(result->Bounds(), composite_result->Bounds());
+
+  // Rounding of width may be off by ~0.1 on Mac.
+  float tolerance = 0.1f;
+  EXPECT_NEAR(result->Width(), composite_result->Width(), tolerance);
+
   EXPECT_EQ(result->SnappedStartPositionForOffset(0),
             composite_result->SnappedStartPositionForOffset(0));
   EXPECT_EQ(result->SnappedStartPositionForOffset(15),
@@ -1030,19 +1244,14 @@ TEST_F(HarfBuzzShaperTest, ShapeResultCopyRangeIntoArabicThaiHanLatin) {
   HarfBuzzShaper shaper(String(mixed_string, 8));
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
 
-  // Check width and bounds are not too much different. ".2" is heuristic.
-  EXPECT_NEAR(result->Width(), result->Bounds().Width(), result->Width() * .2);
-
   scoped_refptr<ShapeResult> composite_result =
-      ShapeResult::Create(&font, 0, direction);
+      ShapeResult::Create(&font, 0, 0, direction);
   result->CopyRange(0, 4, composite_result.get());
   result->CopyRange(4, 6, composite_result.get());
   result->CopyRange(6, 8, composite_result.get());
 
   EXPECT_EQ(result->NumCharacters(), composite_result->NumCharacters());
   EXPECT_EQ(result->SnappedWidth(), composite_result->SnappedWidth());
-  EXPECT_TRUE(composite_result->Bounds().Contains(result->Bounds()))
-      << composite_result->Bounds() << "/" << result->Bounds();
   EXPECT_EQ(result->SnappedStartPositionForOffset(0),
             composite_result->SnappedStartPositionForOffset(0));
   EXPECT_EQ(result->SnappedStartPositionForOffset(1),
@@ -1063,25 +1272,38 @@ TEST_F(HarfBuzzShaperTest, ShapeResultCopyRangeIntoArabicThaiHanLatin) {
             composite_result->SnappedStartPositionForOffset(8));
 }
 
-TEST_F(HarfBuzzShaperTest, ShapeResultCopyRangeAcrossRuns) {
+TEST_P(ShapeParameterTest, ShapeResultCopyRangeAcrossRuns) {
   // Create 3 runs:
   // [0]: 1 character.
   // [1]: 5 characters.
   // [2]: 2 character.
   String mixed_string(u"\u65E5Hello\u65E5\u65E5");
-  TextDirection direction = TextDirection::kLtr;
+  TextDirection direction = GetParam();
   HarfBuzzShaper shaper(mixed_string);
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
 
-  // Check width and bounds are not too much different. ".1" is heuristic.
-  EXPECT_NEAR(result->Width(), result->Bounds().Width(), result->Width() * .1);
-
   // CopyRange(5, 7) should copy 1 character from [1] and 1 from [2].
-  scoped_refptr<ShapeResult> target = ShapeResult::Create(&font, 0, direction);
+  scoped_refptr<ShapeResult> target =
+      ShapeResult::Create(&font, 0, 0, direction);
   result->CopyRange(5, 7, target.get());
   EXPECT_EQ(2u, target->NumCharacters());
 }
 
+TEST_P(ShapeParameterTest, ShapeResultCopyRangeContextMultiRuns) {
+  // Create 2 runs:
+  // [0]: 5 characters.
+  // [1]: 4 character.
+  String mixed_string(u"Hello\u65E5\u65E5\u65E5\u65E5");
+  TextDirection direction = GetParam();
+  HarfBuzzShaper shaper(mixed_string);
+  scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
+
+  scoped_refptr<ShapeResult> sub2to4 = result->SubRange(2, 4);
+  EXPECT_EQ(2u, sub2to4->NumCharacters());
+  scoped_refptr<ShapeResult> sub5to9 = result->SubRange(5, 9);
+  EXPECT_EQ(4u, sub5to9->NumCharacters());
+}
+
 TEST_F(HarfBuzzShaperTest, ShapeResultCopyRangeSegmentGlyphBoundingBox) {
   String string(u"THello worldL");
   TextDirection direction = TextDirection::kLtr;
@@ -1092,39 +1314,12 @@ TEST_F(HarfBuzzShaperTest, ShapeResultCopyRangeSegmentGlyphBoundingBox) {
       shaper.Shape(&font, direction, 6, string.length());
 
   scoped_refptr<ShapeResult> composite_result =
-      ShapeResult::Create(&font, 0, direction);
+      ShapeResult::Create(&font, 0, 0, direction);
   result1->CopyRange(0, 6, composite_result.get());
   result2->CopyRange(6, string.length(), composite_result.get());
 
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
-  EXPECT_EQ(result->Bounds(), composite_result->Bounds());
-
-  // Check width and bounds are not too much different. ".1" is heuristic.
-  EXPECT_NEAR(result->Width(), result->Bounds().Width(), result->Width() * .1);
-}
-
-TEST_F(HarfBuzzShaperTest, ShapeResultCopyRangeBoundsLtr) {
-  String string(u". ");
-  TextDirection direction = TextDirection::kLtr;
-  HarfBuzzShaper shaper(string);
-  scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
-
-  // Because a space character does not have ink, the bounds of "." should be
-  // the same as the bounds of ". ".
-  scoped_refptr<ShapeResult> sub_range = result->SubRange(0, 1);
-  EXPECT_EQ(sub_range->Bounds().Width(), result->Bounds().Width());
-}
-
-TEST_F(HarfBuzzShaperTest, ShapeResultCopyRangeBoundsRtl) {
-  String string(u". ");
-  TextDirection direction = TextDirection::kRtl;
-  HarfBuzzShaper shaper(string);
-  scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
-
-  // Because a space character does not have ink, the bounds of "." should be
-  // the same as the bounds of ". ".
-  scoped_refptr<ShapeResult> sub_range = result->SubRange(0, 1);
-  EXPECT_EQ(sub_range->Bounds().Width(), result->Bounds().Width());
+  EXPECT_EQ(result->Width(), composite_result->Width());
 }
 
 TEST_F(HarfBuzzShaperTest, SubRange) {
@@ -1134,8 +1329,8 @@ TEST_F(HarfBuzzShaperTest, SubRange) {
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
 
   scoped_refptr<ShapeResult> sub_range = result->SubRange(4, 7);
-  DCHECK_EQ(4u, sub_range->StartIndexForResult());
-  DCHECK_EQ(7u, sub_range->EndIndexForResult());
+  DCHECK_EQ(4u, sub_range->StartIndex());
+  DCHECK_EQ(7u, sub_range->EndIndex());
   DCHECK_EQ(3u, sub_range->NumCharacters());
   DCHECK_EQ(result->Direction(), sub_range->Direction());
 }
@@ -1167,7 +1362,7 @@ TEST_F(HarfBuzzShaperTest, SafeToBreakLatinCommonLigatures) {
   // Verify safe to break information in copied results to ensure that both
   // copying and multi-run break information works.
   scoped_refptr<ShapeResult> copied_result =
-      ShapeResult::Create(&testFont, 0, TextDirection::kLtr);
+      ShapeResult::Create(&testFont, 0, 0, TextDirection::kLtr);
   result->CopyRange(0, 3, copied_result.get());
   result->CopyRange(3, string.length(), copied_result.get());
 
@@ -1207,7 +1402,7 @@ TEST_F(HarfBuzzShaperTest, SafeToBreakPreviousLatinCommonLigatures) {
   // Verify safe to break information in copied results to ensure that both
   // copying and multi-run break information works.
   scoped_refptr<ShapeResult> copied_result =
-      ShapeResult::Create(&testFont, 0, TextDirection::kLtr);
+      ShapeResult::Create(&testFont, 0, 0, TextDirection::kLtr);
   result->CopyRange(0, 3, copied_result.get());
   result->CopyRange(3, string.length(), copied_result.get());
 
@@ -1232,59 +1427,58 @@ TEST_F(HarfBuzzShaperTest, SafeToBreakLatinDiscretionaryLigatures) {
           "third_party/MEgalopolis/MEgalopolisExtra.woff"),
       16, &ligatures);
 
-  // RA and CA form ligatures, most glyph pairs have kerning.
-  String string(u"ABRACADABRA");
-  HarfBuzzShaper shaper(string);
+  // $ ./hb-shape   --shaper=ot --features="dlig=1,kern" --show-flags
+  // MEgalopolisExtra.ttf  "RADDAYoVaDD"
+  // [R_A=0+1150|D=2+729|D=3+699|A=4+608#1|Y=5+608#1|o=6+696#1|V=7+652#1|a=8+657#1|D=9+729|D=10+729]
+  // RA Ligature, unkerned D D, D A kerns, A Y kerns, Y o kerns, o V kerns, V a
+  // kerns, no kerning with D.
+  String test_word(u"RADDAYoVaDD");
+  unsigned safe_to_break_positions[] = {2, 3, 9, 10};
+  HarfBuzzShaper shaper(test_word);
   scoped_refptr<ShapeResult> result =
       shaper.Shape(&testFont, TextDirection::kLtr);
-  EXPECT_EQ(6u, result->NextSafeToBreakOffset(1));    // After CA ligature.
-  EXPECT_EQ(6u, result->NextSafeToBreakOffset(6));    // After CA ligature.
-  EXPECT_EQ(11u, result->NextSafeToBreakOffset(7));   // At end of string.
-  EXPECT_EQ(11u, result->NextSafeToBreakOffset(9));   // At end of string.
-  EXPECT_EQ(11u, result->NextSafeToBreakOffset(10));  // At end of string.
 
-  // Add zero-width spaces at the safe to break offsets.
-  String refString(u"ABRACA\u200BDAB\u200BRA");
-  HarfBuzzShaper refShaper(refString);
+  unsigned compare_safe_to_break_position = 0;
+  for (unsigned i = 1; i < test_word.length() - 1; ++i) {
+    EXPECT_EQ(safe_to_break_positions[compare_safe_to_break_position],
+              result->NextSafeToBreakOffset(i));
+    if (i == safe_to_break_positions[compare_safe_to_break_position])
+      compare_safe_to_break_position++;
+  }
+
+  // Add zero-width spaces at some of the safe to break offsets.
+  String inserted_zero_width_spaces(u"RA\u200BD\u200BDAYoVa\u200BD\u200BD");
+  HarfBuzzShaper refShaper(inserted_zero_width_spaces);
   scoped_refptr<ShapeResult> referenceResult =
       refShaper.Shape(&testFont, TextDirection::kLtr);
 
   // Results should be identical if it truly is safe to break at the designated
-  // safe-to-break offsets
+  // safe-to-break offsets because otherwise, the zero-width spaces would have
+  // altered the text spacing, for example by breaking apart ligatures or
+  // kerning pairs.
   EXPECT_EQ(result->SnappedWidth(), referenceResult->SnappedWidth());
-  EXPECT_EQ(result->Bounds(), referenceResult->Bounds());
-  EXPECT_EQ(result->SnappedStartPositionForOffset(0),
-            referenceResult->SnappedStartPositionForOffset(0));
-  EXPECT_EQ(result->SnappedStartPositionForOffset(1),
-            referenceResult->SnappedStartPositionForOffset(1));
-  EXPECT_EQ(result->SnappedStartPositionForOffset(2),
-            referenceResult->SnappedStartPositionForOffset(2));
-  EXPECT_EQ(result->SnappedStartPositionForOffset(3),
-            referenceResult->SnappedStartPositionForOffset(3));
-  EXPECT_EQ(result->SnappedStartPositionForOffset(4),
-            referenceResult->SnappedStartPositionForOffset(4));
-  EXPECT_EQ(result->SnappedStartPositionForOffset(5),
-            referenceResult->SnappedStartPositionForOffset(5));
 
-  // First zero-width space is at position 6 so the the matching character in
-  // the reference results is 7.
-  EXPECT_EQ(result->SnappedStartPositionForOffset(6),
-            referenceResult->SnappedStartPositionForOffset(7));
-  EXPECT_EQ(result->SnappedStartPositionForOffset(7),
-            referenceResult->SnappedStartPositionForOffset(8));
-  EXPECT_EQ(result->SnappedStartPositionForOffset(8),
-            referenceResult->SnappedStartPositionForOffset(9));
-
-  // Second zero-width space is at position 9 so the the matching character in
-  // the reference results is 11.
-  EXPECT_EQ(result->SnappedStartPositionForOffset(9),
-            referenceResult->SnappedStartPositionForOffset(11));
-  EXPECT_EQ(result->SnappedStartPositionForOffset(10),
-            referenceResult->SnappedStartPositionForOffset(12));
+  // Zero-width spaces were inserted, so we need to account for that by
+  // offseting the index that we compare against.
+  unsigned inserts_offset = 0;
+  for (unsigned i = 0; i < test_word.length(); ++i) {
+    if (i == safe_to_break_positions[inserts_offset])
+      inserts_offset++;
+    EXPECT_EQ(
+        result->SnappedStartPositionForOffset(i),
+        referenceResult->SnappedStartPositionForOffset(i + inserts_offset));
+  }
 }
 
-// TODO(layout-dev): This test fails on Mac due to AAT shaping.
-TEST_F(HarfBuzzShaperTest, DISABLED_SafeToBreakArabicCommonLigatures) {
+// TODO(crbug.com/870712): This test fails due to font fallback differences on
+// Android and Fuchsia.
+#if defined(OS_ANDROID) || defined(OS_FUCHSIA)
+#define MAYBE_SafeToBreakArabicCommonLigatures \
+  DISABLED_SafeToBreakArabicCommonLigatures
+#else
+#define MAYBE_SafeToBreakArabicCommonLigatures SafeToBreakArabicCommonLigatures
+#endif
+TEST_F(HarfBuzzShaperTest, MAYBE_SafeToBreakArabicCommonLigatures) {
   FontDescription::VariantLigatures ligatures;
   ligatures.common = FontDescription::kEnabledLigaturesState;
 
@@ -1295,12 +1489,20 @@ TEST_F(HarfBuzzShaperTest, DISABLED_SafeToBreakArabicCommonLigatures) {
   HarfBuzzShaper shaper(string);
   scoped_refptr<ShapeResult> result = shaper.Shape(&font, TextDirection::kRtl);
 
-  // Safe to break at 0, 3, 4, 5, 7, and 11.
   EXPECT_EQ(0u, result->NextSafeToBreakOffset(0));
   EXPECT_EQ(3u, result->NextSafeToBreakOffset(1));
   EXPECT_EQ(3u, result->NextSafeToBreakOffset(2));
   EXPECT_EQ(3u, result->NextSafeToBreakOffset(3));
   EXPECT_EQ(4u, result->NextSafeToBreakOffset(4));
+#if defined(OS_MAC)
+  EXPECT_EQ(5u, result->NextSafeToBreakOffset(5));
+  EXPECT_EQ(11u, result->NextSafeToBreakOffset(6));
+  EXPECT_EQ(11u, result->NextSafeToBreakOffset(7));
+  EXPECT_EQ(11u, result->NextSafeToBreakOffset(8));
+  EXPECT_EQ(11u, result->NextSafeToBreakOffset(9));
+  EXPECT_EQ(11u, result->NextSafeToBreakOffset(10));
+  EXPECT_EQ(11u, result->NextSafeToBreakOffset(11));
+#else
   EXPECT_EQ(5u, result->NextSafeToBreakOffset(5));
   EXPECT_EQ(7u, result->NextSafeToBreakOffset(6));
   EXPECT_EQ(7u, result->NextSafeToBreakOffset(7));
@@ -1308,27 +1510,72 @@ TEST_F(HarfBuzzShaperTest, DISABLED_SafeToBreakArabicCommonLigatures) {
   EXPECT_EQ(11u, result->NextSafeToBreakOffset(9));
   EXPECT_EQ(11u, result->NextSafeToBreakOffset(10));
   EXPECT_EQ(11u, result->NextSafeToBreakOffset(11));
+#endif
   EXPECT_EQ(12u, result->NextSafeToBreakOffset(12));
+
+  EXPECT_EQ(0u, result->PreviousSafeToBreakOffset(0));
+  EXPECT_EQ(0u, result->PreviousSafeToBreakOffset(1));
+  EXPECT_EQ(0u, result->PreviousSafeToBreakOffset(2));
+  EXPECT_EQ(3u, result->PreviousSafeToBreakOffset(3));
+  EXPECT_EQ(4u, result->PreviousSafeToBreakOffset(4));
+#if defined(OS_MAC)
+  EXPECT_EQ(5u, result->PreviousSafeToBreakOffset(5));
+  EXPECT_EQ(5u, result->PreviousSafeToBreakOffset(6));
+  EXPECT_EQ(5u, result->PreviousSafeToBreakOffset(7));
+  EXPECT_EQ(5u, result->PreviousSafeToBreakOffset(8));
+  EXPECT_EQ(5u, result->PreviousSafeToBreakOffset(9));
+  EXPECT_EQ(5u, result->PreviousSafeToBreakOffset(10));
+  EXPECT_EQ(11u, result->PreviousSafeToBreakOffset(11));
+#else
+  EXPECT_EQ(5u, result->PreviousSafeToBreakOffset(5));
+  EXPECT_EQ(5u, result->PreviousSafeToBreakOffset(6));
+  EXPECT_EQ(7u, result->PreviousSafeToBreakOffset(7));
+  EXPECT_EQ(7u, result->PreviousSafeToBreakOffset(8));
+  EXPECT_EQ(7u, result->PreviousSafeToBreakOffset(9));
+  EXPECT_EQ(7u, result->PreviousSafeToBreakOffset(10));
+  EXPECT_EQ(11u, result->PreviousSafeToBreakOffset(11));
+#endif
+  EXPECT_EQ(12u, result->PreviousSafeToBreakOffset(12));
+}
+
+// http://crbug.com/1170334
+TEST_F(HarfBuzzShaperTest, SafeToBreakU0635) {
+  FontDescription::VariantLigatures ligatures;
+  ligatures.common = FontDescription::kEnabledLigaturesState;
+
+  // Five U+0635. This sequence should be rendered once.
+  String string(u"\u0635\u0635\u0635\u0635\u0635");
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> result = shaper.Shape(&font, TextDirection::kRtl);
+
+  EXPECT_EQ(0u, result->NextSafeToBreakOffset(0));
+  EXPECT_EQ(5u, result->NextSafeToBreakOffset(1));
+  EXPECT_EQ(5u, result->NextSafeToBreakOffset(2));
+  EXPECT_EQ(5u, result->NextSafeToBreakOffset(3));
+  EXPECT_EQ(5u, result->NextSafeToBreakOffset(4));
+  EXPECT_EQ(5u, result->NextSafeToBreakOffset(5));
+
+  EXPECT_EQ(0u, result->PreviousSafeToBreakOffset(0));
+  EXPECT_EQ(0u, result->PreviousSafeToBreakOffset(1));
+  EXPECT_EQ(0u, result->PreviousSafeToBreakOffset(2));
+  EXPECT_EQ(0u, result->PreviousSafeToBreakOffset(3));
+  EXPECT_EQ(0u, result->PreviousSafeToBreakOffset(4));
+  EXPECT_EQ(5u, result->PreviousSafeToBreakOffset(5));
 }
 
 // TODO(layout-dev): Expand RTL test coverage and add tests for mixed
 // directionality strings.
 
 // Test when some characters are missing in |runs_|.
-// RTL on Mac may not have runs for all characters. crbug.com/774034
-TEST_P(ShapeParameterTest, DISABLED_SafeToBreakMissingRun) {
+TEST_P(ShapeParameterTest, SafeToBreakMissingRun) {
   TextDirection direction = GetParam();
-  scoped_refptr<ShapeResult> result = ShapeResult::Create(&font, 8, direction);
-  result->InsertRunForTesting(2, 1, direction, {0});
-  result->InsertRunForTesting(3, 3, direction, {0, 1});
-  // The character index 6 and 7 is missing.
-  result->InsertRunForTesting(8, 2, direction, {0});
+  scoped_refptr<ShapeResult> result = CreateMissingRunResult(direction);
 #if DCHECK_IS_ON()
   result->CheckConsistency();
 #endif
 
-  EXPECT_EQ(2u, result->StartIndexForResult());
-  EXPECT_EQ(10u, result->EndIndexForResult());
+  EXPECT_EQ(2u, result->StartIndex());
+  EXPECT_EQ(10u, result->EndIndex());
 
   EXPECT_EQ(2u, result->NextSafeToBreakOffset(2));
   EXPECT_EQ(3u, result->NextSafeToBreakOffset(3));
@@ -1349,6 +1596,82 @@ TEST_P(ShapeParameterTest, DISABLED_SafeToBreakMissingRun) {
   EXPECT_EQ(8u, result->PreviousSafeToBreakOffset(9));
 }
 
+TEST_P(ShapeParameterTest, CopyRangeMissingRun) {
+  TextDirection direction = GetParam();
+  scoped_refptr<ShapeResult> result = CreateMissingRunResult(direction);
+
+  // 6 and 7 are missing but NumCharacters() should be 4.
+  scoped_refptr<ShapeResult> sub = result->SubRange(5, 9);
+  EXPECT_EQ(sub->StartIndex(), 5u);
+  EXPECT_EQ(sub->EndIndex(), 9u);
+  EXPECT_EQ(sub->NumCharacters(), 4u);
+
+  // The end is missing.
+  sub = result->SubRange(5, 7);
+  EXPECT_EQ(sub->StartIndex(), 5u);
+  EXPECT_EQ(sub->EndIndex(), 7u);
+  EXPECT_EQ(sub->NumCharacters(), 2u);
+
+  // The start is missing.
+  sub = result->SubRange(7, 9);
+  EXPECT_EQ(sub->StartIndex(), 7u);
+  EXPECT_EQ(sub->EndIndex(), 9u);
+  EXPECT_EQ(sub->NumCharacters(), 2u);
+}
+
+TEST_P(ShapeParameterTest, CopyRangeNoRuns) {
+  TextDirection direction = GetParam();
+  scoped_refptr<ShapeResult> result =
+      ShapeResult::Create(&font, 0, 2, direction);
+
+  scoped_refptr<ShapeResult> sub0 = result->SubRange(0, 1);
+  EXPECT_EQ(sub0->StartIndex(), 0u);
+  EXPECT_EQ(sub0->EndIndex(), 1u);
+  EXPECT_EQ(sub0->NumCharacters(), 1u);
+
+  scoped_refptr<ShapeResult> sub1 = result->SubRange(1, 2);
+  EXPECT_EQ(sub1->StartIndex(), 1u);
+  EXPECT_EQ(sub1->EndIndex(), 2u);
+  EXPECT_EQ(sub1->NumCharacters(), 1u);
+
+  Vector<scoped_refptr<ShapeResult>> range_results;
+  Vector<ShapeResult::ShapeRange> ranges;
+  range_results.push_back(ShapeResult::CreateEmpty(*result));
+  ranges.push_back(ShapeResult::ShapeRange{0, 1, range_results[0].get()});
+  result->CopyRanges(ranges.data(), ranges.size());
+  for (unsigned i = 0; i < ranges.size(); i++) {
+    const ShapeResult::ShapeRange& range = ranges[i];
+    const ShapeResult& result = *range_results[i];
+    EXPECT_EQ(result.StartIndex(), range.start);
+    EXPECT_EQ(result.EndIndex(), range.end);
+    EXPECT_EQ(result.NumCharacters(), range.end - range.start);
+  }
+}
+
+TEST_P(ShapeParameterTest, ShapeResultViewMissingRun) {
+  TextDirection direction = GetParam();
+  scoped_refptr<ShapeResult> result = CreateMissingRunResult(direction);
+
+  // 6 and 7 are missing but NumCharacters() should be 4.
+  scoped_refptr<ShapeResultView> view =
+      ShapeResultView::Create(result.get(), 5, 9);
+  EXPECT_EQ(view->StartIndex(), 5u);
+  EXPECT_EQ(view->EndIndex(), 9u);
+  EXPECT_EQ(view->NumCharacters(), 4u);
+
+  // The end is missing.
+  view = ShapeResultView::Create(result.get(), 5, 7);
+  EXPECT_EQ(view->StartIndex(), 5u);
+  EXPECT_EQ(view->EndIndex(), 7u);
+  EXPECT_EQ(view->NumCharacters(), 2u);
+
+  // The start is missing.
+  view = ShapeResultView::Create(result.get(), 7, 9);
+  EXPECT_EQ(view->StartIndex(), 7u);
+  EXPECT_EQ(view->EndIndex(), 9u);
+  EXPECT_EQ(view->NumCharacters(), 2u);
+}
+
 // Call this to ensure your test string has some kerning going on.
 static bool KerningIsHappening(const FontDescription& font_description,
                                TextDirection direction,
@@ -1360,10 +1683,7 @@ static bool KerningIsHappening(const FontDescription& font_description,
   kern.SetKerning(FontDescription::kAutoKerning);
 
   Font font_no_kern(no_kern);
-  font_no_kern.Update(nullptr);
-
   Font font_kern(kern);
-  font_kern.Update(nullptr);
 
   HarfBuzzShaper shaper(str);
 
@@ -1475,7 +1795,6 @@ TEST_F(HarfBuzzShaperTest, ShapeVerticalWithoutSubpixelPositionIsRounded) {
 
   font_description.SetOrientation(FontOrientation::kVerticalUpright);
   font = Font(font_description);
-  font.Update(nullptr);
 
   String string(u"\u65E5\u65E5\u65E5");
   TextDirection direction = TextDirection::kLtr;
@@ -1495,7 +1814,6 @@ TEST_F(HarfBuzzShaperTest, ShapeVerticalWithSubpixelPositionIsRounded) {
 
   font_description.SetOrientation(FontOrientation::kVerticalUpright);
   font = Font(font_description);
-  font.Update(nullptr);
 
   String string(u"\u65E5\u65E5\u65E5");
   TextDirection direction = TextDirection::kLtr;
@@ -1511,4 +1829,47 @@ TEST_F(HarfBuzzShaperTest, ShapeVerticalWithSubpixelPositionIsRounded) {
   }
 }
 
+TEST_F(HarfBuzzShaperTest, EmojiPercentage) {
+  // This test relies on Noto Color Emoji from the third_party directory to not
+  // contain sequences and single codepoint emoji from Unicode 13 and 13.1 such
+  // as:
+  // * Couple with Heart: Woman, Man, Medium-Light Skin Tone, Medium-Dark Skin
+  // Tone
+  // * Disguised Face U+1F978
+  // * Anatomical Heart U+1FAC0
+  String string(
+      u"aaaa"
+      u"aa");
+
+  struct Expectation {
+    unsigned expected_clusters;
+    unsigned expected_broken_clusters;
+  };
+
+  Expectation expectations[] = {{3, 2}, {3, 2}, {6, 4}};
+#if defined(OS_ANDROID)
+  // On Android 11, SDK level 30, fallback occurs to an emoji
+  // font that has coverage for the last segment. Adjust the expectation.
+  if (base::android::BuildInfo::GetInstance()->sdk_int() >=
+      base::android::SdkVersion::SDK_VERSION_R) {
+    expectations[2].expected_broken_clusters = 0;
+  }
+#endif
+  unsigned num_calls = 0;
+  HarfBuzzShaper::EmojiMetricsCallback metrics_callback =
+      base::BindLambdaForTesting(
+          [&](unsigned num_clusters, unsigned num_broken_clusters) {
+            CHECK_EQ(num_clusters, expectations[num_calls].expected_clusters);
+            CHECK_EQ(num_broken_clusters,
+                     expectations[num_calls].expected_broken_clusters);
+
+            num_calls++;
+          });
+  HarfBuzzShaper shaper(string, metrics_callback);
+  Font emoji_font = CreateNotoColorEmoji();
+  scoped_refptr<ShapeResult> result =
+      shaper.Shape(&emoji_font, TextDirection::kLtr);
+  CHECK_EQ(num_calls, base::size(expectations));
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/run_segmenter.cc b/third_party/blink/renderer/platform/fonts/shaping/run_segmenter.cc
index b6c634c08be7..3b0074ec6ad1 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/run_segmenter.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/run_segmenter.cc
@@ -4,6 +4,7 @@
 
 #include "third_party/blink/renderer/platform/fonts/shaping/run_segmenter.h"
 
+#include <algorithm>
 #include <memory>
 
 #include "third_party/blink/renderer/platform/fonts/script_run_iterator.h"
@@ -17,18 +18,22 @@ namespace blink {
 
 RunSegmenter::RunSegmenter(const UChar* buffer,
                            unsigned buffer_size,
-                           FontOrientation run_orientation)
+                           FontOrientation run_orientation,
+                           unsigned start_offset)
     : buffer_size_(buffer_size),
-      candidate_range_(NullRange()),
+      start_offset_(start_offset),
+      candidate_range_(NullRange(start_offset)),
       script_run_iterator_(
-          std::make_unique<ScriptRunIterator>(buffer, buffer_size)),
+          std::make_unique<ScriptRunIterator>(buffer + start_offset,
+                                              buffer_size)),
       orientation_iterator_(
           run_orientation == FontOrientation::kVerticalMixed
-              ? std::make_unique<OrientationIterator>(buffer,
+              ? std::make_unique<OrientationIterator>(buffer + start_offset,
                                                       buffer_size,
                                                       run_orientation)
               : nullptr),
-      symbols_iterator_(std::make_unique<SymbolsIterator>(buffer, buffer_size)),
+      symbols_iterator_(std::make_unique<SymbolsIterator>(buffer + start_offset,
+                                                          buffer_size)),
       last_split_(0),
       script_run_iterator_position_(0),
       orientation_iterator_position_(
@@ -37,38 +42,14 @@ RunSegmenter::RunSegmenter(const UChar* buffer,
       symbols_iterator_position_(0),
       at_end_(!buffer_size_) {}
 
-void RunSegmenter::ConsumeScriptIteratorPastLastSplit() {
-  DCHECK(script_run_iterator_);
-  if (script_run_iterator_position_ <= last_split_ &&
-      script_run_iterator_position_ < buffer_size_) {
-    while (script_run_iterator_->Consume(script_run_iterator_position_,
-                                         candidate_range_.script)) {
-      if (script_run_iterator_position_ > last_split_)
-        return;
-    }
-  }
-}
-
-void RunSegmenter::ConsumeOrientationIteratorPastLastSplit() {
-  if (orientation_iterator_ && orientation_iterator_position_ <= last_split_ &&
-      orientation_iterator_position_ < buffer_size_) {
-    while (
-        orientation_iterator_->Consume(&orientation_iterator_position_,
-                                       &candidate_range_.render_orientation)) {
-      if (orientation_iterator_position_ > last_split_)
-        return;
-    }
-  }
-}
-
-void RunSegmenter::ConsumeSymbolsIteratorPastLastSplit() {
-  DCHECK(symbols_iterator_);
-  if (symbols_iterator_position_ <= last_split_ &&
-      symbols_iterator_position_ < buffer_size_) {
-    while (
-        symbols_iterator_->Consume(&symbols_iterator_position_,
-                                   &candidate_range_.font_fallback_priority)) {
-      if (symbols_iterator_position_ > last_split_)
+template <class Iterator, typename SegmentationCategory>
+void RunSegmenter::ConsumeIteratorPastLastSplit(
+    std::unique_ptr<Iterator>& iterator,
+    unsigned* iterator_position,
+    SegmentationCategory* segmentation_category) {
+  if (*iterator_position <= last_split_ && *iterator_position < buffer_size_) {
+    while (iterator->Consume(iterator_position, segmentation_category)) {
+      if (*iterator_position > last_split_)
         return;
     }
   }
@@ -80,30 +61,26 @@ bool RunSegmenter::Consume(RunSegmenterRange* next_range) {
   if (at_end_)
     return false;
 
-  ConsumeScriptIteratorPastLastSplit();
-  ConsumeOrientationIteratorPastLastSplit();
-  ConsumeSymbolsIteratorPastLastSplit();
+  ConsumeIteratorPastLastSplit(script_run_iterator_,
+                               &script_run_iterator_position_,
+                               &candidate_range_.script);
+  ConsumeIteratorPastLastSplit(orientation_iterator_,
+                               &orientation_iterator_position_,
+                               &candidate_range_.render_orientation);
+  ConsumeIteratorPastLastSplit(symbols_iterator_, &symbols_iterator_position_,
+                               &candidate_range_.font_fallback_priority);
 
-  if (script_run_iterator_position_ <= orientation_iterator_position_ &&
-      script_run_iterator_position_ <= symbols_iterator_position_) {
-    last_split_ = script_run_iterator_position_;
-  }
+  unsigned positions[] = {script_run_iterator_position_,
+                          orientation_iterator_position_,
+                          symbols_iterator_position_};
 
-  if (orientation_iterator_position_ <= script_run_iterator_position_ &&
-      orientation_iterator_position_ <= symbols_iterator_position_) {
-    last_split_ = orientation_iterator_position_;
-  }
-
-  if (symbols_iterator_position_ <= script_run_iterator_position_ &&
-      symbols_iterator_position_ <= orientation_iterator_position_) {
-    last_split_ = symbols_iterator_position_;
-  }
+  last_split_ = *std::min_element(std::begin(positions), std::end(positions));
 
   candidate_range_.start = candidate_range_.end;
-  candidate_range_.end = last_split_;
+  candidate_range_.end = last_split_ + start_offset_;
   *next_range = candidate_range_;
 
-  at_end_ = last_split_ == buffer_size_;
+  at_end_ = (last_split_ == buffer_size_);
   return true;
 }
 
diff --git a/third_party/blink/renderer/platform/fonts/shaping/run_segmenter.h b/third_party/blink/renderer/platform/fonts/shaping/run_segmenter.h
index 86bfc774f28f..94c61cfec3ef 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/run_segmenter.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/run_segmenter.h
@@ -7,14 +7,14 @@
 
 #include <unicode/uscript.h>
 #include <memory>
+#include "base/macros.h"
 #include "third_party/blink/renderer/platform/fonts/font_orientation.h"
 #include "third_party/blink/renderer/platform/fonts/orientation_iterator.h"
 #include "third_party/blink/renderer/platform/fonts/script_run_iterator.h"
 #include "third_party/blink/renderer/platform/fonts/small_caps_iterator.h"
 #include "third_party/blink/renderer/platform/fonts/symbols_iterator.h"
 #include "third_party/blink/renderer/platform/fonts/utf16_text_iterator.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
-#include "third_party/blink/renderer/platform/wtf/noncopyable.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
 namespace blink {
 
@@ -23,12 +23,10 @@ namespace blink {
 // font-variant of the text run.
 class PLATFORM_EXPORT RunSegmenter {
   STACK_ALLOCATED();
-  WTF_MAKE_NONCOPYABLE(RunSegmenter);
 
  public:
   // Indices into the UTF-16 buffer that is passed in
-  struct RunSegmenterRange {
-    DISALLOW_NEW();
+  struct PLATFORM_EXPORT RunSegmenterRange {
     unsigned start;
     unsigned end;
     UScriptCode script;
@@ -37,21 +35,27 @@ class PLATFORM_EXPORT RunSegmenter {
   };
 
   // Initialize a RunSegmenter.
-  RunSegmenter(const UChar* buffer, unsigned buffer_size, FontOrientation);
+  RunSegmenter(const UChar* buffer,
+               unsigned buffer_size,
+               FontOrientation,
+               unsigned start_offset = 0);
 
   bool Consume(RunSegmenterRange*);
 
-  static RunSegmenterRange NullRange() {
-    return {0, 0, USCRIPT_INVALID_CODE, OrientationIterator::kOrientationKeep,
-            FontFallbackPriority::kText};
+  static RunSegmenterRange NullRange(unsigned offset = 0) {
+    return {offset, offset, USCRIPT_INVALID_CODE,
+            OrientationIterator::kOrientationKeep, FontFallbackPriority::kText};
   }
 
  private:
-  void ConsumeOrientationIteratorPastLastSplit();
-  void ConsumeScriptIteratorPastLastSplit();
-  void ConsumeSymbolsIteratorPastLastSplit();
+  template <class Iterator, typename SegmentationCategory>
+  void ConsumeIteratorPastLastSplit(
+      std::unique_ptr<Iterator>& iterator,
+      unsigned* iterator_position,
+      SegmentationCategory* segmentation_category);
 
   unsigned buffer_size_;
+  unsigned start_offset_;
   RunSegmenterRange candidate_range_;
   std::unique_ptr<ScriptRunIterator> script_run_iterator_;
   std::unique_ptr<OrientationIterator> orientation_iterator_;
@@ -61,6 +65,8 @@ class PLATFORM_EXPORT RunSegmenter {
   unsigned orientation_iterator_position_;
   unsigned symbols_iterator_position_;
   bool at_end_;
+
+  DISALLOW_COPY_AND_ASSIGN(RunSegmenter);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/run_segmenter_test.cc b/third_party/blink/renderer/platform/fonts/shaping/run_segmenter_test.cc
index 20c9d582be15..5b8739912cf1 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/run_segmenter_test.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/run_segmenter_test.cc
@@ -8,6 +8,7 @@
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/renderer/platform/fonts/orientation_iterator.h"
 #include "third_party/blink/renderer/platform/wtf/assertions.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 
@@ -44,11 +45,12 @@ class RunSegmenterTest : public testing::Test {
  protected:
   void CheckRuns(const Vector<SegmenterTestRun>& runs,
                  FontOrientation orientation) {
-    String text(g_empty_string16_bit);
+    StringBuilder text;
+    text.Ensure16Bit();
     Vector<SegmenterExpectedRun> expect;
     for (auto& run : runs) {
       unsigned length_before = text.length();
-      text.append(String::FromUTF8(run.text.c_str()));
+      text.Append(String::FromUTF8(run.text.c_str()));
       expect.push_back(SegmenterExpectedRun(length_before, text.length(),
                                             run.script, run.render_orientation,
                                             run.font_fallback_priority));
@@ -68,7 +70,7 @@ class RunSegmenterTest : public testing::Test {
   void VerifyRuns(RunSegmenter* run_segmenter,
                   const Vector<SegmenterExpectedRun>& expect) {
     RunSegmenter::RunSegmenterRange segmenter_range;
-    unsigned long run_count = 0;
+    size_t run_count = 0;
     while (run_segmenter->Consume(&segmenter_range)) {
       ASSERT_LT(run_count, expect.size());
       ASSERT_EQ(expect[run_count].start, segmenter_range.start);
@@ -192,10 +194,10 @@ TEST_F(RunSegmenterTest, EmojiZWJSequences) {
         FontFallbackPriority::kEmojiEmoji},
        {"abcd", USCRIPT_LATIN, OrientationIterator::kOrientationKeep,
         FontFallbackPriority::kText},
-       {"", USCRIPT_LATIN, OrientationIterator::kOrientationKeep,
+       {"", USCRIPT_LATIN, OrientationIterator::kOrientationKeep,
         FontFallbackPriority::kEmojiEmoji},
-       {"efg", USCRIPT_LATIN, OrientationIterator::kOrientationKeep,
-        FontFallbackPriority::kText}});
+       {u8"\U0000200Defg", USCRIPT_LATIN,
+        OrientationIterator::kOrientationKeep, FontFallbackPriority::kText}});
 }
 
 TEST_F(RunSegmenterTest, JapaneseLetterlikeEnd) {
@@ -243,13 +245,81 @@ TEST_F(RunSegmenterTest, EmojiSubdivisionFlags) {
 
 TEST_F(RunSegmenterTest, NonEmojiPresentationSymbols) {
   CheckRunsHorizontal(
-      {{u8"\U00002626\U0000262a\U00002638\U0000271d\U00002721", USCRIPT_COMMON,
-        OrientationIterator::kOrientationKeep,
-        FontFallbackPriority::kEmojiText},
-       {u8"\U00002627\U00002628\U00002629\U0000262b\U0000262c\U00002670"
+      {{u8"\U00002626\U0000262a\U00002638\U0000271d\U00002721\U00002627"
+        u8"\U00002628\U00002629\U0000262b\U0000262c\U00002670"
         "\U00002671\U0000271f\U00002720",
         USCRIPT_COMMON, OrientationIterator::kOrientationKeep,
         FontFallbackPriority::kText}});
 }
 
+TEST_F(RunSegmenterTest, StartOffset) {
+  String text = String::FromUTF8("abc");
+  text.Ensure16Bit();
+
+  // skip first 3 characters
+  unsigned start_offset = 3;
+  Vector<SegmenterExpectedRun> expect;
+  expect.push_back(SegmenterExpectedRun(
+      start_offset, text.length(), USCRIPT_HEBREW,
+      OrientationIterator::kOrientationKeep, FontFallbackPriority::kText));
+
+  RunSegmenter run_segmenter(text.Characters16(), text.length() - start_offset,
+                             FontOrientation::kHorizontal, start_offset);
+  VerifyRuns(&run_segmenter, expect);
+}
+
+TEST_F(RunSegmenterTest, CJKBracketsAfterLatinLetter) {
+  CheckRunsHorizontal(
+      {{"A", USCRIPT_LATIN, OrientationIterator::kOrientationKeep,
+        FontFallbackPriority::kText},
+       {"\u300C"   // CJK LEFT CORNER BRACKET
+        "\u56FD"   // CJK UNIFIED IDEOGRAPH
+        "\u300D",  // CJK RIGHT CORNER BRACKET
+        USCRIPT_HAN, OrientationIterator::kOrientationKeep,
+        FontFallbackPriority::kText}});
+}
+
+TEST_F(RunSegmenterTest, CJKBracketsAfterLatinParenthesis) {
+  CheckRunsHorizontal(
+      {{"A(", USCRIPT_LATIN, OrientationIterator::kOrientationKeep,
+        FontFallbackPriority::kText},
+       {"\u300C"   // CJK LEFT CORNER BRACKET
+        "\u56FD"   // CJK UNIFIED IDEOGRAPH
+        "\u300D",  // CJK RIGHT CORNER BRACKET
+        USCRIPT_HAN, OrientationIterator::kOrientationKeep,
+        FontFallbackPriority::kText},
+       {")", USCRIPT_LATIN, OrientationIterator::kOrientationKeep,
+        FontFallbackPriority::kText}});
+}
+
+TEST_F(RunSegmenterTest, CJKBracketsWithLatinParenthesisInside) {
+  CheckRunsHorizontal(
+      {{"A", USCRIPT_LATIN, OrientationIterator::kOrientationKeep,
+        FontFallbackPriority::kText},
+       {"\u300C"  // CJK LEFT CORNER BRACKET
+        "\u56FD"  // CJK UNIFIED IDEOGRAPH
+        "(",
+        USCRIPT_HAN, OrientationIterator::kOrientationKeep,
+        FontFallbackPriority::kText},
+       {"A", USCRIPT_LATIN, OrientationIterator::kOrientationKeep,
+        FontFallbackPriority::kText},
+       {")"
+        "\u300D",  // CJK RIGHT CORNER BRACKET
+        USCRIPT_HAN, OrientationIterator::kOrientationKeep,
+        FontFallbackPriority::kText}});
+}
+
+TEST_F(RunSegmenterTest, CJKBracketsAfterUnmatchingLatinParenthesis) {
+  CheckRunsHorizontal(
+      {{"A((", USCRIPT_LATIN, OrientationIterator::kOrientationKeep,
+        FontFallbackPriority::kText},
+       {"\u300C"   // CJK LEFT CORNER BRACKET
+        "\u56FD"   // CJK UNIFIED IDEOGRAPH
+        "\u300D",  // CJK RIGHT CORNER BRACKET
+        USCRIPT_HAN, OrientationIterator::kOrientationKeep,
+        FontFallbackPriority::kText},
+       {")", USCRIPT_LATIN, OrientationIterator::kOrientationKeep,
+        FontFallbackPriority::kText}});
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_cache.h b/third_party/blink/renderer/platform/fonts/shaping/shape_cache.h
index 90d0cff23602..9dfd507dd0bb 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_cache.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_cache.h
@@ -27,6 +27,8 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_SHAPE_CACHE_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_SHAPE_CACHE_H_
 
+#include "base/containers/span.h"
+#include "base/hash/hash.h"
 #include "base/memory/weak_ptr.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result.h"
 #include "third_party/blink/renderer/platform/text/text_run.h"
@@ -37,21 +39,14 @@
 
 namespace blink {
 
-struct ShapeCacheEntry {
-  DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
-  ShapeCacheEntry() { shape_result_ = nullptr; }
-  scoped_refptr<const ShapeResult> shape_result_;
-};
+using ShapeCacheEntry = scoped_refptr<const ShapeResult>;
 
 class ShapeCache {
   USING_FAST_MALLOC(ShapeCache);
-  WTF_MAKE_NONCOPYABLE(ShapeCache);
   // Used to optimize small strings as hash table keys. Avoids malloc'ing an
   // out-of-line StringImpl.
   class SmallStringKey {
-    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
-
-    void HashString();
+    DISALLOW_NEW();
 
    public:
     static unsigned Capacity() { return kCapacity; }
@@ -64,30 +59,30 @@ class ShapeCache {
         : length_(kDeletedValueLength),
           direction_(static_cast<unsigned>(TextDirection::kLtr)) {}
 
-    SmallStringKey(const LChar* characters,
-                   unsigned short length,
-                   TextDirection direction)
-        : length_(length), direction_(static_cast<unsigned>(direction)) {
-      DCHECK(length <= kCapacity);
+    SmallStringKey(base::span<const LChar> characters, TextDirection direction)
+        : length_(static_cast<uint16_t>(characters.size())),
+          direction_(static_cast<unsigned>(direction)) {
+      DCHECK(characters.size() <= kCapacity);
       // Up-convert from LChar to UChar.
-      for (unsigned short i = 0; i < length; ++i) {
+      for (uint16_t i = 0; i < characters.size(); ++i) {
         characters_[i] = characters[i];
       }
 
-      HashString();
+      hash_ = static_cast<unsigned>(base::FastHash(
+          base::as_bytes(base::make_span(characters_, length_))));
     }
 
-    SmallStringKey(const UChar* characters,
-                   unsigned short length,
-                   TextDirection direction)
-        : length_(length), direction_(static_cast<unsigned>(direction)) {
-      DCHECK(length <= kCapacity);
-      memcpy(characters_, characters, length * sizeof(UChar));
-      HashString();
+    SmallStringKey(base::span<const UChar> characters, TextDirection direction)
+        : length_(static_cast<uint16_t>(characters.size())),
+          direction_(static_cast<unsigned>(direction)) {
+      DCHECK(characters.size() <= kCapacity);
+      memcpy(characters_, characters.data(), characters.size_bytes());
+      hash_ = static_cast<unsigned>(base::FastHash(
+          base::as_bytes(base::make_span(characters_, length_))));
     }
 
     const UChar* Characters() const { return characters_; }
-    unsigned short length() const { return length_; }
+    uint16_t length() const { return length_; }
     TextDirection Direction() const {
       return static_cast<TextDirection>(direction_);
     }
@@ -110,7 +105,7 @@ class ShapeCache {
   };
 
  public:
-  ShapeCache() : weak_factory_(this) {
+  ShapeCache() {
     // TODO(cavalcantii): Investigate tradeoffs of reserving space
     // in short_string_map.
   }
@@ -119,7 +114,7 @@ class ShapeCache {
     if (run.length() > SmallStringKey::Capacity())
       return nullptr;
 
-    return AddSlowCase(run, entry);
+    return AddSlowCase(run, std::move(entry));
   }
 
   void ClearIfVersionChanged(unsigned version) {
@@ -141,10 +136,10 @@ class ShapeCache {
   size_t ByteSize() const {
     size_t self_byte_size = 0;
     for (auto cache_entry : single_char_map_) {
-      self_byte_size += cache_entry.value.shape_result_->ByteSize();
+      self_byte_size += cache_entry.value->ByteSize();
     }
     for (auto cache_entry : short_string_map_) {
-      self_byte_size += cache_entry.value.shape_result_->ByteSize();
+      self_byte_size += cache_entry.value->ByteSize();
     }
     return self_byte_size;
   }
@@ -153,30 +148,27 @@ class ShapeCache {
 
  private:
   ShapeCacheEntry* AddSlowCase(const TextRun& run, ShapeCacheEntry entry) {
-    unsigned length = run.length();
     bool is_new_entry;
     ShapeCacheEntry* value;
-    if (length == 1) {
+    if (run.length() == 1) {
       uint32_t key = run[0];
       // All current codepoints in UTF-32 are bewteen 0x0 and 0x10FFFF,
       // as such use bit 31 (zero-based) to indicate direction.
       if (run.Direction() == TextDirection::kRtl)
         key |= (1u << 31);
-      SingleCharMap::AddResult add_result = single_char_map_.insert(key, entry);
+      SingleCharMap::AddResult add_result =
+          single_char_map_.insert(key, std::move(entry));
       is_new_entry = add_result.is_new_entry;
       value = &add_result.stored_value->value;
     } else {
       SmallStringKey small_string_key;
       if (run.Is8Bit()) {
-        small_string_key =
-            SmallStringKey(run.Characters8(), length, run.Direction());
+        small_string_key = SmallStringKey(run.Span8(), run.Direction());
       } else {
-        small_string_key =
-            SmallStringKey(run.Characters16(), length, run.Direction());
+        small_string_key = SmallStringKey(run.Span16(), run.Direction());
       }
-
       SmallStringMap::AddResult add_result =
-          short_string_map_.insert(small_string_key, entry);
+          short_string_map_.insert(small_string_key, std::move(entry));
       is_new_entry = add_result.is_new_entry;
       value = &add_result.stored_value->value;
     }
@@ -206,6 +198,7 @@ class ShapeCache {
   struct SmallStringKeyHashTraits : WTF::SimpleClassHashTraits<SmallStringKey> {
     STATIC_ONLY(SmallStringKeyHashTraits);
     static const bool kHasIsEmptyValueFunction = true;
+    static const bool kEmptyValueIsZero = false;
     static bool IsEmptyValue(const SmallStringKey& key) {
       return key.IsHashTableEmptyValue();
     }
@@ -237,7 +230,9 @@ class ShapeCache {
   SingleCharMap single_char_map_;
   SmallStringMap short_string_map_;
   unsigned version_ = 0;
-  base::WeakPtrFactory<ShapeCache> weak_factory_;
+  base::WeakPtrFactory<ShapeCache> weak_factory_{this};
+
+  DISALLOW_COPY_AND_ASSIGN(ShapeCache);
 };
 
 inline bool operator==(const ShapeCache::SmallStringKey& a,
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result.cc b/third_party/blink/renderer/platform/fonts/shaping/shape_result.cc
index 5d23754b8310..adc10795ccce 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_result.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result.cc
@@ -39,20 +39,55 @@
 
 #include "base/containers/adapters.h"
 #include "base/memory/ptr_util.h"
+#include "base/numerics/safe_conversions.h"
+#include "build/build_config.h"
 #include "third_party/blink/renderer/platform/fonts/character_range.h"
 #include "third_party/blink/renderer/platform/fonts/font.h"
-#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_buffer.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/glyph_bounds_accumulator.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.h"
+#include "third_party/blink/renderer/platform/text/text_break_iterator.h"
+#include "third_party/blink/renderer/platform/wtf/size_assertions.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
 
 namespace blink {
 
 constexpr unsigned HarfBuzzRunGlyphData::kMaxCharacterIndex;
+constexpr unsigned HarfBuzzRunGlyphData::kMaxGlyphs;
+
+struct SameSizeAsHarfBuzzRunGlyphData {
+  unsigned glyph : 16;
+  unsigned char_index_and_bit_field : 16;
+  float advance;
+};
+
+ASSERT_SIZE(HarfBuzzRunGlyphData, SameSizeAsHarfBuzzRunGlyphData);
+
+struct SameSizeAsRunInfo : public RefCounted<SameSizeAsRunInfo> {
+  struct GlyphDataCollection {
+    void* pointers[2];
+    unsigned integer;
+  } glyph_data;
+  void* pointer;
+  Vector<int> vector;
+  int integers[6];
+};
+
+ASSERT_SIZE(ShapeResult::RunInfo, SameSizeAsRunInfo);
+
+struct SameSizeAsShapeResult : public RefCounted<SameSizeAsShapeResult> {
+  float floats[5];
+  Vector<int> vector;
+  void* pointers[2];
+  unsigned integers[2];
+  unsigned bitfields : 32;
+};
+
+ASSERT_SIZE(ShapeResult, SameSizeAsShapeResult);
 
 unsigned ShapeResult::RunInfo::NextSafeToBreakOffset(unsigned offset) const {
   DCHECK_LE(offset, num_characters_);
-  if (!Rtl()) {
+  if (IsLtr()) {
     for (const auto& glyph_data : glyph_data_) {
       if (glyph_data.safe_to_break_before &&
           glyph_data.character_index >= offset)
@@ -74,7 +109,7 @@ unsigned ShapeResult::RunInfo::PreviousSafeToBreakOffset(
     unsigned offset) const {
   if (offset >= num_characters_)
     return num_characters_;
-  if (!Rtl()) {
+  if (IsLtr()) {
     for (const auto& glyph_data : base::Reversed(glyph_data_)) {
       if (glyph_data.safe_to_break_before &&
           glyph_data.character_index <= offset)
@@ -96,7 +131,7 @@ float ShapeResult::RunInfo::XPositionForVisualOffset(
     unsigned offset,
     AdjustMidCluster adjust_mid_cluster) const {
   DCHECK_LT(offset, num_characters_);
-  if (Rtl())
+  if (IsRtl())
     offset = num_characters_ - offset - 1;
   return XPositionForOffset(offset, adjust_mid_cluster);
 }
@@ -105,11 +140,40 @@ unsigned ShapeResult::RunInfo::NumGraphemes(unsigned start,
                                             unsigned end) const {
   if (graphemes_.size() == 0 || start >= num_characters_)
     return 0;
-  DCHECK_LT(start, end);
-  DCHECK_LE(end, num_characters_);
+  CHECK_LT(start, end);
+  CHECK_LE(end, num_characters_);
+  CHECK_EQ(num_characters_, graphemes_.size());
   return graphemes_[end - 1] - graphemes_[start] + 1;
 }
 
+void ShapeResult::EnsureGraphemes(const StringView& text) const {
+  CHECK_EQ(NumCharacters(), text.length());
+
+  // Hit-testing, canvas, etc. may still call this function for 0-length text,
+  // or glyphs may be missing at all.
+  if (runs_.IsEmpty())
+    return;
+
+  bool is_computed = !runs_.front()->graphemes_.IsEmpty();
+#if DCHECK_IS_ON()
+  for (const auto& run : runs_)
+    DCHECK_EQ(is_computed, !run->graphemes_.IsEmpty());
+#endif
+  if (is_computed)
+    return;
+
+  unsigned result_start_index = StartIndex();
+  for (const scoped_refptr<RunInfo>& run : runs_) {
+    if (!run)
+      continue;
+    DCHECK_GE(run->start_index_, result_start_index);
+    GraphemesClusterList(
+        StringView(text, run->start_index_ - result_start_index,
+                   run->num_characters_),
+        &run->graphemes_);
+  }
+}
+
 // XPositionForOffset returns the X position (in layout space) from the
 // beginning of the run to the beginning of the cluster of glyphs for X
 // character.
@@ -139,7 +203,7 @@ float ShapeResult::RunInfo::XPositionForOffset(
   // the accumulated advance up to the current glyph sequence.
   float accumulated_position = 0;
 
-  if (!Rtl()) {
+  if (IsLtr()) {
     for (unsigned i = 0; i < num_glyphs; ++i) {
       unsigned current_glyph_char_index = glyph_data_[i].character_index;
       // If this glyph is still part of the same glyph sequence for the grapheme
@@ -207,7 +271,7 @@ float ShapeResult::RunInfo::XPositionForOffset(
     unsigned place = graphemes * pos / size;
     pos -= place;
     glyph_sequence_advance = glyph_sequence_advance / graphemes;
-    if (Rtl()) {
+    if (IsRtl()) {
       accumulated_position += glyph_sequence_advance * (graphemes - place - 1);
     } else {
       accumulated_position += glyph_sequence_advance * place;
@@ -218,14 +282,14 @@ float ShapeResult::RunInfo::XPositionForOffset(
   // offset is not at the beginning, we need to jump to the right side of the
   // grapheme. On RTL, if we want AdjustToStart and offset is not at the end, we
   // need to jump to the left side of the grapheme.
-  if (!Rtl() && adjust_mid_cluster == AdjustMidCluster::kToEnd && pos != 0) {
+  if (IsLtr() && adjust_mid_cluster == AdjustMidCluster::kToEnd && pos != 0) {
     accumulated_position += glyph_sequence_advance;
-  } else if (Rtl() && adjust_mid_cluster == AdjustMidCluster::kToEnd &&
+  } else if (IsRtl() && adjust_mid_cluster == AdjustMidCluster::kToEnd &&
              pos != 0) {
     accumulated_position -= glyph_sequence_advance;
   }
 
-  if (Rtl()) {
+  if (IsRtl()) {
     // For RTL, we return the right side.
     accumulated_position += glyph_sequence_advance;
   }
@@ -244,7 +308,6 @@ void ShapeResult::RunInfo::CharacterIndexForXPosition(
     BreakGlyphsOption break_glyphs_option,
     GlyphIndexResult* result) const {
   DCHECK(target_x >= 0 && target_x <= width_);
-  const unsigned num_glyphs = glyph_data_.size();
 
   result->origin_x = 0;
   unsigned glyph_sequence_start = 0;
@@ -252,30 +315,30 @@ void ShapeResult::RunInfo::CharacterIndexForXPosition(
   result->advance = 0.0;
 
   // on RTL, we start on the last index.
-  if (Rtl()) {
+  if (IsRtl()) {
     glyph_sequence_start = glyph_sequence_end = num_characters_;
   }
 
-  for (unsigned i = 0; i < num_glyphs; ++i) {
-    unsigned current_glyph_char_index = glyph_data_[i].character_index;
+  for (const HarfBuzzRunGlyphData& glyph_data : glyph_data_) {
+    unsigned current_glyph_char_index = glyph_data.character_index;
     // If the glyph is part of the same sequence, we just accumulate the
     // advance.
     if (glyph_sequence_start == current_glyph_char_index) {
-      result->advance += glyph_data_[i].advance;
+      result->advance += glyph_data.advance;
       continue;
     }
 
     // Since we are about to move to the next sequence of glyphs, check if
     // the target falls inside it, if it does, we found our sequence.
     if (result->origin_x + result->advance > target_x) {
-      if (!Rtl()) {
+      if (IsLtr()) {
         glyph_sequence_end = current_glyph_char_index;
       }
       break;
     }
 
     // Move to the next sequence, update accumulated_x.
-    if (Rtl()) {
+    if (IsRtl()) {
       // Notice that on RTL, as we move to our next sequence, we already know
       // both bounds. Nonetheless, we still need to move forward so we can
       // capture all glyphs of this sequence.
@@ -283,14 +346,15 @@ void ShapeResult::RunInfo::CharacterIndexForXPosition(
     }
     glyph_sequence_start = current_glyph_char_index;
     result->origin_x += result->advance;
-    result->advance = glyph_data_[i].advance;
+    result->advance = glyph_data.advance;
   }
 
   // At this point, we have [glyph_sequence_start, glyph_sequence_end)
   // representing a sequence of glyphs, of size glyph_sequence_advance. We
   // linearly interpolate how much space each character takes, and reduce the
   // sequence to only match the character size.
-  if (break_glyphs_option == BreakGlyphs) {
+  if (break_glyphs_option == BreakGlyphs &&
+      glyph_sequence_end > glyph_sequence_start) {
     int graphemes = NumGraphemes(glyph_sequence_start, glyph_sequence_end);
     if (graphemes > 1) {
       float unit_size = result->advance / graphemes;
@@ -298,7 +362,7 @@ void ShapeResult::RunInfo::CharacterIndexForXPosition(
       unsigned glyph_length = glyph_sequence_end - glyph_sequence_start;
       unsigned final_size = floor(glyph_length / graphemes);
       result->origin_x += unit_size * step;
-      if (!Rtl()) {
+      if (IsLtr()) {
         glyph_sequence_start += step;
         glyph_sequence_end = glyph_sequence_start + final_size;
       } else {
@@ -309,7 +373,7 @@ void ShapeResult::RunInfo::CharacterIndexForXPosition(
     }
   }
 
-  if (!Rtl()) {
+  if (IsLtr()) {
     result->left_character_index = glyph_sequence_start;
     result->right_character_index = glyph_sequence_end;
   } else {
@@ -318,87 +382,66 @@ void ShapeResult::RunInfo::CharacterIndexForXPosition(
   }
 }
 
-void HarfBuzzRunGlyphData::SetGlyphAndPositions(uint16_t glyph_id,
-                                                uint16_t character_index,
-                                                float advance,
-                                                const FloatSize& offset,
-                                                bool safe_to_break_before) {
-  glyph = glyph_id;
-  DCHECK_LE(character_index, kMaxCharacterIndex);
-  this->character_index = character_index;
-  this->advance = advance;
-  this->offset = offset;
-  this->safe_to_break_before = safe_to_break_before;
-}
-
-ShapeResult::ShapeResult(const SimpleFontData* font_data,
+ShapeResult::ShapeResult(scoped_refptr<const SimpleFontData> font_data,
+                         unsigned start_index,
                          unsigned num_characters,
                          TextDirection direction)
     : width_(0),
       primary_font_(font_data),
+      start_index_(start_index),
       num_characters_(num_characters),
       num_glyphs_(0),
       direction_(static_cast<unsigned>(direction)),
-      has_vertical_offsets_(0) {}
+      has_vertical_offsets_(false),
+      is_applied_spacing_(false) {}
 
 ShapeResult::ShapeResult(const Font* font,
+                         unsigned start_index,
                          unsigned num_characters,
                          TextDirection direction)
-    : ShapeResult(font->PrimaryFont(), num_characters, direction) {}
+    : ShapeResult(font->PrimaryFont(), start_index, num_characters, direction) {
+}
 
 ShapeResult::ShapeResult(const ShapeResult& other)
     : width_(other.width_),
-      glyph_bounding_box_(other.glyph_bounding_box_),
       primary_font_(other.primary_font_),
+      start_index_(other.start_index_),
       num_characters_(other.num_characters_),
       num_glyphs_(other.num_glyphs_),
       direction_(other.direction_),
-      has_vertical_offsets_(other.has_vertical_offsets_) {
+      has_vertical_offsets_(other.has_vertical_offsets_),
+      is_applied_spacing_(other.is_applied_spacing_) {
   runs_.ReserveCapacity(other.runs_.size());
   for (const auto& run : other.runs_)
-    runs_.push_back(std::make_unique<RunInfo>(*run));
+    runs_.push_back(run->Create(*run.get()));
 }
 
 ShapeResult::~ShapeResult() = default;
 
 size_t ShapeResult::ByteSize() const {
-  size_t self_byte_size = sizeof(this);
+  size_t self_byte_size = sizeof(*this);
   for (unsigned i = 0; i < runs_.size(); ++i) {
     self_byte_size += runs_[i]->ByteSize();
   }
   return self_byte_size;
 }
 
-CharacterRange ShapeResult::GetCharacterRange(unsigned from,
-                                              unsigned to) const {
-  return ShapeResultBuffer::GetCharacterRange(this, Direction(), Width(), from,
-                                              to);
-}
-
-unsigned ShapeResult::StartIndexForResult() const {
+bool ShapeResult::IsStartSafeToBreak() const {
+  // Empty is likely a |SubRange| at the middle of a cluster or a ligature.
   if (UNLIKELY(runs_.IsEmpty()))
-    return 0;
-  const RunInfo& first_run = *runs_.front();
-  if (!Rtl())
-    return first_run.start_index_;
-  unsigned end = first_run.start_index_ + first_run.num_characters_;
-  DCHECK_GE(end, NumCharacters());
-  return end - NumCharacters();
-}
-
-unsigned ShapeResult::EndIndexForResult() const {
-  if (UNLIKELY(runs_.IsEmpty()))
-    return NumCharacters();
-  const RunInfo& first_run = *runs_.front();
-  if (!Rtl())
-    return first_run.start_index_ + NumCharacters();
-  return first_run.start_index_ + first_run.num_characters_;
-}
-
-scoped_refptr<ShapeResult> ShapeResult::MutableUnique() const {
-  if (HasOneRef())
-    return const_cast<ShapeResult*>(this);
-  return ShapeResult::Create(*this);
+    return false;
+  const RunInfo* run = nullptr;
+  const HarfBuzzRunGlyphData* glyph_data = nullptr;
+  if (IsLtr()) {
+    run = runs_.front().get();
+    glyph_data = &run->glyph_data_.front();
+  } else {
+    run = runs_.back().get();
+    glyph_data = &run->glyph_data_.back();
+  }
+  return glyph_data->safe_to_break_before &&
+         // If the glyph for the first character is missing, consider not safe.
+         StartIndex() == run->start_index_ + glyph_data->character_index;
 }
 
 unsigned ShapeResult::NextSafeToBreakOffset(unsigned index) const {
@@ -413,18 +456,18 @@ unsigned ShapeResult::NextSafeToBreakOffset(unsigned index) const {
       if (offset <= run->num_characters_) {
         return run->NextSafeToBreakOffset(offset) + run_start;
       }
-      if (Rtl()) {
+      if (IsRtl()) {
         if (it == runs_.begin())
           return run_start + run->num_characters_;
         const auto& previous_run = *--it;
         return previous_run->start_index_;
       }
-    } else if (!Rtl()) {
+    } else if (IsLtr()) {
       return run_start;
     }
   }
 
-  return EndIndexForResult();
+  return EndIndex();
 }
 
 unsigned ShapeResult::PreviousSafeToBreakOffset(unsigned index) const {
@@ -439,10 +482,10 @@ unsigned ShapeResult::PreviousSafeToBreakOffset(unsigned index) const {
       if (offset <= run->num_characters_) {
         return run->PreviousSafeToBreakOffset(offset) + run_start;
       }
-      if (!Rtl()) {
+      if (IsLtr()) {
         return run_start + run->num_characters_;
       }
-    } else if (Rtl()) {
+    } else if (IsRtl()) {
       if (it == runs_.rbegin())
         return run->start_index_;
       const auto& previous_run = *--it;
@@ -450,7 +493,7 @@ unsigned ShapeResult::PreviousSafeToBreakOffset(unsigned index) const {
     }
   }
 
-  return StartIndexForResult();
+  return StartIndex();
 }
 
 // If the position is outside of the result, returns the start or the end offset
@@ -459,31 +502,30 @@ void ShapeResult::OffsetForPosition(float target_x,
                                     BreakGlyphsOption break_glyphs_option,
                                     GlyphIndexResult* result) const {
   if (target_x <= 0) {
-    if (Rtl()) {
+    if (IsRtl()) {
       result->left_character_index = result->right_character_index =
           NumCharacters();
     }
     return;
   }
 
-  unsigned characters_so_far = Rtl() ? NumCharacters() : 0;
+  unsigned characters_so_far = IsRtl() ? NumCharacters() : 0;
   float current_x = 0;
 
-  for (unsigned i = 0; i < runs_.size(); ++i) {
-    const RunInfo* run = runs_[i].get();
+  for (const scoped_refptr<RunInfo>& run_ptr : runs_) {
+    const RunInfo* run = run_ptr.get();
     if (!run)
       continue;
-    if (Rtl())
-      characters_so_far -= runs_[i]->num_characters_;
+    if (IsRtl())
+      characters_so_far -= run->num_characters_;
     float next_x = current_x + run->width_;
     float offset_for_run = target_x - current_x;
     if (offset_for_run >= 0 && offset_for_run < run->width_) {
       // The x value in question is within this script run.
       run->CharacterIndexForXPosition(offset_for_run, break_glyphs_option,
                                       result);
-      result->run_index = i;
       result->characters_on_left_runs = characters_so_far;
-      if (Rtl()) {
+      if (IsRtl()) {
         result->left_character_index =
             characters_so_far + result->left_character_index;
         result->right_character_index =
@@ -499,12 +541,12 @@ void ShapeResult::OffsetForPosition(float target_x,
       result->origin_x += current_x;
       return;
     }
-    if (!Rtl())
+    if (IsLtr())
       characters_so_far += run->num_characters_;
     current_x = next_x;
   }
 
-  if (Rtl()) {
+  if (IsRtl()) {
     result->left_character_index = 0;
     result->right_character_index = 0;
   } else {
@@ -512,7 +554,6 @@ void ShapeResult::OffsetForPosition(float target_x,
     result->right_character_index += characters_so_far;
   }
 
-  result->run_index = runs_.size() - 1;
   result->characters_on_left_runs = characters_so_far;
 
   DCHECK_LE(result->left_character_index, NumCharacters());
@@ -526,7 +567,7 @@ unsigned ShapeResult::OffsetForPosition(
   OffsetForPosition(x, break_glyphs_option, &result);
 
   // For LTR, the offset is always the left one.
-  if (!Rtl())
+  if (IsLtr())
     return result.left_character_index;
 
   // For RTL the offset is the right one, except that the interval is open
@@ -537,9 +578,13 @@ unsigned ShapeResult::OffsetForPosition(
   return result.right_character_index;
 }
 
-unsigned ShapeResult::OffsetForHitTest(
+unsigned ShapeResult::CaretOffsetForHitTest(
     float x,
+    const StringView& text,
     BreakGlyphsOption break_glyphs_option) const {
+  if (break_glyphs_option == BreakGlyphs)
+    EnsureGraphemes(text);
+
   GlyphIndexResult result;
   OffsetForPosition(x, break_glyphs_option, &result);
 
@@ -552,10 +597,10 @@ unsigned ShapeResult::OffsetToFit(float x, TextDirection line_direction) const {
   GlyphIndexResult result;
   OffsetForPosition(x, DontBreakGlyphs, &result);
 
-  if (IsLtr(line_direction))
+  if (blink::IsLtr(line_direction))
     return result.left_character_index;
 
-  if (x == result.origin_x && IsRtl(Direction()))
+  if (x == result.origin_x)
     return result.left_character_index;
   return result.right_character_index;
 }
@@ -571,7 +616,7 @@ float ShapeResult::PositionForOffset(
   // current run.
   unsigned offset = absolute_offset;
 
-  if (Rtl()) {
+  if (IsRtl()) {
     // Convert logical offsets to visual offsets, because results are in
     // logical order while runs are in visual order.
     x = width_;
@@ -583,7 +628,7 @@ float ShapeResult::PositionForOffset(
   for (unsigned i = 0; i < runs_.size(); i++) {
     if (!runs_[i])
       continue;
-    DCHECK_EQ(Rtl(), runs_[i]->Rtl());
+    DCHECK_EQ(IsRtl(), runs_[i]->IsRtl());
     unsigned num_characters = runs_[i]->num_characters_;
 
     if (!offset_x && offset < num_characters) {
@@ -598,11 +643,19 @@ float ShapeResult::PositionForOffset(
 
   // The position in question might be just after the text.
   if (!offset_x && absolute_offset == NumCharacters())
-    return Rtl() ? 0 : width_;
+    return IsRtl() ? 0 : width_;
 
   return offset_x;
 }
 
+float ShapeResult::CaretPositionForOffset(
+    unsigned offset,
+    const StringView& text,
+    AdjustMidCluster adjust_mid_cluster) const {
+  EnsureGraphemes(text);
+  return PositionForOffset(offset, adjust_mid_cluster);
+}
+
 void ShapeResult::FallbackFonts(
     HashSet<const SimpleFontData*>* fallback) const {
   DCHECK(fallback);
@@ -622,6 +675,198 @@ void ShapeResult::GetRunFontData(Vector<RunFontData>* font_data) const {
   }
 }
 
+template <bool has_non_zero_glyph_offsets>
+float ShapeResult::ForEachGlyphImpl(float initial_advance,
+                                    GlyphCallback glyph_callback,
+                                    void* context,
+                                    const RunInfo& run) const {
+  auto glyph_offsets = run.glyph_data_.GetOffsets<has_non_zero_glyph_offsets>();
+  auto total_advance = initial_advance;
+  bool is_horizontal = HB_DIRECTION_IS_HORIZONTAL(run.direction_);
+  for (const auto& glyph_data : run.glyph_data_) {
+    glyph_callback(context, run.start_index_ + glyph_data.character_index,
+                   glyph_data.glyph, *glyph_offsets, total_advance,
+                   is_horizontal, run.canvas_rotation_, run.font_data_.get());
+    total_advance += glyph_data.advance;
+    ++glyph_offsets;
+  }
+  return total_advance;
+}
+
+float ShapeResult::ForEachGlyph(float initial_advance,
+                                GlyphCallback glyph_callback,
+                                void* context) const {
+  auto total_advance = initial_advance;
+  for (const auto& run : runs_) {
+    if (run->glyph_data_.HasNonZeroOffsets()) {
+      total_advance =
+          ForEachGlyphImpl<true>(total_advance, glyph_callback, context, *run);
+    } else {
+      total_advance =
+          ForEachGlyphImpl<false>(total_advance, glyph_callback, context, *run);
+    }
+  }
+  return total_advance;
+}
+
+template <bool has_non_zero_glyph_offsets>
+float ShapeResult::ForEachGlyphImpl(float initial_advance,
+                                    unsigned from,
+                                    unsigned to,
+                                    unsigned index_offset,
+                                    GlyphCallback glyph_callback,
+                                    void* context,
+                                    const RunInfo& run) const {
+  auto glyph_offsets = run.glyph_data_.GetOffsets<has_non_zero_glyph_offsets>();
+  auto total_advance = initial_advance;
+  unsigned run_start = run.start_index_ + index_offset;
+  bool is_horizontal = HB_DIRECTION_IS_HORIZONTAL(run.direction_);
+  const SimpleFontData* font_data = run.font_data_.get();
+
+  if (run.IsLtr()) {  // Left-to-right
+    for (const auto& glyph_data : run.glyph_data_) {
+      const unsigned character_index = run_start + glyph_data.character_index;
+      if (character_index >= to)
+        break;
+      if (character_index >= from) {
+        glyph_callback(context, character_index, glyph_data.glyph,
+                       *glyph_offsets, total_advance, is_horizontal,
+                       run.canvas_rotation_, font_data);
+      }
+      total_advance += glyph_data.advance;
+      ++glyph_offsets;
+    }
+  } else {  // Right-to-left
+    for (const auto& glyph_data : run.glyph_data_) {
+      const unsigned character_index = run_start + glyph_data.character_index;
+      if (character_index < from)
+        break;
+      if (character_index < to) {
+        glyph_callback(context, character_index, glyph_data.glyph,
+                       *glyph_offsets, total_advance, is_horizontal,
+                       run.canvas_rotation_, font_data);
+      }
+      total_advance += glyph_data.advance;
+      ++glyph_offsets;
+    }
+  }
+  return total_advance;
+}
+
+float ShapeResult::ForEachGlyph(float initial_advance,
+                                unsigned from,
+                                unsigned to,
+                                unsigned index_offset,
+                                GlyphCallback glyph_callback,
+                                void* context) const {
+  auto total_advance = initial_advance;
+  for (const auto& run : runs_) {
+    if (run->glyph_data_.HasNonZeroOffsets()) {
+      total_advance = ForEachGlyphImpl<true>(
+          total_advance, from, to, index_offset, glyph_callback, context, *run);
+    } else {
+      total_advance = ForEachGlyphImpl<false>(
+          total_advance, from, to, index_offset, glyph_callback, context, *run);
+    }
+  }
+  return total_advance;
+}
+
+unsigned ShapeResult::CountGraphemesInCluster(base::span<const UChar> str,
+                                              uint16_t start_index,
+                                              uint16_t end_index) {
+  if (start_index > end_index)
+    std::swap(start_index, end_index);
+  uint16_t length = end_index - start_index;
+  TextBreakIterator* cursor_pos_iterator =
+      CursorMovementIterator(str.subspan(start_index, length));
+  if (!cursor_pos_iterator)
+    return 0;
+
+  int cursor_pos = cursor_pos_iterator->current();
+  int num_graphemes = -1;
+  while (0 <= cursor_pos) {
+    cursor_pos = cursor_pos_iterator->next();
+    num_graphemes++;
+  }
+  return std::max(0, num_graphemes);
+}
+
+float ShapeResult::ForEachGraphemeClusters(const StringView& text,
+                                           float initial_advance,
+                                           unsigned from,
+                                           unsigned to,
+                                           unsigned index_offset,
+                                           GraphemeClusterCallback callback,
+                                           void* context) const {
+  unsigned run_offset = index_offset;
+  float advance_so_far = initial_advance;
+  for (const auto& run : runs_) {
+    unsigned graphemes_in_cluster = 1;
+    float cluster_advance = 0;
+
+    // FIXME: should this be run->direction_?
+    bool rtl = Direction() == TextDirection::kRtl;
+
+    // A "cluster" in this context means a cluster as it is used by HarfBuzz:
+    // The minimal group of characters and corresponding glyphs, that cannot be
+    // broken down further from a text shaping point of view.  A cluster can
+    // contain multiple glyphs and grapheme clusters, with mutually overlapping
+    // boundaries.
+    uint16_t cluster_start = static_cast<uint16_t>(
+        rtl ? run->start_index_ + run->num_characters_ + run_offset
+            : run->GlyphToCharacterIndex(0) + run_offset);
+
+    const unsigned num_glyphs = run->glyph_data_.size();
+    for (unsigned i = 0; i < num_glyphs; ++i) {
+      const HarfBuzzRunGlyphData& glyph_data = run->glyph_data_[i];
+      uint16_t current_character_index =
+          run->start_index_ + glyph_data.character_index + run_offset;
+      bool is_run_end = (i + 1 == num_glyphs);
+      bool is_cluster_end =
+          is_run_end || (run->GlyphToCharacterIndex(i + 1) + run_offset !=
+                         current_character_index);
+
+      if ((rtl && current_character_index >= to) ||
+          (!rtl && current_character_index < from)) {
+        advance_so_far += glyph_data.advance;
+        rtl ? --cluster_start : ++cluster_start;
+        continue;
+      }
+
+      cluster_advance += glyph_data.advance;
+
+      if (text.Is8Bit()) {
+        callback(context, current_character_index, advance_so_far, 1,
+                 glyph_data.advance, run->canvas_rotation_);
+
+        advance_so_far += glyph_data.advance;
+      } else if (is_cluster_end) {
+        uint16_t cluster_end;
+        if (rtl) {
+          cluster_end = current_character_index;
+        } else {
+          cluster_end = static_cast<uint16_t>(
+              is_run_end ? run->start_index_ + run->num_characters_ + run_offset
+                         : run->GlyphToCharacterIndex(i + 1) + run_offset);
+        }
+        graphemes_in_cluster =
+            CountGraphemesInCluster(text.Span16(), cluster_start, cluster_end);
+        if (!graphemes_in_cluster || !cluster_advance)
+          continue;
+
+        callback(context, current_character_index, advance_so_far,
+                 graphemes_in_cluster, cluster_advance, run->canvas_rotation_);
+        advance_so_far += cluster_advance;
+
+        cluster_start = cluster_end;
+        cluster_advance = 0;
+      }
+    }
+  }
+  return advance_so_far;
+}
+
 // TODO(kojii): VC2015 fails to explicit instantiation of a member function.
 // Typed functions + this private function are to instantiate instances.
 template <typename TextContainerType>
@@ -636,7 +881,7 @@ void ShapeResult::ApplySpacingImpl(
       continue;
     unsigned run_start_index = run->start_index_ + text_start_offset;
     float total_space_for_run = 0;
-    for (size_t i = 0; i < run->glyph_data_.size(); i++) {
+    for (wtf_size_t i = 0; i < run->glyph_data_.size(); i++) {
       HarfBuzzRunGlyphData& glyph_data = run->glyph_data_[i];
 
       // Skip if it's not a grapheme cluster boundary.
@@ -646,8 +891,15 @@ void ShapeResult::ApplySpacingImpl(
         continue;
       }
 
-      space = spacing.ComputeSpacing(
-          run_start_index + glyph_data.character_index, offset);
+      typename ShapeResultSpacing<TextContainerType>::ComputeSpacingParameters
+          parameters{
+              .index = run_start_index + glyph_data.character_index,
+              .original_advance = glyph_data.advance,
+              .advance_override =
+                  IsCanvasRotationInVerticalUpright(run->canvas_rotation_)
+                      ? run->font_data_->GetAdvanceOverrideVerticalUpright()
+                      : run->font_data_->GetAdvanceOverride()};
+      space = spacing.ComputeSpacing(parameters, offset);
       glyph_data.advance += space;
       total_space_for_run += space;
 
@@ -655,9 +907,9 @@ void ShapeResult::ApplySpacingImpl(
       // non-CJK characters.
       if (UNLIKELY(offset)) {
         if (run->IsHorizontal()) {
-          glyph_data.offset.SetWidth(glyph_data.offset.Width() + offset);
+          run->glyph_data_.AddOffsetWidthAt(i, offset);
         } else {
-          glyph_data.offset.SetHeight(glyph_data.offset.Height() + offset);
+          run->glyph_data_.AddOffsetHeightAt(i, offset);
           has_vertical_offsets_ = true;
         }
         offset = 0;
@@ -680,33 +932,14 @@ void ShapeResult::ApplySpacingImpl(
     if (space < 0)
       total_space += 1;
   }
-
-  // Set the width because glyph bounding box is in logical space.
-  float glyph_bounding_box_width = glyph_bounding_box_.Width() + total_space;
-  if (width_ >= 0 && glyph_bounding_box_width >= 0) {
-    glyph_bounding_box_.SetWidth(glyph_bounding_box_width);
-    return;
-  }
-
-  // Negative word-spacing and/or letter-spacing may cause some glyphs to
-  // overflow the left boundary and result negative measured width. Adjust glyph
-  // bounds accordingly to cover the overflow.
-  // The negative width should be clamped to 0 in CSS box model, but it's up to
-  // caller's responsibility.
-  float left = std::min(width_, glyph_bounding_box_width);
-  if (left < glyph_bounding_box_.X()) {
-    // The right edge should be the width of the first character in most cases,
-    // but computing it requires re-measuring bounding box of each glyph. Leave
-    // it unchanged, which gives an excessive right edge but assures it covers
-    // all glyphs.
-    glyph_bounding_box_.ShiftXEdgeTo(left);
-  } else {
-    glyph_bounding_box_.SetWidth(glyph_bounding_box_width);
-  }
 }
 
 void ShapeResult::ApplySpacing(ShapeResultSpacing<String>& spacing,
                                int text_start_offset) {
+  // For simplicity, we apply spacing once only. If you want to do multiple
+  // time, please get rid of below |DCHECK()|.
+  DCHECK(!is_applied_spacing_) << this;
+  is_applied_spacing_ = true;
   ApplySpacingImpl(spacing, text_start_offset);
 }
 
@@ -727,77 +960,29 @@ float HarfBuzzPositionToFloat(hb_position_t value) {
   return static_cast<float>(value) / (1 << 16);
 }
 
-// This is a helper class to accumulate glyph bounding box.
-//
-// Glyph positions and bounding boxes from HarfBuzz and fonts are in physical
-// coordinate, while ShapeResult::glyph_bounding_box_ is in logical coordinate.
-// To minimize the number of conversions, this class accumulates the bounding
-// boxes in physical coordinate, and convert the accumulated box to logical.
-struct GlyphBoundsAccumulator {
-  // Construct an accumulator with the logical glyph origin.
-  explicit GlyphBoundsAccumulator(float origin) : origin(origin) {}
-
-  // The accumulated glyph bounding box in physical coordinate, until
-  // ConvertVerticalRunToLogical().
-  FloatRect bounds;
-  // The current origin, in logical coordinate.
-  float origin;
-
-  // Unite a glyph bounding box to |bounds|.
-  template <bool is_horizontal_run>
-  void Unite(const HarfBuzzRunGlyphData& glyph_data,
-             FloatRect bounds_for_glyph) {
-    if (UNLIKELY(bounds_for_glyph.IsEmpty()))
-      return;
-
-    // Glyphs are drawn at |origin + offset|. Move glyph_bounds to that point.
-    // All positions in hb_glyph_position_t are relative to the current point.
-    // https://behdad.github.io/harfbuzz/harfbuzz-Buffers.html#hb-glyph-position-t-struct
-    if (is_horizontal_run)
-      bounds_for_glyph.SetX(bounds_for_glyph.X() + origin);
-    else
-      bounds_for_glyph.SetY(bounds_for_glyph.Y() + origin);
-    bounds_for_glyph.Move(glyph_data.offset);
-
-    bounds.Unite(bounds_for_glyph);
-  }
-
-  // Non-template version of |Unite()|, see above.
-  void Unite(bool is_horizontal_run,
-             const HarfBuzzRunGlyphData& glyph,
-             FloatRect bounds_for_glyph) {
-    is_horizontal_run ? Unite<true>(glyph, bounds_for_glyph)
-                      : Unite<false>(glyph, bounds_for_glyph);
-  }
-
-  // Convert vertical run glyph bounding box to logical. Horizontal runs do not
-  // need conversions because physical and logical are the same.
-  void ConvertVerticalRunToLogical(const FontMetrics& font_metrics) {
-    // Convert physical glyph_bounding_box to logical.
-    bounds = bounds.TransposedRect();
-
-    // The glyph bounding box of a vertical run uses ideographic baseline.
-    // Adjust the box Y position because the bounding box of a ShapeResult uses
-    // alphabetic baseline.
-    // See diagrams of base lines at
-    // https://drafts.csswg.org/css-writing-modes-3/#intro-baselines
-    int baseline_adjust = font_metrics.Ascent(kIdeographicBaseline) -
-                          font_metrics.Ascent(kAlphabeticBaseline);
-    bounds.SetY(bounds.Y() + baseline_adjust);
-  }
-};
-
 // Checks whether it's safe to break without reshaping before the given glyph.
 bool IsSafeToBreakBefore(const hb_glyph_info_t* glyph_infos,
-                         unsigned num_glyphs,
-                         unsigned i) {
-  // Before the first glyph is safe to break.
-  if (!i)
-    return true;
+                         unsigned i,
+                         unsigned num_glyph,
+                         TextDirection direction) {
+  if (direction == TextDirection::kLtr) {
+    // Before the first glyph is safe to break.
+    if (!i)
+      return true;
 
-  // Not at a cluster boundary.
-  if (glyph_infos[i].cluster == glyph_infos[i - 1].cluster)
-    return false;
+    // Not at a cluster boundary.
+    if (glyph_infos[i].cluster == glyph_infos[i - 1].cluster)
+      return false;
+  } else {
+    DCHECK_EQ(direction, TextDirection::kRtl);
+    // Before the first glyph is safe to break.
+    if (i == num_glyph - 1)
+      return true;
+
+    // Not at a cluster boundary.
+    if (glyph_infos[i].cluster == glyph_infos[i + 1].cluster)
+      return false;
+  }
 
   // The HB_GLYPH_FLAG_UNSAFE_TO_BREAK flag is set for all glyphs in a
   // given cluster so we only need to check the last one.
@@ -807,41 +992,142 @@ bool IsSafeToBreakBefore(const hb_glyph_info_t* glyph_infos,
 
 }  // anonymous namespace
 
-// Computes glyph positions, sets advance and offset of each glyph to RunInfo.
+// This function computes the number of glyphs and characters that can fit into
+// this RunInfo.
 //
-// Also computes glyph bounding box of the run. In this function, glyph bounding
-// box is in physical.
+// HarfBuzzRunGlyphData has a limit kMaxCharacterIndex for the character index
+// in order to packsave memory. Also, RunInfo has kMaxGlyphs to make the number
+// of glyphs predictable and to minimize the buffer reallocations.
+unsigned ShapeResult::RunInfo::LimitNumGlyphs(
+    unsigned start_glyph,
+    unsigned* num_glyphs_in_out,
+    const bool is_ltr,
+    const hb_glyph_info_t* glyph_infos) {
+  unsigned num_glyphs = *num_glyphs_in_out;
+  CHECK_GT(num_glyphs, 0u);
+
+  // If there were larger character indexes than kMaxCharacterIndex, reduce
+  // num_glyphs so that all character indexes can fit to kMaxCharacterIndex.
+  // Because code points and glyphs are not always 1:1, we need to check the
+  // first and the last cluster.
+  const hb_glyph_info_t* left_glyph_info = &glyph_infos[start_glyph];
+  const hb_glyph_info_t* right_glyph_info = &left_glyph_info[num_glyphs - 1];
+  unsigned start_cluster;
+  if (is_ltr) {
+    start_cluster = left_glyph_info->cluster;
+    unsigned last_cluster = right_glyph_info->cluster;
+    unsigned max_cluster =
+        start_cluster + HarfBuzzRunGlyphData::kMaxCharacterIndex;
+    if (UNLIKELY(last_cluster > max_cluster)) {
+      // Limit at |max_cluster| in LTR. If |max_cluster| is 100:
+      //   0 1 2 ... 98 99 99 101 101 103 ...
+      //                     ^ limit here.
+      // Find |glyph_info| where |cluster| <= |max_cluster|.
+      const hb_glyph_info_t* limit_glyph_info = std::upper_bound(
+          left_glyph_info, right_glyph_info + 1, max_cluster,
+          [](unsigned cluster, const hb_glyph_info_t& glyph_info) {
+            return cluster < glyph_info.cluster;
+          });
+      --limit_glyph_info;
+      CHECK_GT(limit_glyph_info, left_glyph_info);
+      CHECK_LT(limit_glyph_info, right_glyph_info);
+      DCHECK_LE(limit_glyph_info->cluster, max_cluster);
+      // Adjust |right_glyph_info| and recompute dependent variables.
+      right_glyph_info = limit_glyph_info;
+      num_glyphs = right_glyph_info - left_glyph_info + 1;
+      num_characters_ = right_glyph_info[1].cluster - start_cluster;
+    }
+  } else {
+    start_cluster = right_glyph_info->cluster;
+    unsigned last_cluster = left_glyph_info->cluster;
+    unsigned max_cluster =
+        start_cluster + HarfBuzzRunGlyphData::kMaxCharacterIndex;
+    if (UNLIKELY(last_cluster > max_cluster)) {
+      // Limit the right edge, which is in the reverse order in RTL.
+      // If |min_cluster| is 3:
+      //   103 102 ... 4 4 2 2 ...
+      //                  ^ limit here.
+      // Find |glyph_info| where |cluster| >= |min_cluster|.
+      unsigned min_cluster =
+          last_cluster - HarfBuzzRunGlyphData::kMaxCharacterIndex;
+      DCHECK_LT(start_cluster, min_cluster);
+      const hb_glyph_info_t* limit_glyph_info = std::upper_bound(
+          left_glyph_info, right_glyph_info + 1, min_cluster,
+          [](unsigned cluster, const hb_glyph_info_t& glyph_info) {
+            return cluster > glyph_info.cluster;
+          });
+      --limit_glyph_info;
+      CHECK_GT(limit_glyph_info, left_glyph_info);
+      CHECK_LT(limit_glyph_info, right_glyph_info);
+      DCHECK_GE(limit_glyph_info->cluster, min_cluster);
+      // Adjust |right_glyph_info| and recompute dependent variables.
+      right_glyph_info = limit_glyph_info;
+      start_cluster = right_glyph_info->cluster;
+      num_glyphs = right_glyph_info - left_glyph_info + 1;
+      num_characters_ = last_cluster - right_glyph_info[1].cluster;
+    }
+  }
+
+  // num_glyphs maybe still larger than kMaxGlyphs after it was reduced to fit
+  // to kMaxCharacterIndex. Reduce to kMaxGlyphs if so.
+  if (UNLIKELY(num_glyphs > HarfBuzzRunGlyphData::kMaxGlyphs)) {
+    num_glyphs = HarfBuzzRunGlyphData::kMaxGlyphs;
+
+    // If kMaxGlyphs is not a cluster boundary, reduce further until the last
+    // boundary.
+    const unsigned end_cluster = glyph_infos[start_glyph + num_glyphs].cluster;
+    for (;; num_glyphs--) {
+      if (!num_glyphs) {
+        // Extreme edge case when kMaxGlyphs is one grapheme cluster. We don't
+        // have much choices, just cut at kMaxGlyphs.
+        num_glyphs = HarfBuzzRunGlyphData::kMaxGlyphs;
+        break;
+      }
+      if (glyph_infos[start_glyph + num_glyphs - 1].cluster != end_cluster)
+        break;
+    }
+    num_characters_ = is_ltr ? end_cluster - start_cluster
+                             : glyph_infos[start_glyph].cluster - end_cluster;
+  }
+
+  if (num_glyphs == *num_glyphs_in_out)
+    return start_cluster;
+  glyph_data_.Shrink(num_glyphs);
+  *num_glyphs_in_out = num_glyphs;
+  return start_cluster;
+}
+
+// Computes glyph positions, sets advance and offset of each glyph to RunInfo.
 template <bool is_horizontal_run>
 void ShapeResult::ComputeGlyphPositions(ShapeResult::RunInfo* run,
                                         unsigned start_glyph,
                                         unsigned num_glyphs,
                                         hb_buffer_t* harfbuzz_buffer) {
   DCHECK_EQ(is_horizontal_run, run->IsHorizontal());
-  const SimpleFontData& current_font_data = *run->font_data_;
   const hb_glyph_info_t* glyph_infos =
       hb_buffer_get_glyph_infos(harfbuzz_buffer, nullptr);
   const hb_glyph_position_t* glyph_positions =
       hb_buffer_get_glyph_positions(harfbuzz_buffer, nullptr);
-  const unsigned start_cluster =
-      HB_DIRECTION_IS_FORWARD(hb_buffer_get_direction(harfbuzz_buffer))
-          ? glyph_infos[start_glyph].cluster
-          : glyph_infos[start_glyph + num_glyphs - 1].cluster;
 
-  // Compute glyph_origin and glyph_bounding_box in physical, since both offsets
-  // and boudning box of glyphs are in physical. It's the caller's
-  // responsibility to convert the united physical bounds to logical.
+  const bool is_ltr =
+      HB_DIRECTION_IS_FORWARD(hb_buffer_get_direction(harfbuzz_buffer));
+  unsigned start_cluster =
+      run->LimitNumGlyphs(start_glyph, &num_glyphs, is_ltr, glyph_infos);
+  DCHECK_LE(num_glyphs, HarfBuzzRunGlyphData::kMaxGlyphs);
+
+  // Compute glyph_origin in physical, since offsets of glyphs are in physical.
+  // It's the caller's responsibility to convert to logical.
   float total_advance = 0.0f;
-  GlyphBoundsAccumulator bounds(width_);
   bool has_vertical_offsets = !is_horizontal_run;
 
   // HarfBuzz returns result in visual order, no need to flip for RTL.
   for (unsigned i = 0; i < num_glyphs; ++i) {
-    uint16_t glyph = glyph_infos[start_glyph + i].codepoint;
+    const hb_glyph_info_t glyph = glyph_infos[start_glyph + i];
     const hb_glyph_position_t& pos = glyph_positions[start_glyph + i];
 
     // Offset is primarily used when painting glyphs. Keep it in physical.
-    FloatSize offset(HarfBuzzPositionToFloat(pos.x_offset),
-                     -HarfBuzzPositionToFloat(pos.y_offset));
+    GlyphOffset offset(HarfBuzzPositionToFloat(pos.x_offset),
+                       -HarfBuzzPositionToFloat(pos.y_offset));
 
     // One out of x_advance and y_advance is zero, depending on
     // whether the buffer direction is horizontal or vertical.
@@ -849,47 +1135,31 @@ void ShapeResult::ComputeGlyphPositions(ShapeResult::RunInfo* run,
     float advance = is_horizontal_run ? HarfBuzzPositionToFloat(pos.x_advance)
                                       : -HarfBuzzPositionToFloat(pos.y_advance);
 
-    uint16_t character_index =
-        glyph_infos[start_glyph + i].cluster - start_cluster;
-    if (UNLIKELY(character_index > HarfBuzzRunGlyphData::kMaxCharacterIndex)) {
-      // If the character index exceeds the limit, abort and shrink the run to
-      // what are actually stored.
-      run->num_characters_ = character_index;
-      run->glyph_data_.Shrink(i);
-      break;
-    }
-    HarfBuzzRunGlyphData& glyph_data = run->glyph_data_[i];
-    glyph_data.SetGlyphAndPositions(
-        glyph, character_index, advance, offset,
-        IsSafeToBreakBefore(glyph_infos + start_glyph, num_glyphs, i));
+    uint16_t character_index = glyph.cluster - start_cluster;
+    DCHECK_LE(character_index, HarfBuzzRunGlyphData::kMaxCharacterIndex);
+    run->glyph_data_[i] = {glyph.codepoint, character_index,
+                           IsSafeToBreakBefore(glyph_infos + start_glyph, i,
+                                               num_glyphs, Direction()),
+                           advance};
+    run->glyph_data_.SetOffsetAt(i, offset);
+
     total_advance += advance;
     has_vertical_offsets |= (offset.Height() != 0);
-
-    bounds.Unite<is_horizontal_run>(
-        glyph_data, current_font_data.BoundsForGlyph(glyph_data.glyph));
-    bounds.origin += advance;
   }
 
   run->width_ = std::max(0.0f, total_advance);
   has_vertical_offsets_ |= has_vertical_offsets;
-
-  if (!is_horizontal_run)
-    bounds.ConvertVerticalRunToLogical(current_font_data.GetFontMetrics());
-  glyph_bounding_box_.Unite(bounds.bounds);
 }
 
-void ShapeResult::InsertRun(std::unique_ptr<ShapeResult::RunInfo> run_to_insert,
+void ShapeResult::InsertRun(scoped_refptr<ShapeResult::RunInfo> run_to_insert,
                             unsigned start_glyph,
                             unsigned num_glyphs,
                             hb_buffer_t* harfbuzz_buffer) {
   DCHECK_GT(num_glyphs, 0u);
-  std::unique_ptr<ShapeResult::RunInfo> run(std::move(run_to_insert));
-  DCHECK_EQ(num_glyphs, run->glyph_data_.size());
+  scoped_refptr<ShapeResult::RunInfo> run(std::move(run_to_insert));
 
   if (run->IsHorizontal()) {
-    // Inserting a horizontal run into a horizontal or vertical result. In both
-    // cases, no adjustments are needed because |glyph_bounding_box_| is in
-    // logical coordinates and uses alphabetic baseline.
+    // Inserting a horizontal run into a horizontal or vertical result.
     ComputeGlyphPositions<true>(run.get(), start_glyph, num_glyphs,
                                 harfbuzz_buffer);
   } else {
@@ -904,61 +1174,49 @@ void ShapeResult::InsertRun(std::unique_ptr<ShapeResult::RunInfo> run_to_insert,
   InsertRun(std::move(run));
 }
 
-void ShapeResult::InsertRun(std::unique_ptr<ShapeResult::RunInfo> run) {
+void ShapeResult::InsertRun(scoped_refptr<ShapeResult::RunInfo> run) {
   // The runs are stored in result->m_runs in visual order. For LTR, we place
-  // the run to be inserted before the next run with a bigger character
-  // start index. For RTL, we place the run before the next run with a lower
-  // character index. Otherwise, for both directions, at the end.
-  if (HB_DIRECTION_IS_FORWARD(run->direction_)) {
-    for (size_t pos = 0; pos < runs_.size(); ++pos) {
-      if (runs_.at(pos)->start_index_ > run->start_index_) {
-        runs_.insert(pos, std::move(run));
-        break;
-      }
-    }
-  } else {
-    for (size_t pos = 0; pos < runs_.size(); ++pos) {
-      if (runs_.at(pos)->start_index_ < run->start_index_) {
-        runs_.insert(pos, std::move(run));
-        break;
-      }
-    }
-  }
+  // the run to be inserted before the next run with a bigger character start
+  // index.
+  const auto ltr_comparer = [](scoped_refptr<RunInfo>& run,
+                               unsigned start_index) {
+    return run->start_index_ < start_index;
+  };
+
+  // For RTL, we place the run before the next run with a lower character
+  // index. Otherwise, for both directions, at the end.
+  const auto rtl_comparer = [](scoped_refptr<RunInfo>& run,
+                               unsigned start_index) {
+    return run->start_index_ > start_index;
+  };
+
+  Vector<scoped_refptr<RunInfo>>::iterator iterator = std::lower_bound(
+      runs_.begin(), runs_.end(), run->start_index_,
+      HB_DIRECTION_IS_FORWARD(run->direction_) ? ltr_comparer : rtl_comparer);
+  if (iterator != runs_.end())
+    runs_.insert(iterator - runs_.begin(), std::move(run));
+
   // If we didn't find an existing slot to place it, append.
   if (run)
     runs_.push_back(std::move(run));
 }
 
-// Insert a |RunInfo| without glyphs. |StartIndexForResult()| needs a run to
-// compute the start character index. When all glyphs are missing, this function
-// synthesize a run without glyphs.
-void ShapeResult::InsertRunForIndex(unsigned start_character_index) {
-  DCHECK(runs_.IsEmpty());
-  // TODO(fserb): do we need the proper graphemes?
-  Vector<unsigned> graphemes;
-  runs_.push_back(std::make_unique<RunInfo>(
-      primary_font_.get(), !Rtl() ? HB_DIRECTION_LTR : HB_DIRECTION_RTL,
-      CanvasRotationInVertical::kRegular, HB_SCRIPT_UNKNOWN,
-      start_character_index, 0, num_characters_, graphemes));
-}
-
 ShapeResult::RunInfo* ShapeResult::InsertRunForTesting(
     unsigned start_index,
     unsigned num_characters,
     TextDirection direction,
-    Vector<uint16_t> safe_break_offsets,
-    Vector<unsigned> graphemes) {
-  std::unique_ptr<RunInfo> run = std::make_unique<ShapeResult::RunInfo>(
-      nullptr, IsLtr(direction) ? HB_DIRECTION_LTR : HB_DIRECTION_RTL,
+    Vector<uint16_t> safe_break_offsets) {
+  auto run = RunInfo::Create(
+      nullptr, blink::IsLtr(direction) ? HB_DIRECTION_LTR : HB_DIRECTION_RTL,
       CanvasRotationInVertical::kRegular, HB_SCRIPT_COMMON, start_index,
-      num_characters, num_characters, std::move(graphemes));
-  unsigned i = 0;
-  for (auto& glyph_data : run->glyph_data_)
-    glyph_data.SetGlyphAndPositions(0, i++, 0, FloatSize(), false);
+      num_characters, num_characters);
+  for (unsigned i = 0; i < run->glyph_data_.size(); i++) {
+    run->glyph_data_[i] = {0, i, false, 0};
+  }
   for (uint16_t offset : safe_break_offsets)
     run->glyph_data_[offset].safe_to_break_before = true;
   // RTL runs have glyphs in the descending order of character_index.
-  if (Rtl())
+  if (IsRtl())
     run->glyph_data_.Reverse();
   num_glyphs_ += run->NumGlyphs();
   RunInfo* run_ptr = run.get();
@@ -971,12 +1229,12 @@ ShapeResult::RunInfo* ShapeResult::InsertRunForTesting(
 // Runs in RTL result are in visual order, and that new runs should be
 // prepended. This function adjusts the run order after runs were appended.
 void ShapeResult::ReorderRtlRuns(unsigned run_size_before) {
-  DCHECK(Rtl());
+  DCHECK(IsRtl());
   DCHECK_GT(runs_.size(), run_size_before);
   if (runs_.size() == run_size_before + 1) {
     if (!run_size_before)
       return;
-    std::unique_ptr<RunInfo> new_run(std::move(runs_.back()));
+    scoped_refptr<RunInfo> new_run(std::move(runs_.back()));
     runs_.Shrink(runs_.size() - 1);
     runs_.push_front(std::move(new_run));
     return;
@@ -984,7 +1242,7 @@ void ShapeResult::ReorderRtlRuns(unsigned run_size_before) {
 
   // |push_front| is O(n) that we should not call it multiple times.
   // Create a new list in the correct order and swap it.
-  Vector<std::unique_ptr<RunInfo>> new_runs;
+  Vector<scoped_refptr<RunInfo>> new_runs;
   new_runs.ReserveInitialCapacity(runs_.size());
   for (unsigned i = run_size_before; i < runs_.size(); i++)
     new_runs.push_back(std::move(runs_[i]));
@@ -995,71 +1253,79 @@ void ShapeResult::ReorderRtlRuns(unsigned run_size_before) {
   runs_.swap(new_runs);
 }
 
-// Returns the left of the glyph bounding box of the left most character.
-float ShapeResult::LineLeftBounds() const {
-  DCHECK(!runs_.IsEmpty());
-  const RunInfo& run = *runs_.front();
-  const bool is_horizontal_run = run.IsHorizontal();
-  const SimpleFontData& font_data = *run.font_data_;
-  DCHECK(!run.glyph_data_.IsEmpty()) << *this;
-  const unsigned character_index = run.glyph_data_.front().character_index;
-  GlyphBoundsAccumulator bounds(0.f);
-  for (const auto& glyph : run.glyph_data_) {
-    if (character_index != glyph.character_index)
-      break;
-    bounds.Unite(is_horizontal_run, glyph,
-                 font_data.BoundsForGlyph(glyph.glyph));
-    bounds.origin += glyph.advance;
-  }
-  if (UNLIKELY(!is_horizontal_run))
-    bounds.ConvertVerticalRunToLogical(font_data.GetFontMetrics());
-  return bounds.bounds.X();
-}
-
-// Returns the right of the glyph bounding box of the right most character.
-float ShapeResult::LineRightBounds() const {
-  DCHECK(!runs_.IsEmpty());
-  const RunInfo& run = *runs_.back();
-  const bool is_horizontal_run = run.IsHorizontal();
-  const SimpleFontData& font_data = *run.font_data_;
-  DCHECK(!run.glyph_data_.IsEmpty()) << *this;
-  const unsigned character_index = run.glyph_data_.back().character_index;
-  GlyphBoundsAccumulator bounds(width_);
-  for (const auto& glyph : base::Reversed(run.glyph_data_)) {
-    if (character_index != glyph.character_index)
-      break;
-    bounds.origin -= glyph.advance;
-    bounds.Unite(is_horizontal_run, glyph,
-                 font_data.BoundsForGlyph(glyph.glyph));
-  }
-  // If the last character has no ink (e.g., space character), assume the
-  // character before will not overflow more than the width of the space.
-  if (UNLIKELY(bounds.bounds.IsEmpty()))
-    return width_;
-  if (UNLIKELY(!is_horizontal_run))
-    bounds.ConvertVerticalRunToLogical(font_data.GetFontMetrics());
-  return bounds.bounds.MaxX();
-}
-
 void ShapeResult::CopyRange(unsigned start_offset,
                             unsigned end_offset,
                             ShapeResult* target) const {
-  if (!runs_.size())
-    return;
+  unsigned run_index = 0;
+  CopyRangeInternal(run_index, start_offset, end_offset, target);
+}
 
+void ShapeResult::CopyRanges(const ShapeRange* ranges,
+                             unsigned num_ranges) const {
+  DCHECK_GT(num_ranges, 0u);
+
+  // Ranges are in logical order so for RTL the ranges are proccessed back to
+  // front to ensure that they're in a sequential visual order with regards to
+  // the runs.
+  if (IsRtl()) {
+    unsigned run_index = 0;
+    unsigned last_range = num_ranges - 1;
+    for (unsigned i = 0; i < num_ranges; i++) {
+      const ShapeRange& range = ranges[last_range - i];
+#if DCHECK_IS_ON()
+      DCHECK_GE(range.end, range.start);
+      if (i != last_range)
+        DCHECK_GE(range.start, ranges[last_range - (i + 1)].end);
+#endif
+      run_index =
+          CopyRangeInternal(run_index, range.start, range.end, range.target);
+    }
+    return;
+  }
+
+  unsigned run_index = 0;
+  for (unsigned i = 0; i < num_ranges; i++) {
+    const ShapeRange& range = ranges[i];
+#if DCHECK_IS_ON()
+    DCHECK_GE(range.end, range.start);
+    if (i)
+      DCHECK_GE(range.start, ranges[i - 1].end);
+#endif
+    run_index =
+        CopyRangeInternal(run_index, range.start, range.end, range.target);
+  }
+}
+
+unsigned ShapeResult::CopyRangeInternal(unsigned run_index,
+                                        unsigned start_offset,
+                                        unsigned end_offset,
+                                        ShapeResult* target) const {
 #if DCHECK_IS_ON()
   unsigned target_num_characters_before = target->num_characters_;
 #endif
 
+  target->is_applied_spacing_ |= is_applied_spacing_;
+
   // When |target| is empty, its character indexes are the specified sub range
   // of |this|. Otherwise the character indexes are renumbered to be continuous.
-  int index_diff = !target->num_characters_
-                       ? 0
-                       : target->EndIndexForResult() -
-                             std::max(start_offset, StartIndexForResult());
+  //
+  // Compute the diff of index and the number of characters from the source
+  // ShapeResult and given offsets, because computing them from runs/parts can
+  // be inaccurate when all characters in a run/part are missing.
+  int index_diff;
+  if (!target->num_characters_) {
+    index_diff = 0;
+    target->start_index_ = start_offset;
+  } else {
+    index_diff = target->EndIndex() - std::max(start_offset, StartIndex());
+  }
+  target->num_characters_ +=
+      std::min(end_offset, EndIndex()) - std::max(start_offset, StartIndex());
+
   unsigned target_run_size_before = target->runs_.size();
-  float total_width = 0;
-  for (const auto& run : runs_) {
+  bool should_merge = !target->runs_.IsEmpty();
+  for (; run_index < runs_.size(); run_index++) {
+    const auto& run = runs_[run_index];
     unsigned run_start = run->start_index_;
     unsigned run_end = run_start + run->num_characters_;
 
@@ -1068,60 +1334,54 @@ void ShapeResult::CopyRange(unsigned start_offset,
       unsigned end = std::min(end_offset, run_end) - run_start;
       DCHECK(end > start);
 
-      auto sub_run = run->CreateSubRun(start, end);
-      sub_run->start_index_ += index_diff;
-      total_width += sub_run->width_;
-      target->num_characters_ += sub_run->num_characters_;
-      target->num_glyphs_ += sub_run->glyph_data_.size();
-      target->runs_.push_back(std::move(sub_run));
+      if (scoped_refptr<RunInfo> sub_run = run->CreateSubRun(start, end)) {
+        sub_run->start_index_ += index_diff;
+        target->width_ += sub_run->width_;
+        target->num_glyphs_ += sub_run->glyph_data_.size();
+        if (auto merged_run =
+                should_merge ? target->runs_.back()->MergeIfPossible(*sub_run)
+                             : scoped_refptr<RunInfo>()) {
+          target->runs_.back() = std::move(merged_run);
+        } else {
+          target->runs_.push_back(std::move(sub_run));
+        }
+      }
+      should_merge = false;
+
+      // No need to process runs after the end of the range.
+      if ((IsLtr() && end_offset <= run_end) ||
+          (IsRtl() && start_offset >= run_start)) {
+        break;
+      }
     }
   }
 
-  if (!target->num_glyphs_)
-    return;
+  if (!target->num_glyphs_) {
+    return run_index;
+  }
 
   // Runs in RTL result are in visual order, and that new runs should be
   // prepended. Reorder appended runs.
-  DCHECK_EQ(Rtl(), target->Rtl());
-  if (UNLIKELY(Rtl() && target->runs_.size() != target_run_size_before))
+  DCHECK_EQ(IsRtl(), target->IsRtl());
+  if (UNLIKELY(IsRtl() && target->runs_.size() != target_run_size_before))
     target->ReorderRtlRuns(target_run_size_before);
 
-  // Compute new glyph bounding box.
-  //
-  // Computing glyph bounding box from Font is one of the most expensive
-  // operations. If |start_offset| or |end_offset| are the start/end of |this|,
-  // use the current |glyph_bounding_box_| for the side.
-  DCHECK(primary_font_.get() == target->primary_font_.get());
-  bool know_left_edge = start_offset <= StartIndexForResult();
-  bool know_right_edge = end_offset >= EndIndexForResult();
-  if (UNLIKELY(Rtl()))
-    std::swap(know_left_edge, know_right_edge);
-  float left = know_left_edge ? target->width_ + glyph_bounding_box_.X()
-                              : target->LineLeftBounds();
-  target->width_ += total_width;
-  float right = know_right_edge
-                    ? glyph_bounding_box_.MaxX() - width_ + target->width_
-                    : target->LineRightBounds();
-  FloatRect adjusted_box(left, glyph_bounding_box_.Y(),
-                         std::max(right - left, 0.0f),
-                         glyph_bounding_box_.Height());
-  target->glyph_bounding_box_.UniteIfNonZero(adjusted_box);
-
   target->has_vertical_offsets_ |= has_vertical_offsets_;
 
 #if DCHECK_IS_ON()
-  DCHECK_EQ(target->num_characters_ - target_num_characters_before,
-            std::min(end_offset, EndIndexForResult()) -
-                std::max(start_offset, StartIndexForResult()));
-
+  DCHECK_EQ(
+      target->num_characters_ - target_num_characters_before,
+      std::min(end_offset, EndIndex()) - std::max(start_offset, StartIndex()));
   target->CheckConsistency();
 #endif
+
+  return run_index;
 }
 
 scoped_refptr<ShapeResult> ShapeResult::SubRange(unsigned start_offset,
                                                  unsigned end_offset) const {
   scoped_refptr<ShapeResult> sub_range =
-      Create(primary_font_.get(), 0, Direction());
+      Create(primary_font_.get(), 0, 0, Direction());
   CopyRange(start_offset, end_offset, sub_range.get());
   return sub_range;
 }
@@ -1130,18 +1390,19 @@ scoped_refptr<ShapeResult> ShapeResult::CopyAdjustedOffset(
     unsigned start_index) const {
   scoped_refptr<ShapeResult> result = base::AdoptRef(new ShapeResult(*this));
 
-  if (start_index > result->StartIndexForResult()) {
-    unsigned delta = start_index - result->StartIndexForResult();
+  if (start_index > result->StartIndex()) {
+    unsigned delta = start_index - result->StartIndex();
     for (auto& run : result->runs_)
       run->start_index_ += delta;
   } else {
-    unsigned delta = result->StartIndexForResult() - start_index;
+    unsigned delta = result->StartIndex() - start_index;
     for (auto& run : result->runs_) {
       DCHECK(run->start_index_ >= delta);
       run->start_index_ -= delta;
     }
   }
 
+  result->start_index_ = start_index;
   return result;
 }
 
@@ -1153,10 +1414,10 @@ void ShapeResult::CheckConsistency() const {
     return;
   }
 
-  const unsigned start_index = StartIndexForResult();
+  const unsigned start_index = StartIndex();
   unsigned index = start_index;
   unsigned num_glyphs = 0;
-  if (!Rtl()) {
+  if (IsLtr()) {
     for (const auto& run : runs_) {
       // Characters maybe missing, but must be in increasing order.
       DCHECK_GE(run->start_index_, index);
@@ -1172,7 +1433,7 @@ void ShapeResult::CheckConsistency() const {
       num_glyphs += run->glyph_data_.size();
     }
   }
-  const unsigned end_index = EndIndexForResult();
+  const unsigned end_index = EndIndex();
   DCHECK_LE(index, end_index);
   DCHECK_EQ(end_index - start_index, num_characters_);
   DCHECK_EQ(num_glyphs, num_glyphs_);
@@ -1183,35 +1444,167 @@ scoped_refptr<ShapeResult> ShapeResult::CreateForTabulationCharacters(
     const Font* font,
     const TextRun& text_run,
     float position_offset,
-    unsigned count) {
+    unsigned length) {
+  return CreateForTabulationCharacters(
+      font, text_run.Direction(), text_run.GetTabSize(),
+      text_run.XPos() + position_offset, 0, length);
+}
+
+scoped_refptr<ShapeResult> ShapeResult::CreateForTabulationCharacters(
+    const Font* font,
+    TextDirection direction,
+    const TabSize& tab_size,
+    float position,
+    unsigned start_index,
+    unsigned length) {
+  DCHECK_GT(length, 0u);
   const SimpleFontData* font_data = font->PrimaryFont();
-  // Tab characters are always LTR or RTL, not TTB, even when
-  // isVerticalAnyUpright().
-  // We don't pass proper graphemes for tabulation.
-  Vector<unsigned> graphemes;
-  std::unique_ptr<ShapeResult::RunInfo> run = std::make_unique<RunInfo>(
-      font_data, text_run.Rtl() ? HB_DIRECTION_RTL : HB_DIRECTION_LTR,
-      CanvasRotationInVertical::kRegular, HB_SCRIPT_COMMON, 0, count, count,
-      graphemes);
-  float position = text_run.XPos() + position_offset;
-  float start_position = position;
-  for (unsigned i = 0; i < count; i++) {
-    float advance = font->TabWidth(font_data, text_run.GetTabSize(), position);
-    HarfBuzzRunGlyphData& glyph_data = run->glyph_data_[i];
-    glyph_data.SetGlyphAndPositions(font_data->SpaceGlyph(), i, advance,
-                                    FloatSize(), true);
-
-    position += advance;
-  }
-  run->width_ = position - start_position;
-
+  DCHECK(font_data);
   scoped_refptr<ShapeResult> result =
-      ShapeResult::Create(font, count, text_run.Direction());
-  result->width_ = run->width_;
-  result->num_glyphs_ = count;
-  DCHECK_EQ(result->num_glyphs_, count);  // no overflow
+      ShapeResult::Create(font, start_index, length, direction);
+  result->num_glyphs_ = length;
+  DCHECK_EQ(result->num_glyphs_, length);  // no overflow
   result->has_vertical_offsets_ =
       font_data->PlatformData().IsVerticalAnyUpright();
+  // Tab characters are always LTR or RTL, not TTB, even when
+  // isVerticalAnyUpright().
+  hb_direction_t hb_direction =
+      blink::IsLtr(direction) ? HB_DIRECTION_LTR : HB_DIRECTION_RTL;
+  // Only the advance of the first tab is affected by |position|.
+  float advance = font->TabWidth(font_data, tab_size, position);
+  do {
+    unsigned run_length = std::min(length, HarfBuzzRunGlyphData::kMaxGlyphs);
+    scoped_refptr<ShapeResult::RunInfo> run = RunInfo::Create(
+        font_data, hb_direction, CanvasRotationInVertical::kRegular,
+        HB_SCRIPT_COMMON, start_index, run_length, run_length);
+    float start_position = position;
+    for (unsigned i = 0; i < run_length; i++) {
+      // 2nd and following tabs have the base width, without using |position|.
+      if (i == 1)
+        advance = font->TabWidth(font_data, tab_size);
+      run->glyph_data_[i] = {font_data->SpaceGlyph(), i, true, advance};
+      position += advance;
+    }
+    run->width_ = position - start_position;
+    result->width_ += run->width_;
+    result->runs_.push_back(std::move(run));
+    DCHECK_GE(length, run_length);
+    length -= run_length;
+    start_index += run_length;
+  } while (length);
+  return result;
+}
+
+scoped_refptr<ShapeResult> ShapeResult::CreateForSpaces(const Font* font,
+                                                        TextDirection direction,
+                                                        unsigned start_index,
+                                                        unsigned length,
+                                                        float width) {
+  DCHECK_GT(length, 0u);
+  const SimpleFontData* font_data = font->PrimaryFont();
+  DCHECK(font_data);
+  scoped_refptr<ShapeResult> result =
+      ShapeResult::Create(font, start_index, length, direction);
+  result->num_glyphs_ = length;
+  DCHECK_EQ(result->num_glyphs_, length);  // no overflow
+  result->has_vertical_offsets_ =
+      font_data->PlatformData().IsVerticalAnyUpright();
+  hb_direction_t hb_direction =
+      blink::IsLtr(direction) ? HB_DIRECTION_LTR : HB_DIRECTION_RTL;
+  scoped_refptr<ShapeResult::RunInfo> run = RunInfo::Create(
+      font_data, hb_direction, CanvasRotationInVertical::kRegular,
+      HB_SCRIPT_COMMON, start_index, length, length);
+  result->width_ = run->width_ = width;
+  for (unsigned i = 0; i < length; i++) {
+    run->glyph_data_[i] = {font_data->SpaceGlyph(), i, true, width};
+    width = 0;
+  }
+  result->runs_.push_back(std::move(run));
+  return result;
+}
+
+scoped_refptr<ShapeResult> ShapeResult::CreateForStretchyMathOperator(
+    const Font* font,
+    TextDirection direction,
+    Glyph glyph_variant,
+    float stretch_size) {
+  unsigned start_index = 0;
+  unsigned num_characters = 1;
+  scoped_refptr<ShapeResult> result =
+      ShapeResult::Create(font, start_index, num_characters, direction);
+
+  hb_direction_t hb_direction = HB_DIRECTION_LTR;
+  unsigned glyph_index = 0;
+  scoped_refptr<ShapeResult::RunInfo> run = RunInfo::Create(
+      font->PrimaryFont(), hb_direction, CanvasRotationInVertical::kRegular,
+      HB_SCRIPT_COMMON, start_index, 1 /* num_glyph */, num_characters);
+  run->glyph_data_[glyph_index] = {glyph_variant, 0 /* character index */,
+                                   true /* IsSafeToBreakBefore */,
+                                   stretch_size};
+  run->width_ = std::max(0.0f, stretch_size);
+
+  result->width_ = run->width_;
+  result->num_glyphs_ = run->NumGlyphs();
+  result->runs_.push_back(std::move(run));
+
+  return result;
+}
+
+scoped_refptr<ShapeResult> ShapeResult::CreateForStretchyMathOperator(
+    const Font* font,
+    TextDirection direction,
+    OpenTypeMathStretchData::StretchAxis stretch_axis,
+    const OpenTypeMathStretchData::AssemblyParameters& assembly_parameters) {
+  DCHECK(!assembly_parameters.parts.IsEmpty());
+  DCHECK_LE(assembly_parameters.glyph_count, HarfBuzzRunGlyphData::kMaxGlyphs);
+
+  bool is_horizontal_assembly =
+      stretch_axis == OpenTypeMathStretchData::StretchAxis::Horizontal;
+  unsigned start_index = 0;
+  unsigned num_characters = 1;
+  scoped_refptr<ShapeResult> result =
+      ShapeResult::Create(font, start_index, num_characters, direction);
+
+  hb_direction_t hb_direction =
+      is_horizontal_assembly ? HB_DIRECTION_LTR : HB_DIRECTION_TTB;
+  scoped_refptr<ShapeResult::RunInfo> run = RunInfo::Create(
+      font->PrimaryFont(), hb_direction, CanvasRotationInVertical::kRegular,
+      HB_SCRIPT_COMMON, start_index, assembly_parameters.glyph_count,
+      num_characters);
+
+  float overlap = assembly_parameters.connector_overlap;
+  unsigned part_index = 0;
+  for (const auto& part : assembly_parameters.parts) {
+    unsigned repetition_count =
+        part.is_extender ? assembly_parameters.repetition_count : 1;
+    if (!repetition_count)
+      continue;
+    DCHECK(part_index < assembly_parameters.glyph_count);
+    for (unsigned repetition_index = 0; repetition_index < repetition_count;
+         repetition_index++) {
+      unsigned glyph_index =
+          is_horizontal_assembly
+              ? part_index
+              : assembly_parameters.glyph_count - 1 - part_index;
+      float full_advance = glyph_index == assembly_parameters.glyph_count - 1
+                               ? part.full_advance
+                               : part.full_advance - overlap;
+      run->glyph_data_[glyph_index] = {part.glyph, 0 /* character index */,
+                                       !glyph_index /* IsSafeToBreakBefore */,
+                                       full_advance};
+      if (!is_horizontal_assembly) {
+        GlyphOffset glyph_offset(
+            0, -assembly_parameters.stretch_size + part.full_advance);
+        run->glyph_data_.SetOffsetAt(glyph_index, glyph_offset);
+        result->has_vertical_offsets_ |= (glyph_offset.Height() != 0);
+      }
+      part_index++;
+    }
+  }
+  run->width_ = std::max(0.0f, assembly_parameters.stretch_size);
+
+  result->width_ = run->width_;
+  result->num_glyphs_ = run->NumGlyphs();
   result->runs_.push_back(std::move(run));
   return result;
 }
@@ -1234,7 +1627,7 @@ void ShapeResult::ToString(StringBuilder* output) const {
     output->Append(", #chars=");
     output->AppendNumber(run.num_characters_);
     output->Append(", dir=");
-    output->AppendNumber(run.direction_);
+    output->AppendNumber(static_cast<uint32_t>(run.direction_));
     output->Append(", glyphs[");
     output->AppendNumber(run.glyph_data_.size());
     output->Append("]{");
@@ -1267,72 +1660,70 @@ std::ostream& operator<<(std::ostream& ostream,
 template <bool rtl>
 void ShapeResult::ComputePositionData() const {
   auto& data = character_position_->data_;
-  unsigned start_offset = StartIndexForResult();
-  unsigned next_character_index;
-  float run_advance;
-
-  if (!rtl) {
-    next_character_index = 0;
-    run_advance = 0;
-  } else {
-    DCHECK_GE(EndIndexForResult(), start_offset + 1);
-    next_character_index = EndIndexForResult() - (start_offset + 1);
-    run_advance = width_;
-  }
+  unsigned start_offset = StartIndex();
+  unsigned next_character_index = 0;
+  float run_advance = 0;
+  float last_x_position = 0;
 
+  // Iterate runs/glyphs in the visual order; i.e., from the left edge
+  // regardless of the directionality, so that |x_position| is always in
+  // ascending order.
+  // TODO(kojii): It does not work when large negative letter-/word-
+  // spacing is applied.
   for (const auto& run : runs_) {
     if (!run)
       continue;
 
+    // Assumes all runs have the same directionality as the ShapeResult so that
+    // |x_position| is in ascending order.
+    DCHECK_EQ(IsRtl(), run->IsRtl());
+
     float total_advance = run_advance;
     for (const auto& glyph_data : run->glyph_data_) {
-      DCHECK_GE(run->start_index_ + glyph_data.character_index, start_offset);
+      DCHECK_GE(run->start_index_, start_offset);
       unsigned character_index =
           run->start_index_ + glyph_data.character_index - start_offset;
 
-      // Multiple glyphs may have the same character index and not all character
-      // indices may have glyphs.
-      // For character indices without glyps set the x-position to that of the
-      // nearest preceding glyph.
-      if (!rtl) {
-        for (unsigned i = next_character_index; i < character_index; i++) {
-          DCHECK_LT(i, num_characters_);
-          data[i] = {total_advance, false};
+      // Make |character_index| to the visual offset.
+      DCHECK_LT(character_index, num_characters_);
+      if (rtl)
+        character_index = num_characters_ - character_index - 1;
+
+      // If this glyph is the first glyph of a new cluster, set the data.
+      // Otherwise, |data[character_index]| is already set. Do not overwrite.
+      DCHECK_LT(character_index, num_characters_);
+      if (next_character_index <= character_index) {
+        if (next_character_index < character_index) {
+          // Multiple glyphs may have the same character index and not all
+          // character indices may have glyphs. For character indices without
+          // glyphs set the x-position to that of the nearest preceding glyph in
+          // the logical order; i.e., the last position for LTR or this position
+          // for RTL.
+          float x_position = !rtl ? last_x_position : total_advance;
+          for (unsigned i = next_character_index; i < character_index; i++) {
+            DCHECK_LT(i, num_characters_);
+            data[i] = {x_position, false, false};
+          }
         }
 
-        // TODO(layout-dev): This is a bit of a hack, need to represent next
-        // better for RTL. Perhaps by storing last index instead and subtracting
-        // one here instead.
-      } else if (next_character_index != static_cast<unsigned>(-1)) {
-        for (unsigned i = next_character_index; i > character_index; i--) {
-          DCHECK_LT(i, num_characters_);
-          data[i] = {total_advance, false};
-        }
+        data[character_index] = {total_advance, true,
+                                 glyph_data.safe_to_break_before};
+        last_x_position = total_advance;
       }
 
-      // For glyphs with the same character index the last logical one wins.
-      // This is the last visual one in LTR, no need to do anything speical.
-      // For RTL this is the first visual one so skip subsequent ones with the
-      // same character index.
-      if (rtl && next_character_index + 1 == character_index)
-        continue;
-
-      // For glyphs with the same character index in LTR take the advance from
-      // the last one but the safe to break flag from the first.
-      DCHECK_LT(character_index, num_characters_);
-      bool safe_to_break =
-          next_character_index > character_index
-              ? data[next_character_index - 1].safe_to_break_before
-              : glyph_data.safe_to_break_before;
-      data[character_index] = {total_advance, safe_to_break};
-
       total_advance += glyph_data.advance;
-      next_character_index = character_index + (!rtl ? 1 : -1);
+      next_character_index = character_index + 1;
+    }
+    run_advance += run->width_;
+  }
+
+  // Fill |x_position| for the rest of characters, when they don't have
+  // corresponding glyphs.
+  if (next_character_index < num_characters_) {
+    float x_position = !rtl ? last_x_position : run_advance;
+    for (unsigned i = next_character_index; i < num_characters_; i++) {
+      data[i] = {x_position, false, false};
     }
-    if (!rtl)
-      run_advance += run->width_;
-    else
-      run_advance -= run->width_;
   }
 
   character_position_->start_offset_ = start_offset;
@@ -1350,28 +1741,34 @@ void ShapeResult::EnsurePositionData() const {
     ComputePositionData<true>();
 }
 
-unsigned ShapeResult::CachedOffsetForPosition(float x) const {
-  // TODO(layout-dev): Remove once CharacterPositionData::OffsetForPosition
-  // properly supports RTL.
-  if (Rtl())
-    return OffsetForPosition(x, DontBreakGlyphs);
+void ShapeResult::DiscardPositionData() const {
+  character_position_ = nullptr;
+}
 
+unsigned ShapeResult::CachedOffsetForPosition(float x) const {
   DCHECK(character_position_);
-  return character_position_->OffsetForPosition(x);
+  unsigned offset = character_position_->OffsetForPosition(x, IsRtl());
+#if 0
+  // TODO(kojii): This DCHECK fails in ~10 tests. Needs investigations.
+  DCHECK_EQ(OffsetForPosition(x, BreakGlyphsOption::DontBreakGlyphs), offset) << x;
+#endif
+  return offset;
 }
 
 float ShapeResult::CachedPositionForOffset(unsigned offset) const {
-  // TODO(layout-dev): Remove once CharacterPositionData::PositionForOffset
-  // properly supports RTL.
-  if (Rtl())
-    return PositionForOffset(offset);
-
+  DCHECK_GE(offset, 0u);
+  DCHECK_LE(offset, num_characters_);
   DCHECK(character_position_);
-  return character_position_->PositionForOffset(offset);
+  float position = character_position_->PositionForOffset(offset, IsRtl());
+#if 0
+  // TODO(kojii): This DCHECK fails in several tests. Needs investigations.
+  DCHECK_EQ(PositionForOffset(offset), position) << offset;
+#endif
+  return position;
 }
 
 unsigned ShapeResult::CachedNextSafeToBreakOffset(unsigned offset) const {
-  if (Rtl())
+  if (IsRtl())
     return NextSafeToBreakOffset(offset);
 
   DCHECK(character_position_);
@@ -1379,7 +1776,7 @@ unsigned ShapeResult::CachedNextSafeToBreakOffset(unsigned offset) const {
 }
 
 unsigned ShapeResult::CachedPreviousSafeToBreakOffset(unsigned offset) const {
-  if (Rtl())
+  if (IsRtl())
     return PreviousSafeToBreakOffset(offset);
 
   DCHECK(character_position_);
@@ -1389,14 +1786,14 @@ unsigned ShapeResult::CachedPreviousSafeToBreakOffset(unsigned offset) const {
 // TODO(eae): Might be worth trying to set midpoint to ~50% more than the number
 // of characters in the previous line for the first try. Would cut the number
 // of tries in the majority of cases for long strings.
-unsigned ShapeResult::CharacterPositionData::OffsetForPosition(float x) const {
-  // At or before start, return offset *before* the first character.
-  if (x <= 0)
-    return 0;
-
+unsigned ShapeResult::CharacterPositionData::OffsetForPosition(float x,
+                                                               bool rtl) const {
+  // At or before start, return offset *of* the first character.
   // At or beyond the end, return offset *after* the last character.
+  if (x <= 0)
+    return !rtl ? 0 : data_.size();
   if (x >= width_)
-    return data_.size();
+    return !rtl ? data_.size() : 0;
 
   // Do a binary search to find the largest x-position that is less than or
   // equal to the supplied x value.
@@ -1407,7 +1804,11 @@ unsigned ShapeResult::CharacterPositionData::OffsetForPosition(float x) const {
     unsigned midpoint = low + (high - low) / 2;
     if (data_[midpoint].x_position <= x &&
         (midpoint + 1 == length || data_[midpoint + 1].x_position > x)) {
-      return midpoint;
+      if (!rtl)
+        return midpoint;
+      // The border belongs to the logical next character.
+      return data_[midpoint].x_position == x ? data_.size() - midpoint
+                                             : data_.size() - midpoint - 1;
     }
     if (x < data_[midpoint].x_position)
       high = midpoint - 1;
@@ -1418,12 +1819,27 @@ unsigned ShapeResult::CharacterPositionData::OffsetForPosition(float x) const {
   return 0;
 }
 
-float ShapeResult::CharacterPositionData::PositionForOffset(
-    unsigned offset) const {
+float ShapeResult::CharacterPositionData::PositionForOffset(unsigned offset,
+                                                            bool rtl) const {
   DCHECK_GT(data_.size(), 0u);
-  if (offset >= data_.size())
-    return width_;
-  return data_[offset].x_position;
+  if (!rtl) {
+    if (offset < data_.size())
+      return data_[offset].x_position;
+  } else {
+    if (offset >= data_.size())
+      return 0;
+    // Return the left edge of the next character because in RTL, the position
+    // is the right edge of the character.
+    for (unsigned visual_offset = data_.size() - offset - 1;
+         visual_offset < data_.size(); visual_offset++) {
+      if (data_[visual_offset].is_cluster_base) {
+        return visual_offset + 1 < data_.size()
+                   ? data_[visual_offset + 1].x_position
+                   : width_;
+      }
+    }
+  }
+  return width_;
 }
 
 unsigned ShapeResult::CharacterPositionData::NextSafeToBreakOffset(
@@ -1467,4 +1883,114 @@ unsigned ShapeResult::CharacterPositionData::PreviousSafeToBreakOffset(
   return 0;
 }
 
+namespace {
+
+void AddRunInfoRanges(const ShapeResult::RunInfo& run_info,
+                      float offset,
+                      Vector<CharacterRange>* ranges) {
+  Vector<float> character_widths(run_info.num_characters_);
+  for (const auto& glyph : run_info.glyph_data_)
+    character_widths[glyph.character_index] += glyph.advance;
+
+  if (run_info.IsRtl())
+    offset += run_info.width_;
+
+  for (unsigned character_index = 0; character_index < run_info.num_characters_;
+       character_index++) {
+    float start = offset;
+    offset += character_widths[character_index] * (run_info.IsRtl() ? -1 : 1);
+    float end = offset;
+
+    // To match getCharacterRange we flip ranges to ensure start <= end.
+    if (end < start)
+      ranges->push_back(CharacterRange(end, start, 0, 0));
+    else
+      ranges->push_back(CharacterRange(start, end, 0, 0));
+  }
+}
+
+}  // anonymous namespace
+
+float ShapeResult::IndividualCharacterRanges(Vector<CharacterRange>* ranges,
+                                             float start_x) const {
+  DCHECK(ranges);
+  float current_x = start_x;
+
+  if (IsRtl()) {
+    unsigned run_count = runs_.size();
+    for (int index = run_count - 1; index >= 0; index--) {
+      current_x -= runs_[index]->width_;
+      AddRunInfoRanges(*runs_[index], current_x, ranges);
+    }
+  } else {
+    for (const auto& run : runs_) {
+      AddRunInfoRanges(*run, current_x, ranges);
+      current_x += run->width_;
+    }
+  }
+
+  return current_x;
+}
+
+template <bool is_horizontal_run, bool has_non_zero_glyph_offsets>
+void ShapeResult::ComputeRunInkBounds(const ShapeResult::RunInfo& run,
+                                      float run_advance,
+                                      FloatRect* ink_bounds) const {
+  // Get glyph bounds from Skia. It's a lot faster if we give it list of glyph
+  // IDs rather than calling it for each glyph.
+  // TODO(kojii): MacOS does not benefit from batching the Skia request due to
+  // https://bugs.chromium.org/p/skia/issues/detail?id=5328, and the cost to
+  // prepare batching, which is normally much less than the benefit of
+  // batching, is not ignorable unfortunately.
+  auto glyph_offsets = run.glyph_data_.GetOffsets<has_non_zero_glyph_offsets>();
+  const SimpleFontData& current_font_data = *run.font_data_;
+  unsigned num_glyphs = run.glyph_data_.size();
+#if !defined(OS_MAC)
+  Vector<Glyph, 256> glyphs(num_glyphs);
+  unsigned i = 0;
+  for (const auto& glyph_data : run.glyph_data_)
+    glyphs[i++] = glyph_data.glyph;
+  Vector<SkRect, 256> bounds_list(num_glyphs);
+  current_font_data.BoundsForGlyphs(glyphs, &bounds_list);
+#endif
+
+  GlyphBoundsAccumulator bounds(run_advance);
+  for (unsigned j = 0; j < num_glyphs; ++j) {
+    const HarfBuzzRunGlyphData& glyph_data = run.glyph_data_[j];
+#if defined(OS_MAC)
+    FloatRect glyph_bounds = current_font_data.BoundsForGlyph(glyph_data.glyph);
+#else
+    FloatRect glyph_bounds(bounds_list[j]);
+#endif
+    bounds.Unite<is_horizontal_run>(glyph_bounds, *glyph_offsets);
+    ++glyph_offsets;
+    bounds.origin += glyph_data.advance;
+  }
+
+  if (!is_horizontal_run)
+    bounds.ConvertVerticalRunToLogical(current_font_data.GetFontMetrics());
+  ink_bounds->Unite(bounds.bounds);
+}
+
+FloatRect ShapeResult::ComputeInkBounds() const {
+  FloatRect ink_bounds;
+  float run_advance = 0.0f;
+  for (const auto& run : runs_) {
+    if (run->glyph_data_.HasNonZeroOffsets()) {
+      if (run->IsHorizontal())
+        ComputeRunInkBounds<true, true>(*run.get(), run_advance, &ink_bounds);
+      else
+        ComputeRunInkBounds<false, true>(*run.get(), run_advance, &ink_bounds);
+    } else {
+      if (run->IsHorizontal())
+        ComputeRunInkBounds<true, false>(*run.get(), run_advance, &ink_bounds);
+      else
+        ComputeRunInkBounds<false, false>(*run.get(), run_advance, &ink_bounds);
+    }
+    run_advance += run->width_;
+  }
+
+  return ink_bounds;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result.h b/third_party/blink/renderer/platform/fonts/shaping/shape_result.h
index 926faed4e2b9..a733598210ec 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_result.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result.h
@@ -32,15 +32,20 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_SHAPE_RESULT_H_
 
 #include <memory>
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/fonts/canvas_rotation_in_vertical.h"
+#include "third_party/blink/renderer/platform/fonts/glyph.h"
+#include "third_party/blink/renderer/platform/fonts/opentype/open_type_math_stretch_data.h"
+#include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
 #include "third_party/blink/renderer/platform/geometry/float_rect.h"
-#include "third_party/blink/renderer/platform/layout_unit.h"
+#include "third_party/blink/renderer/platform/geometry/layout_unit.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/text/text_direction.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/forward.h"
 #include "third_party/blink/renderer/platform/wtf/hash_set.h"
-#include "third_party/blink/renderer/platform/wtf/noncopyable.h"
 #include "third_party/blink/renderer/platform/wtf/ref_counted.h"
+#include "third_party/blink/renderer/platform/wtf/text/unicode.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 
 struct hb_buffer_t;
@@ -51,8 +56,8 @@ struct CharacterRange;
 class Font;
 template <typename TextContainerType>
 class PLATFORM_EXPORT ShapeResultSpacing;
-class SimpleFontData;
 class TextRun;
+class ShapeResultView;
 
 enum class AdjustMidCluster {
   // Adjust the middle of a grapheme cluster to the logical end boundary.
@@ -62,8 +67,10 @@ enum class AdjustMidCluster {
 };
 
 struct ShapeResultCharacterData {
-  DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
+  DISALLOW_NEW();
   float x_position;
+  // Set for the logical first character of a cluster.
+  unsigned is_cluster_base : 1;
   unsigned safe_to_break_before : 1;
 };
 
@@ -83,12 +90,38 @@ enum BreakGlyphsOption {
   BreakGlyphs,
 };
 
+// std::function is forbidden in Chromium and base::Callback is way too
+// expensive so we resort to a good old function pointer instead.
+typedef void (*GlyphCallback)(void* context,
+                              unsigned character_index,
+                              Glyph,
+                              FloatSize glyph_offset,
+                              float total_advance,
+                              bool is_horizontal,
+                              CanvasRotationInVertical,
+                              const SimpleFontData*);
+
+typedef void (*GraphemeClusterCallback)(void* context,
+                                        unsigned character_index,
+                                        float total_advance,
+                                        unsigned graphemes_in_cluster,
+                                        float cluster_advance,
+                                        CanvasRotationInVertical);
+
 class PLATFORM_EXPORT ShapeResult : public RefCounted<ShapeResult> {
+  USING_FAST_MALLOC(ShapeResult);
+
  public:
   static scoped_refptr<ShapeResult> Create(const Font* font,
-                                    unsigned num_characters,
-                                    TextDirection direction) {
-    return base::AdoptRef(new ShapeResult(font, num_characters, direction));
+                                           unsigned start_index,
+                                           unsigned num_characters,
+                                           TextDirection direction) {
+    return base::AdoptRef(
+        new ShapeResult(font, start_index, num_characters, direction));
+  }
+  static scoped_refptr<ShapeResult> CreateEmpty(const ShapeResult& other) {
+    return base::AdoptRef(
+        new ShapeResult(other.primary_font_, 0, 0, other.Direction()));
   }
   static scoped_refptr<ShapeResult> Create(const ShapeResult& other) {
     return base::AdoptRef(new ShapeResult(other));
@@ -97,29 +130,51 @@ class PLATFORM_EXPORT ShapeResult : public RefCounted<ShapeResult> {
       const Font*,
       const TextRun&,
       float position_offset,
-      unsigned count);
+      unsigned length);
+  static scoped_refptr<ShapeResult> CreateForTabulationCharacters(
+      const Font* font,
+      TextDirection direction,
+      const TabSize& tab_size,
+      float position,
+      unsigned start_index,
+      unsigned length);
+  static scoped_refptr<ShapeResult> CreateForSpaces(const Font* font,
+                                                    TextDirection direction,
+                                                    unsigned start_index,
+                                                    unsigned length,
+                                                    float width);
+  static scoped_refptr<ShapeResult> CreateForStretchyMathOperator(
+      const Font*,
+      TextDirection,
+      Glyph,
+      float stretch_size);
+  static scoped_refptr<ShapeResult> CreateForStretchyMathOperator(
+      const Font*,
+      TextDirection,
+      OpenTypeMathStretchData::StretchAxis,
+      const OpenTypeMathStretchData::AssemblyParameters&);
   ~ShapeResult();
 
-  // Returns a mutable unique instance. If |this| has more than 1 ref count,
-  // a clone is created.
-  scoped_refptr<ShapeResult> MutableUnique() const;
-
   // The logical width of this result.
   float Width() const { return width_; }
   LayoutUnit SnappedWidth() const { return LayoutUnit::FromFloatCeil(width_); }
-  // The glyph bounding box, in logical coordinates, using alphabetic baseline
-  // even when the result is in vertical flow.
-  const FloatRect& Bounds() const { return glyph_bounding_box_; }
   unsigned NumCharacters() const { return num_characters_; }
-  CharacterRange GetCharacterRange(unsigned from, unsigned to) const;
+  unsigned NumGlyphs() const { return num_glyphs_; }
+
+  // TODO(eae): Remove start_x and return value once ShapeResultBuffer has been
+  // removed.
+  float IndividualCharacterRanges(Vector<CharacterRange>* ranges,
+                                  float start_x = 0) const;
+
   // The character start/end index of a range shape result.
-  unsigned StartIndexForResult() const;
-  unsigned EndIndexForResult() const;
+  unsigned StartIndex() const { return start_index_; }
+  unsigned EndIndex() const { return start_index_ + num_characters_; }
   void FallbackFonts(HashSet<const SimpleFontData*>*) const;
   TextDirection Direction() const {
     return static_cast<TextDirection>(direction_);
   }
-  bool Rtl() const { return Direction() == TextDirection::kRtl; }
+  bool IsLtr() const { return blink::IsLtr(Direction()); }
+  bool IsRtl() const { return blink::IsRtl(Direction()); }
 
   // True if at least one glyph in this result has vertical offsets.
   //
@@ -127,39 +182,58 @@ class PLATFORM_EXPORT ShapeResult : public RefCounted<ShapeResult> {
   // have vertical offsets.
   bool HasVerticalOffsets() const { return has_vertical_offsets_; }
 
+  // Note: We should not reuse |ShapeResult| if we call |ApplySpacing()|.
+  bool IsAppliedSpacing() const { return is_applied_spacing_; }
+
   // For memory reporting.
   size_t ByteSize() const;
 
+  // True if |StartIndex()| is safe to break.
+  bool IsStartSafeToBreak() const;
+
   // Returns the next or previous offsets respectively at which it is safe to
   // break without reshaping.
   // The |offset| given and the return value is for the original string, between
-  // |StartIndexForResult| and |EndIndexForResult|.
+  // |StartIndex| and |EndIndex|.
   // TODO(eae): Remove these ones the cached versions are used everywhere.
   unsigned NextSafeToBreakOffset(unsigned offset) const;
   unsigned PreviousSafeToBreakOffset(unsigned offset) const;
 
-  // Returns the offset, relative to StartIndexForResult, whose (origin,
+  // Returns the offset, relative to StartIndex, whose (origin,
   // origin+advance) contains |x|.
   unsigned OffsetForPosition(float x, BreakGlyphsOption) const;
   // Returns the offset whose glyph boundary is nearest to |x|. Depends on
   // whether |x| is on the left-half or the right-half of the glyph, it
   // determines the left-boundary or the right-boundary, then computes the
   // offset from the bidi direction.
-  unsigned OffsetForHitTest(float x, BreakGlyphsOption) const;
+  unsigned CaretOffsetForHitTest(float x,
+                                 const StringView& text,
+                                 BreakGlyphsOption) const;
   // Returns the offset that can fit to between |x| and the left or the right
   // edge. The side of the edge is determined by |line_direction|.
   unsigned OffsetToFit(float x, TextDirection line_direction) const;
   unsigned OffsetForPosition(float x,
+                             const StringView& text,
                              IncludePartialGlyphsOption include_partial_glyphs,
                              BreakGlyphsOption break_glyphs_option) const {
-    return include_partial_glyphs == OnlyFullGlyphs
-               ? OffsetForPosition(x, break_glyphs_option)
-               : OffsetForHitTest(x, break_glyphs_option);
+    if (include_partial_glyphs == OnlyFullGlyphs) {
+      // TODO(kojii): Consider prohibiting OnlyFullGlyphs+BreakGlyphs, used only
+      // in tests.
+      if (break_glyphs_option == BreakGlyphs)
+        EnsureGraphemes(text);
+      return OffsetForPosition(x, break_glyphs_option);
+    }
+    return CaretOffsetForHitTest(x, text, break_glyphs_option);
   }
 
-  // Returns the position for a given offset, relative to StartIndexForResult.
+  // Returns the position for a given offset, relative to StartIndex.
   float PositionForOffset(unsigned offset,
                           AdjustMidCluster = AdjustMidCluster::kToEnd) const;
+  // Similar to |PositionForOffset| with mid-glyph (mid-ligature) support.
+  float CaretPositionForOffset(
+      unsigned offset,
+      const StringView& text,
+      AdjustMidCluster = AdjustMidCluster::kToEnd) const;
   LayoutUnit SnappedStartPositionForOffset(unsigned offset) const {
     return LayoutUnit::FromFloatFloor(PositionForOffset(offset));
   }
@@ -170,6 +244,9 @@ class PLATFORM_EXPORT ShapeResult : public RefCounted<ShapeResult> {
   // Computes and caches a position data object as needed.
   void EnsurePositionData() const;
 
+  // Discards cached position data, freeing up memory.
+  void DiscardPositionData() const;
+
   // Fast versions of OffsetForPosition and PositionForOffset that operates on
   // a cache (that needs to be pre-computed using EnsurePositionData) and that
   // does not take partial glyphs into account.
@@ -180,7 +257,7 @@ class PLATFORM_EXPORT ShapeResult : public RefCounted<ShapeResult> {
   // break without reshaping. Operates on a cache (that needs to be pre-computed
   // using EnsurePositionData) and does not take partial glyphs into account.
   // The |offset| given and the return value is for the original string, between
-  // |StartIndexForResult| and |EndIndexForResult|.
+  // |StartIndex| and |EndIndex|.
   unsigned CachedNextSafeToBreakOffset(unsigned offset) const;
   unsigned CachedPreviousSafeToBreakOffset(unsigned offset) const;
 
@@ -188,14 +265,30 @@ class PLATFORM_EXPORT ShapeResult : public RefCounted<ShapeResult> {
   // configured to |ShapeResultSpacing|.
   // |text_start_offset| adjusts the character index in the ShapeResult before
   // giving it to |ShapeResultSpacing|. It can be negative if
-  // |StartIndexForResult()| is larger than the text in |ShapeResultSpacing|.
+  // |StartIndex()| is larger than the text in |ShapeResultSpacing|.
   void ApplySpacing(ShapeResultSpacing<String>&, int text_start_offset = 0);
   scoped_refptr<ShapeResult> ApplySpacingToCopy(ShapeResultSpacing<TextRun>&,
                                          const TextRun&) const;
 
   // Append a copy of a range within an existing result to another result.
+  //
+  // For sequential copies the vector version below is prefered as it avoid a
+  // linear scan to find the first run for the range.
   void CopyRange(unsigned start, unsigned end, ShapeResult*) const;
 
+  struct ShapeRange {
+    ShapeRange(unsigned start, unsigned end, ShapeResult* target)
+        : start(start), end(end), target(target) {}
+
+    unsigned start;
+    unsigned end;
+    ShapeResult* target;
+  };
+
+  // Copy a set of sequential ranges. The ranges may not overlap and the offsets
+  // must be sequential and monotically increasing.
+  void CopyRanges(const ShapeRange* ranges, unsigned num_ranges) const;
+
   // Create a new ShapeResult instance from a range within an existing result.
   scoped_refptr<ShapeResult> SubRange(unsigned start_offset,
                                       unsigned end_offset) const;
@@ -206,39 +299,96 @@ class PLATFORM_EXPORT ShapeResult : public RefCounted<ShapeResult> {
   // Computes the list of fonts along with the number of glyphs for each font.
   struct RunFontData {
     SimpleFontData* font_data_;
-    size_t glyph_count_;
+    wtf_size_t glyph_count_;
   };
   void GetRunFontData(Vector<RunFontData>* font_data) const;
 
+  // Iterates over, and calls the specified callback function, for all the
+  // glyphs. Also tracks (and returns) a seeded total advance.
+  // The second version of the method only invokes the callback for glyphs in
+  // the specified range and stops after the range.
+  // The context parameter will be given as the first parameter for the callback
+  // function.
+  //
+  // TODO(eae): Remove the initial_advance and index_offset parameters once
+  // ShapeResultBuffer has been removed as they're only used in cases where
+  // multiple ShapeResult are combined in a ShapeResultBuffer.
+  float ForEachGlyph(float initial_advance, GlyphCallback, void* context) const;
+  float ForEachGlyph(float initial_advance,
+                     unsigned from,
+                     unsigned to,
+                     unsigned index_offset,
+                     GlyphCallback,
+                     void* context) const;
+
+  // Iterates over, and calls the specified callback function, for all the
+  // grapheme clusters. As ShapeResuls do not contain the original text content
+  // a StringView with the text must be supplied and must match the text that
+  // was used generate the ShapeResult.
+  // Also tracks (and returns) a seeded total advance.
+  // The context parameter will be given as the first parameter for the callback
+  // function.
+  float ForEachGraphemeClusters(const StringView& text,
+                                float initial_advance,
+                                unsigned from,
+                                unsigned to,
+                                unsigned index_offset,
+                                GraphemeClusterCallback,
+                                void* context) const;
+
+  // Computes and returns the ink bounds (or visual overflow rect). This is
+  // quite expensive and involves measuring each glyphaccumulating the bounds.
+  FloatRect ComputeInkBounds() const;
+
+  // Only used by CachingWordShapeIterator
+  // TODO(eae): Remove once LayoutNG lands. https://crbug.com/591099
+  void SetDeprecatedInkBounds(FloatRect r) const { deprecated_ink_bounds_ = r; }
+  FloatRect DeprecatedInkBounds() const { return deprecated_ink_bounds_; }
+
   String ToString() const;
   void ToString(StringBuilder*) const;
 
+  class GlyphOffset;
   struct RunInfo;
   RunInfo* InsertRunForTesting(unsigned start_index,
                                unsigned num_characters,
                                TextDirection,
-                               Vector<uint16_t> safe_break_offsets = {},
-                               Vector<unsigned> graphemes = {});
+                               Vector<uint16_t> safe_break_offsets = {});
 #if DCHECK_IS_ON()
   void CheckConsistency() const;
 #endif
 
  protected:
-  ShapeResult(const SimpleFontData*, unsigned num_characters, TextDirection);
-  ShapeResult(const Font*, unsigned num_characters, TextDirection);
+  ShapeResult(scoped_refptr<const SimpleFontData>,
+              unsigned start_index,
+              unsigned num_characters,
+              TextDirection);
+  ShapeResult(const Font*,
+              unsigned start_index,
+              unsigned num_characters,
+              TextDirection);
   ShapeResult(const ShapeResult&);
 
   static scoped_refptr<ShapeResult> Create(const SimpleFontData* font_data,
+                                           unsigned start_index,
                                            unsigned num_characters,
                                            TextDirection direction) {
     return base::AdoptRef(
-        new ShapeResult(font_data, num_characters, direction));
+        new ShapeResult(font_data, start_index, num_characters, direction));
   }
 
+  // Ensure |grapheme_| is computed. |BreakGlyphs| is valid only when
+  // |grapheme_| is computed.
+  void EnsureGraphemes(const StringView& text) const;
+
+  static unsigned CountGraphemesInCluster(base::span<const UChar>,
+                                          uint16_t start_index,
+                                          uint16_t end_index);
+
   struct GlyphIndexResult {
     STACK_ALLOCATED();
 
-    unsigned run_index = 0;
+   public:
     // The total number of characters of runs_[0..run_index - 1].
     unsigned characters_on_left_runs = 0;
 
@@ -264,6 +414,8 @@ class PLATFORM_EXPORT ShapeResult : public RefCounted<ShapeResult> {
   // mapping from character index to x-position and O(log n) time, using binary
   // search, from x-position to character index.
   class CharacterPositionData {
+    USING_FAST_MALLOC(CharacterPositionData);
+
    public:
     CharacterPositionData(unsigned num_characters, float width)
         : data_(num_characters), width_(width) {}
@@ -275,12 +427,14 @@ class PLATFORM_EXPORT ShapeResult : public RefCounted<ShapeResult> {
 
     // Returns the offset of the last character that fully fits before the given
     // x-position.
-    unsigned OffsetForPosition(float x) const;
+    unsigned OffsetForPosition(float x, bool rtl) const;
 
     // Returns the x-position for a given offset.
-    float PositionForOffset(unsigned offset) const;
+    float PositionForOffset(unsigned offset, bool rtl) const;
 
    private:
+    // This vector is indexed by visual-offset; the character offset from the
+    // left edge regardless of the TextDirection.
     Vector<ShapeResultCharacterData> data_;
     unsigned start_offset_;
     float width_;
@@ -288,6 +442,17 @@ class PLATFORM_EXPORT ShapeResult : public RefCounted<ShapeResult> {
     friend class ShapeResult;
   };
 
+  // Append a copy of a range within an existing result to another result.
+  //
+  // For sequential copies the run_index argument indicates the run to start at.
+  // If set to zero it will always scan from the first run which is guaranteed
+  // to produce the correct results at the cost of run-time performance.
+  // Returns the appropriate run_index for the next sequential invocation.
+  unsigned CopyRangeInternal(unsigned run_index,
+                             unsigned start,
+                             unsigned end,
+                             ShapeResult* target) const;
+
   template <bool>
   void ComputePositionData() const;
 
@@ -299,25 +464,36 @@ class PLATFORM_EXPORT ShapeResult : public RefCounted<ShapeResult> {
                              unsigned start_glyph,
                              unsigned num_glyphs,
                              hb_buffer_t*);
-  void InsertRun(std::unique_ptr<ShapeResult::RunInfo>,
+  void InsertRun(scoped_refptr<ShapeResult::RunInfo>,
                  unsigned start_glyph,
                  unsigned num_glyphs,
                  hb_buffer_t*);
-  void InsertRun(std::unique_ptr<ShapeResult::RunInfo>);
-  void InsertRunForIndex(unsigned start_character_index);
+  void InsertRun(scoped_refptr<ShapeResult::RunInfo>);
   void ReorderRtlRuns(unsigned run_size_before);
 
-  float LineLeftBounds() const;
-  float LineRightBounds() const;
+  template <bool is_horizontal_run, bool has_non_zero_glyph_offsets>
+  void ComputeRunInkBounds(const ShapeResult::RunInfo&,
+                           float run_advance,
+                           FloatRect* ink_bounds) const;
+
+  // Common signatures with ShapeResultView, to templatize algorithms.
+  const Vector<scoped_refptr<RunInfo>>& RunsOrParts() const { return runs_; }
+  unsigned StartIndexOffsetForRun() const { return 0; }
 
   float width_;
-  FloatRect glyph_bounding_box_;
-  Vector<std::unique_ptr<RunInfo>> runs_;
+
+  // Only used by CachingWordShapeIterator and stored here for memory reduction
+  // reasons. See https://crbug.com/955776
+  // TODO(eae): Remove once LayoutNG lands. https://crbug.com/591099
+  mutable FloatRect deprecated_ink_bounds_;
+
+  Vector<scoped_refptr<RunInfo>> runs_;
   scoped_refptr<const SimpleFontData> primary_font_;
   mutable std::unique_ptr<CharacterPositionData> character_position_;
 
+  unsigned start_index_;
   unsigned num_characters_;
-  unsigned num_glyphs_ : 30;
+  unsigned num_glyphs_ : 29;
 
   // Overall direction for the TextRun, dictates which order each individual
   // sub run (represented by RunInfo structs in the m_runs vector) can have a
@@ -327,9 +503,34 @@ class PLATFORM_EXPORT ShapeResult : public RefCounted<ShapeResult> {
   // Tracks whether any runs contain glyphs with a y-offset != 0.
   unsigned has_vertical_offsets_ : 1;
 
+  // True once called |ApplySpacing()|.
+  unsigned is_applied_spacing_ : 1;
+
+  // Note: When you add more bit flags, please consider to reduce size of
+  // |num_glyphs_| or |num_characters_|.
+
+ private:
   friend class HarfBuzzShaper;
   friend class ShapeResultBuffer;
   friend class ShapeResultBloberizer;
+  friend class ShapeResultView;
+  friend class ShapeResultTest;
+  friend class StretchyOperatorShaper;
+
+  template <bool has_non_zero_glyph_offsets>
+  float ForEachGlyphImpl(float initial_advance,
+                         GlyphCallback,
+                         void* context,
+                         const RunInfo& run) const;
+
+  template <bool has_non_zero_glyph_offsets>
+  float ForEachGlyphImpl(float initial_advance,
+                         unsigned from,
+                         unsigned to,
+                         unsigned index_offset,
+                         GlyphCallback,
+                         void* context,
+                         const RunInfo& run) const;
 };
 
 PLATFORM_EXPORT std::ostream& operator<<(std::ostream&, const ShapeResult&);
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer.cc b/third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer.cc
index ab70452701cc..52cde3b6eddc 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer.cc
@@ -8,20 +8,34 @@
 #include "third_party/blink/renderer/platform/fonts/font.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result.h"
-#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h"
 #include "third_party/blink/renderer/platform/fonts/text_run_paint_info.h"
 #include "third_party/blink/renderer/platform/text/text_break_iterator.h"
 #include "third_party/blink/renderer/platform/text/text_run.h"
 
 namespace blink {
 
-ShapeResultBloberizer::ShapeResultBloberizer(const Font& font,
-                                             float device_scale_factor,
-                                             Type type)
-    : font_(font), device_scale_factor_(device_scale_factor), type_(type) {}
+namespace {
+template <typename T, size_t E>
+std::ostream& operator<<(std::ostream& out, const base::span<T, E>& c) {
+#if DCHECK_IS_ON()
+  for (auto&& e : c)
+    out << e << " ";
+#endif
+  return out;
+}
+}  // namespace
+
+ShapeResultBloberizer::ShapeResultBloberizer(
+    const FontDescription& font_description,
+    float device_scale_factor,
+    Type type)
+    : font_description_(font_description),
+      device_scale_factor_(device_scale_factor),
+      type_(type) {}
 
 bool ShapeResultBloberizer::HasPendingVerticalOffsets() const {
-  // We exclusively store either horizontal/x-only ofssets -- in which case
+  // We exclusively store either horizontal/x-only offsets -- in which case
   // m_offsets.size == size, or vertical/xy offsets -- in which case
   // m_offsets.size == size * 2.
   DCHECK(pending_glyphs_.size() == pending_offsets_.size() ||
@@ -29,6 +43,114 @@ bool ShapeResultBloberizer::HasPendingVerticalOffsets() const {
   return pending_glyphs_.size() != pending_offsets_.size();
 }
 
+void ShapeResultBloberizer::SetText(const StringView& text,
+                                    unsigned from,
+                                    unsigned to,
+                                    base::span<const unsigned> cluster_starts) {
+  if (current_text_.IsNull())
+    CommitPendingRun();
+
+  // Any outstanding 'current' state should have been moved to 'pending'.
+  DCHECK(current_character_indexes_.IsEmpty());
+
+  DVLOG(4) << "   SetText from: " << from << " to: " << to;
+
+  // cluster_ends_ must be at least the size of the source run length,
+  // but the run length may be negative (in which case no glyphs will be added).
+  if (from < to) {
+    DVLOG(4) << "   SetText text: "
+             << StringView(text, from, to - from).ToString();
+    cluster_ends_.resize(to - from);
+    for (size_t i = 0; i < cluster_starts.size() - 1; ++i) {
+      cluster_ends_[cluster_starts[i] - from] = cluster_starts[i + 1];
+    }
+  } else {
+    cluster_ends_.Shrink(0);
+  }
+
+  DVLOG(4) << "   Cluster ends: " << base::make_span(cluster_ends_);
+
+  cluster_ends_offset_ = from;
+  current_text_ = text;
+}
+
+void ShapeResultBloberizer::CommitText() {
+  if (current_character_indexes_.IsEmpty())
+    return;
+
+  unsigned from = current_character_indexes_[0];
+  unsigned to = current_character_indexes_[0];
+  for (unsigned character_index : current_character_indexes_) {
+    unsigned character_index_end =
+        cluster_ends_[character_index - cluster_ends_offset_];
+    from = std::min(from, character_index);
+    to = std::max(to, character_index_end);
+  }
+
+  DCHECK(!current_text_.IsNull());
+
+  DVLOG(4) << "   CommitText from: " << from << " to: " << to;
+  DVLOG(4) << "   CommitText glyphs: "
+           << base::make_span(
+                  pending_glyphs_.end() - current_character_indexes_.size(),
+                  pending_glyphs_.end());
+  DVLOG(4) << "   CommitText cluster starts: "
+           << base::make_span(current_character_indexes_);
+
+  size_t pending_utf8_original_size = pending_utf8_.size();
+  size_t pending_utf8_character_indexes_original_size =
+      pending_utf8_character_indexes_.size();
+
+  // Do the UTF-8 conversion here.
+  // For each input code point track the location of output UTF-8 code point.
+
+  unsigned current_text_length = current_text_.length();
+  DCHECK_LE(to, current_text_length);
+
+  unsigned size = to - from;
+  Vector<uint32_t, 256> pending_utf8_character_index_from_character_index(size);
+  if (current_text_.Is8Bit()) {
+    const LChar* latin1 = current_text_.Characters8();
+    wtf_size_t utf8_size = pending_utf8_.size();
+    for (size_t i = from; i < to;) {
+      pending_utf8_character_index_from_character_index[i - from] = utf8_size;
+
+      LChar cp = latin1[i++];
+      pending_utf8_.Grow(utf8_size + U8_LENGTH(cp));
+      U8_APPEND_UNSAFE(pending_utf8_.begin(), utf8_size, cp);
+    }
+  } else {
+    const UChar* utf16 = current_text_.Characters16();
+    wtf_size_t utf8_size = pending_utf8_.size();
+    for (size_t i = from; i < to;) {
+      pending_utf8_character_index_from_character_index[i - from] = utf8_size;
+
+      UChar32 cp;
+      U16_NEXT_OR_FFFD(utf16, i, current_text_length, cp);
+      pending_utf8_.Grow(utf8_size + U8_LENGTH(cp));
+      U8_APPEND_UNSAFE(pending_utf8_.begin(), utf8_size, cp);
+    }
+  }
+
+  for (unsigned character_index : current_character_indexes_) {
+    unsigned index = character_index - from;
+    pending_utf8_character_indexes_.push_back(
+        pending_utf8_character_index_from_character_index[index]);
+  }
+
+  current_character_indexes_.Shrink(0);
+
+  DVLOG(4) << "  CommitText appended UTF-8: \""
+           << std::string(&pending_utf8_[pending_utf8_original_size],
+                          pending_utf8_.end())
+           << "\"";
+  DVLOG(4) << "  CommitText UTF-8 indexes: "
+           << base::make_span(
+                  &pending_utf8_character_indexes_
+                      [pending_utf8_character_indexes_original_size],
+                  pending_utf8_character_indexes_.end());
+}
+
 void ShapeResultBloberizer::CommitPendingRun() {
   if (pending_glyphs_.IsEmpty())
     return;
@@ -40,20 +162,47 @@ void ShapeResultBloberizer::CommitPendingRun() {
     builder_rotation_ = pending_canvas_rotation_;
   }
 
-  PaintFont run_font;
-  run_font.SetTextEncoding(SkPaint::kGlyphID_TextEncoding);
-  pending_font_data_->PlatformData().SetupPaintFont(
-      &run_font, device_scale_factor_, &font_);
+  CommitText();
+
+  SkFont run_font;
+  pending_font_data_->PlatformData().SetupSkFont(
+      &run_font, device_scale_factor_, &font_description_);
 
   const auto run_size = pending_glyphs_.size();
-  const auto& buffer = HasPendingVerticalOffsets()
-                           ? builder_.AllocRunPos(run_font, run_size)
-                           : builder_.AllocRunPosH(run_font, run_size, 0);
+  const auto text_size = pending_utf8_.size();
+  const auto& buffer = [&]() {
+    if (HasPendingVerticalOffsets()) {
+      if (text_size)
+        return builder_.allocRunTextPos(run_font, run_size, text_size);
+      else
+        return builder_.allocRunPos(run_font, run_size);
+    } else {
+      if (text_size)
+        return builder_.allocRunTextPosH(run_font, run_size, 0, text_size);
+      else
+        return builder_.allocRunPosH(run_font, run_size, 0);
+    }
+  }();
+  builder_run_count_ += 1;
+
+  if (text_size) {
+    DVLOG(4) << "  CommitPendingRun text: \""
+             << std::string(pending_utf8_.begin(), pending_utf8_.end()) << "\"";
+    DVLOG(4) << "  CommitPendingRun glyphs: "
+             << base::make_span(pending_glyphs_);
+    DVLOG(4) << "  CommitPendingRun indexes: "
+             << base::make_span(pending_utf8_character_indexes_);
+    DCHECK_EQ(pending_utf8_character_indexes_.size(), run_size);
+    std::copy(pending_utf8_character_indexes_.begin(),
+              pending_utf8_character_indexes_.end(), buffer.clusters);
+    std::copy(pending_utf8_.begin(), pending_utf8_.end(), buffer.utf8text);
+
+    pending_utf8_.Shrink(0);
+    pending_utf8_character_indexes_.Shrink(0);
+  }
 
   std::copy(pending_glyphs_.begin(), pending_glyphs_.end(), buffer.glyphs);
   std::copy(pending_offsets_.begin(), pending_offsets_.end(), buffer.pos);
-
-  builder_run_count_ += 1;
   pending_glyphs_.Shrink(0);
   pending_offsets_.Shrink(0);
 }
@@ -62,7 +211,7 @@ void ShapeResultBloberizer::CommitPendingBlob() {
   if (!builder_run_count_)
     return;
 
-  blobs_.emplace_back(builder_.TakeTextBlob(), builder_rotation_);
+  blobs_.emplace_back(builder_.make(), builder_rotation_);
   builder_run_count_ = 0;
 }
 
@@ -75,14 +224,326 @@ const ShapeResultBloberizer::BlobBuffer& ShapeResultBloberizer::Blobs() {
   return blobs_;
 }
 
-float ShapeResultBloberizer::FillGlyphs(
+inline bool ShapeResultBloberizer::IsSkipInkException(
+    const StringView& text,
+    unsigned character_index) {
+  // We want to skip descenders in general, but it is undesirable renderings for
+  // CJK characters.
+  return type_ == ShapeResultBloberizer::Type::kTextIntercepts &&
+         !Character::CanTextDecorationSkipInk(
+             text.CodepointAt(character_index));
+}
+
+inline void ShapeResultBloberizer::AddEmphasisMark(
+    const GlyphData& emphasis_data,
+    CanvasRotationInVertical canvas_rotation,
+    FloatPoint glyph_center,
+    float mid_glyph_offset) {
+  const SimpleFontData* emphasis_font_data = emphasis_data.font_data;
+  DCHECK(emphasis_font_data);
+
+  bool is_vertical =
+      emphasis_font_data->PlatformData().IsVerticalAnyUpright() &&
+      IsCanvasRotationInVerticalUpright(emphasis_data.canvas_rotation);
+
+  if (!is_vertical) {
+    Add(emphasis_data.glyph, emphasis_font_data,
+        CanvasRotationInVertical::kRegular, mid_glyph_offset - glyph_center.X(),
+        0);
+  } else {
+    Add(emphasis_data.glyph, emphasis_font_data, emphasis_data.canvas_rotation,
+        FloatPoint(-glyph_center.X(), mid_glyph_offset - glyph_center.Y()), 0);
+  }
+}
+
+namespace {
+class GlyphCallbackContext {
+  STACK_ALLOCATED();
+
+ public:
+  ShapeResultBloberizer* bloberizer;
+  const StringView& text;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(GlyphCallbackContext);
+};
+}  // namespace
+
+/*static*/ void ShapeResultBloberizer::AddGlyphToBloberizer(
+    void* context,
+    unsigned character_index,
+    Glyph glyph,
+    FloatSize glyph_offset,
+    float advance,
+    bool is_horizontal,
+    CanvasRotationInVertical rotation,
+    const SimpleFontData* font_data) {
+  GlyphCallbackContext* parsed_context =
+      static_cast<GlyphCallbackContext*>(context);
+  ShapeResultBloberizer* bloberizer = parsed_context->bloberizer;
+  const StringView& text = parsed_context->text;
+
+  if (bloberizer->IsSkipInkException(text, character_index))
+    return;
+  FloatPoint start_offset =
+      is_horizontal ? FloatPoint(advance, 0) : FloatPoint(0, advance);
+  bloberizer->Add(glyph, font_data, rotation, start_offset + glyph_offset,
+                  character_index);
+}
+
+/*static*/ void ShapeResultBloberizer::AddFastHorizontalGlyphToBloberizer(
+    void* context,
+    unsigned character_index,
+    Glyph glyph,
+    FloatSize glyph_offset,
+    float advance,
+    bool is_horizontal,
+    CanvasRotationInVertical canvas_rotation,
+    const SimpleFontData* font_data) {
+  ShapeResultBloberizer* bloberizer =
+      static_cast<ShapeResultBloberizer*>(context);
+  DCHECK(!glyph_offset.Height());
+  DCHECK(is_horizontal);
+  bloberizer->Add(glyph, font_data, canvas_rotation,
+                  advance + glyph_offset.Width(), character_index);
+}
+
+float ShapeResultBloberizer::FillGlyphsForResult(const ShapeResult* result,
+                                                 const StringView& text,
+                                                 unsigned from,
+                                                 unsigned to,
+                                                 float initial_advance,
+                                                 unsigned run_offset) {
+  GlyphCallbackContext context = {this, text};
+  return result->ForEachGlyph(initial_advance, from, to, run_offset,
+                              AddGlyphToBloberizer,
+                              static_cast<void*>(&context));
+}
+
+namespace {
+class ClusterCallbackContext {
+  STACK_ALLOCATED();
+
+ public:
+  ShapeResultBloberizer* bloberizer;
+  const StringView& text;
+  const GlyphData& emphasis_data;
+  FloatPoint glyph_center;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ClusterCallbackContext);
+};
+}  // namespace
+
+/*static*/ void ShapeResultBloberizer::AddEmphasisMarkToBloberizer(
+    void* context,
+    unsigned character_index,
+    float advance_so_far,
+    unsigned graphemes_in_cluster,
+    float cluster_advance,
+    CanvasRotationInVertical canvas_rotation) {
+  ClusterCallbackContext* parsed_context =
+      static_cast<ClusterCallbackContext*>(context);
+  ShapeResultBloberizer* bloberizer = parsed_context->bloberizer;
+  const StringView& text = parsed_context->text;
+  const GlyphData& emphasis_data = parsed_context->emphasis_data;
+  FloatPoint glyph_center = parsed_context->glyph_center;
+
+  if (text.Is8Bit()) {
+    if (Character::CanReceiveTextEmphasis(text[character_index])) {
+      bloberizer->AddEmphasisMark(emphasis_data, canvas_rotation, glyph_center,
+                                  advance_so_far + cluster_advance / 2);
+    }
+  } else {
+    float glyph_advance_x = cluster_advance / graphemes_in_cluster;
+    for (unsigned j = 0; j < graphemes_in_cluster; ++j) {
+      // Do not put emphasis marks on space, separator, and control
+      // characters.
+      if (Character::CanReceiveTextEmphasis(text[character_index])) {
+        bloberizer->AddEmphasisMark(emphasis_data, canvas_rotation,
+                                    glyph_center,
+                                    advance_so_far + glyph_advance_x / 2);
+      }
+      advance_so_far += glyph_advance_x;
+    }
+  }
+}
+
+namespace {
+class ClusterStarts {
+  STACK_ALLOCATED();
+
+ public:
+  ClusterStarts() = default;
+
+  static void Accumulate(void* context,
+                         unsigned character_index,
+                         Glyph,
+                         FloatSize,
+                         float,
+                         bool,
+                         CanvasRotationInVertical,
+                         const SimpleFontData*) {
+    ClusterStarts* self = static_cast<ClusterStarts*>(context);
+
+    if (self->cluster_starts_.IsEmpty() ||
+        self->last_seen_character_index_ != character_index) {
+      self->cluster_starts_.push_back(character_index);
+      self->last_seen_character_index_ = character_index;
+    }
+  }
+
+  void Finish(unsigned from, unsigned to) {
+    std::sort(cluster_starts_.begin(), cluster_starts_.end());
+    DCHECK_EQ(
+        std::adjacent_find(cluster_starts_.begin(), cluster_starts_.end()),
+        cluster_starts_.end());
+    DVLOG(4) << "  Cluster starts: " << base::make_span(cluster_starts_);
+    if (!cluster_starts_.IsEmpty()) {
+      // 'from' may point inside a cluster; the least seen index may be larger.
+      DCHECK_LE(from, *cluster_starts_.begin());
+      DCHECK_LT(*(cluster_starts_.end() - 1), to);
+    }
+    cluster_starts_.push_back(to);
+  }
+
+  base::span<const unsigned> Data() { return cluster_starts_; }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ClusterStarts);
+
+  Vector<unsigned, 256> cluster_starts_;
+  unsigned last_seen_character_index_ = 0;
+};
+}  // namespace
+
+ShapeResultBloberizer::FillGlyphs::FillGlyphs(
+    const FontDescription& font_description,
+    float device_scale_factor,
     const TextRunPaintInfo& run_info,
-    const ShapeResultBuffer& result_buffer) {
+    const ShapeResultBuffer& result_buffer,
+    const Type type)
+    : ShapeResultBloberizer(font_description, device_scale_factor, type) {
   if (CanUseFastPath(run_info.from, run_info.to, run_info.run.length(),
                      result_buffer.HasVerticalOffsets())) {
-    return FillFastHorizontalGlyphs(result_buffer, run_info.run.Direction());
+    DVLOG(4) << "FillGlyphs fast path";
+    DCHECK(!result_buffer.HasVerticalOffsets());
+    DCHECK_NE(type_, ShapeResultBloberizer::Type::kTextIntercepts);
+    DCHECK_NE(type_, ShapeResultBloberizer::Type::kEmitText);
+    advance_ =
+        FillFastHorizontalGlyphs(result_buffer, run_info.run.Direction());
+    return;
   }
 
+  DVLOG(4) << "FillGlyphs slow path";
+
+  float advance = 0;
+  auto results = result_buffer.results_;
+
+  if (type_ == Type::kEmitText) {
+    unsigned word_offset = 0;
+    ClusterStarts cluster_starts;
+    for (const auto& word_result : results) {
+      word_result->ForEachGlyph(advance, run_info.from, run_info.to,
+                                word_offset, ClusterStarts::Accumulate,
+                                static_cast<void*>(&cluster_starts));
+      word_offset += word_result->NumCharacters();
+    }
+    cluster_starts.Finish(run_info.from, run_info.to);
+    SetText(run_info.run.ToStringView(), run_info.from, run_info.to,
+            cluster_starts.Data());
+  }
+
+  if (run_info.run.Rtl()) {
+    unsigned word_offset = run_info.run.length();
+    for (unsigned j = 0; j < results.size(); j++) {
+      unsigned resolved_index = results.size() - 1 - j;
+      const scoped_refptr<const ShapeResult>& word_result =
+          results[resolved_index];
+      unsigned word_characters = word_result->NumCharacters();
+      word_offset -= word_characters;
+      DVLOG(4) << " FillGlyphs RTL run from: " << run_info.from
+               << " to: " << run_info.to << " offset: " << word_offset
+               << " length: " << word_characters;
+      advance =
+          FillGlyphsForResult(word_result.get(), run_info.run.ToStringView(),
+                              run_info.from, run_info.to, advance, word_offset);
+    }
+  } else {
+    unsigned word_offset = 0;
+    for (const auto& word_result : results) {
+      unsigned word_characters = word_result->NumCharacters();
+      DVLOG(4) << " FillGlyphs LTR run from: " << run_info.from
+               << " to: " << run_info.to << " offset: " << word_offset
+               << " length: " << word_characters;
+      advance =
+          FillGlyphsForResult(word_result.get(), run_info.run.ToStringView(),
+                              run_info.from, run_info.to, advance, word_offset);
+      word_offset += word_characters;
+    }
+  }
+
+  if (type_ == Type::kEmitText)
+    CommitText();
+
+  advance_ = advance;
+}
+
+ShapeResultBloberizer::FillGlyphsNG::FillGlyphsNG(
+    const FontDescription& font_description,
+    float device_scale_factor,
+    const StringView& text,
+    unsigned from,
+    unsigned to,
+    const ShapeResultView* result,
+    const Type type)
+    : ShapeResultBloberizer(font_description, device_scale_factor, type) {
+  DCHECK(result);
+  DCHECK(to <= text.length());
+  float initial_advance = 0;
+  if (CanUseFastPath(from, to, result)) {
+    DVLOG(4) << "FillGlyphsNG fast path";
+    DCHECK(!result->HasVerticalOffsets());
+    DCHECK_NE(type_, ShapeResultBloberizer::Type::kTextIntercepts);
+    DCHECK_NE(type_, ShapeResultBloberizer::Type::kEmitText);
+    advance_ = result->ForEachGlyph(initial_advance,
+                                    &AddFastHorizontalGlyphToBloberizer,
+                                    static_cast<void*>(this));
+    return;
+  }
+
+  DVLOG(4) << "FillGlyphsNG slow path";
+  unsigned run_offset = 0;
+  if (type_ == Type::kEmitText) {
+    ClusterStarts cluster_starts;
+    result->ForEachGlyph(initial_advance, from, to, run_offset,
+                         ClusterStarts::Accumulate,
+                         static_cast<void*>(&cluster_starts));
+    cluster_starts.Finish(from, to);
+    SetText(text, from, to, cluster_starts.Data());
+  }
+
+  GlyphCallbackContext context = {this, text};
+  advance_ =
+      result->ForEachGlyph(initial_advance, from, to, run_offset,
+                           AddGlyphToBloberizer, static_cast<void*>(&context));
+
+  if (type_ == Type::kEmitText)
+    CommitText();
+}
+
+ShapeResultBloberizer::FillTextEmphasisGlyphs::FillTextEmphasisGlyphs(
+    const FontDescription& font_description,
+    float device_scale_factor,
+    const TextRunPaintInfo& run_info,
+    const ShapeResultBuffer& result_buffer,
+    const GlyphData& emphasis)
+    : ShapeResultBloberizer(font_description,
+                            device_scale_factor,
+                            Type::kNormal) {
+  FloatPoint glyph_center =
+      emphasis.font_data->BoundsForGlyph(emphasis.glyph).Center();
+
   float advance = 0;
   auto results = result_buffer.results_;
 
@@ -90,182 +551,49 @@ float ShapeResultBloberizer::FillGlyphs(
     unsigned word_offset = run_info.run.length();
     for (unsigned j = 0; j < results.size(); j++) {
       unsigned resolved_index = results.size() - 1 - j;
-      const scoped_refptr<const ShapeResult>& word_result = results[resolved_index];
+      const scoped_refptr<const ShapeResult>& word_result =
+          results[resolved_index];
       word_offset -= word_result->NumCharacters();
-      advance =
-          FillGlyphsForResult(word_result.get(), run_info.run, run_info.from,
-                              run_info.to, advance, word_offset);
+      StringView text = run_info.run.ToStringView();
+      ClusterCallbackContext context = {this, text, emphasis, glyph_center};
+      advance = word_result->ForEachGraphemeClusters(
+          text, advance, run_info.from, run_info.to, word_offset,
+          AddEmphasisMarkToBloberizer, static_cast<void*>(&context));
     }
-  } else {
+  } else {  // Left-to-right.
     unsigned word_offset = 0;
     for (const auto& word_result : results) {
-      advance =
-          FillGlyphsForResult(word_result.get(), run_info.run, run_info.from,
-                              run_info.to, advance, word_offset);
+      StringView text = run_info.run.ToStringView();
+      ClusterCallbackContext context = {this, text, emphasis, glyph_center};
+      advance = word_result->ForEachGraphemeClusters(
+          text, advance, run_info.from, run_info.to, word_offset,
+          AddEmphasisMarkToBloberizer, static_cast<void*>(&context));
       word_offset += word_result->NumCharacters();
     }
   }
 
-  return advance;
+  advance_ = advance;
 }
 
-float ShapeResultBloberizer::FillGlyphs(const StringView& text,
-                                        unsigned from,
-                                        unsigned to,
-                                        const ShapeResult* result) {
-  DCHECK(result);
-  DCHECK(to <= text.length());
-  if (CanUseFastPath(from, to, result))
-    return FillFastHorizontalGlyphs(result);
-
-  float advance = 0;
-  float word_offset = 0;
-  return FillGlyphsForResult(result, text, from, to, advance, word_offset);
-}
-
-void ShapeResultBloberizer::FillTextEmphasisGlyphs(
-    const TextRunPaintInfo& run_info,
-    const GlyphData& emphasis_data,
-    const ShapeResultBuffer& result_buffer) {
-  float advance = 0;
-  unsigned word_offset = run_info.run.Rtl() ? run_info.run.length() : 0;
-  auto results = result_buffer.results_;
-
-  for (unsigned j = 0; j < results.size(); j++) {
-    unsigned resolved_index = run_info.run.Rtl() ? results.size() - 1 - j : j;
-    const scoped_refptr<const ShapeResult>& word_result = results[resolved_index];
-    for (unsigned i = 0; i < word_result->runs_.size(); i++) {
-      unsigned resolved_offset =
-          word_offset - (run_info.run.Rtl() ? word_result->NumCharacters() : 0);
-      advance += FillTextEmphasisGlyphsForRun(
-          word_result->runs_[i].get(), run_info.run,
-          run_info.run.CharactersLength(), run_info.run.Direction(),
-          run_info.from, run_info.to, emphasis_data, advance, resolved_offset);
-    }
-    word_offset += word_result->NumCharacters() * (run_info.run.Rtl() ? -1 : 1);
-  }
-}
-
-void ShapeResultBloberizer::FillTextEmphasisGlyphs(const StringView& text,
-                                                   TextDirection direction,
-                                                   unsigned from,
-                                                   unsigned to,
-                                                   const GlyphData& emphasis,
-                                                   const ShapeResult* result) {
-  float advance = 0;
-  unsigned offset = 0;
-
-  for (unsigned i = 0; i < result->runs_.size(); i++) {
-    advance += FillTextEmphasisGlyphsForRun(result->runs_[i].get(), text,
-                                            text.length(), direction, from, to,
-                                            emphasis, advance, offset);
-  }
-}
-
-namespace {
-
-template <typename TextContainerType>
-inline bool IsSkipInkException(const ShapeResultBloberizer& bloberizer,
-                               const TextContainerType& text,
-                               unsigned character_index) {
-  // We want to skip descenders in general, but it is undesirable renderings for
-  // CJK characters.
-  return bloberizer.GetType() == ShapeResultBloberizer::Type::kTextIntercepts &&
-         !Character::CanTextDecorationSkipInk(
-             text.CodepointAt(character_index));
-}
-
-template <typename TextContainerType>
-inline void AddGlyphToBloberizer(ShapeResultBloberizer& bloberizer,
-                                 float advance,
-                                 hb_direction_t direction,
-                                 CanvasRotationInVertical canvas_rotation,
-                                 const SimpleFontData* font_data,
-                                 const HarfBuzzRunGlyphData& glyph_data,
-                                 const TextContainerType& text,
-                                 unsigned character_index) {
-  FloatPoint start_offset = HB_DIRECTION_IS_HORIZONTAL(direction)
-                                ? FloatPoint(advance, 0)
-                                : FloatPoint(0, advance);
-  if (!IsSkipInkException(bloberizer, text, character_index)) {
-    bloberizer.Add(glyph_data.glyph, font_data, canvas_rotation,
-                   start_offset + glyph_data.offset);
-  }
-}
-
-inline void AddEmphasisMark(ShapeResultBloberizer& bloberizer,
-                            const GlyphData& emphasis_data,
-                            CanvasRotationInVertical canvas_rotation,
-                            FloatPoint glyph_center,
-                            float mid_glyph_offset) {
-  const SimpleFontData* emphasis_font_data = emphasis_data.font_data;
-  DCHECK(emphasis_font_data);
-
-  bool is_vertical =
-      emphasis_font_data->PlatformData().IsVerticalAnyUpright() &&
-      emphasis_data.canvas_rotation ==
-          CanvasRotationInVertical::kRotateCanvasUpright;
-
-  if (!is_vertical) {
-    bloberizer.Add(emphasis_data.glyph, emphasis_font_data,
-                   CanvasRotationInVertical::kRegular,
-                   mid_glyph_offset - glyph_center.X());
-  } else {
-    bloberizer.Add(
-        emphasis_data.glyph, emphasis_font_data,
-        CanvasRotationInVertical::kRotateCanvasUpright,
-        FloatPoint(-glyph_center.X(), mid_glyph_offset - glyph_center.Y()));
-  }
-}
-
-inline unsigned CountGraphemesInCluster(const UChar* str,
-                                        unsigned str_length,
-                                        uint16_t start_index,
-                                        uint16_t end_index) {
-  if (start_index > end_index) {
-    uint16_t temp_index = start_index;
-    start_index = end_index;
-    end_index = temp_index;
-  }
-  uint16_t length = end_index - start_index;
-  DCHECK_LE(static_cast<unsigned>(start_index + length), str_length);
-  TextBreakIterator* cursor_pos_iterator =
-      CursorMovementIterator(&str[start_index], length);
-
-  int cursor_pos = cursor_pos_iterator->current();
-  int num_graphemes = -1;
-  while (0 <= cursor_pos) {
-    cursor_pos = cursor_pos_iterator->next();
-    num_graphemes++;
-  }
-  return std::max(0, num_graphemes);
-}
-
-}  // namespace
-
-template <typename TextContainerType>
-float ShapeResultBloberizer::FillGlyphsForResult(const ShapeResult* result,
-                                                 const TextContainerType& text,
-                                                 unsigned from,
-                                                 unsigned to,
-                                                 float initial_advance,
-                                                 unsigned run_offset) {
-  auto total_advance = initial_advance;
-
-  for (const auto& run : result->runs_) {
-    total_advance = run->ForEachGlyphInRange(
-        total_advance, from, to, run_offset,
-        [&](const HarfBuzzRunGlyphData& glyph_data, float total_advance,
-            uint16_t character_index) -> bool {
-
-          AddGlyphToBloberizer(*this, total_advance, run->direction_,
-                               run->canvas_rotation_, run->font_data_.get(),
-                               glyph_data, text, character_index);
-          return true;
-        });
-  }
-
-  return total_advance;
+ShapeResultBloberizer::FillTextEmphasisGlyphsNG::FillTextEmphasisGlyphsNG(
+    const FontDescription& font_description,
+    float device_scale_factor,
+    const StringView& text,
+    unsigned from,
+    unsigned to,
+    const ShapeResultView* result,
+    const GlyphData& emphasis)
+    : ShapeResultBloberizer(font_description,
+                            device_scale_factor,
+                            Type::kNormal) {
+  FloatPoint glyph_center =
+      emphasis.font_data->BoundsForGlyph(emphasis.glyph).Center();
+  ClusterCallbackContext context = {this, text, emphasis, glyph_center};
+  float initial_advance = 0;
+  unsigned index_offset = 0;
+  advance_ = result->ForEachGraphemeClusters(
+      text, initial_advance, from, to, index_offset,
+      AddEmphasisMarkToBloberizer, static_cast<void*>(&context));
 }
 
 bool ShapeResultBloberizer::CanUseFastPath(unsigned from,
@@ -273,23 +601,25 @@ bool ShapeResultBloberizer::CanUseFastPath(unsigned from,
                                            unsigned length,
                                            bool has_vertical_offsets) {
   return !from && to == length && !has_vertical_offsets &&
-         GetType() != ShapeResultBloberizer::Type::kTextIntercepts;
+         type_ != ShapeResultBloberizer::Type::kTextIntercepts &&
+         type_ != ShapeResultBloberizer::Type::kEmitText;
 }
 
-bool ShapeResultBloberizer::CanUseFastPath(unsigned from,
-                                           unsigned to,
-                                           const ShapeResult* shape_result) {
-  return from <= shape_result->StartIndexForResult() &&
-         to >= shape_result->EndIndexForResult() &&
+bool ShapeResultBloberizer::CanUseFastPath(
+    unsigned from,
+    unsigned to,
+    const ShapeResultView* shape_result) {
+  return from <= shape_result->StartIndex() && to >= shape_result->EndIndex() &&
          !shape_result->HasVerticalOffsets() &&
-         GetType() != ShapeResultBloberizer::Type::kTextIntercepts;
+         type_ != ShapeResultBloberizer::Type::kTextIntercepts &&
+         type_ != ShapeResultBloberizer::Type::kEmitText;
 }
 
 float ShapeResultBloberizer::FillFastHorizontalGlyphs(
     const ShapeResultBuffer& result_buffer,
     TextDirection text_direction) {
   DCHECK(!result_buffer.HasVerticalOffsets());
-  DCHECK_NE(GetType(), ShapeResultBloberizer::Type::kTextIntercepts);
+  DCHECK_NE(type_, ShapeResultBloberizer::Type::kTextIntercepts);
 
   float advance = 0;
   auto results = result_buffer.results_;
@@ -303,119 +633,14 @@ float ShapeResultBloberizer::FillFastHorizontalGlyphs(
   return advance;
 }
 
-float ShapeResultBloberizer::FillFastHorizontalGlyphs(
-    const ShapeResult* shape_result,
-    float advance) {
-  DCHECK(!shape_result->HasVerticalOffsets());
-  DCHECK_NE(GetType(), ShapeResultBloberizer::Type::kTextIntercepts);
+float ShapeResultBloberizer::FillFastHorizontalGlyphs(const ShapeResult* result,
+                                                      float initial_advance) {
+  DCHECK(!result->HasVerticalOffsets());
+  DCHECK_NE(type_, ShapeResultBloberizer::Type::kTextIntercepts);
 
-  for (const auto& run : shape_result->runs_) {
-    DCHECK(run);
-    DCHECK(HB_DIRECTION_IS_HORIZONTAL(run->direction_));
-
-    advance =
-        run->ForEachGlyph(advance,
-                          [&](const HarfBuzzRunGlyphData& glyph_data,
-                              float total_advance) -> bool {
-                            DCHECK(!glyph_data.offset.Height());
-                            Add(glyph_data.glyph, run->font_data_.get(),
-                                run->CanvasRotation(),
-                                total_advance + glyph_data.offset.Width());
-                            return true;
-                          });
-  }
-
-  return advance;
-}
-
-template <typename TextContainerType>
-float ShapeResultBloberizer::FillTextEmphasisGlyphsForRun(
-    const ShapeResult::RunInfo* run,
-    const TextContainerType& text,
-    unsigned text_length,
-    TextDirection direction,
-    unsigned from,
-    unsigned to,
-    const GlyphData& emphasis_data,
-    float initial_advance,
-    unsigned run_offset) {
-  if (!run)
-    return 0;
-
-  unsigned graphemes_in_cluster = 1;
-  float cluster_advance = 0;
-
-  FloatPoint glyph_center =
-      emphasis_data.font_data->BoundsForGlyph(emphasis_data.glyph).Center();
-
-  // A "cluster" in this context means a cluster as it is used by HarfBuzz:
-  // The minimal group of characters and corresponding glyphs, that cannot be
-  // broken down further from a text shaping point of view.  A cluster can
-  // contain multiple glyphs and grapheme clusters, with mutually overlapping
-  // boundaries. Below we count grapheme clusters per HarfBuzz clusters, then
-  // linearly split the sum of corresponding glyph advances by the number of
-  // grapheme clusters in order to find positions for emphasis mark drawing.
-  uint16_t cluster_start = static_cast<uint16_t>(
-      direction == TextDirection::kRtl
-          ? run->start_index_ + run->num_characters_ + run_offset
-          : run->GlyphToCharacterIndex(0) + run_offset);
-
-  float advance_so_far = initial_advance;
-  const unsigned num_glyphs = run->glyph_data_.size();
-  for (unsigned i = 0; i < num_glyphs; ++i) {
-    const HarfBuzzRunGlyphData& glyph_data = run->glyph_data_[i];
-    uint16_t current_character_index =
-        run->start_index_ + glyph_data.character_index + run_offset;
-    bool is_run_end = (i + 1 == num_glyphs);
-    bool is_cluster_end =
-        is_run_end || (run->GlyphToCharacterIndex(i + 1) + run_offset !=
-                       current_character_index);
-
-    if ((direction == TextDirection::kRtl && current_character_index >= to) ||
-        (direction != TextDirection::kRtl && current_character_index < from)) {
-      advance_so_far += glyph_data.advance;
-      direction == TextDirection::kRtl ? --cluster_start : ++cluster_start;
-      continue;
-    }
-
-    cluster_advance += glyph_data.advance;
-
-    if (text.Is8Bit()) {
-      float glyph_advance_x = glyph_data.advance;
-      if (Character::CanReceiveTextEmphasis(text[current_character_index])) {
-        AddEmphasisMark(*this, emphasis_data, run->CanvasRotation(),
-                        glyph_center, advance_so_far + glyph_advance_x / 2);
-      }
-      advance_so_far += glyph_advance_x;
-    } else if (is_cluster_end) {
-      uint16_t cluster_end;
-      if (direction == TextDirection::kRtl) {
-        cluster_end = current_character_index;
-      } else {
-        cluster_end = static_cast<uint16_t>(
-            is_run_end ? run->start_index_ + run->num_characters_ + run_offset
-                       : run->GlyphToCharacterIndex(i + 1) + run_offset);
-      }
-      graphemes_in_cluster = CountGraphemesInCluster(
-          text.Characters16(), text_length, cluster_start, cluster_end);
-      if (!graphemes_in_cluster || !cluster_advance)
-        continue;
-
-      float glyph_advance_x = cluster_advance / graphemes_in_cluster;
-      for (unsigned j = 0; j < graphemes_in_cluster; ++j) {
-        // Do not put emphasis marks on space, separator, and control
-        // characters.
-        if (Character::CanReceiveTextEmphasis(text[current_character_index])) {
-          AddEmphasisMark(*this, emphasis_data, run->CanvasRotation(),
-                          glyph_center, advance_so_far + glyph_advance_x / 2);
-        }
-        advance_so_far += glyph_advance_x;
-      }
-      cluster_start = cluster_end;
-      cluster_advance = 0;
-    }
-  }
-  return advance_so_far - initial_advance;
+  return result->ForEachGlyph(initial_advance,
+                              &AddFastHorizontalGlyphToBloberizer,
+                              static_cast<void*>(this));
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer.h b/third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer.h
index a3204c4739d8..ece3bf49c4bf 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer.h
@@ -10,50 +10,51 @@
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_buffer.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
 #include "third_party/blink/renderer/platform/geometry/float_point.h"
-#include "third_party/blink/renderer/platform/graphics/paint/paint_text_blob.h"
-#include "third_party/blink/renderer/platform/graphics/paint/paint_typeface.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 #include "third_party/skia/include/core/SkTextBlob.h"
 
 namespace blink {
 
-class Font;
+class FontDescription;
 struct TextRunPaintInfo;
 
 class PLATFORM_EXPORT ShapeResultBloberizer {
-  WTF_MAKE_NONCOPYABLE(ShapeResultBloberizer);
   STACK_ALLOCATED();
 
  public:
-  enum class Type { kNormal, kTextIntercepts };
+  enum class Type { kNormal, kTextIntercepts, kEmitText };
 
-  ShapeResultBloberizer(const Font&,
+  struct FillGlyphsNG;
+  struct FillTextEmphasisGlyphsNG;
+
+  struct FillGlyphs;
+  struct FillTextEmphasisGlyphs;
+
+  ShapeResultBloberizer(const FontDescription&,
                         float device_scale_factor,
-                        Type = Type::kNormal);
+                        Type);
 
-  Type GetType() const { return type_; }
+  struct BlobInfo {
+    BlobInfo(sk_sp<SkTextBlob> b, CanvasRotationInVertical r)
+        : blob(std::move(b)), rotation(r) {}
+    sk_sp<SkTextBlob> blob;
+    CanvasRotationInVertical rotation;
+  };
+  using BlobBuffer = Vector<BlobInfo, 16>;
 
-  float FillGlyphs(const TextRunPaintInfo&, const ShapeResultBuffer&);
-  float FillGlyphs(const StringView&,
-                   unsigned from,
-                   unsigned to,
-                   const ShapeResult*);
-  void FillTextEmphasisGlyphs(const TextRunPaintInfo&,
-                              const GlyphData& emphasis_data,
-                              const ShapeResultBuffer&);
-  void FillTextEmphasisGlyphs(const StringView&,
-                              TextDirection,
-                              unsigned from,
-                              unsigned to,
-                              const GlyphData& emphasis_data,
-                              const ShapeResult*);
+  const BlobBuffer& Blobs();
+  float Advance() const { return advance_; }
+
+ private:
+  friend class ShapeResultBloberizerTestInfo;
 
   void Add(Glyph glyph,
            const SimpleFontData* font_data,
            CanvasRotationInVertical canvas_rotation,
-           float h_offset) {
+           float h_offset,
+           unsigned character_index) {
     // cannot mix x-only/xy offsets
     DCHECK(!HasPendingVerticalOffsets());
 
@@ -62,17 +63,24 @@ class PLATFORM_EXPORT ShapeResultBloberizer {
       CommitPendingRun();
       pending_font_data_ = font_data;
       pending_canvas_rotation_ = canvas_rotation;
-      DCHECK_EQ(canvas_rotation, CanvasRotationInVertical::kRegular);
+      DCHECK(!IsCanvasRotationInVerticalUpright(canvas_rotation))
+          << static_cast<int>(canvas_rotation);
     }
 
     pending_glyphs_.push_back(glyph);
     pending_offsets_.push_back(h_offset);
+    if (!current_text_.IsNull()) {
+      DVLOG(5) << "  Appending glyph " << glyph << " with start index "
+               << character_index;
+      current_character_indexes_.push_back(character_index);
+    }
   }
 
   void Add(Glyph glyph,
            const SimpleFontData* font_data,
            CanvasRotationInVertical canvas_rotation,
-           const FloatPoint& offset) {
+           const FloatPoint& offset,
+           unsigned character_index) {
     // cannot mix x-only/xy offsets
     DCHECK(pending_glyphs_.IsEmpty() || HasPendingVerticalOffsets());
 
@@ -82,7 +90,7 @@ class PLATFORM_EXPORT ShapeResultBloberizer {
       pending_font_data_ = font_data;
       pending_canvas_rotation_ = canvas_rotation;
       pending_vertical_baseline_x_offset_ =
-          canvas_rotation == CanvasRotationInVertical::kRegular
+          !IsCanvasRotationInVerticalUpright(canvas_rotation)
               ? 0
               : font_data->GetFontMetrics().FloatAscent() -
                     font_data->GetFontMetrics().FloatAscent(
@@ -93,63 +101,77 @@ class PLATFORM_EXPORT ShapeResultBloberizer {
     pending_offsets_.push_back(offset.X() +
                                pending_vertical_baseline_x_offset_);
     pending_offsets_.push_back(offset.Y());
+    if (!current_text_.IsNull()) {
+      DVLOG(5) << "  Appending glyph " << glyph << " with start index "
+               << character_index;
+      current_character_indexes_.push_back(character_index);
+    }
   }
 
-  struct BlobInfo {
-    BlobInfo(scoped_refptr<PaintTextBlob> b, CanvasRotationInVertical r)
-        : blob(std::move(b)), rotation(r) {}
-    scoped_refptr<PaintTextBlob> blob;
-    CanvasRotationInVertical rotation;
-  };
-
-  using BlobBuffer = Vector<BlobInfo, 16>;
-  const BlobBuffer& Blobs();
-
- private:
-  friend class ShapeResultBloberizerTestInfo;
-
-  // Where TextContainerType can be either a TextRun or a StringView.
-  // For legacy layout and LayoutNG respectively.
-  template <typename TextContainerType>
-  float FillGlyphsForResult(const ShapeResult*,
-                            const TextContainerType&,
-                            unsigned from,
-                            unsigned to,
-                            float initial_advance,
-                            unsigned run_offset);
-
-  // Whether the FillFastHorizontalGlyphs can be used. Only applies for full
-  // runs with no vertical offsets and no text intercepts.
+  // Whether the FillFastHorizontalGlyphs or AddFastHorizontalGlyphToBloberizer
+  // can be used. Only applies for full runs with no vertical offsets, no text
+  // intercepts, and not emitting text.
   bool CanUseFastPath(unsigned from,
                       unsigned to,
                       unsigned length,
                       bool has_vertical_offsets);
-  bool CanUseFastPath(unsigned from, unsigned to, const ShapeResult*);
+  bool CanUseFastPath(unsigned from, unsigned to, const ShapeResultView*);
   float FillFastHorizontalGlyphs(const ShapeResultBuffer&, TextDirection);
   float FillFastHorizontalGlyphs(const ShapeResult*, float advance = 0);
+  static void AddFastHorizontalGlyphToBloberizer(void* context,
+                                                 unsigned,
+                                                 Glyph,
+                                                 FloatSize glyph_offset,
+                                                 float advance,
+                                                 bool is_horizontal,
+                                                 CanvasRotationInVertical,
+                                                 const SimpleFontData*);
 
-  template <typename TextContainerType>
-  float FillTextEmphasisGlyphsForRun(const ShapeResult::RunInfo*,
-                                     const TextContainerType&,
-                                     unsigned text_length,
-                                     TextDirection,
-                                     unsigned from,
-                                     unsigned to,
-                                     const GlyphData& emphasis_data,
-                                     float initial_advance,
-                                     unsigned run_offset);
+  float FillGlyphsForResult(const ShapeResult*,
+                            const StringView&,
+                            unsigned from,
+                            unsigned to,
+                            float initial_advance,
+                            unsigned run_offset);
+  static void AddGlyphToBloberizer(void* context,
+                                   unsigned character_index,
+                                   Glyph,
+                                   FloatSize glyph_offset,
+                                   float advance,
+                                   bool is_horizontal,
+                                   CanvasRotationInVertical,
+                                   const SimpleFontData*);
 
+  void AddEmphasisMark(const GlyphData& emphasis_data,
+                       CanvasRotationInVertical canvas_rotation,
+                       FloatPoint glyph_center,
+                       float mid_glyph_offset);
+  static void AddEmphasisMarkToBloberizer(
+      void* context,
+      unsigned character_index,
+      float advance_so_far,
+      unsigned graphemes_in_cluster,
+      float cluster_advance,
+      CanvasRotationInVertical canvas_rotation);
+
+  bool IsSkipInkException(const StringView& text, unsigned character_index);
+
+  void SetText(const StringView& text,
+               unsigned from,
+               unsigned to,
+               base::span<const unsigned> cluster_starts);
+  void CommitText();
   void CommitPendingRun();
   void CommitPendingBlob();
 
   bool HasPendingVerticalOffsets() const;
 
-  const Font& font_;
+  const FontDescription& font_description_;
   const float device_scale_factor_;
   const Type type_;
 
   // Current text blob state.
-  PaintTextBlobBuilder builder_;
+  SkTextBlobBuilder builder_;
   CanvasRotationInVertical builder_rotation_ =
       CanvasRotationInVertical::kRegular;
   size_t builder_run_count_ = 0;
@@ -160,10 +182,59 @@ class PLATFORM_EXPORT ShapeResultBloberizer {
       CanvasRotationInVertical::kRegular;
   Vector<Glyph, 1024> pending_glyphs_;
   Vector<float, 1024> pending_offsets_;
+
+  Vector<uint8_t, 1024> pending_utf8_;
+  Vector<uint32_t, 1024> pending_utf8_character_indexes_;
+  Vector<unsigned, 1024> current_character_indexes_;
+  Vector<unsigned, 1024> cluster_ends_;
+  unsigned cluster_ends_offset_ = 0;
+  StringView current_text_;
+
   float pending_vertical_baseline_x_offset_ = 0;
 
   // Constructed blobs.
   BlobBuffer blobs_;
+  float advance_ = 0;
+
+  DISALLOW_COPY_AND_ASSIGN(ShapeResultBloberizer);
+};
+
+struct PLATFORM_EXPORT ShapeResultBloberizer::FillGlyphsNG
+    : public ShapeResultBloberizer {
+  FillGlyphsNG(const FontDescription&,
+               float device_scale_factor,
+               const StringView&,
+               unsigned from,
+               unsigned to,
+               const ShapeResultView*,
+               Type);
+};
+struct PLATFORM_EXPORT ShapeResultBloberizer::FillTextEmphasisGlyphsNG
+    : public ShapeResultBloberizer {
+  FillTextEmphasisGlyphsNG(const FontDescription&,
+                           float device_scale_factor,
+                           const StringView&,
+                           unsigned from,
+                           unsigned to,
+                           const ShapeResultView*,
+                           const GlyphData& emphasis_data);
+};
+
+struct PLATFORM_EXPORT ShapeResultBloberizer::FillGlyphs
+    : public ShapeResultBloberizer {
+  FillGlyphs(const FontDescription&,
+             float device_scale_factor,
+             const TextRunPaintInfo&,
+             const ShapeResultBuffer&,
+             Type);
+};
+struct PLATFORM_EXPORT ShapeResultBloberizer::FillTextEmphasisGlyphs
+    : public ShapeResultBloberizer {
+  FillTextEmphasisGlyphs(const FontDescription&,
+                         float device_scale_factor,
+                         const TextRunPaintInfo&,
+                         const ShapeResultBuffer&,
+                         const GlyphData& emphasis_data);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer_test.cc b/third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer_test.cc
index 3704e85e4ee9..aa132e086608 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer_test.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer_test.cc
@@ -9,12 +9,13 @@
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/renderer/platform/fonts/character_range.h"
 #include "third_party/blink/renderer/platform/fonts/font.h"
+#include "third_party/blink/renderer/platform/fonts/ng_text_fragment_paint_info.h"
 #include "third_party/blink/renderer/platform/fonts/opentype/open_type_vertical_data.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/caching_word_shaper.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
 #include "third_party/blink/renderer/platform/fonts/text_run_paint_info.h"
-#include "third_party/blink/renderer/platform/graphics/paint/paint_typeface.h"
 
 namespace blink {
 
@@ -25,8 +26,7 @@ namespace {
 static scoped_refptr<SimpleFontData> CreateTestSimpleFontData(
     bool force_rotation = false) {
   FontPlatformData platform_data(
-      PaintTypeface::FromSkTypeface(SkTypeface::MakeDefault()), CString(), 10,
-      false, false,
+      SkTypeface::MakeDefault(), std::string(), 10, false, false,
       force_rotation ? FontOrientation::kVerticalUpright
                      : FontOrientation::kHorizontal);
   return SimpleFontData::Create(platform_data, nullptr);
@@ -41,7 +41,6 @@ class ShapeResultBloberizerTest : public testing::Test {
     font_description.SetGenericFamily(FontDescription::kStandardFamily);
 
     font = Font(font_description);
-    font.Update(nullptr);
     ASSERT_TRUE(font.CanShapeWordByWord());
     fallback_fonts = nullptr;
     cache = std::make_unique<ShapeCache>();
@@ -57,11 +56,77 @@ class ShapeResultBloberizerTest : public testing::Test {
   hb_script_t script = HB_SCRIPT_INVALID;
 };
 
+struct ExpectedRun {
+  int glyph_count;
+  std::string utf8;
+  // Currently RTL is output in reverse of logical order, but this is not
+  // a requirement. This really just expects montonicity.
+  enum ClusterDirection { Ascending, Descending } cluster_direction;
+};
+using ExpectedBlob = std::vector<const ExpectedRun>;
+
+struct ExpectedRange {
+  unsigned from;
+  unsigned to;
+  unsigned length() { return to - from; }
+};
+
+void CheckBlobBuffer(const ShapeResultBloberizer::BlobBuffer& blob_buffer,
+                     const std::vector<const ExpectedBlob>& expected_blobs) {
+  EXPECT_EQ(blob_buffer.size(), expected_blobs.size());
+  const ShapeResultBloberizer::BlobInfo* blob_info_iter = blob_buffer.begin();
+  auto&& expected_blob_iter = expected_blobs.begin();
+  for (; blob_info_iter != blob_buffer.end() &&
+         expected_blob_iter != expected_blobs.end();
+       ++blob_info_iter, ++expected_blob_iter) {
+    size_t blob_index = expected_blob_iter - expected_blobs.begin();
+    const ExpectedBlob& expected_blob = *expected_blob_iter;
+    SkTextBlob::Iter::Run run;
+    size_t actual_run_count = 0;
+    for (SkTextBlob::Iter it(*blob_info_iter->blob.get()); it.next(&run);) {
+      ++actual_run_count;
+    }
+    EXPECT_EQ(actual_run_count, expected_blob.size()) << "Blob: " << blob_index;
+    auto&& expected_run_iter = expected_blob.begin();
+    SkTextBlob::Iter it(*blob_info_iter->blob.get());
+    for (; it.next(&run) && expected_run_iter != expected_blob.end();
+         ++expected_run_iter) {
+      size_t run_index = expected_run_iter - expected_blob.begin();
+      const ExpectedRun& expected_run = *expected_run_iter;
+      EXPECT_EQ(expected_run.glyph_count, run.fGlyphCount)
+          << "Blob: " << blob_index << " Run: " << run_index;
+
+      int actual_size = run.fUtf8Size_forTest;
+      int expected_size = expected_run.utf8.size();
+      EXPECT_EQ(actual_size, expected_size)
+          << "Blob: " << blob_index << " Run: " << run_index;
+      for (int i = 0; i < actual_size && i < expected_size; ++i) {
+        EXPECT_EQ(run.fUtf8_forTest[i], expected_run.utf8[i])
+            << "Blob: " << blob_index << " Run: " << run_index << " i: " << i;
+      }
+
+      auto utf8_index_previous = run.fClusterIndex_forTest[0];
+      for (int i = 0; i < run.fGlyphCount; ++i) {
+        EXPECT_LE(0ul, run.fClusterIndex_forTest[i]);
+        EXPECT_LT((int)run.fClusterIndex_forTest[i], run.fUtf8Size_forTest);
+        auto expected_direction = expected_run.cluster_direction;
+        if (expected_direction == ExpectedRun::ClusterDirection::Ascending) {
+          EXPECT_LE(utf8_index_previous, run.fClusterIndex_forTest[i]);
+        } else {
+          EXPECT_GE(utf8_index_previous, run.fClusterIndex_forTest[i]);
+        }
+        utf8_index_previous = run.fClusterIndex_forTest[i];
+      }
+    }
+  }
+}
+
 }  // anonymous namespace
 
 TEST_F(ShapeResultBloberizerTest, StartsEmpty) {
   Font font;
-  ShapeResultBloberizer bloberizer(font, 1);
+  ShapeResultBloberizer bloberizer(font.GetFontDescription(), 1,
+                                   ShapeResultBloberizer::Type::kNormal);
 
   EXPECT_EQ(ShapeResultBloberizerTestInfo::PendingRunFontData(bloberizer),
             nullptr);
@@ -80,14 +145,17 @@ TEST_F(ShapeResultBloberizerTest, StartsEmpty) {
 
 TEST_F(ShapeResultBloberizerTest, StoresGlyphsOffsets) {
   Font font;
-  ShapeResultBloberizer bloberizer(font, 1);
+  ShapeResultBloberizer bloberizer(font.GetFontDescription(), 1,
+                                   ShapeResultBloberizer::Type::kNormal);
 
   scoped_refptr<SimpleFontData> font1 = CreateTestSimpleFontData();
   scoped_refptr<SimpleFontData> font2 = CreateTestSimpleFontData();
 
   // 2 pending glyphs
-  bloberizer.Add(42, font1.get(), CanvasRotationInVertical::kRegular, 10);
-  bloberizer.Add(43, font1.get(), CanvasRotationInVertical::kRegular, 15);
+  ShapeResultBloberizerTestInfo::Add(bloberizer, 42, font1.get(),
+                                     CanvasRotationInVertical::kRegular, 10, 0);
+  ShapeResultBloberizerTestInfo::Add(bloberizer, 43, font1.get(),
+                                     CanvasRotationInVertical::kRegular, 15, 1);
 
   EXPECT_EQ(ShapeResultBloberizerTestInfo::PendingRunFontData(bloberizer),
             font1.get());
@@ -112,7 +180,8 @@ TEST_F(ShapeResultBloberizerTest, StoresGlyphsOffsets) {
   EXPECT_EQ(ShapeResultBloberizerTestInfo::CommittedBlobCount(bloberizer), 0ul);
 
   // one more glyph, different font => pending run flush
-  bloberizer.Add(44, font2.get(), CanvasRotationInVertical::kRegular, 12);
+  ShapeResultBloberizerTestInfo::Add(bloberizer, 44, font2.get(),
+                                     CanvasRotationInVertical::kRegular, 12, 0);
 
   EXPECT_EQ(ShapeResultBloberizerTestInfo::PendingRunFontData(bloberizer),
             font2.get());
@@ -140,16 +209,19 @@ TEST_F(ShapeResultBloberizerTest, StoresGlyphsOffsets) {
 
 TEST_F(ShapeResultBloberizerTest, StoresGlyphsVerticalOffsets) {
   Font font;
-  ShapeResultBloberizer bloberizer(font, 1);
+  ShapeResultBloberizer bloberizer(font.GetFontDescription(), 1,
+                                   ShapeResultBloberizer::Type::kNormal);
 
   scoped_refptr<SimpleFontData> font1 = CreateTestSimpleFontData();
   scoped_refptr<SimpleFontData> font2 = CreateTestSimpleFontData();
 
   // 2 pending glyphs
-  bloberizer.Add(42, font1.get(), CanvasRotationInVertical::kRegular,
-                 FloatPoint(10, 0));
-  bloberizer.Add(43, font1.get(), CanvasRotationInVertical::kRegular,
-                 FloatPoint(15, 0));
+  ShapeResultBloberizerTestInfo::Add(bloberizer, 42, font1.get(),
+                                     CanvasRotationInVertical::kRegular,
+                                     FloatPoint(10, 0), 0);
+  ShapeResultBloberizerTestInfo::Add(bloberizer, 43, font1.get(),
+                                     CanvasRotationInVertical::kRegular,
+                                     FloatPoint(15, 0), 1);
 
   EXPECT_EQ(ShapeResultBloberizerTestInfo::PendingRunFontData(bloberizer),
             font1.get());
@@ -176,8 +248,9 @@ TEST_F(ShapeResultBloberizerTest, StoresGlyphsVerticalOffsets) {
   EXPECT_EQ(ShapeResultBloberizerTestInfo::CommittedBlobCount(bloberizer), 0ul);
 
   // one more glyph, different font => pending run flush
-  bloberizer.Add(44, font2.get(), CanvasRotationInVertical::kRegular,
-                 FloatPoint(12, 2));
+  ShapeResultBloberizerTestInfo::Add(bloberizer, 44, font2.get(),
+                                     CanvasRotationInVertical::kRegular,
+                                     FloatPoint(12, 2), 2);
 
   EXPECT_EQ(ShapeResultBloberizerTestInfo::PendingRunFontData(bloberizer),
             font2.get());
@@ -206,7 +279,8 @@ TEST_F(ShapeResultBloberizerTest, StoresGlyphsVerticalOffsets) {
 
 TEST_F(ShapeResultBloberizerTest, MixedBlobRotation) {
   Font font;
-  ShapeResultBloberizer bloberizer(font, 1);
+  ShapeResultBloberizer bloberizer(font.GetFontDescription(), 1,
+                                   ShapeResultBloberizer::Type::kNormal);
 
   scoped_refptr<SimpleFontData> test_font = CreateTestSimpleFontData();
 
@@ -237,7 +311,8 @@ TEST_F(ShapeResultBloberizerTest, MixedBlobRotation) {
   };
 
   for (const auto& op : append_ops) {
-    bloberizer.Add(42, test_font.get(), op.canvas_rotation, FloatPoint());
+    ShapeResultBloberizerTestInfo::Add(bloberizer, 42, test_font.get(),
+                                       op.canvas_rotation, FloatPoint(), 0);
     EXPECT_EQ(
         op.expected_pending_glyphs,
         ShapeResultBloberizerTestInfo::PendingRunGlyphs(bloberizer).size());
@@ -257,26 +332,27 @@ TEST_F(ShapeResultBloberizerTest, MixedBlobRotation) {
 // results when shaping word by word as when shaping the full run in one go.
 TEST_F(ShapeResultBloberizerTest, CommonAccentLeftToRightFillGlyphBuffer) {
   // "/. ." with an accent mark over the first dot.
-  const UChar kStr[] = {0x2F, 0x301, 0x2E, 0x20, 0x2E, 0x0};
-  TextRun text_run(kStr, 5);
+  const UChar kStr[] = {0x2F, 0x301, 0x2E, 0x20, 0x2E};
+  TextRun text_run(kStr, base::make_span(kStr).size());
   TextRunPaintInfo run_info(text_run);
   run_info.to = 3;
 
-  ShapeResultBloberizer bloberizer(font, 1);
   CachingWordShaper word_shaper(font);
   ShapeResultBuffer buffer;
   word_shaper.FillResultBuffer(run_info, &buffer);
-  bloberizer.FillGlyphs(run_info, buffer);
+  ShapeResultBloberizer::FillGlyphs bloberizer(
+      font.GetFontDescription(), 1.0f, run_info, buffer,
+      ShapeResultBloberizer::Type::kEmitText);
 
   Font reference_font(font_description);
-  reference_font.Update(nullptr);
   reference_font.SetCanShapeWordByWordForTesting(false);
 
-  ShapeResultBloberizer reference_bloberizer(reference_font, 1);
-  CachingWordShaper reference_word_shaper(font);
+  CachingWordShaper reference_word_shaper(reference_font);
   ShapeResultBuffer reference_buffer;
   reference_word_shaper.FillResultBuffer(run_info, &reference_buffer);
-  reference_bloberizer.FillGlyphs(run_info, reference_buffer);
+  ShapeResultBloberizer::FillGlyphs reference_bloberizer(
+      reference_font.GetFontDescription(), 1.0f, run_info, reference_buffer,
+      ShapeResultBloberizer::Type::kEmitText);
 
   const auto& glyphs =
       ShapeResultBloberizerTestInfo::PendingRunGlyphs(bloberizer);
@@ -288,33 +364,45 @@ TEST_F(ShapeResultBloberizerTest, CommonAccentLeftToRightFillGlyphBuffer) {
   EXPECT_EQ(reference_glyphs[0], glyphs[0]);
   EXPECT_EQ(reference_glyphs[1], glyphs[1]);
   EXPECT_EQ(reference_glyphs[2], glyphs[2]);
+
+  CheckBlobBuffer(
+      bloberizer.Blobs(),
+      {{
+          {3,
+           text_run.ToStringView()
+               .ToString()
+               .Substring(run_info.from, run_info.to - run_info.from)
+               .Utf8(),
+           ExpectedRun::ClusterDirection::Ascending},
+      }});
 }
 
 // Tests that filling a glyph buffer for a specific range returns the same
 // results when shaping word by word as when shaping the full run in one go.
 TEST_F(ShapeResultBloberizerTest, CommonAccentRightToLeftFillGlyphBuffer) {
   // "[] []" with an accent mark over the last square bracket.
-  const UChar kStr[] = {0x5B, 0x5D, 0x20, 0x5B, 0x301, 0x5D, 0x0};
-  TextRun text_run(kStr, 6);
+  const UChar kStr[] = {0x5B, 0x5D, 0x20, 0x5B, 0x301, 0x5D};
+  TextRun text_run(kStr, base::make_span(kStr).size());
   text_run.SetDirection(TextDirection::kRtl);
   TextRunPaintInfo run_info(text_run);
   run_info.from = 1;
 
-  ShapeResultBloberizer bloberizer(font, 1);
   CachingWordShaper word_shaper(font);
   ShapeResultBuffer buffer;
   word_shaper.FillResultBuffer(run_info, &buffer);
-  bloberizer.FillGlyphs(run_info, buffer);
+  ShapeResultBloberizer::FillGlyphs bloberizer(
+      font.GetFontDescription(), 1.0f, run_info, buffer,
+      ShapeResultBloberizer::Type::kEmitText);
 
   Font reference_font(font_description);
-  reference_font.Update(nullptr);
   reference_font.SetCanShapeWordByWordForTesting(false);
 
-  ShapeResultBloberizer reference_bloberizer(reference_font, 1);
-  CachingWordShaper reference_word_shaper(font);
+  CachingWordShaper reference_word_shaper(reference_font);
   ShapeResultBuffer reference_buffer;
   reference_word_shaper.FillResultBuffer(run_info, &reference_buffer);
-  reference_bloberizer.FillGlyphs(run_info, reference_buffer);
+  ShapeResultBloberizer::FillGlyphs reference_bloberizer(
+      reference_font.GetFontDescription(), 1.0f, run_info, reference_buffer,
+      ShapeResultBloberizer::Type::kEmitText);
 
   const auto& glyphs =
       ShapeResultBloberizerTestInfo::PendingRunGlyphs(bloberizer);
@@ -330,26 +418,231 @@ TEST_F(ShapeResultBloberizerTest, CommonAccentRightToLeftFillGlyphBuffer) {
   EXPECT_EQ(reference_glyphs[4], glyphs[4]);
 }
 
+TEST_F(ShapeResultBloberizerTest, CommonAccentRightToLeftFillGlyphBufferNG) {
+  // "[] []" with an accent mark over the last square bracket.
+  const UChar kStr[] = {0x5B, 0x5D, 0x20, 0x5B, 0x301, 0x5D};
+  String string(kStr, base::make_span(kStr).size());
+
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> result = shaper.Shape(&font, TextDirection::kRtl);
+
+  scoped_refptr<ShapeResultView> result_view =
+      ShapeResultView::Create(result.get());
+  NGTextFragmentPaintInfo text_info{StringView(string), 1, string.length(),
+                                    result_view.get()};
+  ShapeResultBloberizer::FillGlyphsNG bloberizer_ng(
+      font.GetFontDescription(), 1.0f, text_info.text, text_info.from,
+      text_info.to, text_info.shape_result,
+      ShapeResultBloberizer::Type::kEmitText);
+
+  CheckBlobBuffer(
+      bloberizer_ng.Blobs(),
+      {{
+          {5,
+           string.Substring(text_info.from, text_info.to - text_info.from)
+               .Utf8(),
+           ExpectedRun::ClusterDirection::Descending},
+      }});
+}
+
+TEST_F(ShapeResultBloberizerTest, FourByteUtf8CodepointsNG) {
+  // Codepoints which encode to four UTF-8 code units.
+  const UChar kStr[] = {0xD841, 0xDF31, 0xD841, 0xDF79};
+  String string(kStr, base::make_span(kStr).size());
+
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> result = shaper.Shape(&font, TextDirection::kLtr);
+
+  scoped_refptr<ShapeResultView> result_view =
+      ShapeResultView::Create(result.get());
+  NGTextFragmentPaintInfo text_info{StringView(string), 0, string.length(),
+                                    result_view.get()};
+  ShapeResultBloberizer::FillGlyphsNG bloberizer_ng(
+      font.GetFontDescription(), 1.0f, text_info.text, text_info.from,
+      text_info.to, text_info.shape_result,
+      ShapeResultBloberizer::Type::kEmitText);
+
+  CheckBlobBuffer(
+      bloberizer_ng.Blobs(),
+      {{
+          {2,
+           string.Substring(text_info.from, text_info.to - text_info.from)
+               .Utf8(),
+           ExpectedRun::ClusterDirection::Ascending},
+      }});
+}
+
+TEST_F(ShapeResultBloberizerTest, OffsetIntoTrailingSurrogateNG) {
+  // Codepoints which encode to four UTF-8 code units.
+  const UChar kStr[] = {0xD841, 0xDF31, 0xD841, 0xDF79};
+  String string(kStr, base::make_span(kStr).size());
+
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> result = shaper.Shape(&font, TextDirection::kLtr);
+
+  scoped_refptr<ShapeResultView> result_view =
+      ShapeResultView::Create(result.get());
+  // Start at offset 1 into text at trailing surrogate.
+  NGTextFragmentPaintInfo text_info{StringView(string), 1, string.length(),
+                                    result_view.get()};
+  ShapeResultBloberizer::FillGlyphsNG bloberizer_ng(
+      font.GetFontDescription(), 1.0f, text_info.text, text_info.from,
+      text_info.to, text_info.shape_result,
+      ShapeResultBloberizer::Type::kEmitText);
+
+  // Do not expect the trailing surrogate to be in any output.
+  const auto& glyphs =
+      ShapeResultBloberizerTestInfo::PendingRunGlyphs(bloberizer_ng);
+  EXPECT_EQ(1u, glyphs.size());
+
+  CheckBlobBuffer(
+      bloberizer_ng.Blobs(),
+      {{
+          {1,
+           string
+               .Substring(text_info.from + 1, text_info.to - text_info.from - 1)
+               .Utf8(),
+           ExpectedRun::ClusterDirection::Ascending},
+      }});
+}
+
+TEST_F(ShapeResultBloberizerTest, LatinMultRunNG) {
+  TextDirection direction = TextDirection::kLtr;
+  String string = "Testing ShapeResultIterator::CopyRange";
+
+  ExpectedRange range_a{0, 5};
+  ExpectedRange range_b{5, 7};
+  ExpectedRange range_c{7, 32};
+  ExpectedRange range_d{32, 38};
+  HarfBuzzShaper shaper_a(string.Substring(range_a.from, range_a.to));
+  HarfBuzzShaper shaper_b(string.Substring(range_b.from, range_b.to));
+  HarfBuzzShaper shaper_c(string.Substring(range_c.from, range_c.to));
+  HarfBuzzShaper shaper_d(string.Substring(range_d.from, range_d.to));
+
+  FontDescription font2_description(font_description);
+  font2_description.SetComputedSize(20);
+  Font font2(font2_description);
+
+  // Combine four separate results into a single one to ensure we have a result
+  // with multiple runs. Interleave fonts to ensure run changes.
+  scoped_refptr<ShapeResult> result =
+      ShapeResult::Create(&font, 0, 0, direction);
+  shaper_a.Shape(&font, direction)
+      ->CopyRange(0u, range_a.length(), result.get());
+  shaper_b.Shape(&font2, direction)
+      ->CopyRange(0u, range_b.length(), result.get());
+  shaper_c.Shape(&font, direction)
+      ->CopyRange(0u, range_c.length(), result.get());
+  shaper_d.Shape(&font2, direction)
+      ->CopyRange(0u, range_d.length(), result.get());
+
+  scoped_refptr<ShapeResultView> result_view =
+      ShapeResultView::Create(result.get());
+  NGTextFragmentPaintInfo text_info{StringView(string), 1, string.length(),
+                                    result_view.get()};
+  ShapeResultBloberizer::FillGlyphsNG bloberizer_ng(
+      font.GetFontDescription(), 1.0f, text_info.text, text_info.from,
+      text_info.to, text_info.shape_result,
+      ShapeResultBloberizer::Type::kEmitText);
+
+  CheckBlobBuffer(
+      bloberizer_ng.Blobs(),
+      {{
+          // T"esti"
+          {range_a.length() - 1,
+           string.Substring(range_a.from + 1, range_a.length() - 1).Utf8(),
+           ExpectedRun::ClusterDirection::Ascending},
+          // "ng"
+          {range_b.length(),
+           string.Substring(range_b.from, range_b.length()).Utf8(),
+           ExpectedRun::ClusterDirection::Ascending},
+          // " ShapeResultIterator::Cop"
+          {range_c.length(),
+           string.Substring(range_c.from, range_c.length()).Utf8(),
+           ExpectedRun::ClusterDirection::Ascending},
+          // "yRange"
+          {range_d.length(),
+           string.Substring(range_d.from, range_d.length()).Utf8(),
+           ExpectedRun::ClusterDirection::Ascending},
+      }});
+}
+
+TEST_F(ShapeResultBloberizerTest, SupplementaryMultiRunNG) {
+  TextDirection direction = TextDirection::kLtr;
+  // 
+  const UChar kStrSupp[] = {0xD841, 0xDF0E, 0xD841, 0xDF31, 0xD841, 0xDF79,
+                            0xD843, 0xDC53, 0xD843, 0xDC78, 0xD843, 0xDC96,
+                            0xD843, 0xDCCF, 0xD843, 0xDCD5};
+  String string(kStrSupp, base::make_span(kStrSupp).size());
+
+  ExpectedRange range_a{0, 6};
+  ExpectedRange range_b{6, 12};
+  ExpectedRange range_c{12, 16};
+  HarfBuzzShaper shaper_a(string.Substring(range_a.from, range_a.to));
+  HarfBuzzShaper shaper_b(string.Substring(range_b.from, range_b.to));
+  HarfBuzzShaper shaper_c(string.Substring(range_c.from, range_c.to));
+
+  FontDescription font2_description(font_description);
+  font2_description.SetComputedSize(20);
+  Font font2(font2_description);
+
+  // Combine four separate results into a single one to ensure we have a result
+  // with multiple runs. Interleave fonts to ensure run changes.
+  scoped_refptr<ShapeResult> result =
+      ShapeResult::Create(&font, 0, 0, direction);
+  shaper_a.Shape(&font, direction)
+      ->CopyRange(0u, range_a.length(), result.get());
+  shaper_b.Shape(&font2, direction)
+      ->CopyRange(0u, range_b.length(), result.get());
+  shaper_c.Shape(&font, direction)
+      ->CopyRange(0u, range_c.length(), result.get());
+
+  scoped_refptr<ShapeResultView> result_view =
+      ShapeResultView::Create(result.get());
+  NGTextFragmentPaintInfo text_info{StringView(string), 0, string.length(),
+                                    result_view.get()};
+  ShapeResultBloberizer::FillGlyphsNG bloberizer_ng(
+      font.GetFontDescription(), 1.0f, text_info.text, text_info.from,
+      text_info.to, text_info.shape_result,
+      ShapeResultBloberizer::Type::kEmitText);
+
+  CheckBlobBuffer(bloberizer_ng.Blobs(),
+                  {{
+                      // ""
+                      {range_a.length() / 2,
+                       string.Substring(range_a.from, range_a.length()).Utf8(),
+                       ExpectedRun::ClusterDirection::Ascending},
+                      // ""
+                      {range_b.length() / 2,
+                       string.Substring(range_b.from, range_b.length()).Utf8(),
+                       ExpectedRun::ClusterDirection::Ascending},
+                      // ""
+                      {range_c.length() / 2,
+                       string.Substring(range_c.from, range_c.length()).Utf8(),
+                       ExpectedRun::ClusterDirection::Ascending},
+                  }});
+}
+
 // Tests that runs with zero glyphs (the ZWJ non-printable character in this
 // case) are handled correctly. This test passes if it does not cause a crash.
 TEST_F(ShapeResultBloberizerTest, SubRunWithZeroGlyphs) {
   // "Foo &zwnj; bar"
-  const UChar kStr[] = {0x46, 0x6F, 0x6F, 0x20, 0x200C,
-                        0x20, 0x62, 0x61, 0x71, 0x0};
-  TextRun text_run(kStr, 9);
+  const UChar kStr[] = {0x46, 0x6F, 0x6F, 0x20, 0x200C, 0x20, 0x62, 0x61, 0x71};
+  TextRun text_run(kStr, base::make_span(kStr).size());
 
   CachingWordShaper shaper(font);
   FloatRect glyph_bounds;
   ASSERT_GT(shaper.Width(text_run, nullptr, &glyph_bounds), 0);
 
-  ShapeResultBloberizer bloberizer(font, 1);
   TextRunPaintInfo run_info(text_run);
   run_info.to = 8;
 
   CachingWordShaper word_shaper(font);
   ShapeResultBuffer buffer;
   word_shaper.FillResultBuffer(run_info, &buffer);
-  bloberizer.FillGlyphs(run_info, buffer);
+  ShapeResultBloberizer::FillGlyphs bloberizer(
+      font.GetFontDescription(), 1.0f, run_info, buffer,
+      ShapeResultBloberizer::Type::kEmitText);
 
   shaper.GetCharacterRange(text_run, 0, 8);
 }
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_buffer.cc b/third_party/blink/renderer/platform/fonts/shaping/shape_result_buffer.cc
index 1800d807bdcc..e51374bf2699 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_result_buffer.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_buffer.cc
@@ -13,34 +13,26 @@
 
 namespace blink {
 
-// TODO(eae): This is a bit of a hack to allow reuse of the implementation
-// for both ShapeResultBuffer and single ShapeResult use cases. Ideally the
-// logic should move into ShapeResult itself and then the ShapeResultBuffer
-// implementation may wrap that.
+namespace {
+
+unsigned CharactersInShapeResult(
+    const Vector<scoped_refptr<const ShapeResult>, 64>& results) {
+  unsigned num_characters = 0;
+  for (const scoped_refptr<const ShapeResult>& result : results)
+    num_characters += result->NumCharacters();
+  return num_characters;
+}
+
+}  // namespace
+
 CharacterRange ShapeResultBuffer::GetCharacterRange(
-    scoped_refptr<const ShapeResult> result,
-    TextDirection direction,
-    float total_width,
-    unsigned from,
-    unsigned to) {
-  Vector<scoped_refptr<const ShapeResult>, 64> results;
-  results.push_back(result);
-  return GetCharacterRangeInternal(results, direction, total_width, from, to);
-}
-
-CharacterRange ShapeResultBuffer::GetCharacterRange(float total_width,
-                                                    TextDirection direction,
-                                                    unsigned from,
-                                                    unsigned to) const {
-  return GetCharacterRangeInternal(results_, direction, total_width, from, to);
-}
-
-CharacterRange ShapeResultBuffer::GetCharacterRangeInternal(
-    const Vector<scoped_refptr<const ShapeResult>, 64>& results,
+    const StringView& text,
     TextDirection direction,
     float total_width,
     unsigned absolute_from,
-    unsigned absolute_to) {
+    unsigned absolute_to) const {
+  DCHECK_EQ(CharactersInShapeResult(results_), text.length());
+
   float current_x = 0;
   float from_x = 0;
   float to_x = 0;
@@ -59,8 +51,10 @@ CharacterRange ShapeResultBuffer::GetCharacterRangeInternal(
   int to = absolute_to;
 
   unsigned total_num_characters = 0;
-  for (unsigned j = 0; j < results.size(); j++) {
-    const scoped_refptr<const ShapeResult> result = results[j];
+  for (unsigned j = 0; j < results_.size(); j++) {
+    const scoped_refptr<const ShapeResult> result = results_[j];
+    result->EnsureGraphemes(
+        StringView(text, total_num_characters, result->NumCharacters()));
     if (direction == TextDirection::kRtl) {
       // Convert logical offsets to visual offsets, because results are in
       // logical order while runs are in visual order.
@@ -75,7 +69,7 @@ CharacterRange ShapeResultBuffer::GetCharacterRangeInternal(
     for (unsigned i = 0; i < result->runs_.size(); i++) {
       if (!result->runs_[i])
         continue;
-      DCHECK_EQ(direction == TextDirection::kRtl, result->runs_[i]->Rtl());
+      DCHECK_EQ(direction == TextDirection::kRtl, result->runs_[i]->IsRtl());
       int num_characters = result->runs_[i]->num_characters_;
       if (!found_from_x && from >= 0 && from < num_characters) {
         from_x = result->runs_[i]->XPositionForVisualOffset(
@@ -96,8 +90,8 @@ CharacterRange ShapeResultBuffer::GetCharacterRangeInternal(
       }
 
       if (found_from_x || found_to_x) {
-        min_y = std::min(min_y, result->Bounds().Y());
-        max_y = std::max(max_y, result->Bounds().MaxY());
+        min_y = std::min(min_y, result->DeprecatedInkBounds().Y());
+        max_y = std::max(max_y, result->DeprecatedInkBounds().MaxY());
       }
 
       if (found_from_x && found_to_x)
@@ -131,53 +125,102 @@ CharacterRange ShapeResultBuffer::GetCharacterRangeInternal(
   return CharacterRange(to_x, from_x, -min_y, max_y);
 }
 
-void ShapeResultBuffer::AddRunInfoRanges(const ShapeResult::RunInfo& run_info,
-                                         float offset,
-                                         Vector<CharacterRange>& ranges) {
-  Vector<float> character_widths(run_info.num_characters_);
-  for (const auto& glyph : run_info.glyph_data_)
-    character_widths[glyph.character_index] += glyph.advance;
-
-  for (unsigned character_index = 0; character_index < run_info.num_characters_;
-       character_index++) {
-    float start = offset;
-    offset += character_widths[character_index];
-    float end = offset;
-
-    // To match getCharacterRange we flip ranges to ensure start <= end.
-    if (end < start)
-      ranges.push_back(CharacterRange(end, start, 0, 0));
-    else
-      ranges.push_back(CharacterRange(start, end, 0, 0));
-  }
-}
-
 Vector<CharacterRange> ShapeResultBuffer::IndividualCharacterRanges(
     TextDirection direction,
     float total_width) const {
   Vector<CharacterRange> ranges;
   float current_x = direction == TextDirection::kRtl ? total_width : 0;
-  for (const scoped_refptr<const ShapeResult> result : results_) {
-    if (direction == TextDirection::kRtl)
-      current_x -= result->Width();
-    unsigned run_count = result->runs_.size();
-    for (unsigned index = 0; index < run_count; index++) {
-      unsigned run_index =
-          direction == TextDirection::kRtl ? run_count - 1 - index : index;
-      AddRunInfoRanges(*result->runs_[run_index], current_x, ranges);
-      current_x += result->runs_[run_index]->width_;
-    }
-    if (direction == TextDirection::kRtl)
-      current_x -= result->Width();
-  }
+  for (const scoped_refptr<const ShapeResult>& result : results_)
+    current_x = result->IndividualCharacterRanges(&ranges, current_x);
   return ranges;
 }
 
+void ShapeResultBuffer::AddRunInfoAdvances(const ShapeResult::RunInfo& run_info,
+                                           double offset,
+                                           Vector<double>& advances) {
+  const unsigned num_glyphs = run_info.glyph_data_.size();
+  const unsigned num_chars = run_info.num_characters_;
+
+  if (run_info.IsRtl())
+    offset += run_info.width_;
+
+  double current_width = 0;
+  for (unsigned glyph_id = 0; glyph_id < num_glyphs; glyph_id++) {
+    unsigned gid = run_info.IsRtl() ? num_glyphs - glyph_id - 1 : glyph_id;
+    unsigned next_gid =
+        run_info.IsRtl() ? num_glyphs - glyph_id - 2 : glyph_id + 1;
+    const HarfBuzzRunGlyphData& glyph = run_info.glyph_data_[gid];
+
+    unsigned char_id = glyph.character_index;
+    unsigned next_char_id =
+        (glyph_id + 1 == num_glyphs)
+            ? num_chars
+            : run_info.glyph_data_[next_gid].character_index;
+
+    current_width += glyph.advance;
+
+    if (char_id == next_char_id)
+      continue;
+
+    unsigned num_graphemes = run_info.NumGraphemes(char_id, next_char_id);
+
+    for (unsigned i = char_id; i < next_char_id; i++) {
+      if (run_info.IsRtl()) {
+        advances.push_back(offset - (current_width / num_graphemes));
+      } else {
+        advances.push_back(offset);
+      }
+
+      if (num_graphemes == next_char_id - char_id) {
+        offset += (current_width / num_graphemes) * (run_info.IsRtl() ? -1 : 1);
+      }
+    }
+
+    if (num_graphemes != next_char_id - char_id) {
+      offset += current_width * (run_info.IsRtl() ? -1 : 1);
+    }
+
+    current_width = 0;
+  }
+}
+
+Vector<double> ShapeResultBuffer::IndividualCharacterAdvances(
+    const StringView& text,
+    TextDirection direction,
+    float total_width) const {
+  unsigned character_offset = 0;
+  Vector<double> advances;
+  double current_x = direction == TextDirection::kRtl ? total_width : 0;
+
+  for (const scoped_refptr<const ShapeResult>& result : results_) {
+    unsigned run_count = result->runs_.size();
+
+    result->EnsureGraphemes(
+        StringView(text, character_offset, result->NumCharacters()));
+
+    if (result->IsRtl()) {
+      for (int index = run_count - 1; index >= 0; index--) {
+        current_x -= result->runs_[index]->width_;
+        AddRunInfoAdvances(*result->runs_[index], current_x, advances);
+      }
+    } else {
+      for (unsigned index = 0; index < run_count; index++) {
+        AddRunInfoAdvances(*result->runs_[index], current_x, advances);
+        current_x += result->runs_[index]->width_;
+      }
+    }
+
+    character_offset += result->NumCharacters();
+  }
+  return advances;
+}
+
 int ShapeResultBuffer::OffsetForPosition(
     const TextRun& run,
     float target_x,
     IncludePartialGlyphsOption partial_glyphs,
     BreakGlyphsOption break_glyphs) const {
+  StringView text = run.ToStringView();
   unsigned total_offset;
   if (run.Rtl()) {
     total_offset = run.length();
@@ -188,22 +231,26 @@ int ShapeResultBuffer::OffsetForPosition(
       total_offset -= word_result->NumCharacters();
       if (target_x >= 0 && target_x <= word_result->Width()) {
         int offset_for_word = word_result->OffsetForPosition(
-            target_x, partial_glyphs, break_glyphs);
+            target_x,
+            StringView(text, total_offset, word_result->NumCharacters()),
+            partial_glyphs, break_glyphs);
         return total_offset + offset_for_word;
       }
       target_x -= word_result->Width();
     }
   } else {
     total_offset = 0;
-    for (const auto& word_result : results_) {
+    for (const scoped_refptr<const ShapeResult>& word_result : results_) {
       if (!word_result)
         continue;
       int offset_for_word = word_result->OffsetForPosition(
-          target_x, partial_glyphs, break_glyphs);
+          target_x, StringView(text, 0, word_result->NumCharacters()),
+          partial_glyphs, break_glyphs);
       DCHECK_GE(offset_for_word, 0);
       total_offset += offset_for_word;
       if (target_x >= 0 && target_x <= word_result->Width())
         return total_offset;
+      text = StringView(text, word_result->NumCharacters());
       target_x -= word_result->Width();
     }
   }
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_buffer.h b/third_party/blink/renderer/platform/fonts/shaping/shape_result_buffer.h
index ace7dcd7b48a..12303d8f7c20 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_result_buffer.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_buffer.h
@@ -8,7 +8,7 @@
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 
 namespace blink {
@@ -20,7 +20,6 @@ class ShapeResultBloberizer;
 class TextRun;
 
 class PLATFORM_EXPORT ShapeResultBuffer {
-  WTF_MAKE_NONCOPYABLE(ShapeResultBuffer);
   STACK_ALLOCATED();
 
  public:
@@ -37,18 +36,16 @@ class PLATFORM_EXPORT ShapeResultBuffer {
                         float target_x,
                         IncludePartialGlyphsOption,
                         BreakGlyphsOption) const;
-  CharacterRange GetCharacterRange(float total_width,
+  CharacterRange GetCharacterRange(const StringView& text,
                                    TextDirection,
+                                   float total_width,
                                    unsigned from,
                                    unsigned to) const;
   Vector<CharacterRange> IndividualCharacterRanges(TextDirection,
                                                    float total_width) const;
-
-  static CharacterRange GetCharacterRange(scoped_refptr<const ShapeResult>,
-                                          TextDirection,
-                                          float total_width,
-                                          unsigned from,
-                                          unsigned to);
+  Vector<double> IndividualCharacterAdvances(const StringView&,
+                                             TextDirection,
+                                             float total_width) const;
 
   Vector<ShapeResult::RunFontData> GetRunFontData() const;
 
@@ -58,21 +55,17 @@ class PLATFORM_EXPORT ShapeResultBuffer {
 
  private:
   friend class ShapeResultBloberizer;
-  static CharacterRange GetCharacterRangeInternal(
-      const Vector<scoped_refptr<const ShapeResult>, 64>&,
-      TextDirection,
-      float total_width,
-      unsigned from,
-      unsigned to);
 
-  static void AddRunInfoRanges(const ShapeResult::RunInfo&,
-                               float offset,
-                               Vector<CharacterRange>&);
+  static void AddRunInfoAdvances(const ShapeResult::RunInfo& run_info,
+                                 double offset,
+                                 Vector<double>& advances);
 
   // Empirically, cases where we get more than 50 ShapeResults are extremely
   // rare.
   Vector<scoped_refptr<const ShapeResult>, 64> results_;
   bool has_vertical_offsets_;
+
+  DISALLOW_COPY_AND_ASSIGN(ShapeResultBuffer);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h b/third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h
index 3609c7666822..68d3ca9e2541 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h
@@ -35,8 +35,7 @@
 #include <hb.h>
 #include <memory>
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
-#include "third_party/blink/renderer/platform/wtf/noncopyable.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 
 namespace blink {
@@ -45,59 +44,84 @@ class SimpleFontData;
 
 // This struct should be TriviallyCopyable so that std::copy() is equivalent to
 // memcpy.
+// Because glyph offsets are often zero, particularly for Latin runs, we hold it
+// in |ShapeResult::GlyphData::_offsets_| for reducing memory usage.
 struct HarfBuzzRunGlyphData {
-  DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
+  DISALLOW_NEW();
 
-  static constexpr unsigned kMaxCharacterIndex = (1 << 15) - 1;
+  static constexpr unsigned kCharacterIndexBits = 15;
+  static constexpr unsigned kMaxCharacterIndex = (1 << kCharacterIndexBits) - 1;
+  static constexpr unsigned kMaxGlyphs = 1 << kCharacterIndexBits;
 
-  uint16_t glyph;
-  unsigned character_index : 15;
+  unsigned glyph : 16;
+  unsigned character_index : kCharacterIndexBits;
   unsigned safe_to_break_before : 1;
-  float advance;
-  FloatSize offset;
 
-  void SetGlyphAndPositions(uint16_t glyph_id,
-                            uint16_t character_index,
-                            float advance,
-                            const FloatSize& offset,
-                            bool safe_to_break_before);
+  float advance;
 };
 
-struct ShapeResult::RunInfo {
+// |GlyphOffset| is a simple wrapper of |FloatSize| to allocate |GlyphOffset|
+// with |new GlyphOffset[size]| because of |FloatSize| is declared with
+// |DISALLOW_NEW()|.
+class ShapeResult::GlyphOffset final : public FloatSize {
+  USING_FAST_MALLOC(GlyphOffset);
+
+ public:
+  using FloatSize::FloatSize;
+
+  explicit GlyphOffset(const FloatSize& other) : FloatSize(other) {}
+};
+
+struct ShapeResult::RunInfo : public RefCounted<ShapeResult::RunInfo> {
   USING_FAST_MALLOC(RunInfo);
 
  public:
+  static scoped_refptr<RunInfo> Create(const SimpleFontData* font,
+                                       hb_direction_t dir,
+                                       CanvasRotationInVertical canvas_rotation,
+                                       hb_script_t script,
+                                       unsigned start_index,
+                                       unsigned num_glyphs,
+                                       unsigned num_characters) {
+    return base::AdoptRef(new RunInfo(font, dir, canvas_rotation, script,
+                                      start_index, num_glyphs, num_characters));
+  }
+
+  static scoped_refptr<RunInfo> Create(const RunInfo& other) {
+    return base::AdoptRef(new RunInfo(other));
+  }
+
   RunInfo(const SimpleFontData* font,
           hb_direction_t dir,
           CanvasRotationInVertical canvas_rotation,
           hb_script_t script,
           unsigned start_index,
           unsigned num_glyphs,
-          unsigned num_characters,
-          Vector<unsigned> graphemes)
-      : font_data_(const_cast<SimpleFontData*>(font)),
-        direction_(dir),
-        canvas_rotation_(canvas_rotation),
-        script_(script),
-        glyph_data_(num_glyphs),
-        graphemes_(graphemes),
+          unsigned num_characters)
+      : glyph_data_(
+            std::min(num_glyphs, HarfBuzzRunGlyphData::kMaxCharacterIndex + 1)),
+        font_data_(const_cast<SimpleFontData*>(font)),
         start_index_(start_index),
         num_characters_(num_characters),
-        width_(0.0f) {}
+        width_(0.0f),
+        script_(script),
+        direction_(dir),
+        canvas_rotation_(canvas_rotation) {}
 
   RunInfo(const RunInfo& other)
-      : font_data_(other.font_data_),
-        direction_(other.direction_),
-        canvas_rotation_(other.canvas_rotation_),
-        script_(other.script_),
-        glyph_data_(other.glyph_data_),
+      : glyph_data_(other.glyph_data_),
+        font_data_(other.font_data_),
         graphemes_(other.graphemes_),
         start_index_(other.start_index_),
         num_characters_(other.num_characters_),
-        width_(other.width_) {}
+        width_(other.width_),
+        script_(other.script_),
+        direction_(other.direction_),
+        canvas_rotation_(other.canvas_rotation_) {}
 
   unsigned NumGlyphs() const { return glyph_data_.size(); }
-  bool Rtl() const { return HB_DIRECTION_IS_BACKWARD(direction_); }
+  bool IsLtr() const { return HB_DIRECTION_IS_FORWARD(direction_); }
+  bool IsRtl() const { return HB_DIRECTION_IS_BACKWARD(direction_); }
   bool IsHorizontal() const { return HB_DIRECTION_IS_HORIZONTAL(direction_); }
   CanvasRotationInVertical CanvasRotation() const { return canvas_rotation_; }
   unsigned NextSafeToBreakOffset(unsigned) const;
@@ -107,87 +131,59 @@ struct ShapeResult::RunInfo {
   void CharacterIndexForXPosition(float,
                                   BreakGlyphsOption,
                                   GlyphIndexResult*) const;
-  void SetGlyphAndPositions(unsigned index,
-                            uint16_t glyph_id,
-                            float advance,
-                            float offset_x,
-                            float offset_y);
+  unsigned LimitNumGlyphs(unsigned start_glyph,
+                          unsigned* num_glyphs_in_out,
+                          const bool is_ltr,
+                          const hb_glyph_info_t* glyph_infos);
 
-  size_t GlyphToCharacterIndex(size_t i) const {
+  unsigned GlyphToCharacterIndex(unsigned i) const {
     return start_index_ + glyph_data_[i].character_index;
   }
 
   unsigned NumGraphemes(unsigned start, unsigned end) const;
 
   // For memory reporting.
-  size_t ByteSize() const {
-    return sizeof(this) + glyph_data_.size() * sizeof(HarfBuzzRunGlyphData);
-  }
+  size_t ByteSize() const { return sizeof(*this) + glyph_data_.ByteSize(); }
 
   // Represents a range of HarfBuzzRunGlyphData. |begin| and |end| follow the
   // iterator pattern; i.e., |begin| is lower or equal to |end| in the address
   // space regardless of LTR/RTL. |begin| is inclusive, |end| is exclusive.
   struct GlyphDataRange {
-    HarfBuzzRunGlyphData* begin;
-    HarfBuzzRunGlyphData* end;
+    GlyphDataRange FindGlyphDataRange(bool is_rtl,
+                                      unsigned start_character_index,
+                                      unsigned end_character_index) const;
+    unsigned size() const { return static_cast<unsigned>(end - begin); }
+
+    const HarfBuzzRunGlyphData* begin = nullptr;
+    const HarfBuzzRunGlyphData* end = nullptr;
+    const GlyphOffset* offsets = nullptr;
   };
 
   // Find the range of HarfBuzzRunGlyphData for the specified character index
   // range. This function uses binary search twice, hence O(2 log n).
   GlyphDataRange FindGlyphDataRange(unsigned start_character_index,
-                                    unsigned end_character_index) {
-    const auto comparer = [](const HarfBuzzRunGlyphData& glyph_data,
-                             unsigned index) {
-      return glyph_data.character_index < index;
-    };
-    if (!Rtl()) {
-      HarfBuzzRunGlyphData* start_glyph =
-          std::lower_bound(glyph_data_.begin(), glyph_data_.end(),
-                           start_character_index, comparer);
-      if (UNLIKELY(start_glyph == glyph_data_.end()))
-        return {nullptr, nullptr};
-      HarfBuzzRunGlyphData* end_glyph = std::lower_bound(
-          start_glyph, glyph_data_.end(), end_character_index, comparer);
-      return {start_glyph, end_glyph};
-    }
-
-    // RTL needs to use reverse iterators because there maybe multiple glyphs
-    // for a character, and we want to find the first one in the logical order.
-    auto start_glyph =
-        std::lower_bound(glyph_data_.rbegin(), glyph_data_.rend(),
-                         start_character_index, comparer);
-    if (UNLIKELY(start_glyph == glyph_data_.rend()))
-      return {nullptr, nullptr};
-    auto end_glyph = std::lower_bound(start_glyph, glyph_data_.rend(),
-                                      end_character_index, comparer);
-    // Convert reverse iterators to pointers. Then increment to make |begin|
-    // inclusive and |end| exclusive.
-    return {&*end_glyph + 1, &*start_glyph + 1};
+                                    unsigned end_character_index) const {
+    GlyphDataRange range = GetGlyphDataRange().FindGlyphDataRange(
+        IsRtl(), start_character_index, end_character_index);
+    return range;
   }
 
   // Creates a new RunInfo instance representing a subset of the current run.
-  std::unique_ptr<RunInfo> CreateSubRun(unsigned start, unsigned end) {
+  // Returns |nullptr| if there are no glyphs in the specified range.
+  scoped_refptr<RunInfo> CreateSubRun(unsigned start, unsigned end) {
     DCHECK(end > start);
     unsigned number_of_characters = std::min(end - start, num_characters_);
     auto glyphs = FindGlyphDataRange(start, end);
-    unsigned number_of_glyphs = std::distance(glyphs.begin, glyphs.end);
+    unsigned number_of_glyphs =
+        static_cast<unsigned>(std::distance(glyphs.begin, glyphs.end));
+    if (UNLIKELY(!number_of_glyphs))
+      return nullptr;
 
-    Vector<unsigned> sub_graphemes;
-    if (graphemes_.size()) {
-      sub_graphemes.resize(number_of_characters);
-      for (unsigned i = 0; i < number_of_characters; ++i) {
-        sub_graphemes[i] = graphemes_[start + i];
-      }
-    }
+    auto run =
+        Create(font_data_.get(), direction_, canvas_rotation_, script_,
+               start_index_ + start, number_of_glyphs, number_of_characters);
 
-    auto run = std::make_unique<RunInfo>(
-        font_data_.get(), direction_, canvas_rotation_, script_,
-        start_index_ + start, number_of_glyphs, number_of_characters,
-        std::move(sub_graphemes));
-
-    static_assert(base::is_trivially_copyable<HarfBuzzRunGlyphData>::value,
-                  "HarfBuzzRunGlyphData should be trivially copyable");
-    std::copy(glyphs.begin, glyphs.end, run->glyph_data_.begin());
+    run->glyph_data_.CopyFromRange(glyphs);
 
     float total_advance = 0;
     for (HarfBuzzRunGlyphData& glyph_data : run->glyph_data_) {
@@ -201,62 +197,46 @@ struct ShapeResult::RunInfo {
     return run;
   }
 
-  // Iterates over, and applies the functor to all the glyphs in this run.
-  // Also tracks (and returns) a seeded total advance.
-  //
-  // Functor signature:
-  //
-  //   bool func(const HarfBuzzRunGlyphData& glyphData, float totalAdvance)
-  //
-  // where the returned bool signals whether iteration should continue (true)
-  // or stop (false).
-  template <typename Func>
-  float ForEachGlyph(float initial_advance, Func func) const {
-    float total_advance = initial_advance;
-
-    for (const auto& glyph_data : glyph_data_) {
-      if (!func(glyph_data, total_advance))
-        break;
-      total_advance += glyph_data.advance;
+  // Returns new |RunInfo| if |this| and |other| are merged. Otherwise returns
+  // null.
+  scoped_refptr<RunInfo> MergeIfPossible(const RunInfo& other) const {
+    if (!CanMerge(other))
+      return nullptr;
+    DCHECK_LT(start_index_, other.start_index_);
+    auto run =
+        Create(font_data_.get(), direction_, canvas_rotation_, script_,
+               start_index_, glyph_data_.size() + other.glyph_data_.size(),
+               num_characters_ + other.num_characters_);
+    // Note: We populate |graphemes_| on demand, e.g. hit testing.
+    const int index_adjust = other.start_index_ - start_index_;
+    if (UNLIKELY(IsRtl())) {
+      run->glyph_data_.CopyFrom(other.glyph_data_, glyph_data_);
+      auto* const end = run->glyph_data_.begin() + other.glyph_data_.size();
+      for (auto* it = run->glyph_data_.begin(); it < end; ++it)
+        it->character_index += index_adjust;
+    } else {
+      run->glyph_data_.CopyFrom(glyph_data_, other.glyph_data_);
+      auto* const end = run->glyph_data_.end();
+      for (auto* it = run->glyph_data_.begin() + glyph_data_.size(); it < end;
+           ++it)
+        it->character_index += index_adjust;
     }
-
-    return total_advance;
+    run->width_ = width_ + other.width_;
+    return run;
   }
 
-  // Same as the above, except it only applies the functor to glyphs in the
-  // specified range, and stops after the range.
-  template <typename Func>
-  float ForEachGlyphInRange(float initial_advance,
-                            unsigned from,
-                            unsigned to,
-                            unsigned index_offset,
-                            Func func) const {
-    return ForEachGlyph(
-        initial_advance,
-        [&](const HarfBuzzRunGlyphData& glyph_data,
-            float total_advance) -> bool {
-          const unsigned character_index =
-              start_index_ + glyph_data.character_index + index_offset;
-
-          if (character_index < from) {
-            // Glyph out-of-range; before the range (and must continue
-            // accumulating advance) in LTR.
-            return !Rtl();
-          }
-
-          if (character_index >= to) {
-            // Glyph out-of-range; before the range (and must continue
-            // accumulating advance) in RTL.
-            return Rtl();
-          }
-
-          // Glyph in range; apply functor.
-          return func(glyph_data, total_advance, character_index);
-        });
+  // Returns true if |other| can be merged at end of |this|.
+  bool CanMerge(const RunInfo& other) const {
+    return start_index_ + num_characters_ == other.start_index_ &&
+           canvas_rotation_ == other.canvas_rotation_ &&
+           font_data_ == other.font_data_ && direction_ == other.direction_ &&
+           script_ == other.script_ &&
+           glyph_data_.size() + other.glyph_data_.size() <
+               HarfBuzzRunGlyphData::kMaxCharacterIndex + 1;
   }
 
   void ExpandRangeToIncludePartialGlyphs(int offset, int* from, int* to) const {
-    int start = !Rtl() ? offset : (offset + num_characters_);
+    int start = IsLtr() ? offset : (offset + num_characters_);
     int end = offset + num_characters_;
 
     for (unsigned i = 0; i < glyph_data_.size(); ++i) {
@@ -264,7 +244,7 @@ struct ShapeResult::RunInfo {
       if (start == index)
         continue;
 
-      if (!Rtl())
+      if (IsLtr())
         end = index;
 
       if (end > *from && start < *to) {
@@ -272,8 +252,8 @@ struct ShapeResult::RunInfo {
         *to = std::max(*to, end);
       }
 
-      if (!Rtl())
-        end = num_characters_;
+      if (IsLtr())
+        end = offset + num_characters_;
       else
         end = start;
       start = index;
@@ -285,13 +265,275 @@ struct ShapeResult::RunInfo {
     }
   }
 
+  // Common signatures with RunInfoPart, to templatize algorithms.
+  const RunInfo* GetRunInfo() const { return this; }
+  const GlyphDataRange GetGlyphDataRange() const {
+    return {glyph_data_.begin(), glyph_data_.end(),
+            glyph_data_.GetMayBeOffsets()};
+  }
+  unsigned OffsetToRunStartIndex() const { return 0; }
+
+  class GlyphDataCollection;
+
+  // A array of glyph offsets. If all offsets are zero, we don't allocate
+  // storage for reducing memory usage.
+  class GlyphOffsetArray final {
+   public:
+    explicit GlyphOffsetArray(unsigned size) : size_(size) {}
+
+    GlyphOffsetArray(const GlyphOffsetArray& other) : size_(other.size_) {
+      if (!other.storage_)
+        return;
+      std::copy(other.storage_.get(), other.storage_.get() + other.size(),
+                AllocateStorage());
+    }
+
+    // A return value of |GetOffsets()| to represent optional |GlyphOffset|
+    // array.
+    template <bool has_non_zero_glyph_offsets>
+    struct iterator final {};
+
+    template <bool has_non_zero_glyph_offsets>
+    iterator<has_non_zero_glyph_offsets> GetIterator() const {
+      return iterator<has_non_zero_glyph_offsets>(*this);
+    }
+
+    template <bool has_non_zero_glyph_offsets>
+    iterator<has_non_zero_glyph_offsets> GetIteratorForRange(
+        const GlyphDataRange& range) const {
+      return iterator<has_non_zero_glyph_offsets>(range);
+    }
+
+    unsigned size() const { return size_; }
+    bool IsEmpty() const { return size() == 0; }
+
+    size_t ByteSize() const {
+      return storage_ ? size() * sizeof(GlyphOffset) : 0;
+    }
+
+    void CopyFrom(const GlyphOffsetArray& other1,
+                  const GlyphOffsetArray& other2) {
+      SECURITY_CHECK(size() == other1.size() + other2.size());
+      DCHECK(!other1.IsEmpty());
+      DCHECK(!other2.IsEmpty());
+      if (other1.storage_) {
+        if (!storage_)
+          AllocateStorage();
+        std::copy(other1.storage_.get(), other1.storage_.get() + other1.size(),
+                  storage_.get());
+      }
+      if (other2.storage_) {
+        if (!storage_)
+          AllocateStorage();
+        std::copy(other2.storage_.get(), other2.storage_.get() + other2.size(),
+                  storage_.get() + other1.size());
+      }
+    }
+
+    void CopyFromRange(const GlyphDataRange& range) {
+      DCHECK_EQ(range.size(), size());
+      if (!range.offsets || range.size() == 0) {
+        storage_.reset();
+        return;
+      }
+      std::copy(range.offsets, range.offsets + range.size(), AllocateStorage());
+    }
+
+    GlyphOffset* GetStorage() const { return storage_.get(); }
+    bool HasStorage() const { return storage_.get(); }
+
+    void Reverse() {
+      if (!storage_)
+        return;
+      std::reverse(storage_.get(), storage_.get() + size());
+    }
+
+    void Shrink(unsigned new_size) {
+      DCHECK_GE(new_size, 1u);
+      // Note: To follow Vector<T>::Shrink(), we accept |new_size == size()|
+      if (new_size == size())
+        return;
+      DCHECK_LT(new_size, size());
+      size_ = new_size;
+      if (!storage_)
+        return;
+      GlyphOffset* new_offsets = new GlyphOffset[new_size];
+      std::copy(storage_.get(), storage_.get() + new_size, new_offsets);
+      storage_.reset(new_offsets);
+    }
+
+    // Functions to change one element.
+    void AddHeightAt(unsigned index, float delta) {
+      DCHECK_LT(index, size());
+      DCHECK_NE(delta, 0.0f);
+      if (!storage_)
+        AllocateStorage();
+      storage_[index].SetHeight(storage_[index].Height() + delta);
+    }
+
+    void AddWidthAt(unsigned index, float delta) {
+      DCHECK_LT(index, size());
+      DCHECK_NE(delta, 0.0f);
+      if (!storage_)
+        AllocateStorage();
+      storage_[index].SetWidth(storage_[index].Width() + delta);
+    }
+
+    void SetAt(unsigned index, GlyphOffset offset) {
+      DCHECK_LT(index, size());
+      if (!storage_) {
+        if (offset.Width() == 0 && offset.Height() == 0)
+          return;
+        AllocateStorage();
+      }
+      storage_[index] = offset;
+    }
+
+   private:
+    // Note: HarfBuzzShaperTest.ShapeVerticalUpright uses non-zero glyph offset.
+    GlyphOffset* AllocateStorage() {
+      DCHECK_GE(size(), 1u);
+      DCHECK(!storage_);
+      storage_.reset(new GlyphOffset[size()]);
+      return storage_.get();
+    }
+
+    std::unique_ptr<GlyphOffset[]> storage_;
+    unsigned size_;
+  };
+
+  // Collection of |HarfBuzzRunGlyphData| with optional glyph offset
+  class GlyphDataCollection final {
+   public:
+    explicit GlyphDataCollection(unsigned num_glyphs)
+        : data_(new HarfBuzzRunGlyphData[num_glyphs]), offsets_(num_glyphs) {}
+
+    GlyphDataCollection(const GlyphDataCollection& other)
+        : data_(new HarfBuzzRunGlyphData[other.size()]),
+          offsets_(other.offsets_) {
+      static_assert(base::is_trivially_copyable<HarfBuzzRunGlyphData>::value,
+                    "HarfBuzzRunGlyphData should be trivially copyable");
+      std::copy(other.data_.get(), other.data_.get() + other.size(),
+                data_.get());
+    }
+
+    HarfBuzzRunGlyphData& operator[](unsigned index) {
+      DCHECK_LT(index, size());
+      return data_[index];
+    }
+
+    const HarfBuzzRunGlyphData& operator[](unsigned index) const {
+      DCHECK_LT(index, size());
+      return data_[index];
+    }
+
+    bool HasNonZeroOffsets() const { return offsets_.HasStorage(); }
+
+    size_t ByteSize() const {
+      return sizeof(*this) + size() * sizeof(HarfBuzzRunGlyphData) +
+             offsets_.ByteSize();
+    }
+
+    template <bool has_non_zero_glyph_offsets>
+    GlyphOffsetArray::iterator<has_non_zero_glyph_offsets> GetOffsets() const {
+      return offsets_.GetIterator<has_non_zero_glyph_offsets>();
+    }
+
+    GlyphOffset* GetMayBeOffsets() const { return offsets_.GetStorage(); }
+
+    // Note: Caller should be adjust |HarfBuzzRunGlyphData.character_index|.
+    void CopyFrom(const GlyphDataCollection& other1,
+                  const GlyphDataCollection& other2) {
+      SECURITY_CHECK(size() == other1.size() + other2.size());
+      DCHECK(!other1.IsEmpty());
+      DCHECK(!other2.IsEmpty());
+      std::copy(other1.data_.get(), other1.data_.get() + other1.size(),
+                data_.get());
+      std::copy(other2.data_.get(), other2.data_.get() + other2.size(),
+                data_.get() + other1.size());
+      offsets_.CopyFrom(other1.offsets_, other2.offsets_);
+    }
+
+    // Note: Caller should be adjust |HarfBuzzRunGlyphData.character_index|.
+    void CopyFromRange(const GlyphDataRange& range) {
+      DCHECK_EQ(static_cast<size_t>(range.end - range.begin), size());
+      static_assert(base::is_trivially_copyable<HarfBuzzRunGlyphData>::value,
+                    "HarfBuzzRunGlyphData should be trivially copyable");
+      std::copy(range.begin, range.end, data_.get());
+      offsets_.CopyFromRange(range);
+    }
+
+    void AddOffsetHeightAt(unsigned index, float delta) {
+      offsets_.AddHeightAt(index, delta);
+    }
+
+    void AddOffsetWidthAt(unsigned index, float delta) {
+      offsets_.AddWidthAt(index, delta);
+    }
+
+    void SetOffsetAt(unsigned index, GlyphOffset offset) {
+      offsets_.SetAt(index, offset);
+    }
+
+    // Vector<HarfBuzzRunGlyphData> like functions
+    using iterator = HarfBuzzRunGlyphData*;
+    using const_iterator = const HarfBuzzRunGlyphData*;
+    iterator begin() { return data_.get(); }
+    iterator end() { return data_.get() + size(); }
+    const_iterator begin() const { return data_.get(); }
+    const_iterator end() const { return data_.get() + size(); }
+
+    using reverse_iterator = std::reverse_iterator<iterator>;
+    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
+    reverse_iterator rbegin() { return std::make_reverse_iterator(end()); }
+    reverse_iterator rend() { return std::make_reverse_iterator(begin()); }
+    const_reverse_iterator rbegin() const {
+      return std::make_reverse_iterator(end());
+    }
+    const_reverse_iterator rend() const {
+      return std::make_reverse_iterator(begin());
+    }
+
+    unsigned size() const { return offsets_.size(); }
+    bool IsEmpty() const { return size() == 0; }
+
+    const HarfBuzzRunGlyphData& front() const {
+      CHECK(!IsEmpty());
+      return (*this)[0];
+    }
+    const HarfBuzzRunGlyphData& back() const {
+      CHECK(!IsEmpty());
+      return (*this)[size() - 1];
+    }
+
+    void Reverse() {
+      std::reverse(begin(), end());
+      offsets_.Reverse();
+    }
+
+    void Shrink(unsigned new_size) {
+      DCHECK_GE(new_size, 1u);
+      // Note: To follow Vector<T>::Shrink(), we accept |new_size == size()|
+      if (new_size == size())
+        return;
+      DCHECK_LT(new_size, size());
+      HarfBuzzRunGlyphData* new_data = new HarfBuzzRunGlyphData[new_size];
+      std::copy(data_.get(), data_.get() + new_size, new_data);
+      data_.reset(new_data);
+      offsets_.Shrink(new_size);
+    }
+
+   private:
+    // Note: |offsets_| holds number of elements instead o here to reduce
+    // memory usage.
+    std::unique_ptr<HarfBuzzRunGlyphData[]> data_;
+    // |offsets_| holds collection of offset for |data_[i]|.
+    // When all offsets are zero, we don't allocate for reducing memory usage.
+    GlyphOffsetArray offsets_;
+  };
+
+  GlyphDataCollection glyph_data_;
   scoped_refptr<SimpleFontData> font_data_;
-  hb_direction_t direction_;
-  // For upright-in-vertical we need to tell the ShapeResultBloberizer to rotate
-  // the canvas back 90deg for this RunInfo.
-  CanvasRotationInVertical canvas_rotation_;
-  hb_script_t script_;
-  Vector<HarfBuzzRunGlyphData> glyph_data_;
 
   // graphemes_[i] is the number of graphemes up to (and including) the ith
   // character in the run.
@@ -300,8 +542,88 @@ struct ShapeResult::RunInfo {
   unsigned start_index_;
   unsigned num_characters_;
   float width_;
+
+  hb_script_t script_;
+  hb_direction_t direction_;
+
+  // For upright-in-vertical we need to tell the ShapeResultBloberizer to rotate
+  // the canvas back 90deg for this RunInfo.
+  CanvasRotationInVertical canvas_rotation_;
 };
 
+// For non-zero glyph offset array
+template <>
+struct ShapeResult::RunInfo::GlyphOffsetArray::iterator<true> final {
+  // The constructor for ShapeResult
+  explicit iterator(const GlyphOffsetArray& array)
+      : pointer(array.storage_.get()) {
+    DCHECK(pointer);
+  }
+
+  // The constructor for ShapeResultView
+  explicit iterator(const GlyphDataRange& range) : pointer(range.offsets) {
+    DCHECK(pointer);
+  }
+
+  GlyphOffset operator*() const { return *pointer; }
+  void operator++() { ++pointer; }
+
+  const GlyphOffset* pointer;
+};
+
+// For zero glyph offset array
+template <>
+struct ShapeResult::RunInfo::GlyphOffsetArray::iterator<false> final {
+  explicit iterator(const GlyphOffsetArray& array) {
+    DCHECK(!array.HasStorage());
+  }
+  explicit iterator(const GlyphDataRange& range) { DCHECK(!range.offsets); }
+  GlyphOffset operator*() const { return GlyphOffset(); }
+  void operator++() {}
+};
+
+// Find the range of HarfBuzzRunGlyphData for the specified character index
+// range. This function uses binary search twice, hence O(2 log n).
+inline ShapeResult::RunInfo::GlyphDataRange
+ShapeResult::RunInfo::GlyphDataRange::FindGlyphDataRange(
+    bool is_rtl,
+    unsigned start_character_index,
+    unsigned end_character_index) const {
+  const auto comparer = [](const HarfBuzzRunGlyphData& glyph_data,
+                           unsigned index) {
+    return glyph_data.character_index < index;
+  };
+  if (!is_rtl) {
+    const HarfBuzzRunGlyphData* start_glyph =
+        std::lower_bound(begin, end, start_character_index, comparer);
+    if (UNLIKELY(start_glyph == end))
+      return GlyphDataRange();
+    const HarfBuzzRunGlyphData* end_glyph =
+        std::lower_bound(start_glyph, end, end_character_index, comparer);
+    if (offsets)
+      return {start_glyph, end_glyph, offsets + (start_glyph - begin)};
+    return {start_glyph, end_glyph, nullptr};
+  }
+
+  // RTL needs to use reverse iterators because there maybe multiple glyphs
+  // for a character, and we want to find the first one in the logical order.
+  const auto rbegin = std::reverse_iterator<const HarfBuzzRunGlyphData*>(end);
+  const auto rend = std::reverse_iterator<const HarfBuzzRunGlyphData*>(begin);
+  const auto start_glyph_it =
+      std::lower_bound(rbegin, rend, start_character_index, comparer);
+  if (UNLIKELY(start_glyph_it == rend))
+    return GlyphDataRange();
+  const auto end_glyph_it =
+      std::lower_bound(start_glyph_it, rend, end_character_index, comparer);
+  // Convert reverse iterators to pointers. Then increment to make |begin|
+  // inclusive and |end| exclusive.
+  const HarfBuzzRunGlyphData* start_glyph = &*end_glyph_it + 1;
+  const HarfBuzzRunGlyphData* end_glyph = &*start_glyph_it + 1;
+  if (offsets)
+    return {start_glyph, end_glyph, offsets + (start_glyph - begin)};
+  return {start_glyph, end_glyph, nullptr};
+}
+
 }  // namespace blink
 
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_SHAPE_RESULT_INLINE_HEADERS_H_
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_run_info_test.cc b/third_party/blink/renderer/platform/fonts/shaping/shape_result_run_info_test.cc
new file mode 100644
index 000000000000..cc95d8b1d792
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_run_info_test.cc
@@ -0,0 +1,104 @@
+// Copyright (c) 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace blink {
+
+class ShapeResultRunInfoTest : public testing::Test {};
+
+TEST_F(ShapeResultRunInfoTest, CopyConstructor) {
+  ShapeResult::RunInfo::GlyphOffsetArray offsets(2);
+
+  ShapeResult::RunInfo::GlyphOffsetArray offsets2(offsets);
+  EXPECT_FALSE(offsets2.HasStorage());
+
+  offsets.SetAt(0, ShapeResult::GlyphOffset(1, 1));
+  ShapeResult::RunInfo::GlyphOffsetArray offsets3(offsets);
+  ASSERT_TRUE(offsets3.HasStorage());
+  EXPECT_EQ(ShapeResult::GlyphOffset(1, 1), offsets3.GetStorage()[0]);
+}
+
+TEST_F(ShapeResultRunInfoTest, CopyFromRange) {
+  ShapeResult::RunInfo::GlyphOffsetArray offsets(2);
+  HarfBuzzRunGlyphData glyhp_data[2];
+
+  ShapeResult::RunInfo::GlyphOffsetArray offsets2(2);
+  offsets2.CopyFromRange({&glyhp_data[0], &glyhp_data[2], nullptr});
+  EXPECT_FALSE(offsets2.HasStorage());
+
+  offsets.SetAt(0, ShapeResult::GlyphOffset(1, 1));
+  ASSERT_TRUE(offsets.HasStorage());
+
+  ShapeResult::RunInfo::GlyphOffsetArray offsets3(2);
+  offsets3.CopyFromRange(
+      {&glyhp_data[0], &glyhp_data[2], offsets.GetStorage()});
+  ASSERT_TRUE(offsets3.HasStorage());
+  EXPECT_EQ(ShapeResult::GlyphOffset(1, 1), offsets3.GetStorage()[0]);
+}
+
+TEST_F(ShapeResultRunInfoTest, GlyphOffsetArrayReverse) {
+  ShapeResult::RunInfo::GlyphOffsetArray offsets(2);
+
+  offsets.Reverse();
+  EXPECT_FALSE(offsets.HasStorage());
+
+  offsets.SetAt(0, ShapeResult::GlyphOffset(1, 1));
+  ASSERT_TRUE(offsets.HasStorage());
+  offsets.Reverse();
+  EXPECT_EQ(ShapeResult::GlyphOffset(), offsets.GetStorage()[0]);
+  EXPECT_EQ(ShapeResult::GlyphOffset(1, 1), offsets.GetStorage()[1]);
+}
+
+TEST_F(ShapeResultRunInfoTest, GlyphOffsetArraySetAddOffsetHeightAt) {
+  ShapeResult::RunInfo::GlyphOffsetArray offsets(2);
+
+  offsets.AddHeightAt(1, 1.5f);
+  ASSERT_TRUE(offsets.HasStorage());
+  EXPECT_EQ(ShapeResult::GlyphOffset(0, 1.5f), offsets.GetStorage()[1]);
+
+  offsets.AddHeightAt(1, 2.0f);
+  ASSERT_TRUE(offsets.HasStorage());
+  EXPECT_EQ(ShapeResult::GlyphOffset(0, 3.5f), offsets.GetStorage()[1]);
+}
+
+TEST_F(ShapeResultRunInfoTest, GlyphOffsetArraySetAddOffsetWidthAt) {
+  ShapeResult::RunInfo::GlyphOffsetArray offsets(2);
+
+  offsets.AddWidthAt(1, 1.5f);
+  ASSERT_TRUE(offsets.HasStorage());
+  EXPECT_EQ(ShapeResult::GlyphOffset(1.5f, 0), offsets.GetStorage()[1]);
+
+  offsets.AddWidthAt(1, 2.0f);
+  ASSERT_TRUE(offsets.HasStorage());
+  EXPECT_EQ(ShapeResult::GlyphOffset(3.5f, 0), offsets.GetStorage()[1]);
+}
+
+TEST_F(ShapeResultRunInfoTest, GlyphOffsetArraySetAt) {
+  ShapeResult::RunInfo::GlyphOffsetArray offsets(2);
+
+  offsets.SetAt(0, ShapeResult::GlyphOffset());
+  EXPECT_FALSE(offsets.HasStorage());
+
+  offsets.SetAt(1, ShapeResult::GlyphOffset(1, 1));
+  EXPECT_TRUE(offsets.HasStorage());
+}
+
+TEST_F(ShapeResultRunInfoTest, GlyphOffsetArrayShrink) {
+  ShapeResult::RunInfo::GlyphOffsetArray offsets(3);
+
+  offsets.Shrink(2);
+  EXPECT_FALSE(offsets.HasStorage());
+
+  offsets.SetAt(0, ShapeResult::GlyphOffset(1, 1));
+  ASSERT_TRUE(offsets.HasStorage());
+
+  offsets.Shrink(1);
+  ASSERT_TRUE(offsets.HasStorage());
+  EXPECT_EQ(ShapeResult::GlyphOffset(1, 1), offsets.GetStorage()[0]);
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.cc b/third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.cc
index 8e6a111da184..326648748f72 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.cc
@@ -4,30 +4,17 @@
 
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.h"
 
+#include "third_party/blink/renderer/platform/fonts/font.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
 #include "third_party/blink/renderer/platform/text/text_run.h"
 
 namespace blink {
 
 template <typename TextContainerType>
-ShapeResultSpacing<TextContainerType>::ShapeResultSpacing(
-    const TextContainerType& text)
-    : text_(text),
-      letter_spacing_(0),
-      word_spacing_(0),
-      expansion_(0),
-      expansion_per_opportunity_(0),
-      expansion_opportunity_count_(0),
-      text_justify_(TextJustify::kAuto),
-      has_spacing_(false),
-      normalize_space_(false),
-      allow_tabs_(false),
-      is_after_expansion_(false) {}
-
-template <typename TextContainerType>
-bool ShapeResultSpacing<TextContainerType>::SetSpacing(
-    const FontDescription& font_description) {
-  if (!font_description.LetterSpacing() && !font_description.WordSpacing()) {
+bool ShapeResultSpacing<TextContainerType>::SetSpacing(const Font& font) {
+  const FontDescription& font_description = font.GetFontDescription();
+  if (!font_description.LetterSpacing() && !font_description.WordSpacing() &&
+      !font.HasAdvanceOverride()) {
     has_spacing_ = false;
     return false;
   }
@@ -56,18 +43,19 @@ void ShapeResultSpacing<TextContainerType>::SetExpansion(
 
 template <typename TextContainerType>
 void ShapeResultSpacing<TextContainerType>::SetSpacingAndExpansion(
-    const FontDescription& font_description) {
+    const Font& font) {
   // Available only for TextRun since it has expansion data.
   NOTREACHED();
 }
 
 template <>
-void ShapeResultSpacing<TextRun>::SetSpacingAndExpansion(
-    const FontDescription& font_description) {
+void ShapeResultSpacing<TextRun>::SetSpacingAndExpansion(const Font& font) {
+  const FontDescription& font_description = font.GetFontDescription();
   letter_spacing_ = font_description.LetterSpacing();
   word_spacing_ = font_description.WordSpacing();
   expansion_ = text_.Expansion();
-  has_spacing_ = letter_spacing_ || word_spacing_ || expansion_;
+  has_spacing_ = letter_spacing_ || word_spacing_ || expansion_ ||
+                 font.HasAdvanceOverride();
   if (!has_spacing_)
     return;
 
@@ -99,12 +87,10 @@ void ShapeResultSpacing<TextContainerType>::ComputeExpansion(
   bool is_after_expansion = is_after_expansion_;
   if (text_.Is8Bit()) {
     expansion_opportunity_count_ = Character::ExpansionOpportunityCount(
-        text_.Characters8(), text_.length(), direction, is_after_expansion,
-        text_justify_);
+        text_.Span8(), direction, is_after_expansion, text_justify_);
   } else {
     expansion_opportunity_count_ = Character::ExpansionOpportunityCount(
-        text_.Characters16(), text_.length(), direction, is_after_expansion,
-        text_justify_);
+        text_.Span16(), direction, is_after_expansion, text_justify_);
   }
   if (is_after_expansion && !allows_trailing_expansion) {
     DCHECK_GT(expansion_opportunity_count_, 0u);
@@ -135,9 +121,11 @@ float ShapeResultSpacing<TextContainerType>::NextExpansion() {
 }
 
 template <typename TextContainerType>
-float ShapeResultSpacing<TextContainerType>::ComputeSpacing(unsigned index,
-                                                            float& offset) {
+float ShapeResultSpacing<TextContainerType>::ComputeSpacing(
+    const ComputeSpacingParameters& parameters,
+    float& offset) {
   DCHECK(has_spacing_);
+  unsigned index = parameters.index;
   UChar32 character = text_[index];
   bool treat_as_space =
       (Character::TreatAsSpace(character) ||
@@ -148,8 +136,14 @@ float ShapeResultSpacing<TextContainerType>::ComputeSpacing(unsigned index,
     character = kSpaceCharacter;
 
   float spacing = 0;
-  if (letter_spacing_ && !Character::TreatAsZeroWidthSpace(character))
-    spacing += letter_spacing_;
+
+  bool has_letter_spacing =
+      letter_spacing_ || (parameters.advance_override != 1.0);
+  if (has_letter_spacing && !Character::TreatAsZeroWidthSpace(character)) {
+    spacing +=
+        parameters.original_advance * (parameters.advance_override - 1.0) +
+        letter_spacing_;
+  }
 
   if (treat_as_space && (index || character == kNoBreakSpaceCharacter))
     spacing += word_spacing_;
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.h b/third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.h
index 391de4222b88..3e32be027015 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.h
@@ -7,11 +7,11 @@
 
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/text/character.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
 namespace blink {
 
-class FontDescription;
+class Font;
 
 // A context object to apply letter-spacing, word-spacing, and justification to
 // ShapeResult.
@@ -20,15 +20,32 @@ class PLATFORM_EXPORT ShapeResultSpacing final {
   STACK_ALLOCATED();
 
  public:
-  explicit ShapeResultSpacing(const TextContainerType&);
+  explicit ShapeResultSpacing(const TextContainerType& text)
+      : text_(text),
+        letter_spacing_(0),
+        word_spacing_(0),
+        expansion_(0),
+        expansion_per_opportunity_(0),
+        expansion_opportunity_count_(0),
+        text_justify_(TextJustify::kAuto),
+        has_spacing_(false),
+        normalize_space_(false),
+        allow_tabs_(false),
+        is_after_expansion_(false) {}
 
   const TextContainerType& Text() const { return text_; }
-  float LetterSpacing() const { return letter_spacing_; }
+  float LetterSpacing() const { return has_spacing_ ? letter_spacing_ : .0f; }
+  float WordSpacing() const { return has_spacing_ ? word_spacing_ : .0f; }
   bool HasSpacing() const { return has_spacing_; }
   bool HasExpansion() const { return expansion_opportunity_count_; }
+  unsigned ExpansionOppotunityCount() const {
+    return expansion_opportunity_count_;
+  }
 
-  // Set letter-spacing and word-spacing.
-  bool SetSpacing(const FontDescription&);
+  // Set letter-spacing, word-spacing, and advance-override. Uses a Font
+  // argument instead of FontDescription as advance-override is retrieved
+  // from CSS @font-face, not from style like word-spacing and letter-spacing.
+  bool SetSpacing(const Font&);
 
   // Set the expansion for the justification.
   void SetExpansion(float expansion,
@@ -37,15 +54,24 @@ class PLATFORM_EXPORT ShapeResultSpacing final {
                     bool allows_leading_expansion = false,
                     bool allows_trailing_expansion = false);
 
-  // Set letter-spacing, word-spacing, and justification.
-  // Available only for TextRun.
-  void SetSpacingAndExpansion(const FontDescription&);
+  // Set letter-spacing, word-spacing, advance-override and
+  // justification. Available only for TextRun.
+  void SetSpacingAndExpansion(const Font&);
 
   // Compute the sum of all spacings for the specified |index|.
   // The |index| is for the |TextContainerType| given in the constructor.
   // For justification, this function must be called incrementally since it
   // keeps states and counts consumed justification opportunities.
-  float ComputeSpacing(unsigned index, float& offset);
+  struct ComputeSpacingParameters {
+    unsigned index;
+    float original_advance = 0.0;
+    float advance_override = 1.0;
+  };
+  float ComputeSpacing(unsigned index, float& offset) {
+    return ComputeSpacing(ComputeSpacingParameters{.index = index}, offset);
+  }
+  float ComputeSpacing(const ComputeSpacingParameters& parameters,
+                       float& offset);
 
  private:
   bool IsAfterExpansion() const { return is_after_expansion_; }
@@ -73,8 +99,7 @@ class PLATFORM_EXPORT ShapeResultSpacing final {
 // Forward declare so no implicit instantiations happen before the
 // first explicit instantiation (which would be a C++ violation).
 template <>
-void ShapeResultSpacing<TextRun>::SetSpacingAndExpansion(
-    const FontDescription&);
+void ShapeResultSpacing<TextRun>::SetSpacingAndExpansion(const Font&);
 }  // namespace blink
 
 #endif
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_test.cc b/third_party/blink/renderer/platform/fonts/shaping/shape_result_test.cc
new file mode 100644
index 000000000000..dd6b2700ebb8
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_test.cc
@@ -0,0 +1,314 @@
+// Copyright (c) 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h"
+
+#include "base/containers/span.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/fonts/font.h"
+#include "third_party/blink/renderer/platform/fonts/font_cache.h"
+#include "third_party/blink/renderer/platform/fonts/font_test_utilities.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.h"
+#include "third_party/blink/renderer/platform/testing/font_test_helpers.h"
+#include "third_party/blink/renderer/platform/testing/unit_test_helpers.h"
+
+namespace blink {
+
+class ShapeResultTest : public testing::Test {
+ protected:
+  void SetUp() override {
+    font_description.SetComputedSize(12.0);
+    font = Font(font_description);
+
+    FontDescription::VariantLigatures ligatures;
+    arabic_font = blink::test::CreateTestFont(
+        "Noto",
+        blink::test::PlatformTestDataPath(
+            "third_party/Noto/NotoNaskhArabic-regular.woff2"),
+        12.0, &ligatures);
+  }
+
+  void TearDown() override {}
+
+  void TestCopyRangesLatin(const ShapeResult*) const;
+  void TestCopyRangesArabic(const ShapeResult*) const;
+
+  static bool HasNonZeroGlyphOffsets(const ShapeResult& result) {
+    for (const auto& run : result.RunsOrParts()) {
+      if (run->glyph_data_.HasNonZeroOffsets())
+        return true;
+    }
+    return false;
+  }
+
+  // Release the ShapeResults held inside an array of ShapeResult::ShapeRange
+  // instances.
+  static void ReleaseShapeRange(base::span<ShapeResult::ShapeRange> ranges) {
+    for (auto& range : ranges) {
+      range.target->Release();
+    }
+  }
+
+  ShapeResult* CreateShapeResult(TextDirection direction) const {
+    return new ShapeResult(
+        direction == TextDirection::kLtr ? &font : &arabic_font, 0, 0,
+        direction);
+  }
+
+  FontCachePurgePreventer font_cache_purge_preventer;
+  FontDescription font_description;
+  Font font;
+  Font arabic_font;
+};
+
+void ShapeResultTest::TestCopyRangesLatin(const ShapeResult* result) const {
+  const unsigned num_ranges = 4;
+  ShapeResult::ShapeRange ranges[num_ranges] = {
+      {0, 10, CreateShapeResult(TextDirection::kLtr)},
+      {10, 20, CreateShapeResult(TextDirection::kLtr)},
+      {20, 30, CreateShapeResult(TextDirection::kLtr)},
+      {30, 38, CreateShapeResult(TextDirection::kLtr)}};
+  result->CopyRanges(&ranges[0], num_ranges);
+
+  Vector<ShapeResultTestGlyphInfo> glyphs[num_ranges];
+  for (unsigned i = 0; i < num_ranges; i++)
+    ComputeGlyphResults(*ranges[i].target, &glyphs[i]);
+  EXPECT_EQ(glyphs[0].size(), 10u);
+  EXPECT_EQ(glyphs[1].size(), 10u);
+  EXPECT_EQ(glyphs[2].size(), 10u);
+  EXPECT_EQ(glyphs[3].size(), 8u);
+
+  scoped_refptr<ShapeResult> reference[num_ranges];
+  reference[0] = result->SubRange(0, 10);
+  reference[1] = result->SubRange(10, 20);
+  reference[2] = result->SubRange(20, 30);
+  reference[3] = result->SubRange(30, 38);
+  Vector<ShapeResultTestGlyphInfo> reference_glyphs[num_ranges];
+  for (unsigned i = 0; i < num_ranges; i++)
+    ComputeGlyphResults(*reference[i], &reference_glyphs[i]);
+  EXPECT_EQ(reference_glyphs[0].size(), 10u);
+  EXPECT_EQ(reference_glyphs[1].size(), 10u);
+  EXPECT_EQ(reference_glyphs[2].size(), 10u);
+  EXPECT_EQ(reference_glyphs[3].size(), 8u);
+
+  EXPECT_TRUE(CompareResultGlyphs(glyphs[0], reference_glyphs[0], 0u, 10u));
+  EXPECT_TRUE(CompareResultGlyphs(glyphs[1], reference_glyphs[1], 0u, 10u));
+  EXPECT_TRUE(CompareResultGlyphs(glyphs[2], reference_glyphs[2], 0u, 10u));
+  EXPECT_TRUE(CompareResultGlyphs(glyphs[3], reference_glyphs[3], 0u, 8u));
+  ReleaseShapeRange(ranges);
+}
+
+void ShapeResultTest::TestCopyRangesArabic(const ShapeResult* result) const {
+  const unsigned num_ranges = 4;
+  ShapeResult::ShapeRange ranges[num_ranges] = {
+      {0, 4, CreateShapeResult(TextDirection::kRtl)},
+      {4, 7, CreateShapeResult(TextDirection::kRtl)},
+      {7, 10, CreateShapeResult(TextDirection::kRtl)},
+      {10, 15, CreateShapeResult(TextDirection::kRtl)}};
+  result->CopyRanges(&ranges[0], num_ranges);
+
+  Vector<ShapeResultTestGlyphInfo> glyphs[num_ranges];
+  for (unsigned i = 0; i < num_ranges; i++)
+    ComputeGlyphResults(*ranges[i].target, &glyphs[i]);
+  EXPECT_EQ(glyphs[0].size(), 4u);
+  EXPECT_EQ(glyphs[1].size(), 3u);
+  EXPECT_EQ(glyphs[2].size(), 3u);
+  EXPECT_EQ(glyphs[3].size(), 5u);
+
+  scoped_refptr<ShapeResult> reference[num_ranges];
+  reference[0] = result->SubRange(0, 4);
+  reference[1] = result->SubRange(4, 7);
+  reference[2] = result->SubRange(7, 10);
+  reference[3] = result->SubRange(10, 17);
+  Vector<ShapeResultTestGlyphInfo> reference_glyphs[num_ranges];
+  for (unsigned i = 0; i < num_ranges; i++)
+    ComputeGlyphResults(*reference[i], &reference_glyphs[i]);
+  EXPECT_EQ(reference_glyphs[0].size(), 4u);
+  EXPECT_EQ(reference_glyphs[1].size(), 3u);
+  EXPECT_EQ(reference_glyphs[2].size(), 3u);
+  EXPECT_EQ(reference_glyphs[3].size(), 5u);
+
+  EXPECT_TRUE(CompareResultGlyphs(glyphs[0], reference_glyphs[0], 0u, 4u));
+  EXPECT_TRUE(CompareResultGlyphs(glyphs[1], reference_glyphs[1], 0u, 3u));
+  EXPECT_TRUE(CompareResultGlyphs(glyphs[2], reference_glyphs[2], 0u, 3u));
+  EXPECT_TRUE(CompareResultGlyphs(glyphs[3], reference_glyphs[3], 0u, 5u));
+  ReleaseShapeRange(ranges);
+}
+
+TEST_F(ShapeResultTest, CopyRangeLatin) {
+  String string = "Testing ShapeResultIterator::CopyRange";
+  TextDirection direction = TextDirection::kLtr;
+
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> result = shaper.Shape(&font, direction);
+  TestCopyRangesLatin(result.get());
+}
+
+// Identical to CopyRangeLatin except the source range shape result is split
+// into multiple runs to test the handling of ranges spanning runs and runs
+// spanning ranges.
+TEST_F(ShapeResultTest, CopyRangeLatinMultiRun) {
+  TextDirection direction = TextDirection::kLtr;
+  String string = "Testing ShapeResultIterator::CopyRange";
+  HarfBuzzShaper shaper_a(string.Substring(0, 5));
+  HarfBuzzShaper shaper_b(string.Substring(5, 7));
+  HarfBuzzShaper shaper_c(string.Substring(7, 32));
+  HarfBuzzShaper shaper_d(string.Substring(32, 38));
+
+  // Combine four separate results into a single one to ensure we have a result
+  // with multiple runs.
+  scoped_refptr<ShapeResult> result =
+      ShapeResult::Create(&font, 0, 0, direction);
+  shaper_a.Shape(&font, direction)->CopyRange(0u, 5u, result.get());
+  shaper_b.Shape(&font, direction)->CopyRange(0u, 2u, result.get());
+  shaper_c.Shape(&font, direction)->CopyRange(0u, 25u, result.get());
+  shaper_d.Shape(&font, direction)->CopyRange(0u, 6u, result.get());
+  TestCopyRangesLatin(result.get());
+}
+
+TEST_F(ShapeResultTest, CopyRangeLatinMultiRunWithHoles) {
+  TextDirection direction = TextDirection::kLtr;
+  String string = "Testing copying a range with holes";
+  HarfBuzzShaper shaper_a(string.Substring(0, 5));
+  HarfBuzzShaper shaper_b(string.Substring(5, 7));
+  HarfBuzzShaper shaper_c(string.Substring(7, 32));
+  HarfBuzzShaper shaper_d(string.Substring(32, 34));
+
+  scoped_refptr<ShapeResult> result =
+      ShapeResult::Create(&font, 0, 0, direction);
+  shaper_a.Shape(&font, direction)->CopyRange(0u, 5u, result.get());
+  shaper_b.Shape(&font, direction)->CopyRange(0u, 2u, result.get());
+  shaper_c.Shape(&font, direction)->CopyRange(0u, 25u, result.get());
+  shaper_d.Shape(&font, direction)->CopyRange(0u, 2u, result.get());
+
+  ShapeResult::ShapeRange ranges[] = {
+      {4, 17, CreateShapeResult(TextDirection::kLtr)},
+      {20, 23, CreateShapeResult(TextDirection::kLtr)},
+      {25, 31, CreateShapeResult(TextDirection::kLtr)}};
+  result->CopyRanges(&ranges[0], 3);
+  Vector<ShapeResultTestGlyphInfo> glyphs[3];
+  ComputeGlyphResults(*ranges[0].target, &glyphs[0]);
+  ComputeGlyphResults(*ranges[1].target, &glyphs[1]);
+  ComputeGlyphResults(*ranges[2].target, &glyphs[2]);
+  EXPECT_EQ(glyphs[0].size(), 13u);
+  EXPECT_EQ(glyphs[1].size(), 3u);
+  EXPECT_EQ(glyphs[2].size(), 6u);
+
+  scoped_refptr<ShapeResult> reference[3];
+  reference[0] = result->SubRange(4, 17);
+  reference[1] = result->SubRange(20, 23);
+  reference[2] = result->SubRange(25, 31);
+  Vector<ShapeResultTestGlyphInfo> reference_glyphs[3];
+  ComputeGlyphResults(*reference[0], &reference_glyphs[0]);
+  ComputeGlyphResults(*reference[1], &reference_glyphs[1]);
+  ComputeGlyphResults(*reference[2], &reference_glyphs[2]);
+  EXPECT_EQ(reference_glyphs[0].size(), 13u);
+  EXPECT_EQ(reference_glyphs[1].size(), 3u);
+  EXPECT_EQ(reference_glyphs[2].size(), 6u);
+
+  EXPECT_TRUE(CompareResultGlyphs(glyphs[0], reference_glyphs[0], 0u, 13u));
+  EXPECT_TRUE(CompareResultGlyphs(glyphs[1], reference_glyphs[1], 0u, 3u));
+  EXPECT_TRUE(CompareResultGlyphs(glyphs[2], reference_glyphs[2], 0u, 6u));
+  ReleaseShapeRange(ranges);
+}
+
+TEST_F(ShapeResultTest, CopyRangeArabic) {
+  //   
+  String string(
+      u"\u0646\u0635\u0627\u062E\u062A\u0628\u0627\u0631\u0627\u0644\u0639"
+      u"\u0631\u0628\u064A\u0629");
+  TextDirection direction = TextDirection::kRtl;
+
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> result = shaper.Shape(&arabic_font, direction);
+  TestCopyRangesArabic(result.get());
+}
+
+// Identical to CopyRangeArabic except the source range shape result is split
+// into multiple runs to test the handling of ranges spanning runs and runs
+// spanning ranges.
+TEST_F(ShapeResultTest, CopyRangeArabicMultiRun) {
+  //   
+  String string(
+      u"\u0646\u0635\u0627\u062E\u062A\u0628\u0627\u0631\u0627\u0644\u0639"
+      u"\u0631\u0628\u064A\u0629");
+  TextDirection direction = TextDirection::kRtl;
+
+  HarfBuzzShaper shaper_a(string.Substring(0, 2));
+  HarfBuzzShaper shaper_b(string.Substring(2, 9));
+  HarfBuzzShaper shaper_c(string.Substring(9, 15));
+
+  // Combine three separate results into a single one to ensure we have a result
+  // with multiple runs.
+  scoped_refptr<ShapeResult> result =
+      ShapeResult::Create(&arabic_font, 0, 0, direction);
+  shaper_a.Shape(&arabic_font, direction)->CopyRange(0u, 2u, result.get());
+  shaper_b.Shape(&arabic_font, direction)->CopyRange(0u, 7u, result.get());
+  shaper_c.Shape(&arabic_font, direction)->CopyRange(0u, 8u, result.get());
+
+  TestCopyRangesArabic(result.get());
+}
+
+static struct IsStartSafeToBreakData {
+  bool expected;
+  const char16_t* text;
+  TextDirection direction = TextDirection::kLtr;
+  unsigned start_offset = 0;
+  unsigned end_offset = 0;
+} is_start_safe_to_break_data[] = {
+    {true, u"XX", TextDirection::kLtr},
+    {true, u"XX", TextDirection::kRtl},
+    // SubRange, assuming there is no kerning between "XX".
+    {true, u"XX", TextDirection::kLtr, 1, 2},
+    {true, u"XX", TextDirection::kRtl, 1, 2},
+    // Between "A" and "V" usually have a kerning.
+    {false, u"AV", TextDirection::kLtr, 1, 2},
+    {false, u"AV", TextDirection::kRtl, 1, 2},
+    // SubRange at the middle of a cluster.
+    // U+06D7 ARABIC SMALL HIGH LIGATURE QAF WITH LAM WITH ALEF MAKSURA
+    {false, u" \u06D7", TextDirection::kLtr, 1, 2},
+    {false, u" \u06D7", TextDirection::kRtl, 1, 2},
+    {false, u" \u06D7.", TextDirection::kLtr, 1, 3},
+    {false, u" \u06D7.", TextDirection::kRtl, 1, 3},
+};
+
+class IsStartSafeToBreakDataTest
+    : public ShapeResultTest,
+      public testing::WithParamInterface<IsStartSafeToBreakData> {};
+
+INSTANTIATE_TEST_SUITE_P(ShapeResultTest,
+                         IsStartSafeToBreakDataTest,
+                         testing::ValuesIn(is_start_safe_to_break_data));
+
+TEST_P(IsStartSafeToBreakDataTest, IsStartSafeToBreakData) {
+  const IsStartSafeToBreakData data = GetParam();
+  String string(data.text);
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<ShapeResult> result = shaper.Shape(&font, data.direction);
+  if (data.end_offset)
+    result = result->SubRange(data.start_offset, data.end_offset);
+  EXPECT_EQ(result->IsStartSafeToBreak(), data.expected);
+}
+
+TEST_F(ShapeResultTest, ComputeInkBoundsWithZeroOffset) {
+  String string(u"abc");
+  HarfBuzzShaper shaper(string);
+  auto result = shaper.Shape(&font, TextDirection::kLtr);
+  EXPECT_FALSE(HasNonZeroGlyphOffsets(*result));
+  EXPECT_FALSE(result->ComputeInkBounds().IsZero());
+}
+
+// TDOO(yosin): We should use a font including U+0A81 or other code point
+// having non-zero glyph offset.
+TEST_F(ShapeResultTest, DISABLED_ComputeInkBoundsWithNonZeroOffset) {
+  // U+0A81 has non-zero glyph offset
+  String string(u"xy\u0A81z");
+  HarfBuzzShaper shaper(string);
+  auto result = shaper.Shape(&font, TextDirection::kLtr);
+  ASSERT_TRUE(HasNonZeroGlyphOffsets(*result));
+  EXPECT_FALSE(result->ComputeInkBounds().IsZero());
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.cc b/third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.cc
index 29dfd4406b86..8a1bbf59717b 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.cc
@@ -43,12 +43,12 @@ bool ShapeResultTestInfo::RunInfoForTesting(unsigned run_index,
 }
 
 uint16_t ShapeResultTestInfo::GlyphForTesting(unsigned run_index,
-                                              size_t glyph_index) const {
+                                              unsigned glyph_index) const {
   return runs_[run_index]->glyph_data_[glyph_index].glyph;
 }
 
 float ShapeResultTestInfo::AdvanceForTesting(unsigned run_index,
-                                             size_t glyph_index) const {
+                                             unsigned glyph_index) const {
   return runs_[run_index]->glyph_data_[glyph_index].advance;
 }
 
@@ -68,4 +68,74 @@ Vector<unsigned> ShapeResultTestInfo::CharacterIndexesForTesting() const {
   return character_indexes;
 }
 
+void AddGlyphInfo(void* context,
+                  unsigned character_index,
+                  Glyph glyph,
+                  FloatSize glyph_offset,
+                  float advance,
+                  bool is_horizontal,
+                  CanvasRotationInVertical rotation,
+                  const SimpleFontData* font_data) {
+  auto* list = static_cast<Vector<ShapeResultTestGlyphInfo>*>(context);
+  ShapeResultTestGlyphInfo glyph_info = {character_index, glyph, advance};
+  list->push_back(glyph_info);
+}
+
+void ComputeGlyphResults(const ShapeResult& result,
+                         Vector<ShapeResultTestGlyphInfo>* glyphs) {
+  result.ForEachGlyph(0, AddGlyphInfo, static_cast<void*>(glyphs));
+}
+
+bool CompareResultGlyphs(const Vector<ShapeResultTestGlyphInfo>& test,
+                         const Vector<ShapeResultTestGlyphInfo>& reference,
+                         unsigned reference_start,
+                         unsigned num_glyphs) {
+  float advance_offset = reference[reference_start].advance;
+  bool glyphs_match = true;
+  for (unsigned i = 0; i < test.size(); i++) {
+    const auto& test_glyph = test[i];
+    const auto& reference_glyph = reference[i + reference_start];
+    if (test_glyph.character_index != reference_glyph.character_index ||
+        test_glyph.glyph != reference_glyph.glyph ||
+        test_glyph.advance != reference_glyph.advance - advance_offset) {
+      glyphs_match = false;
+      break;
+    }
+  }
+  if (!glyphs_match) {
+    fprintf(stderr, " Actual     ");
+    fprintf(stderr, " Expected \n");
+    fprintf(stderr, " Character Index  Glyph  Advance     ");
+    fprintf(stderr, " Character Index  Glyph  Advance \n");
+    fprintf(stderr, "    ");
+    fprintf(stderr, "\n");
+    for (unsigned i = 0; i < test.size(); i++) {
+      const auto& test_glyph = test[i];
+      const auto& reference_glyph = reference[i + reference_start];
+
+      if (test_glyph.character_index == reference_glyph.character_index)
+        fprintf(stderr, "      %10u ", test_glyph.character_index);
+      else
+        fprintf(stderr, "     %10u", test_glyph.character_index);
+
+      if (test_glyph.glyph == reference_glyph.glyph)
+        fprintf(stderr, "  %04X ", test_glyph.glyph);
+      else
+        fprintf(stderr, " %04X", test_glyph.glyph);
+
+      if (test_glyph.advance == reference_glyph.advance)
+        fprintf(stderr, " %7.2f     ", test_glyph.advance);
+      else
+        fprintf(stderr, "%7.2f    ", test_glyph.advance);
+
+      fprintf(stderr, "      %10u   %04X  %7.2f \n",
+              reference_glyph.character_index, reference_glyph.glyph,
+              reference_glyph.advance - advance_offset);
+    }
+    fprintf(stderr, "    ");
+    fprintf(stderr, "\n");
+  }
+  return glyphs_match;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.h b/third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.h
index f659681dec19..6e7d72bb1c8f 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.h
@@ -7,6 +7,7 @@
 
 #include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_bloberizer.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
 #include <hb.h>
 
@@ -25,14 +26,35 @@ class PLATFORM_EXPORT ShapeResultTestInfo : public ShapeResult {
                          unsigned& num_characters,
                          unsigned& num_glyphs,
                          hb_script_t&) const;
-  uint16_t GlyphForTesting(unsigned run_index, size_t glyph_index) const;
-  float AdvanceForTesting(unsigned run_index, size_t glyph_index) const;
+  uint16_t GlyphForTesting(unsigned run_index, unsigned glyph_index) const;
+  float AdvanceForTesting(unsigned run_index, unsigned glyph_index) const;
   SimpleFontData* FontDataForTesting(unsigned run_index) const;
   Vector<unsigned> CharacterIndexesForTesting() const;
 };
 
 class PLATFORM_EXPORT ShapeResultBloberizerTestInfo {
+  STATIC_ONLY(ShapeResultBloberizerTestInfo);
+
  public:
+  static void Add(ShapeResultBloberizer& bloberizer,
+                  Glyph glyph,
+                  const SimpleFontData* font_data,
+                  CanvasRotationInVertical canvas_rotation,
+                  float h_offset,
+                  unsigned character_index) {
+    bloberizer.Add(glyph, font_data, canvas_rotation, h_offset,
+                   character_index);
+  }
+
+  static void Add(ShapeResultBloberizer& bloberizer,
+                  Glyph glyph,
+                  const SimpleFontData* font_data,
+                  CanvasRotationInVertical canvas_rotation,
+                  const FloatPoint& offset,
+                  unsigned character_index) {
+    bloberizer.Add(glyph, font_data, canvas_rotation, offset, character_index);
+  }
+
   static const SimpleFontData* PendingRunFontData(
       const ShapeResultBloberizer& bloberizer) {
     return bloberizer.pending_font_data_;
@@ -67,6 +89,30 @@ class PLATFORM_EXPORT ShapeResultBloberizerTestInfo {
   }
 };
 
+struct PLATFORM_EXPORT ShapeResultTestGlyphInfo {
+  unsigned character_index;
+  Glyph glyph;
+  float advance;
+};
+
+void PLATFORM_EXPORT AddGlyphInfo(void* context,
+                                  unsigned character_index,
+                                  Glyph,
+                                  FloatSize glyph_offset,
+                                  float advance,
+                                  bool is_horizontal,
+                                  CanvasRotationInVertical,
+                                  const SimpleFontData*);
+
+void PLATFORM_EXPORT ComputeGlyphResults(const ShapeResult&,
+                                         Vector<ShapeResultTestGlyphInfo>*);
+
+bool PLATFORM_EXPORT
+CompareResultGlyphs(const Vector<ShapeResultTestGlyphInfo>& test,
+                    const Vector<ShapeResultTestGlyphInfo>& reference,
+                    unsigned reference_start,
+                    unsigned num_glyphs);
+
 }  // namespace blink
 
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_SHAPE_RESULT_TEST_INFO_H_
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_view.cc b/third_party/blink/renderer/platform/fonts/shaping/shape_result_view.cc
new file mode 100644
index 000000000000..c41eeae4d4cd
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_view.cc
@@ -0,0 +1,664 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h"
+
+#include <iterator>
+#include "base/containers/adapters.h"
+#include "build/build_config.h"
+#include "third_party/blink/renderer/platform/fonts/font.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/glyph_bounds_accumulator.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h"
+
+namespace blink {
+
+// Note: We allocate |RunInfoPart| in flexible array in |ShapeResultView|.
+struct ShapeResultView::RunInfoPart {
+ public:
+  RunInfoPart(scoped_refptr<const ShapeResult::RunInfo> run,
+              ShapeResult::RunInfo::GlyphDataRange range,
+              unsigned start_index,
+              unsigned offset,
+              unsigned num_characters,
+              float width)
+      : run_(run),
+        range_(range),
+        start_index_(start_index),
+        offset_(offset),
+        num_characters_(num_characters),
+        width_(width) {}
+
+  using const_iterator = const HarfBuzzRunGlyphData*;
+  const_iterator begin() const { return range_.begin; }
+  const_iterator end() const { return range_.end; }
+  using const_reverse_iterator = std::reverse_iterator<const_iterator>;
+  const_reverse_iterator rbegin() const {
+    return const_reverse_iterator(end());
+  }
+  const_reverse_iterator rend() const {
+    return const_reverse_iterator(begin());
+  }
+  const HarfBuzzRunGlyphData& GlyphAt(unsigned index) const {
+    return *(range_.begin + index);
+  }
+  template <bool has_non_zero_glyph_offsets>
+  ShapeResult::RunInfo::GlyphOffsetArray::iterator<has_non_zero_glyph_offsets>
+  GetGlyphOffsets() const {
+    return ShapeResult::RunInfo::GlyphOffsetArray::iterator<
+        has_non_zero_glyph_offsets>(range_);
+  }
+  bool HasGlyphOffsets() const { return range_.offsets; }
+  // The end character index of |this| without considering offsets in
+  // |ShapeResultView|. This is analogous to:
+  //   GlyphAt(IsRtl() ? -1 : NumGlyphs()).character_index
+  // if such |HarfBuzzRunGlyphData| is available.
+  unsigned CharacterIndexOfEndGlyph() const {
+    return num_characters_ + offset_;
+  }
+
+  bool IsLtr() const { return run_->IsLtr(); }
+  bool IsRtl() const { return run_->IsRtl(); }
+  bool IsHorizontal() const { return run_->IsHorizontal(); }
+  unsigned NumCharacters() const { return num_characters_; }
+  unsigned NumGlyphs() const { return range_.end - range_.begin; }
+  float Width() const { return width_; }
+
+  unsigned PreviousSafeToBreakOffset(unsigned offset) const;
+
+  // Common signatures with RunInfo, to templatize algorithms.
+  const ShapeResult::RunInfo* GetRunInfo() const { return run_.get(); }
+  const ShapeResult::RunInfo::GlyphDataRange& GetGlyphDataRange() const {
+    return range_;
+  }
+  ShapeResult::RunInfo::GlyphDataRange FindGlyphDataRange(
+      unsigned start_character_index,
+      unsigned end_character_index) const {
+    return GetGlyphDataRange().FindGlyphDataRange(
+        IsRtl(), start_character_index, end_character_index);
+  }
+  unsigned OffsetToRunStartIndex() const { return offset_; }
+
+  // The helper function for implementing |CreateViewsForResult()| for
+  // handling iterating over |Vector<scoped_refptr<RunInfo>>| and
+  // |base::span<RunInfoPart>|.
+  const RunInfoPart* get() const { return this; }
+
+  void ExpandRangeToIncludePartialGlyphs(unsigned offset,
+                                         unsigned* from,
+                                         unsigned* to) const {
+    DCHECK_GE(offset + start_index_, offset_);
+    unsigned part_offset = offset + start_index_ - offset_;
+    run_->ExpandRangeToIncludePartialGlyphs(
+        part_offset, reinterpret_cast<int*>(from), reinterpret_cast<int*>(to));
+  }
+
+  scoped_refptr<const ShapeResult::RunInfo> run_;
+  ShapeResult::RunInfo::GlyphDataRange range_;
+
+  // Start index for partial run, adjusted to ensure that runs are continuous.
+  unsigned start_index_;
+
+  // Offset relative to start index for the original run.
+  unsigned offset_;
+
+  unsigned num_characters_;
+  float width_;
+};
+
+unsigned ShapeResultView::RunInfoPart::PreviousSafeToBreakOffset(
+    unsigned offset) const {
+  if (offset >= NumCharacters())
+    return NumCharacters();
+  offset += offset_;
+  if (IsLtr()) {
+    for (const auto& glyph : base::Reversed(*this)) {
+      if (glyph.safe_to_break_before && glyph.character_index <= offset)
+        return glyph.character_index - offset_;
+    }
+  } else {
+    for (const auto& glyph : *this) {
+      if (glyph.safe_to_break_before && glyph.character_index <= offset)
+        return glyph.character_index - offset_;
+    }
+  }
+
+  // Next safe break is at the start of the run.
+  return 0;
+}
+
+// The offset to add to |HarfBuzzRunGlyphData.character_index| to compute the
+// character index of the source string.
+unsigned ShapeResultView::CharacterIndexOffsetForGlyphData(
+    const RunInfoPart& part) const {
+  return part.start_index_ + char_index_offset_ - part.offset_;
+}
+
+template <class ShapeResultType>
+ShapeResultView::ShapeResultView(const ShapeResultType* other)
+    : primary_font_(other->primary_font_),
+      start_index_(0),
+      num_characters_(0),
+      num_glyphs_(0),
+      direction_(other->direction_),
+      has_vertical_offsets_(other->has_vertical_offsets_),
+      width_(0) {}
+
+ShapeResultView::~ShapeResultView() {
+  for (auto& part : Parts())
+    part.~RunInfoPart();
+}
+
+scoped_refptr<ShapeResult> ShapeResultView::CreateShapeResult() const {
+  ShapeResult* new_result =
+      new ShapeResult(primary_font_, start_index_ + char_index_offset_,
+                      num_characters_, Direction());
+  new_result->runs_.ReserveCapacity(num_parts_);
+  for (const auto& part : RunsOrParts()) {
+    auto new_run = ShapeResult::RunInfo::Create(
+        part.run_->font_data_.get(), part.run_->direction_,
+        part.run_->canvas_rotation_, part.run_->script_, part.start_index_,
+        part.NumGlyphs(), part.num_characters_);
+    new_run->glyph_data_.CopyFromRange(part.range_);
+    for (HarfBuzzRunGlyphData& glyph_data : new_run->glyph_data_) {
+      glyph_data.character_index -= part.offset_;
+    }
+
+    new_run->start_index_ += char_index_offset_;
+    new_run->width_ = part.width_;
+    new_run->num_characters_ = part.num_characters_;
+    new_result->runs_.push_back(std::move(new_run));
+  }
+
+  new_result->num_glyphs_ = num_glyphs_;
+  new_result->has_vertical_offsets_ = has_vertical_offsets_;
+  new_result->width_ = width_;
+
+  return base::AdoptRef(new_result);
+}
+
+template <class ShapeResultType>
+void ShapeResultView::CreateViewsForResult(const ShapeResultType* other,
+                                           unsigned start_index,
+                                           unsigned end_index) {
+  // Compute the diff of index and the number of characters from the source
+  // ShapeResult and given offsets, because computing them from runs/parts can
+  // be inaccurate when all characters in a run/part are missing.
+  int index_diff = start_index_ + num_characters_ -
+                   std::max(start_index, other->StartIndex());
+  num_characters_ += std::min(end_index, other->EndIndex()) -
+                     std::max(start_index, other->StartIndex());
+
+  RunInfoPart* part = Parts().data() + num_parts_;
+  for (const auto& run_or_part : other->RunsOrParts()) {
+    auto* const run = run_or_part.get();
+    if (!run->GetRunInfo())
+      continue;
+    // Compute start/end of the run, or of the part if ShapeResultView.
+    unsigned part_start = run->start_index_ + other->StartIndexOffsetForRun();
+    if (other->IsRtl()) {
+      // Under RTL and multiple parts, A RunInfoPart may have an
+      // offset_ greater than start_index. In this case, run_start
+      // would result in an invalid negative value.
+      part_start = std::max(part_start, run->OffsetToRunStartIndex());
+    }
+    unsigned run_end = part_start + run->num_characters_;
+    if (start_index < run_end && end_index > part_start) {
+      ShapeResult::RunInfo::GlyphDataRange range;
+
+      // Adjust start/end to the character index of |RunInfo|. The start index
+      // of |RunInfo| could be different from |part_start| for ShapeResultView.
+      DCHECK_GE(part_start, run->OffsetToRunStartIndex());
+      unsigned run_start = part_start - run->OffsetToRunStartIndex();
+      unsigned adjusted_start =
+          start_index > run_start
+              ? std::max(start_index, part_start) - run_start
+              : 0;
+      unsigned adjusted_end = std::min(end_index, run_end) - run_start;
+      DCHECK(adjusted_end > adjusted_start);
+      unsigned part_characters = adjusted_end - adjusted_start;
+      float part_width;
+
+      // Avoid O(log n) find operation if the entire run is in range.
+      if (part_start >= start_index && run_end <= end_index) {
+        range = run->GetGlyphDataRange();
+        part_width = run->width_;
+      } else {
+        range = run->FindGlyphDataRange(adjusted_start, adjusted_end);
+        part_width = 0;
+        for (auto* glyph = range.begin; glyph != range.end; glyph++)
+          part_width += glyph->advance;
+      }
+
+      // Adjust start_index for runs to be continuous.
+      unsigned part_start_index = run_start + adjusted_start + index_diff;
+      unsigned part_offset = adjusted_start;
+      new (part) RunInfoPart(run->GetRunInfo(), range, part_start_index,
+                             part_offset, part_characters, part_width);
+      ++part;
+
+      num_glyphs_ += range.end - range.begin;
+      width_ += part_width;
+    }
+  }
+  num_parts_ = static_cast<wtf_size_t>(std::distance(Parts().data(), part));
+}
+
+scoped_refptr<ShapeResultView> ShapeResultView::Create(const Segment* segments,
+                                                       size_t segment_count) {
+  DCHECK_GT(segment_count, 0u);
+#if DCHECK_IS_ON()
+  for (unsigned i = 0; i < segment_count; ++i) {
+    DCHECK((segments[i].result || segments[i].view) &&
+           (!segments[i].result || !segments[i].view));
+  }
+#endif
+  wtf_size_t num_parts = 0;
+  for (auto& segment : base::span<const Segment>(segments, segment_count)) {
+    num_parts += segment.result ? segment.result->RunsOrParts().size()
+                                : segment.view->RunsOrParts().size();
+  }
+  static_assert(sizeof(ShapeResultView) % alignof(RunInfoPart) == 0,
+                "We have RunInfoPart as flexible array in ShapeResultView");
+  const size_t byte_size =
+      sizeof(ShapeResultView) + sizeof(RunInfoPart) * num_parts;
+  void* buffer = ::WTF::Partitions::FastMalloc(
+      byte_size, ::WTF::GetStringWithTypeName<ShapeResultView>());
+  ShapeResultView* out = segments[0].result
+                             ? new (buffer) ShapeResultView(segments[0].result)
+                             : new (buffer) ShapeResultView(segments[0].view);
+  out->AddSegments(segments, segment_count);
+  return base::AdoptRef(out);
+}
+
+scoped_refptr<ShapeResultView> ShapeResultView::Create(
+    const ShapeResult* result,
+    unsigned start_index,
+    unsigned end_index) {
+  Segment segment = {result, start_index, end_index};
+  return Create(&segment, 1);
+}
+
+scoped_refptr<ShapeResultView> ShapeResultView::Create(
+    const ShapeResultView* result,
+    unsigned start_index,
+    unsigned end_index) {
+  Segment segment = {result, start_index, end_index};
+  return Create(&segment, 1);
+}
+
+scoped_refptr<ShapeResultView> ShapeResultView::Create(
+    const ShapeResult* result) {
+  // This specialization is an optimization to allow the bounding box to be
+  // re-used.
+  const wtf_size_t num_parts = result->RunsOrParts().size();
+  static_assert(sizeof(ShapeResultView) % alignof(RunInfoPart) == 0,
+                "We have RunInfoPart as flexible array in ShapeResultView");
+  const size_t byte_size =
+      sizeof(ShapeResultView) + sizeof(RunInfoPart) * num_parts;
+  void* buffer = ::WTF::Partitions::FastMalloc(
+      byte_size, ::WTF::GetStringWithTypeName<ShapeResultView>());
+  ShapeResultView* out = new (buffer) ShapeResultView(result);
+  out->char_index_offset_ = result->StartIndex();
+  if (out->IsLtr()) {
+    out->start_index_ = 0;
+  } else {
+    out->start_index_ = out->char_index_offset_;
+    out->char_index_offset_ = 0;
+  }
+  out->CreateViewsForResult(result, 0, std::numeric_limits<unsigned>::max());
+  out->has_vertical_offsets_ = result->has_vertical_offsets_;
+  return base::AdoptRef(out);
+}
+
+void ShapeResultView::AddSegments(const Segment* segments,
+                                  size_t segment_count) {
+  // This method assumes that no parts have been added yet.
+  DCHECK_EQ(num_parts_, 0u);
+
+  // Segments are in logical order, runs and parts are in visual order. Iterate
+  // over segments back-to-front for RTL.
+  DCHECK_GT(segment_count, 0u);
+  unsigned last_segment_index = segment_count - 1;
+
+  // Compute start index offset for the overall run. This is added to the start
+  // index of each glyph to ensure consistency with ShapeResult::SubRange
+  char_index_offset_ = segments[0].result ? segments[0].result->StartIndex()
+                                          : segments[0].view->StartIndex();
+  char_index_offset_ = std::max(char_index_offset_, segments[0].start_index);
+  if (IsLtr()) {  // Left-to-right
+    start_index_ = 0;
+  } else {  // Right to left
+    start_index_ = char_index_offset_;
+    char_index_offset_ = 0;
+  }
+
+  for (unsigned i = 0; i < segment_count; i++) {
+    const Segment& segment = segments[IsRtl() ? last_segment_index - i : i];
+    if (segment.result) {
+      DCHECK_EQ(segment.result->Direction(), Direction());
+      CreateViewsForResult(segment.result, segment.start_index,
+                           segment.end_index);
+      has_vertical_offsets_ |= segment.result->has_vertical_offsets_;
+    } else if (segment.view) {
+      DCHECK_EQ(segment.view->Direction(), Direction());
+      CreateViewsForResult(segment.view, segment.start_index,
+                           segment.end_index);
+      has_vertical_offsets_ |= segment.view->has_vertical_offsets_;
+    } else {
+      NOTREACHED();
+    }
+  }
+}
+
+unsigned ShapeResultView::PreviousSafeToBreakOffset(unsigned index) const {
+  for (auto it = RunsOrParts().rbegin(); it != RunsOrParts().rend(); ++it) {
+    const auto& part = *it;
+    unsigned run_start = part.start_index_;
+    if (index >= run_start) {
+      unsigned offset = index - run_start;
+      if (offset <= part.num_characters_) {
+        return part.PreviousSafeToBreakOffset(offset) + run_start;
+      }
+      if (IsLtr()) {
+        return run_start + part.num_characters_;
+      }
+    } else if (IsRtl()) {
+      if (it == RunsOrParts().rbegin())
+        return part.start_index_;
+      const auto& previous_run = *--it;
+      return previous_run.start_index_ + previous_run.num_characters_;
+    }
+  }
+
+  return StartIndex();
+}
+
+void ShapeResultView::GetRunFontData(
+    Vector<ShapeResult::RunFontData>* font_data) const {
+  for (const auto& part : RunsOrParts()) {
+    font_data->push_back(ShapeResult::RunFontData(
+        {part.run_->font_data_.get(), part.end() - part.begin()}));
+  }
+}
+
+void ShapeResultView::FallbackFonts(
+    HashSet<const SimpleFontData*>* fallback) const {
+  DCHECK(fallback);
+  DCHECK(primary_font_);
+  for (const auto& part : RunsOrParts()) {
+    if (part.run_->font_data_ && part.run_->font_data_ != primary_font_) {
+      fallback->insert(part.run_->font_data_.get());
+    }
+  }
+}
+
+template <bool has_non_zero_glyph_offsets>
+float ShapeResultView::ForEachGlyphImpl(float initial_advance,
+                                        GlyphCallback glyph_callback,
+                                        void* context,
+                                        const RunInfoPart& part) const {
+  auto glyph_offsets = part.GetGlyphOffsets<has_non_zero_glyph_offsets>();
+  const auto& run = part.run_;
+  auto total_advance = initial_advance;
+  bool is_horizontal = HB_DIRECTION_IS_HORIZONTAL(run->direction_);
+  const SimpleFontData* font_data = run->font_data_.get();
+  const unsigned character_index_offset_for_glyph_data =
+      CharacterIndexOffsetForGlyphData(part);
+  for (const auto& glyph_data : part) {
+    unsigned character_index =
+        glyph_data.character_index + character_index_offset_for_glyph_data;
+    glyph_callback(context, character_index, glyph_data.glyph, *glyph_offsets,
+                   total_advance, is_horizontal, run->canvas_rotation_,
+                   font_data);
+    total_advance += glyph_data.advance;
+    ++glyph_offsets;
+  }
+  return total_advance;
+}
+
+float ShapeResultView::ForEachGlyph(float initial_advance,
+                                    GlyphCallback glyph_callback,
+                                    void* context) const {
+  auto total_advance = initial_advance;
+  for (const auto& part : RunsOrParts()) {
+    if (part.HasGlyphOffsets()) {
+      total_advance =
+          ForEachGlyphImpl<true>(total_advance, glyph_callback, context, part);
+    } else {
+      total_advance =
+          ForEachGlyphImpl<false>(total_advance, glyph_callback, context, part);
+    }
+  }
+  return total_advance;
+}
+
+template <bool has_non_zero_glyph_offsets>
+float ShapeResultView::ForEachGlyphImpl(float initial_advance,
+                                        unsigned from,
+                                        unsigned to,
+                                        unsigned index_offset,
+                                        GlyphCallback glyph_callback,
+                                        void* context,
+                                        const RunInfoPart& part) const {
+  auto glyph_offsets = part.GetGlyphOffsets<has_non_zero_glyph_offsets>();
+  auto total_advance = initial_advance;
+  const auto& run = part.run_;
+  bool is_horizontal = HB_DIRECTION_IS_HORIZONTAL(run->direction_);
+  const SimpleFontData* font_data = run->font_data_.get();
+  const unsigned character_index_offset_for_glyph_data =
+      CharacterIndexOffsetForGlyphData(part);
+  if (run->IsLtr()) {  // Left-to-right
+    for (const auto& glyph_data : part) {
+      unsigned character_index =
+          glyph_data.character_index + character_index_offset_for_glyph_data;
+      if (character_index >= to)
+        break;
+      if (character_index >= from) {
+        glyph_callback(context, character_index, glyph_data.glyph,
+                       *glyph_offsets, total_advance, is_horizontal,
+                       run->canvas_rotation_, font_data);
+      }
+      total_advance += glyph_data.advance;
+      ++glyph_offsets;
+    }
+
+  } else {  // Right-to-left
+    for (const auto& glyph_data : part) {
+      unsigned character_index =
+          glyph_data.character_index + character_index_offset_for_glyph_data;
+      if (character_index < from)
+        break;
+      if (character_index < to) {
+        glyph_callback(context, character_index, glyph_data.glyph,
+                       *glyph_offsets, total_advance, is_horizontal,
+                       run->canvas_rotation_, font_data);
+      }
+      total_advance += glyph_data.advance;
+      ++glyph_offsets;
+    }
+  }
+  return total_advance;
+}
+
+float ShapeResultView::ForEachGlyph(float initial_advance,
+                                    unsigned from,
+                                    unsigned to,
+                                    unsigned index_offset,
+                                    GlyphCallback glyph_callback,
+                                    void* context) const {
+  auto total_advance = initial_advance;
+
+  for (const auto& part : Parts()) {
+    if (part.HasGlyphOffsets()) {
+      total_advance = ForEachGlyphImpl<true>(
+          total_advance, from, to, index_offset, glyph_callback, context, part);
+    } else {
+      total_advance = ForEachGlyphImpl<false>(
+          total_advance, from, to, index_offset, glyph_callback, context, part);
+    }
+  }
+  return total_advance;
+}
+
+float ShapeResultView::ForEachGraphemeClusters(const StringView& text,
+                                               float initial_advance,
+                                               unsigned from,
+                                               unsigned to,
+                                               unsigned index_offset,
+                                               GraphemeClusterCallback callback,
+                                               void* context) const {
+  unsigned run_offset = index_offset;
+  float advance_so_far = initial_advance;
+
+  for (const auto& part : RunsOrParts()) {
+    if (!part.NumGlyphs())
+      continue;
+
+    const auto& run = part.run_;
+    unsigned graphemes_in_cluster = 1;
+    float cluster_advance = 0;
+    bool rtl = Direction() == TextDirection::kRtl;
+
+    // A "cluster" in this context means a cluster as it is used by HarfBuzz:
+    // The minimal group of characters and corresponding glyphs, that cannot be
+    // broken down further from a text shaping point of view.  A cluster can
+    // contain multiple glyphs and grapheme clusters, with mutually overlapping
+    // boundaries.
+    const unsigned character_index_offset_for_glyph_data =
+        CharacterIndexOffsetForGlyphData(part) + run_offset;
+    uint16_t cluster_start =
+        static_cast<uint16_t>(rtl ? part.CharacterIndexOfEndGlyph() +
+                                        character_index_offset_for_glyph_data
+                                  : part.GlyphAt(0).character_index +
+                                        character_index_offset_for_glyph_data);
+
+    const unsigned num_glyphs = part.NumGlyphs();
+    for (unsigned i = 0; i < num_glyphs; ++i) {
+      const HarfBuzzRunGlyphData& glyph_data = part.GlyphAt(i);
+      uint16_t current_character_index =
+          glyph_data.character_index + character_index_offset_for_glyph_data;
+
+      bool is_run_end = (i + 1 == num_glyphs);
+      bool is_cluster_end =
+          is_run_end || (part.GlyphAt(i + 1).character_index +
+                             character_index_offset_for_glyph_data !=
+                         current_character_index);
+
+      if ((rtl && current_character_index >= to) ||
+          (!rtl && current_character_index < from)) {
+        advance_so_far += glyph_data.advance;
+        rtl ? --cluster_start : ++cluster_start;
+        continue;
+      }
+
+      cluster_advance += glyph_data.advance;
+
+      if (text.Is8Bit()) {
+        callback(context, current_character_index, advance_so_far, 1,
+                 glyph_data.advance, run->canvas_rotation_);
+
+        advance_so_far += glyph_data.advance;
+      } else if (is_cluster_end) {
+        uint16_t cluster_end;
+        if (rtl) {
+          cluster_end = current_character_index;
+        } else {
+          cluster_end = static_cast<uint16_t>(
+              is_run_end ? part.CharacterIndexOfEndGlyph() +
+                               character_index_offset_for_glyph_data
+                         : part.GlyphAt(i + 1).character_index +
+                               character_index_offset_for_glyph_data);
+        }
+        graphemes_in_cluster = ShapeResult::CountGraphemesInCluster(
+            text.Span16(), cluster_start, cluster_end);
+        if (!graphemes_in_cluster || !cluster_advance)
+          continue;
+
+        callback(context, current_character_index, advance_so_far,
+                 graphemes_in_cluster, cluster_advance, run->canvas_rotation_);
+        advance_so_far += cluster_advance;
+
+        cluster_start = cluster_end;
+        cluster_advance = 0;
+      }
+    }
+  }
+  return advance_so_far;
+}
+
+template <bool is_horizontal_run, bool has_non_zero_glyph_offsets>
+void ShapeResultView::ComputePartInkBounds(
+    const ShapeResultView::RunInfoPart& part,
+    float run_advance,
+    FloatRect* ink_bounds) const {
+  // Get glyph bounds from Skia. It's a lot faster if we give it list of glyph
+  // IDs rather than calling it for each glyph.
+  // TODO(kojii): MacOS does not benefit from batching the Skia request due to
+  // https://bugs.chromium.org/p/skia/issues/detail?id=5328, and the cost to
+  // prepare batching, which is normally much less than the benefit of
+  // batching, is not ignorable unfortunately.
+  auto glyph_offsets = part.GetGlyphOffsets<has_non_zero_glyph_offsets>();
+  const SimpleFontData& current_font_data = *part.run_->font_data_;
+  unsigned num_glyphs = part.NumGlyphs();
+#if !defined(OS_MAC)
+  Vector<Glyph, 256> glyphs(num_glyphs);
+  unsigned i = 0;
+  for (const auto& glyph_data : part)
+    glyphs[i++] = glyph_data.glyph;
+  Vector<SkRect, 256> bounds_list(num_glyphs);
+  current_font_data.BoundsForGlyphs(glyphs, &bounds_list);
+#endif
+
+  GlyphBoundsAccumulator bounds(run_advance);
+  for (unsigned j = 0; j < num_glyphs; ++j) {
+    const HarfBuzzRunGlyphData& glyph_data = part.GlyphAt(j);
+#if defined(OS_MAC)
+    FloatRect glyph_bounds = current_font_data.BoundsForGlyph(glyph_data.glyph);
+#else
+    FloatRect glyph_bounds(bounds_list[j]);
+#endif
+    bounds.Unite<is_horizontal_run>(glyph_bounds, *glyph_offsets);
+    bounds.origin += glyph_data.advance;
+    ++glyph_offsets;
+  }
+
+  if (!is_horizontal_run)
+    bounds.ConvertVerticalRunToLogical(current_font_data.GetFontMetrics());
+  ink_bounds->Unite(bounds.bounds);
+}
+
+FloatRect ShapeResultView::ComputeInkBounds() const {
+  FloatRect ink_bounds;
+
+  float run_advance = 0.0f;
+  for (const auto& part : Parts()) {
+    if (part.HasGlyphOffsets()) {
+      if (part.IsHorizontal()) {
+        ComputePartInkBounds<true, true>(part, run_advance, &ink_bounds);
+      } else {
+        ComputePartInkBounds<false, true>(part, run_advance, &ink_bounds);
+      }
+    } else {
+      if (part.IsHorizontal()) {
+        ComputePartInkBounds<true, false>(part, run_advance, &ink_bounds);
+      } else {
+        ComputePartInkBounds<false, false>(part, run_advance, &ink_bounds);
+      }
+    }
+    run_advance += part.Width();
+  }
+
+  return ink_bounds;
+}
+
+void ShapeResultView::ExpandRangeToIncludePartialGlyphs(unsigned* from,
+                                                        unsigned* to) const {
+  unsigned accumulated_offset = char_index_offset_;
+  for (const auto& part : Parts()) {
+    part.ExpandRangeToIncludePartialGlyphs(accumulated_offset, from, to);
+    accumulated_offset += part.NumCharacters();
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h b/third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h
new file mode 100644
index 000000000000..ea1d1b817d3d
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h
@@ -0,0 +1,231 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_SHAPE_RESULT_VIEW_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_SHAPE_RESULT_VIEW_H_
+
+#include <memory>
+#include "base/containers/span.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result.h"
+#include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
+#include "third_party/blink/renderer/platform/geometry/layout_unit.h"
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/text/text_direction.h"
+#include "third_party/blink/renderer/platform/wtf/forward.h"
+#include "third_party/blink/renderer/platform/wtf/vector.h"
+
+namespace blink {
+
+class ShapeResult;
+
+// Class representing a read-only composite of views into one or more existing
+// shape results.
+// Implemented as a list of ref counted RunInfo instances and a start/end
+// offset for each, represented using the internal RunInfoPart struct.
+// This allows lines to be reference sections of the overall paragraph shape
+// results without the memory or computational overhead of a copy.
+//
+// The example below shows the shape result and the individual lines as
+// ShapeResultView instances pointing to the original paragraph results for
+// the string "Pack my box with five dozen liquor jugs.":
+//  
+//   Paragraph with single run, no re-shaping for lines. 
+//  
+//   runs_  
+//     1:   Pack my box with five dozen liquor jugs.   
+//          
+//   lines  
+//     1:   Pack my box with    -> view, run 1:  0-16  
+//     2:   five dozen liquor   -> view, run 1: 17-34  
+//     3:   jugs.               -> view, run 1: 35-40  
+//          
+//  
+//
+// In cases where a portion of the line needs re-shaping the new results are
+// added as separate runs at the beginning and/or end of the runs_ vector with a
+// reference to zero or more sub-runs in the middle representing the original
+// content that could be reused.
+//
+// In the example below the end of the first line "Jack!" needs to be re-shaped:
+//  
+//   Paragraph with single run, requiring re-shape.      
+//  
+//   runs_  
+//     1:   "Now fax quiz Jack!" my brave ghost pled.  
+//          
+//   lines  
+//     1:   "Now fax quiz     -> view, run 1:  0-14    
+//     1:   Jack!             -> new result/run        
+//     2:   my brave ghost    -> view, run 1: 21-35    
+//     3:   pled.             -> view, run 1: 41-36    
+//          
+//  
+//
+// In this case the beginning of the first line would be represented as a part
+// referecing the a range into the original ShapeResult while the last word wold
+// be a separate result owned by the ShapeResultView instance. The second
+// and third lines would again be represented as parts.
+class PLATFORM_EXPORT ShapeResultView final
+    : public RefCounted<ShapeResultView> {
+ public:
+  // Create a new ShapeResultView from a pre-defined list of segments.
+  // The segments list is assumed to be in logical order.
+  struct Segment {
+    Segment() = default;
+    Segment(const ShapeResult* result, unsigned start_index, unsigned end_index)
+        : result(result),
+          view(nullptr),
+          start_index(start_index),
+          end_index(end_index) {}
+    Segment(const ShapeResultView* view,
+            unsigned start_index,
+            unsigned end_index)
+        : result(nullptr),
+          view(view),
+          start_index(start_index),
+          end_index(end_index) {}
+    const ShapeResult* result;
+    const ShapeResultView* view;
+    unsigned start_index;
+    unsigned end_index;
+  };
+  static scoped_refptr<ShapeResultView> Create(const Segment*, size_t);
+
+  // Creates a new ShapeResultView from a single segment.
+  static scoped_refptr<ShapeResultView> Create(const ShapeResult*);
+  static scoped_refptr<ShapeResultView> Create(const ShapeResult*,
+                                               unsigned start_index,
+                                               unsigned end_index);
+  static scoped_refptr<ShapeResultView> Create(const ShapeResultView*,
+                                               unsigned start_index,
+                                               unsigned end_index);
+
+  ~ShapeResultView();
+
+  scoped_refptr<ShapeResult> CreateShapeResult() const;
+
+  unsigned StartIndex() const { return start_index_ + char_index_offset_; }
+  unsigned EndIndex() const { return StartIndex() + num_characters_; }
+  unsigned NumCharacters() const { return num_characters_; }
+  unsigned NumGlyphs() const { return num_glyphs_; }
+  float Width() const { return width_; }
+  LayoutUnit SnappedWidth() const { return LayoutUnit::FromFloatCeil(width_); }
+  TextDirection Direction() const {
+    return static_cast<TextDirection>(direction_);
+  }
+  bool IsLtr() const { return blink::IsLtr(Direction()); }
+  bool IsRtl() const { return blink::IsRtl(Direction()); }
+  bool HasVerticalOffsets() const { return has_vertical_offsets_; }
+  void FallbackFonts(HashSet<const SimpleFontData*>* fallback) const;
+
+  unsigned PreviousSafeToBreakOffset(unsigned index) const;
+
+  float ForEachGlyph(float initial_advance, GlyphCallback, void* context) const;
+  float ForEachGlyph(float initial_advance,
+                     unsigned from,
+                     unsigned to,
+                     unsigned index_offset,
+                     GlyphCallback,
+                     void* context) const;
+
+  float ForEachGraphemeClusters(const StringView& text,
+                                float initial_advance,
+                                unsigned from,
+                                unsigned to,
+                                unsigned index_offset,
+                                GraphemeClusterCallback,
+                                void* context) const;
+
+  // Computes and returns the ink bounds (or visual overflow rect). This is
+  // quite expensive and involves measuring each glyphaccumulating the bounds.
+  FloatRect ComputeInkBounds() const;
+
+  scoped_refptr<const SimpleFontData> PrimaryFont() const {
+    return primary_font_;
+  }
+  void GetRunFontData(Vector<ShapeResult::RunFontData>*) const;
+
+  void ExpandRangeToIncludePartialGlyphs(unsigned* from, unsigned* to) const;
+
+ private:
+  template <class ShapeResultType>
+  explicit ShapeResultView(const ShapeResultType*);
+
+  struct RunInfoPart;
+  template <class ShapeResultType>
+  void CreateViewsForResult(const ShapeResultType*,
+                            unsigned start_index,
+                            unsigned end_index);
+  void AddSegments(const Segment*, size_t);
+
+  unsigned CharacterIndexOffsetForGlyphData(const RunInfoPart&) const;
+
+  template <bool is_horizontal_run, bool has_glyph_offsets>
+  void ComputePartInkBounds(const ShapeResultView::RunInfoPart&,
+                            float run_advance,
+                            FloatRect* ink_bounds) const;
+
+  // Common signatures with ShapeResult, to templatize algorithms.
+  base::span<const RunInfoPart> RunsOrParts() const { return Parts(); }
+
+  base::span<RunInfoPart> Parts() {
+    return {reinterpret_cast<RunInfoPart*>(parts_), num_parts_};
+  }
+  base::span<const RunInfoPart> Parts() const {
+    return {reinterpret_cast<const RunInfoPart*>(parts_), num_parts_};
+  }
+  unsigned StartIndexOffsetForRun() const { return char_index_offset_; }
+
+  scoped_refptr<const SimpleFontData> primary_font_;
+
+  unsigned start_index_;
+  unsigned num_characters_;
+  unsigned num_glyphs_ : 30;
+
+  // Overall direction for the TextRun, dictates which order each individual
+  // sub run (represented by RunInfo structs in the m_runs vector) can
+  // have a different text direction.
+  unsigned direction_ : 1;
+
+  // Tracks whether any runs contain glyphs with a y-offset != 0.
+  unsigned has_vertical_offsets_ : 1;
+
+  // Offset of the first component added to the view. Used for compatibility
+  // with ShapeResult::SubRange
+  unsigned char_index_offset_;
+
+  float width_;
+  wtf_size_t num_parts_ = 0;
+
+  // TODO(yosin): We should declare |RunInoPart| in this file to avoid using
+  // dummy struct.
+  // Note: To avoid declaring |RunInfoPart| here, we use dummy struct.
+  struct {
+    void* alignment;
+  } parts_[];
+
+ private:
+  friend class ShapeResult;
+
+  template <bool has_glyph_offsets>
+  float ForEachGlyphImpl(float initial_advance,
+                         GlyphCallback,
+                         void* context,
+                         const RunInfoPart& part) const;
+
+  template <bool has_glyph_offsets>
+  float ForEachGlyphImpl(float initial_advance,
+                         unsigned from,
+                         unsigned to,
+                         unsigned index_offset,
+                         GlyphCallback,
+                         void* context,
+                         const RunInfoPart& part) const;
+
+  DISALLOW_COPY_AND_ASSIGN(ShapeResultView);
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_SHAPE_RESULT_VIEW_H_
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shape_result_view_test.cc b/third_party/blink/renderer/platform/fonts/shaping/shape_result_view_test.cc
new file mode 100644
index 000000000000..62fbee4b8005
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/shape_result_view_test.cc
@@ -0,0 +1,355 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker.h"
+
+#include <unicode/uscript.h>
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/fonts/font.h"
+#include "third_party/blink/renderer/platform/fonts/font_cache.h"
+#include "third_party/blink/renderer/platform/fonts/font_test_utilities.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h"
+
+namespace blink {
+
+class ShapeResultViewTest : public testing::Test {
+ protected:
+  void SetUp() override {
+    font_description.SetComputedSize(12.0);
+    font = Font(font_description);
+  }
+
+  void TearDown() override {}
+
+  FontCachePurgePreventer font_cache_purge_preventer;
+  FontDescription font_description;
+  Font font;
+};
+
+TEST_F(ShapeResultViewTest, LatinSingleView) {
+  String string =
+      To16Bit("Test run with multiple words and breaking opportunities.", 56);
+  TextDirection direction = TextDirection::kLtr;
+
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<const ShapeResult> result = shaper.Shape(&font, direction);
+  Vector<ShapeResultTestGlyphInfo> glyphs;
+  result->ForEachGlyph(0, AddGlyphInfo, static_cast<void*>(&glyphs));
+
+  // Test view at the start of the result: "Test run with multiple"
+  ShapeResultView::Segment segment = {result.get(), 0, 22};
+  auto first4 = ShapeResultView::Create(&segment, 1);
+
+  EXPECT_EQ(first4->StartIndex(), 0u);
+  EXPECT_EQ(first4->NumCharacters(), 22u);
+  EXPECT_EQ(first4->NumGlyphs(), 22u);
+
+  Vector<ShapeResultTestGlyphInfo> first4_glyphs;
+  first4->ForEachGlyph(0, AddGlyphInfo, static_cast<void*>(&first4_glyphs));
+  EXPECT_EQ(first4_glyphs.size(), 22u);
+  EXPECT_TRUE(CompareResultGlyphs(first4_glyphs, glyphs, 0u, 22u));
+
+  // Test view in the middle of the result: "multiple words and breaking"
+  segment = {result.get(), 14, 41};
+  auto middle4 = ShapeResultView::Create(&segment, 1);
+
+  EXPECT_EQ(middle4->StartIndex(), 14u);
+  EXPECT_EQ(middle4->NumCharacters(), 27u);
+  EXPECT_EQ(middle4->NumGlyphs(), 27u);
+
+  Vector<ShapeResultTestGlyphInfo> middle4_glyphs;
+  middle4->ForEachGlyph(0, AddGlyphInfo, static_cast<void*>(&middle4_glyphs));
+  EXPECT_EQ(middle4_glyphs.size(), 27u);
+  EXPECT_TRUE(CompareResultGlyphs(middle4_glyphs, glyphs, 14u, 27u));
+
+  // Test view at the end of the result: "breaking opportunities."
+  segment = {result.get(), 33, 56};
+  auto last2 = ShapeResultView::Create(&segment, 1);
+
+  EXPECT_EQ(last2->StartIndex(), 33u);
+  EXPECT_EQ(last2->NumCharacters(), 23u);
+  EXPECT_EQ(last2->NumGlyphs(), 23u);
+
+  Vector<ShapeResultTestGlyphInfo> last2_glyphs;
+  last2->ForEachGlyph(0, AddGlyphInfo, static_cast<void*>(&last2_glyphs));
+  EXPECT_EQ(last2_glyphs.size(), 23u);
+  EXPECT_TRUE(CompareResultGlyphs(last2_glyphs, glyphs, 33u, 23u));
+}
+
+TEST_F(ShapeResultViewTest, ArabicSingleView) {
+  String string = To16Bit(" ", 7);
+  TextDirection direction = TextDirection::kRtl;
+
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<const ShapeResult> result = shaper.Shape(&font, direction);
+  Vector<ShapeResultTestGlyphInfo> glyphs;
+  result->ForEachGlyph(0, AddGlyphInfo, static_cast<void*>(&glyphs));
+
+  // Test view at the start of the result: ""
+  ShapeResultView::Segment segment = {result.get(), 0, 4};
+  auto first_word = ShapeResultView::Create(&segment, 1);
+  Vector<ShapeResultTestGlyphInfo> first_glyphs;
+  first_word->ForEachGlyph(0, AddGlyphInfo, static_cast<void*>(&first_glyphs));
+
+  EXPECT_EQ(first_word->StartIndex(), 0u);
+  EXPECT_EQ(first_word->NumCharacters(), 4u);
+  EXPECT_EQ(first_word->NumGlyphs(), 4u);
+  EXPECT_EQ(first_glyphs.size(), 4u);
+
+  String first_reference_string = To16Bit("", 4);
+  HarfBuzzShaper first_reference_shaper(first_reference_string);
+  scoped_refptr<const ShapeResult> first_wortd_reference =
+      first_reference_shaper.Shape(&font, direction);
+  Vector<ShapeResultTestGlyphInfo> first_reference_glyphs;
+  first_wortd_reference->ForEachGlyph(
+      0, AddGlyphInfo, static_cast<void*>(&first_reference_glyphs));
+  EXPECT_EQ(first_reference_glyphs.size(), 4u);
+
+  EXPECT_TRUE(
+      CompareResultGlyphs(first_glyphs, first_reference_glyphs, 0u, 4u));
+  EXPECT_TRUE(CompareResultGlyphs(first_glyphs, glyphs, 3u, 7u));
+
+  // Test view at the end of the result: ""
+  segment = {result.get(), 4, 7};
+  auto last_word = ShapeResultView::Create(&segment, 1);
+  Vector<ShapeResultTestGlyphInfo> last_glyphs;
+  last_word->ForEachGlyph(0, AddGlyphInfo, static_cast<void*>(&last_glyphs));
+
+  EXPECT_EQ(last_word->StartIndex(), 4u);
+  EXPECT_EQ(last_word->NumCharacters(), 3u);
+  EXPECT_EQ(last_word->NumGlyphs(), 3u);
+  EXPECT_EQ(last_glyphs.size(), 3u);
+}
+
+TEST_F(ShapeResultViewTest, PreviousSafeToBreak) {
+  String string =
+      u"\u0028\u05D1\u0029\u0020\u05D4\u05D1\u05DC\u0020\u05D0\u05DE\u05E8"
+      u"\u0020\u05E2\u05DC\u0020"
+      u"\u05D3\u05D1\u05E8\u05D9\u0020\u05D4\u05D1\u05DC\u05D9\u0020\u05D4"
+      u"\u05E2\u05D5\u05DC\u05DD\u002C"
+      u"\u0020\u05D5\u05E1\u05DE\u05DA\u0020\u05D4\u05B2\u05D1\u05B5\u05DC"
+      u"\u0020\u05D0\u05DC\u0020\u05D4"
+      u"\u05D1\u05DC\u05D9\u05DD\u0020\u05D5\u05D0\u05DD\u0020\u05DC\u05D0"
+      u"\u0020\u05D9\u05DE\u05E6\u05D0"
+      u"\u0020\u05DE\u05D4\u05E9\u05DE\u05D5\u05EA\u0020\u05E9\u05D4\u05DD"
+      u"\u0020\u05E2\u05DC\u0020\u05DE"
+      u"\u05E9\u05E7\u05DC\u0020\u05D0\u05E8\u05E5\u0020\u05E9\u05D9\u05E9"
+      u"\u05EA\u05E0\u05D4\u0020\u05D7"
+      u"\u05D5\u05E5\u0020\u05DE\u05B5\u05D7\u05B2\u05D3\u05B7\u05E8\u0020"
+      u"\u05DE\u05B4\u05E9\u05B0\u05C1"
+      u"\u05DB\u05B8\u05D1\u05B0\u05DA\u05B8\u0020\u0028\u05E9\u05DE\u05D5"
+      u"\u05EA\u0020\u05D6\u05F3\u003A"
+      u"\u05DB\u05F4\u05D7\u0029";
+  TextDirection direction = TextDirection::kRtl;
+  HarfBuzzShaper shaper(string);
+  const RunSegmenter::RunSegmenterRange range = {
+      51, 131, USCRIPT_HEBREW, blink::OrientationIterator::kOrientationKeep,
+      blink::FontFallbackPriority::kText};
+  scoped_refptr<ShapeResult> shape_result =
+      shaper.Shape(&font, direction, 51, 131, range);
+
+  unsigned start_offset = 59;
+  unsigned end_offset = 118;
+  scoped_refptr<const ShapeResultView> result_view =
+      ShapeResultView::Create(shape_result.get(), start_offset, end_offset);
+  scoped_refptr<ShapeResult> result = result_view->CreateShapeResult();
+
+  unsigned offset = end_offset;
+  do {
+    unsigned safe = result_view->PreviousSafeToBreakOffset(offset);
+    unsigned cached_safe = result->CachedPreviousSafeToBreakOffset(offset);
+    EXPECT_EQ(safe, cached_safe);
+  } while (--offset > start_offset);
+}
+
+TEST_F(ShapeResultViewTest, LatinMultiRun) {
+  TextDirection direction = TextDirection::kLtr;
+  HarfBuzzShaper shaper_a(To16Bit("hello", 5));
+  HarfBuzzShaper shaper_b(To16Bit(" w", 2));
+  HarfBuzzShaper shaper_c(To16Bit("orld", 4));
+  HarfBuzzShaper shaper_d(To16Bit("!", 1));
+
+  // Combine four separate results into a single one to ensure we have a result
+  // with multiple runs: "hello world!"
+  scoped_refptr<ShapeResult> result =
+      ShapeResult::Create(&font, 0, 0, direction);
+  shaper_a.Shape(&font, direction)->CopyRange(0u, 5u, result.get());
+  shaper_b.Shape(&font, direction)->CopyRange(0u, 2u, result.get());
+  shaper_c.Shape(&font, direction)->CopyRange(0u, 4u, result.get());
+  shaper_d.Shape(&font, direction)->CopyRange(0u, 1u, result.get());
+
+  Vector<ShapeResultTestGlyphInfo> result_glyphs;
+  result->ForEachGlyph(0, AddGlyphInfo, static_cast<void*>(&result_glyphs));
+
+  // Create composite view out of multiple segments where at least some of the
+  // segments have multiple runs: "hello wood wold!"
+  ShapeResultView::Segment segments[5] = {
+      {result.get(), 0, 8},    // "hello wo"
+      {result.get(), 7, 8},    // "o"
+      {result.get(), 10, 11},  // "d"
+      {result.get(), 5, 8},    // " wo"
+      {result.get(), 9, 12},   // "ld!"
+  };
+  auto composite_view = ShapeResultView::Create(&segments[0], 5);
+  Vector<ShapeResultTestGlyphInfo> view_glyphs;
+  composite_view->ForEachGlyph(0, AddGlyphInfo,
+                               static_cast<void*>(&view_glyphs));
+
+  EXPECT_EQ(composite_view->StartIndex(), 0u);
+  EXPECT_EQ(composite_view->NumCharacters(), 16u);
+  EXPECT_EQ(composite_view->NumGlyphs(), 16u);
+  EXPECT_EQ(view_glyphs.size(), 16u);
+
+  HarfBuzzShaper shaper2(To16Bit("hello world!", 12));
+  scoped_refptr<const ShapeResult> result2 = shaper2.Shape(&font, direction);
+  Vector<ShapeResultTestGlyphInfo> glyphs2;
+  result2->ForEachGlyph(0, AddGlyphInfo, static_cast<void*>(&glyphs2));
+  EXPECT_TRUE(CompareResultGlyphs(result_glyphs, glyphs2, 0u, 12u));
+
+  HarfBuzzShaper reference_shaper(To16Bit("hello wood wold!", 16));
+  scoped_refptr<const ShapeResult> reference_result =
+      reference_shaper.Shape(&font, direction);
+  Vector<ShapeResultTestGlyphInfo> reference_glyphs;
+  reference_result->ForEachGlyph(0, AddGlyphInfo,
+                                 static_cast<void*>(&reference_glyphs));
+
+  scoped_refptr<ShapeResult> composite_copy =
+      ShapeResult::Create(&font, 0, 0, direction);
+  result->CopyRange(0, 8, composite_copy.get());
+  result->CopyRange(7, 8, composite_copy.get());
+  result->CopyRange(10, 11, composite_copy.get());
+  result->CopyRange(5, 8, composite_copy.get());
+  result->CopyRange(9, 12, composite_copy.get());
+
+  Vector<ShapeResultTestGlyphInfo> composite_copy_glyphs;
+  composite_copy->ForEachGlyph(0, AddGlyphInfo,
+                               static_cast<void*>(&composite_copy_glyphs));
+
+  EXPECT_TRUE(CompareResultGlyphs(view_glyphs, reference_glyphs, 0u, 16u));
+  EXPECT_TRUE(
+      CompareResultGlyphs(composite_copy_glyphs, reference_glyphs, 0u, 16u));
+  EXPECT_EQ(composite_view->Width(), composite_copy->Width());
+}
+
+TEST_F(ShapeResultViewTest, LatinCompositeView) {
+  String string =
+      To16Bit("Test run with multiple words and breaking opportunities.", 56);
+  TextDirection direction = TextDirection::kLtr;
+
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<const ShapeResult> result = shaper.Shape(&font, direction);
+  Vector<ShapeResultTestGlyphInfo> glyphs;
+  result->ForEachGlyph(0, AddGlyphInfo, static_cast<void*>(&glyphs));
+
+  String reference_string = To16Bit("multiple breaking opportunities Test", 36);
+  HarfBuzzShaper reference_shaper(reference_string);
+  scoped_refptr<const ShapeResult> reference_result =
+      reference_shaper.Shape(&font, direction);
+  Vector<ShapeResultTestGlyphInfo> reference_glyphs;
+
+  // Match the character index logic of ShapeResult::CopyRange where the the
+  // character index of the first result is preserved and all subsequent ones
+  // are adjusted to be sequential.
+  // TODO(layout-dev): Arguably both should be updated to renumber the first
+  // result as well but some callers depend on the existing behavior.
+  scoped_refptr<ShapeResult> composite_copy =
+      ShapeResult::Create(&font, 0, 0, direction);
+  result->CopyRange(14, 23, composite_copy.get());
+  result->CopyRange(33, 55, composite_copy.get());
+  result->CopyRange(4, 5, composite_copy.get());
+  result->CopyRange(0, 4, composite_copy.get());
+  EXPECT_EQ(composite_copy->NumCharacters(), reference_result->NumCharacters());
+  EXPECT_EQ(composite_copy->NumGlyphs(), reference_result->NumGlyphs());
+  composite_copy->ForEachGlyph(0, AddGlyphInfo,
+                               static_cast<void*>(&reference_glyphs));
+
+  // Create composite view out of multiple segments:
+  ShapeResultView::Segment segments[4] = {
+      {result.get(), 14, 23},  // "multiple "
+      {result.get(), 33, 55},  // "breaking opportunities"
+      {result.get(), 4, 5},    // " "
+      {result.get(), 0, 4}     // "Test"
+  };
+  auto composite_view = ShapeResultView::Create(&segments[0], 4);
+
+  EXPECT_EQ(composite_view->StartIndex(), composite_copy->StartIndex());
+  EXPECT_EQ(composite_view->NumCharacters(), reference_result->NumCharacters());
+  EXPECT_EQ(composite_view->NumGlyphs(), reference_result->NumGlyphs());
+
+  Vector<ShapeResultTestGlyphInfo> composite_glyphs;
+  composite_view->ForEachGlyph(0, AddGlyphInfo,
+                               static_cast<void*>(&composite_glyphs));
+  EXPECT_EQ(composite_glyphs.size(), 36u);
+  EXPECT_TRUE(CompareResultGlyphs(composite_glyphs, reference_glyphs, 0u, 22u));
+  EXPECT_EQ(composite_view->Width(), composite_copy->Width());
+}
+
+TEST_F(ShapeResultViewTest, MixedScriptsCompositeView) {
+  String string_a = To16Bit("Test with multiple  ", 22);
+  String string_b = To16Bit("and .", 7);
+  TextDirection direction = TextDirection::kLtr;
+
+  HarfBuzzShaper shaper_a(string_a);
+  scoped_refptr<const ShapeResult> result_a = shaper_a.Shape(&font, direction);
+  HarfBuzzShaper shaper_b(string_b);
+  scoped_refptr<const ShapeResult> result_b = shaper_b.Shape(&font, direction);
+
+  String reference_string = To16Bit("Test with multiple  and .", 29);
+  HarfBuzzShaper reference_shaper(reference_string);
+  scoped_refptr<const ShapeResult> reference_result =
+      reference_shaper.Shape(&font, direction);
+
+  // Create a copy using CopyRange and compare with that to ensure that the same
+  // fonts are used for both the composite and the reference. The combined
+  // reference_result data might use different fonts, resulting in different
+  // glyph ids and metrics.
+  scoped_refptr<ShapeResult> composite_copy =
+      ShapeResult::Create(&font, 0, 0, direction);
+  result_a->CopyRange(0, 22, composite_copy.get());
+  result_b->CopyRange(0, 7, composite_copy.get());
+  EXPECT_EQ(composite_copy->NumCharacters(), reference_result->NumCharacters());
+  EXPECT_EQ(composite_copy->NumGlyphs(), reference_result->NumGlyphs());
+  Vector<ShapeResultTestGlyphInfo> reference_glyphs;
+  composite_copy->ForEachGlyph(0, AddGlyphInfo,
+                               static_cast<void*>(&reference_glyphs));
+
+  ShapeResultView::Segment segments[4] = {{result_a.get(), 0, 22},
+                                          {result_b.get(), 0, 7}};
+  auto composite_view = ShapeResultView::Create(&segments[0], 2);
+
+  EXPECT_EQ(composite_view->StartIndex(), 0u);
+  EXPECT_EQ(composite_view->NumCharacters(), reference_result->NumCharacters());
+  EXPECT_EQ(composite_view->NumGlyphs(), reference_result->NumGlyphs());
+
+  Vector<ShapeResultTestGlyphInfo> composite_glyphs;
+  composite_view->ForEachGlyph(0, AddGlyphInfo,
+                               static_cast<void*>(&composite_glyphs));
+  EXPECT_TRUE(CompareResultGlyphs(composite_glyphs, reference_glyphs, 0u,
+                                  reference_glyphs.size()));
+  EXPECT_EQ(composite_view->Width(), composite_copy->Width());
+}
+
+TEST_F(ShapeResultViewTest, TrimEndOfView) {
+  String string = To16Bit("12345678901234567890", 20);
+  TextDirection direction = TextDirection::kLtr;
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<const ShapeResult> result = shaper.Shape(&font, direction);
+
+  // Create a view from 5 to 20.
+  scoped_refptr<const ShapeResultView> view1 =
+      ShapeResultView::Create(result.get(), 5, 20);
+  EXPECT_EQ(view1->NumCharacters(), 15u);
+  EXPECT_EQ(view1->NumGlyphs(), 15u);
+
+  // Trim the last character from the view.
+  scoped_refptr<const ShapeResultView> view2 =
+      ShapeResultView::Create(view1.get(), 5, 19);
+  EXPECT_EQ(view2->NumCharacters(), 14u);
+  EXPECT_EQ(view2->NumGlyphs(), 14u);
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker.cc b/third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker.cc
index a7cd5af2461d..d05c94ce466e 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker.cc
@@ -4,35 +4,24 @@
 
 #include "third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker.h"
 
-#include "third_party/blink/renderer/platform/fonts/font.h"
-#include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result.h"
-#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h"
-#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h"
 #include "third_party/blink/renderer/platform/text/text_break_iterator.h"
 
 namespace blink {
 
 ShapingLineBreaker::ShapingLineBreaker(
-    const HarfBuzzShaper* shaper,
-    const Font* font,
     scoped_refptr<const ShapeResult> result,
     const LazyLineBreakIterator* break_iterator,
-    const RunSegmenter::RunSegmenterRange* pre_segmented,
-    ShapeResultSpacing<String>* spacing,
-    const Hyphenation* hyphenation)
-    : shaper_(shaper),
-      font_(font),
+    const Hyphenation* hyphenation,
+    ShapeCallback shape_callback,
+    void* shape_callback_context)
+    : shape_callback_(shape_callback),
+      shape_callback_context_(shape_callback_context),
       result_(result),
-      pre_segmented_(pre_segmented),
       break_iterator_(break_iterator),
-      spacing_(spacing),
       hyphenation_(hyphenation),
       is_soft_hyphen_enabled_(true) {
-  // ShapeResultSpacing is stateful when it has expansions. We may use it in
-  // arbitrary order that it cannot have expansions.
-  DCHECK(!spacing_ || !spacing_->HasExpansion());
-
   // Line breaking performance relies on high-performance x-position to
   // character offset lookup. Ensure that the desired cache has been computed.
   DCHECK(result_);
@@ -43,35 +32,61 @@ namespace {
 
 // ShapingLineBreaker computes using visual positions. This function flips
 // logical advance to visual, or vice versa.
-LayoutUnit FlipRtl(LayoutUnit value, TextDirection direction) {
+inline LayoutUnit FlipRtl(LayoutUnit value, TextDirection direction) {
   return IsLtr(direction) ? value : -value;
 }
 
-// Snaps a visual position to the line start direction.
-LayoutUnit SnapStart(float value, TextDirection direction) {
-  return IsLtr(direction) ? LayoutUnit::FromFloatFloor(value)
-                          : LayoutUnit::FromFloatCeil(value);
+inline float FlipRtl(float value, TextDirection direction) {
+  return IsLtr(direction) ? value : -value;
 }
 
-// Snaps a visual position to the line end direction.
-LayoutUnit SnapEnd(float value, TextDirection direction) {
-  return IsLtr(direction) ? LayoutUnit::FromFloatCeil(value)
-                          : LayoutUnit::FromFloatFloor(value);
+inline bool IsBreakableSpace(UChar ch) {
+  return LazyLineBreakIterator::IsBreakableSpace(ch) ||
+         Character::IsOtherSpaceSeparator(ch);
 }
 
 bool IsAllSpaces(const String& text, unsigned start, unsigned end) {
   return StringView(text, start, end - start)
-      .IsAllSpecialCharacters<LazyLineBreakIterator::IsBreakableSpace>();
+      .IsAllSpecialCharacters<IsBreakableSpace>();
 }
 
-bool ShouldHyphenate(const String& text, unsigned start, unsigned end) {
+bool ShouldHyphenate(const String& text,
+                     unsigned word_start,
+                     unsigned word_end,
+                     unsigned line_start) {
+  // If this is the first word in this line, allow to hyphenate. Otherwise the
+  // word will overflow.
+  if (word_start <= line_start)
+    return true;
   // Do not hyphenate the last word in a paragraph, except when it's a single
   // word paragraph.
-  if (IsAllSpaces(text, end, text.length()))
-    return IsAllSpaces(text, 0, start);
+  if (IsAllSpaces(text, word_end, text.length()))
+    return IsAllSpaces(text, 0, word_start);
   return true;
 }
 
+inline void CheckBreakOffset(unsigned offset, unsigned start, unsigned end) {
+  // It is critical to move the offset forward, or NGLineBreaker may keep adding
+  // NGInlineItemResult until all the memory is consumed.
+  CHECK_GT(offset, start);
+  // The offset must be within the given range, or NGLineBreaker will fail to
+  // sync item with offset.
+  CHECK_LE(offset, end);
+}
+
+unsigned FindNonHangableEnd(const String& text, unsigned candidate) {
+  DCHECK_LT(candidate, text.length());
+  DCHECK(IsBreakableSpace(text[candidate]));
+
+  // Looking for the non-hangable run end
+  unsigned non_hangable_end = candidate;
+  while (non_hangable_end > 0) {
+    if (!IsBreakableSpace(text[--non_hangable_end]))
+      return non_hangable_end + 1;
+  }
+  return non_hangable_end;
+}
+
 }  // namespace
 
 inline const String& ShapingLineBreaker::GetText() const {
@@ -91,21 +106,21 @@ unsigned ShapingLineBreaker::Hyphenate(unsigned offset,
     return 0;
 
   const String& text = GetText();
+  const StringView word(text, word_start, word_len);
+  const unsigned word_offset = offset - word_start;
   if (backwards) {
-    unsigned before_index = offset - word_start;
-    if (before_index <= Hyphenation::kMinimumPrefixLength)
+    if (word_offset < Hyphenation::kMinimumPrefixLength)
       return 0;
-    unsigned prefix_length = hyphenation_->LastHyphenLocation(
-        StringView(text, word_start, word_len), before_index);
-    DCHECK(!prefix_length || prefix_length < before_index);
+    unsigned prefix_length =
+        hyphenation_->LastHyphenLocation(word, word_offset + 1);
+    DCHECK(!prefix_length || prefix_length <= word_offset);
     return prefix_length;
   } else {
-    unsigned after_index = offset - word_start;
-    if (word_len <= after_index + Hyphenation::kMinimumSuffixLength)
+    if (word_len - word_offset < Hyphenation::kMinimumSuffixLength)
       return 0;
     unsigned prefix_length = hyphenation_->FirstHyphenLocation(
-        StringView(text, word_start, word_len), after_index);
-    DCHECK(!prefix_length || prefix_length > after_index);
+        word, word_offset ? word_offset - 1 : 0);
+    DCHECK(!prefix_length || prefix_length >= word_offset);
     return prefix_length;
   }
 }
@@ -116,8 +131,11 @@ ShapingLineBreaker::BreakOpportunity ShapingLineBreaker::Hyphenate(
     bool backwards) const {
   const String& text = GetText();
   unsigned word_end = break_iterator_->NextBreakOpportunity(offset);
+  if (word_end != offset && IsBreakableSpace(text[word_end - 1]))
+    word_end = std::max(offset, FindNonHangableEnd(text, word_end - 1));
   if (word_end == offset) {
-    DCHECK_EQ(offset, break_iterator_->PreviousBreakOpportunity(offset, start));
+    DCHECK(IsBreakableSpace(text[offset]) ||
+           offset == break_iterator_->PreviousBreakOpportunity(offset, start));
     return {word_end, false};
   }
   unsigned previous_break_opportunity =
@@ -125,11 +143,12 @@ ShapingLineBreaker::BreakOpportunity ShapingLineBreaker::Hyphenate(
   unsigned word_start = previous_break_opportunity;
   // Skip the leading spaces of this word because the break iterator breaks
   // before spaces.
+  // TODO (jfernandez): This is no longer true, so we should remove this code.
   while (word_start < text.length() &&
          LazyLineBreakIterator::IsBreakableSpace(text[word_start]))
     word_start++;
   if (offset >= word_start &&
-      ShouldHyphenate(text, previous_break_opportunity, word_end)) {
+      ShouldHyphenate(text, previous_break_opportunity, word_end, start)) {
     unsigned prefix_length = Hyphenate(offset, word_start, word_end, backwards);
     if (prefix_length)
       return {word_start + prefix_length, true};
@@ -140,50 +159,78 @@ ShapingLineBreaker::BreakOpportunity ShapingLineBreaker::Hyphenate(
 ShapingLineBreaker::BreakOpportunity
 ShapingLineBreaker::PreviousBreakOpportunity(unsigned offset,
                                              unsigned start) const {
+  const String& text = GetText();
   if (UNLIKELY(!IsSoftHyphenEnabled())) {
-    const String& text = GetText();
     for (;; offset--) {
       offset = break_iterator_->PreviousBreakOpportunity(offset, start);
       if (offset <= start || offset >= text.length() ||
-          text[offset - 1] != kSoftHyphenCharacter)
+          text[offset - 1] != kSoftHyphenCharacter) {
+        if (IsBreakableSpace(text[offset - 1]))
+          return {offset, FindNonHangableEnd(text, offset - 1), false};
         return {offset, false};
+      }
     }
   }
 
   if (UNLIKELY(hyphenation_))
     return Hyphenate(offset, start, true);
 
-  return {break_iterator_->PreviousBreakOpportunity(offset, start), false};
+  // If the break opportunity is preceded by trailing spaces, find the
+  // end of non-hangable character (i.e., start of the space run).
+  unsigned break_offset =
+      break_iterator_->PreviousBreakOpportunity(offset, start);
+  if (IsBreakableSpace(text[break_offset - 1]))
+    return {break_offset, FindNonHangableEnd(text, break_offset - 1), false};
+
+  return {break_offset, false};
 }
 
 ShapingLineBreaker::BreakOpportunity ShapingLineBreaker::NextBreakOpportunity(
     unsigned offset,
-    unsigned start) const {
+    unsigned start,
+    unsigned len) const {
+  const String& text = GetText();
   if (UNLIKELY(!IsSoftHyphenEnabled())) {
-    const String& text = GetText();
     for (;; offset++) {
       offset = break_iterator_->NextBreakOpportunity(offset);
-      if (offset >= text.length() || text[offset - 1] != kSoftHyphenCharacter)
+      if (offset >= text.length() || text[offset - 1] != kSoftHyphenCharacter) {
+        if (IsBreakableSpace(text[offset - 1]))
+          return {offset, FindNonHangableEnd(text, offset - 1), false};
         return {offset, false};
+      }
     }
   }
 
   if (UNLIKELY(hyphenation_))
     return Hyphenate(offset, start, false);
 
-  return {break_iterator_->NextBreakOpportunity(offset), false};
+  // We should also find the beginning of the space run to find the
+  // end of non-hangable character (i.e., start of the space run),
+  // which may be useful to avoid reshaping.
+  unsigned break_offset = break_iterator_->NextBreakOpportunity(offset, len);
+  if (IsBreakableSpace(text[break_offset - 1]))
+    return {break_offset, FindNonHangableEnd(text, break_offset - 1), false};
+
+  return {break_offset, false};
 }
 
-inline scoped_refptr<ShapeResult> ShapingLineBreaker::Shape(TextDirection direction,
-                                                     unsigned start,
-                                                     unsigned end) {
-  if (!spacing_ || !spacing_->HasSpacing())
-    return shaper_->Shape(font_, direction, start, end, pre_segmented_);
+inline void ShapingLineBreaker::SetBreakOffset(unsigned break_offset,
+                                               const String& text,
+                                               Result* result) {
+  result->break_offset = break_offset;
+  result->is_hyphenated =
+      text[result->break_offset - 1] == kSoftHyphenCharacter;
+}
 
-  scoped_refptr<ShapeResult> result =
-      shaper_->Shape(font_, direction, start, end, pre_segmented_);
-  result->ApplySpacing(*spacing_);
-  return result;
+inline void ShapingLineBreaker::SetBreakOffset(
+    const BreakOpportunity& break_opportunity,
+    const String& text,
+    Result* result) {
+  result->break_offset = break_opportunity.offset;
+  result->is_hyphenated =
+      break_opportunity.is_hyphenated ||
+      text[result->break_offset - 1] == kSoftHyphenCharacter;
+  result->non_hangable_run_end = break_opportunity.non_hangable_run_end;
 }
 
 // Shapes a line of text by finding a valid and appropriate break opportunity
@@ -215,31 +262,34 @@ inline scoped_refptr<ShapeResult> ShapingLineBreaker::Shape(TextDirection direct
 //   If we further assume that the font kerns with space then even though it's a
 //   valid break opportunity reshaping is required as the combined width of the
 //   two segments "Line " and "breaking" may be different from "Line breaking".
-scoped_refptr<const ShapeResult> ShapingLineBreaker::ShapeLine(
+scoped_refptr<const ShapeResultView> ShapingLineBreaker::ShapeLine(
     unsigned start,
     LayoutUnit available_space,
     unsigned options,
     ShapingLineBreaker::Result* result_out) {
   DCHECK_GE(available_space, LayoutUnit(0));
-  unsigned range_start = result_->StartIndexForResult();
-  unsigned range_end = result_->EndIndexForResult();
+  unsigned range_start = result_->StartIndex();
+  unsigned range_end = result_->EndIndex();
   DCHECK_GE(start, range_start);
   DCHECK_LT(start, range_end);
+  result_out->is_overflow = false;
   result_out->is_hyphenated = false;
+  result_out->has_trailing_spaces = false;
   const String& text = GetText();
+  const bool is_break_after_any_space =
+      break_iterator_->BreakSpace() == BreakSpaceType::kAfterEverySpace;
 
   // The start position in the original shape results.
-  float start_position_float =
-      result_->CachedPositionForOffset(start - range_start);
-  TextDirection direction = result_->Direction();
-  LayoutUnit start_position = SnapStart(start_position_float, direction);
+  float start_position = result_->CachedPositionForOffset(start - range_start);
 
   // Find a candidate break opportunity by identifying the last offset before
   // exceeding the available space and the determine the closest valid break
   // preceding the candidate.
-  LayoutUnit end_position = SnapEnd(start_position_float, direction) +
-                            FlipRtl(available_space, direction);
-  DCHECK_GE(FlipRtl(end_position - start_position, direction), LayoutUnit(0));
+  TextDirection direction = result_->Direction();
+  float end_position = start_position + FlipRtl(available_space, direction);
+  DCHECK_GE(FlipRtl(LayoutUnit::FromFloatCeil(end_position - start_position),
+                    direction),
+            LayoutUnit(0));
   unsigned candidate_break =
       result_->CachedOffsetForPosition(end_position) + range_start;
 
@@ -251,7 +301,7 @@ scoped_refptr<const ShapeResult> ShapingLineBreaker::ShapeLine(
     // The |result_| does not have glyphs to fill the available space,
     // and thus unable to compute. Return the result up to range_end.
     DCHECK_EQ(candidate_break, range_end);
-    result_out->break_offset = range_end;
+    SetBreakOffset(range_end, text, result_out);
     return ShapeToEnd(start, first_safe, range_start, range_end);
   }
 
@@ -259,24 +309,69 @@ scoped_refptr<const ShapeResult> ShapingLineBreaker::ShapeLine(
   // comparing floats. See ShapeLineZeroAvailableWidth on Linux/Mac.
   candidate_break = std::max(candidate_break, start);
 
-  // If there are no break opportunity before candidate_break, overflow.
-  // Find the next break opportunity after the candidate_break.
+  // If we are in the middle of a trailing space sequence, which are
+  // defined by the UAX#14 spec as Break After (A) class, we should
+  // look for breaking opportunityes after the end of the sequence.
+  // https://www.unicode.org/reports/tr14/#BA
+  // TODO(jfernandez): if break-spaces, do special handling.
   BreakOpportunity break_opportunity =
-      PreviousBreakOpportunity(candidate_break, start);
-  bool is_overflow = break_opportunity.offset <= start;
-  if (is_overflow) {
+      !IsBreakableSpace(text[candidate_break]) || is_break_after_any_space
+          ? PreviousBreakOpportunity(candidate_break, start)
+          : NextBreakOpportunity(std::max(candidate_break, start + 1), start,
+                                 range_end);
+
+  // There are no break opportunity before candidate_break, overflow.
+  // Find the next break opportunity after the candidate_break.
+  // TODO: (jfernandez): Maybe also non_hangable_run_end <= start ?
+  result_out->is_overflow = break_opportunity.offset <= start;
+  if (result_out->is_overflow) {
+    DCHECK(is_break_after_any_space ||
+           !IsBreakableSpace(text[candidate_break]));
     if (options & kNoResultIfOverflow)
       return nullptr;
-    break_opportunity =
-        NextBreakOpportunity(std::max(candidate_break, start + 1), start);
-    // |range_end| may not be a break opportunity, but this function cannot
-    // measure beyond it.
-    if (break_opportunity.offset >= range_end) {
-      result_out->break_offset = range_end;
-      return ShapeToEnd(start, first_safe, range_start, range_end);
+    // No need to scan past range_end for a break opportunity.
+    break_opportunity = NextBreakOpportunity(
+        std::max(candidate_break, start + 1), start, range_end);
+  }
+
+  // We don't care whether this result contains only spaces if we
+  // are breaking after any space. We shouldn't early return either
+  // in that case.
+  if (!is_break_after_any_space && break_opportunity.non_hangable_run_end &&
+      break_opportunity.non_hangable_run_end <= start) {
+    // TODO (jfenandez): There may be cases where candidate_break is
+    // not a breakable space but we also want to early return for
+    // triggering the trailing spaces handling
+    if (IsBreakableSpace(text[candidate_break])) {
+      result_out->has_trailing_spaces = true;
+      result_out->break_offset = std::min(range_end, break_opportunity.offset);
+      result_out->non_hangable_run_end = break_opportunity.non_hangable_run_end;
+#if DCHECK_IS_ON()
+      DCHECK(IsAllSpaces(text, start, result_out->break_offset));
+#endif
+      result_out->is_hyphenated = false;
+      return ShapeResultView::Create(result_.get(), start,
+                                     result_out->break_offset);
     }
   }
-  DCHECK_GT(break_opportunity.offset, start);
+
+  // |range_end| may not be a break opportunity, but this function cannot
+  // measure beyond it.
+  if (break_opportunity.offset >= range_end) {
+    SetBreakOffset(range_end, text, result_out);
+    if (result_out->is_overflow)
+      return ShapeToEnd(start, first_safe, range_start, range_end);
+    break_opportunity.offset = range_end;
+    if (break_opportunity.non_hangable_run_end &&
+        range_end < break_opportunity.non_hangable_run_end) {
+      break_opportunity.non_hangable_run_end = base::nullopt;
+    }
+    if (IsBreakableSpace(text[range_end - 1])) {
+      break_opportunity.non_hangable_run_end =
+          FindNonHangableEnd(text, range_end - 1);
+    }
+  }
+  CheckBreakOffset(break_opportunity.offset, start, range_end);
 
   // If the start offset is not at a safe-to-break boundary the content between
   // the start and the next safe-to-break boundary needs to be reshaped and the
@@ -285,45 +380,82 @@ scoped_refptr<const ShapeResult> ShapingLineBreaker::ShapeLine(
   if (first_safe != start) {
     if (first_safe >= break_opportunity.offset) {
       // There is no safe-to-break, reshape the whole range.
-      result_out->break_offset = break_opportunity.offset;
-      return Shape(direction, start, break_opportunity.offset);
+      if (!is_break_after_any_space && break_opportunity.non_hangable_run_end) {
+        break_opportunity.offset =
+            std::max(start + 1, *break_opportunity.non_hangable_run_end);
+      }
+      SetBreakOffset(break_opportunity, text, result_out);
+      CheckBreakOffset(result_out->break_offset, start, range_end);
+      return ShapeResultView::Create(
+          Shape(start, break_opportunity.offset).get());
     }
-    LayoutUnit original_width = FlipRtl(
-        SnapEnd(result_->CachedPositionForOffset(first_safe - range_start),
-                direction) -
-            start_position,
-        direction);
-    line_start_result = Shape(direction, start, first_safe);
+    float first_safe_position =
+        result_->CachedPositionForOffset(first_safe - range_start);
+    LayoutUnit original_width = LayoutUnit::FromFloatCeil(
+        FlipRtl(first_safe_position - start_position, direction));
+    line_start_result = Shape(start, first_safe);
     available_space += line_start_result->SnappedWidth() - original_width;
   }
   DCHECK_GE(first_safe, start);
   DCHECK_LE(first_safe, break_opportunity.offset);
 
   scoped_refptr<const ShapeResult> line_end_result;
+  bool reshape_line_end = true;
+  if (options & kDontReshapeEndIfAtSpace) {
+    if (IsBreakableSpace(text[break_opportunity.offset - 1]))
+      reshape_line_end = false;
+  }
+  // Avoid re-shape if at the end of the range.
+  // TODO (jfernandez): Is this even possible ? Shouldn't we just
+  // early return if offset >= range_end ?
+  if (break_opportunity.offset == range_end)
+    reshape_line_end = false;
+  if (!is_break_after_any_space && break_opportunity.non_hangable_run_end) {
+    break_opportunity.offset =
+        std::max(start + 1, *break_opportunity.non_hangable_run_end);
+  }
   unsigned last_safe = break_opportunity.offset;
-  if (break_opportunity.offset > start) {
+  if (reshape_line_end) {
     // If the previous valid break opportunity is not at a safe-to-break
     // boundary reshape between the safe-to-break offset and the valid break
     // offset. If the resulting width exceeds the available space the
     // preceding boundary is tried until the available space is sufficient.
     while (true) {
-      DCHECK_LE(first_safe, break_opportunity.offset);
-      last_safe = std::max(
-          result_->CachedPreviousSafeToBreakOffset(break_opportunity.offset),
-          first_safe);
-      DCHECK_LE(last_safe, break_opportunity.offset);
-      DCHECK_GE(last_safe, first_safe);
+      DCHECK_LE(start, break_opportunity.offset);
+      if (!is_break_after_any_space && break_opportunity.non_hangable_run_end) {
+        break_opportunity.offset =
+            std::max(start + 1, *break_opportunity.non_hangable_run_end);
+      }
+      last_safe =
+          result_->CachedPreviousSafeToBreakOffset(break_opportunity.offset);
+      // No need to reshape the line end because this opportunity is safe.
       if (last_safe == break_opportunity.offset)
         break;
-      DCHECK_LE(break_opportunity.offset, range_end);
-      if (is_overflow) {
-        line_end_result = Shape(direction, last_safe, break_opportunity.offset);
+      if (UNLIKELY(last_safe > break_opportunity.offset)) {
+        // TODO(crbug.com/1787026): This should not happen, but we see crashes.
+        NOTREACHED();
         break;
       }
-      LayoutUnit safe_position = SnapStart(
-          result_->CachedPositionForOffset(last_safe - range_start), direction);
-      line_end_result = Shape(direction, last_safe, break_opportunity.offset);
-      if (line_end_result->SnappedWidth() <=
+
+      // Moved the opportunity back enough to require reshaping the whole line.
+      if (UNLIKELY(last_safe < first_safe)) {
+        DCHECK(last_safe == 0 || last_safe < start);
+        last_safe = start;
+        line_start_result = nullptr;
+      }
+
+      // If previously determined to let it overflow, reshape the line end.
+      DCHECK_LE(break_opportunity.offset, range_end);
+      if (UNLIKELY(result_out->is_overflow)) {
+        line_end_result = Shape(last_safe, break_opportunity.offset);
+        break;
+      }
+
+      // Check if this opportunity can fit after reshaping the line end.
+      float safe_position =
+          result_->CachedPositionForOffset(last_safe - range_start);
+      line_end_result = Shape(last_safe, break_opportunity.offset);
+      if (line_end_result->Width() <=
           FlipRtl(end_position - safe_position, direction))
         break;
 
@@ -340,11 +472,24 @@ scoped_refptr<const ShapeResult> ShapingLineBreaker::ShapeLine(
       // This line will overflow, but there are multiple choices to break,
       // because none can fit. The one after candidate_break is better for
       // ligatures, but the one before is better for kernings.
+      result_out->is_overflow = true;
+      // TODO (jfernandez): Would be possible to refactor this logic
+      // with the one performed prior tp the reshape
+      // (FindBreakingOpportuntty() + overflow handling)?
       break_opportunity = PreviousBreakOpportunity(candidate_break, start);
+      if (break_opportunity.offset <= start) {
+        break_opportunity = NextBreakOpportunity(
+            std::max(candidate_break, start + 1), start, range_end);
+        if (break_opportunity.offset >= range_end) {
+          SetBreakOffset(range_end, text, result_out);
+          return ShapeToEnd(start, first_safe, range_start, range_end);
+        }
+      }
       // Loop once more to compute last_safe for the new break opportunity.
-      is_overflow = true;
     }
   }
+  // It is critical to move forward, or callers may end up in an infinite loop.
+  CheckBreakOffset(break_opportunity.offset, start, range_end);
   DCHECK_GE(break_opportunity.offset, last_safe);
   DCHECK_EQ(break_opportunity.offset - start,
             (line_start_result ? line_start_result->NumCharacters() : 0) +
@@ -353,59 +498,57 @@ scoped_refptr<const ShapeResult> ShapingLineBreaker::ShapeLine(
 
   // Create shape results for the line by copying from the re-shaped result (if
   // reshaping was needed) and the original shape results.
-  scoped_refptr<ShapeResult> line_result = ShapeResult::Create(font_, 0, direction);
+  ShapeResultView::Segment segments[3];
   unsigned max_length = std::numeric_limits<unsigned>::max();
+  unsigned count = 0;
   if (line_start_result)
-    line_start_result->CopyRange(0, max_length, line_result.get());
+    segments[count++] = {line_start_result.get(), 0, max_length};
   if (last_safe > first_safe)
-    result_->CopyRange(first_safe, last_safe, line_result.get());
+    segments[count++] = {result_.get(), first_safe, last_safe};
   if (line_end_result)
-    line_end_result->CopyRange(last_safe, max_length, line_result.get());
-
-  DCHECK_GT(break_opportunity.offset, start);
-  DCHECK_LE(break_opportunity.offset, range_end);
+    segments[count++] = {line_end_result.get(), last_safe, max_length};
+  auto line_result = ShapeResultView::Create(&segments[0], count);
   DCHECK_EQ(break_opportunity.offset - start, line_result->NumCharacters());
 
-  result_out->break_offset = break_opportunity.offset;
-  result_out->is_hyphenated =
-      break_opportunity.is_hyphenated ||
-      text[break_opportunity.offset - 1] == kSoftHyphenCharacter;
+  SetBreakOffset(break_opportunity, text, result_out);
   return line_result;
 }
 
 // Shape from the specified offset to the end of the ShapeResult.
 // If |start| is safe-to-break, this copies the subset of the result.
-scoped_refptr<const ShapeResult> ShapingLineBreaker::ShapeToEnd(
+scoped_refptr<const ShapeResultView> ShapingLineBreaker::ShapeToEnd(
     unsigned start,
     unsigned first_safe,
     unsigned range_start,
     unsigned range_end) {
   DCHECK(result_);
-  DCHECK_EQ(range_start, result_->StartIndexForResult());
-  DCHECK_EQ(range_end, result_->EndIndexForResult());
+  DCHECK_EQ(range_start, result_->StartIndex());
+  DCHECK_EQ(range_end, result_->EndIndex());
   DCHECK_GE(start, range_start);
   DCHECK_LT(start, range_end);
   DCHECK_GE(first_safe, start);
 
   // If |start| is at the start of the range the entire result object may be
-  // reused, which avoids creating an extra copy an the sub-range logic.
+  // reused, which avoids the sub-range logic and bounds computation.
   if (start == range_start)
-    return result_;
+    return ShapeResultView::Create(result_.get());
 
   // If |start| is safe-to-break, no reshape is needed.
   if (start == first_safe)
-    return result_->SubRange(start, range_end);
+    return ShapeResultView::Create(result_.get(), start, range_end);
 
   // If no safe-to-break offset is found in range, reshape the entire range.
-  TextDirection direction = result_->Direction();
-  if (first_safe >= range_end)
-    return Shape(direction, start, range_end);
+  if (first_safe >= range_end) {
+    scoped_refptr<ShapeResult> line_result = Shape(start, range_end);
+    return ShapeResultView::Create(line_result.get());
+  }
 
   // Otherwise reshape to |first_safe|, then copy the rest.
-  scoped_refptr<ShapeResult> line_result = Shape(direction, start, first_safe);
-  result_->CopyRange(first_safe, range_end, line_result.get());
-  DCHECK_EQ(range_end - start, line_result->NumCharacters());
-  return line_result;
+  scoped_refptr<ShapeResult> line_start = Shape(start, first_safe);
+  ShapeResultView::Segment segments[2] = {
+      {line_start.get(), 0, std::numeric_limits<unsigned>::max()},
+      {result_.get(), first_safe, range_end}};
+  return ShapeResultView::Create(&segments[0], 2);
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker.h b/third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker.h
index d06cc93ae584..1b4e61ce700b 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker.h
+++ b/third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker.h
@@ -6,21 +6,18 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_SHAPING_LINE_BREAKER_H_
 
 #include "third_party/blink/renderer/platform/fonts/shaping/run_segmenter.h"
-#include "third_party/blink/renderer/platform/layout_unit.h"
+#include "third_party/blink/renderer/platform/geometry/layout_unit.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/text/text_direction.h"
 #include "third_party/blink/renderer/platform/wtf/text/atomic_string.h"
 
 namespace blink {
 
-class Font;
 class ShapeResult;
-class HarfBuzzShaper;
+class ShapeResultView;
 class Hyphenation;
 class LazyLineBreakIterator;
 enum class LineBreakType;
-template <typename TextContainerType>
-class ShapeResultSpacing;
 
 // Shapes a line of text by finding the ideal break position as indicated by the
 // available space and the shape results for the entire paragraph. Once an ideal
@@ -36,26 +33,40 @@ class PLATFORM_EXPORT ShapingLineBreaker final {
   STACK_ALLOCATED();
 
  public:
-  // Construct a ShapingLineBreaker.
+  // Callback function to reshape line edges.
   //
-  // When the ShapeResult is from a RunSegmenterRange, giving it can skip
-  // running RunSegmenter for much better performance.
-  ShapingLineBreaker(const HarfBuzzShaper*,
-                     const Font*,
-                     scoped_refptr<const ShapeResult>,
-                     const LazyLineBreakIterator*,
-                     const RunSegmenter::RunSegmenterRange* = nullptr,
-                     ShapeResultSpacing<String>* = nullptr,
-                     const Hyphenation* = nullptr);
-  ~ShapingLineBreaker() = default;
+  // std::function is forbidden in Chromium and base::Callback is way too
+  // expensive so we resort to a good old function pointer instead.
+  using ShapeCallback = scoped_refptr<ShapeResult> (*)(void* context,
+                                                       unsigned start,
+                                                       unsigned end);
+
+  // Construct a ShapingLineBreaker.
+  ShapingLineBreaker(scoped_refptr<const ShapeResult> result,
+                     const LazyLineBreakIterator* break_iterator,
+                     const Hyphenation* hyphenation,
+                     ShapeCallback shape_callback,
+                     void* shape_callback_context);
 
   // Represents details of the result of |ShapeLine()|.
   struct Result {
     STACK_ALLOCATED();
 
+   public:
+    // Indicates the limits of the space run.
+    base::Optional<unsigned> non_hangable_run_end;
+
     // Indicates the resulting break offset.
     unsigned break_offset;
 
+    // Indicates that the shape result contains trailing spaces
+    bool has_trailing_spaces;
+
+    // True if there were no break opportunities that can fit. When this is
+    // false, the result width should be smaller than or equal to the available
+    // space.
+    bool is_overflow;
+
     // True if the break is hyphenated, either by automatic hyphenation or
     // soft-hyphen characters.
     // The hyphen glyph is not included in the |ShapeResult|, and that appending
@@ -69,19 +80,23 @@ class PLATFORM_EXPORT ShapingLineBreaker final {
     kDefaultOptions = 0,
     // Disable reshpaing the start edge even if the start offset is not safe-
     // to-break. Set if this is not at the start edge of a wrapped line.
-    kDontReshapeStart = 1,
+    kDontReshapeStart = 1 << 0,
+    // Disable reshaping the end edge if it is at a breakable space, even if it
+    // is not safe-to-break. Good for performance if accurate width is not
+    // critical.
+    kDontReshapeEndIfAtSpace = 1 << 1,
     // Returns nullptr if this line overflows. When the word is very long, such
     // as URL or data, creating ShapeResult is expensive. Set this option to
     // suppress if ShapeResult is not needed when this line overflows.
-    kNoResultIfOverflow = 2,
+    kNoResultIfOverflow = 1 << 2,
   };
-  scoped_refptr<const ShapeResult> ShapeLine(unsigned start_offset,
-                                             LayoutUnit available_space,
-                                             unsigned options,
-                                             Result* result_out);
-  scoped_refptr<const ShapeResult> ShapeLine(unsigned start_offset,
-                                             LayoutUnit available_space,
-                                             Result* result_out) {
+  scoped_refptr<const ShapeResultView> ShapeLine(unsigned start_offset,
+                                                 LayoutUnit available_space,
+                                                 unsigned options,
+                                                 Result* result_out);
+  scoped_refptr<const ShapeResultView> ShapeLine(unsigned start_offset,
+                                                 LayoutUnit available_space,
+                                                 Result* result_out) {
     return ShapeLine(start_offset, available_space, kDefaultOptions,
                      result_out);
   }
@@ -97,12 +112,24 @@ class PLATFORM_EXPORT ShapingLineBreaker final {
   struct BreakOpportunity {
     STACK_ALLOCATED();
 
+   public:
+    BreakOpportunity(unsigned new_offset, bool hyphenated)
+        : offset(new_offset),
+          is_hyphenated(hyphenated) {}
+    BreakOpportunity(unsigned new_offset, unsigned run_end, bool hyphenated)
+        : offset(new_offset),
+          non_hangable_run_end(run_end),
+          is_hyphenated(hyphenated) {}
+
     unsigned offset;
+    base::Optional<unsigned> non_hangable_run_end;
     bool is_hyphenated;
   };
   BreakOpportunity PreviousBreakOpportunity(unsigned offset,
                                             unsigned start) const;
-  BreakOpportunity NextBreakOpportunity(unsigned offset, unsigned start) const;
+  BreakOpportunity NextBreakOpportunity(unsigned offset,
+                                        unsigned start,
+                                        unsigned len) const;
   BreakOpportunity Hyphenate(unsigned offset,
                              unsigned start,
                              bool backwards) const;
@@ -111,20 +138,21 @@ class PLATFORM_EXPORT ShapingLineBreaker final {
                      unsigned word_end,
                      bool backwards) const;
 
-  scoped_refptr<ShapeResult> Shape(TextDirection, unsigned start, unsigned end);
-  scoped_refptr<const ShapeResult> ShapeToEnd(unsigned start,
-                                              unsigned first_safe,
-                                              unsigned range_start,
-                                              unsigned range_end);
+  scoped_refptr<ShapeResult> Shape(unsigned start, unsigned end) {
+    return (*shape_callback_)(shape_callback_context_, start, end);
+  }
+  scoped_refptr<const ShapeResultView> ShapeToEnd(unsigned start,
+                                                  unsigned first_safe,
+                                                  unsigned range_start,
+                                                  unsigned range_end);
 
-  const HarfBuzzShaper* shaper_;
-  const Font* font_;
+  void SetBreakOffset(unsigned break_offset, const String&, Result*);
+  void SetBreakOffset(const BreakOpportunity&, const String&, Result*);
+
+  const ShapeCallback shape_callback_;
+  void* shape_callback_context_;
   scoped_refptr<const ShapeResult> result_;
-  const RunSegmenter::RunSegmenterRange* pre_segmented_;
   const LazyLineBreakIterator* break_iterator_;
-  // TODO(kojii): ShapeResultSpacing is not const because it's stateful when it
-  // has expansions. Split spacing and expansions to make this const.
-  ShapeResultSpacing<String>* spacing_;
   const Hyphenation* hyphenation_;
   bool is_soft_hyphen_enabled_;
 
diff --git a/third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker_test.cc b/third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker_test.cc
index 16b10a591283..52c122ef5ee7 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker_test.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/shaping_line_breaker_test.cc
@@ -10,8 +10,8 @@
 #include "third_party/blink/renderer/platform/fonts/font.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #include "third_party/blink/renderer/platform/fonts/font_test_utilities.h"
-#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h"
 #include "third_party/blink/renderer/platform/text/text_break_iterator.h"
 #include "third_party/blink/renderer/platform/text/text_run.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
@@ -20,12 +20,26 @@ namespace blink {
 
 namespace {
 
-scoped_refptr<const ShapeResult> ShapeLine(ShapingLineBreaker* breaker,
-                                           unsigned start_offset,
-                                           LayoutUnit available_space,
-                                           unsigned* break_offset) {
+struct HarfBuzzShaperCallbackContext {
+  const HarfBuzzShaper* shaper;
+  const Font* font;
+  TextDirection direction;
+};
+
+scoped_refptr<ShapeResult> HarfBuzzShaperCallback(void* untyped_context,
+                                                  unsigned start,
+                                                  unsigned end) {
+  HarfBuzzShaperCallbackContext* context =
+      static_cast<HarfBuzzShaperCallbackContext*>(untyped_context);
+  return context->shaper->Shape(context->font, context->direction, start, end);
+}
+
+scoped_refptr<const ShapeResultView> ShapeLine(ShapingLineBreaker* breaker,
+                                               unsigned start_offset,
+                                               LayoutUnit available_space,
+                                               unsigned* break_offset) {
   ShapingLineBreaker::Result result;
-  scoped_refptr<const ShapeResult> shape_result =
+  scoped_refptr<const ShapeResultView> shape_result =
       breaker->ShapeLine(start_offset, available_space, &result);
   *break_offset = result.break_offset;
   return shape_result;
@@ -38,7 +52,21 @@ class ShapingLineBreakerTest : public testing::Test {
   void SetUp() override {
     font_description.SetComputedSize(12.0);
     font = Font(font_description);
-    font.Update(nullptr);
+  }
+
+  void SelectLucidaFont() {
+    FontFamily lucida_family;
+    // Windows 10
+    lucida_family.SetFamily("Lucida Grande");
+    // Windows 7
+    lucida_family.AppendFamily("Lucida Grande");
+    // Linux
+    lucida_family.AppendFamily("Lucida Medium");
+    // Mac
+    lucida_family.AppendFamily("Lucida Medium");
+
+    font_description.SetFamily(lucida_family);
+    font = Font(font_description);
   }
 
   void TearDown() override {}
@@ -48,7 +76,8 @@ class ShapingLineBreakerTest : public testing::Test {
                                         const String& string) {
     Vector<unsigned> break_positions;
     for (unsigned i = 0; i <= string.length(); i++) {
-      unsigned next = breaker.NextBreakOpportunity(i, 0).offset;
+      unsigned next =
+          breaker.NextBreakOpportunity(i, 0, string.length()).offset;
       if (break_positions.IsEmpty() || break_positions.back() != next)
         break_positions.push_back(next);
     }
@@ -108,8 +137,10 @@ TEST_F(ShapingLineBreakerTest, ShapeLineLatin) {
       shaper.Shape(&font, direction, 0, 4);
   ASSERT_LT(first1->SnappedWidth(), first2->SnappedWidth());
 
-  ShapingLineBreaker breaker(&shaper, &font, result.get(), &break_iterator);
-  scoped_refptr<const ShapeResult> line;
+  HarfBuzzShaperCallbackContext context{&shaper, &font, result->Direction()};
+  ShapingLineBreaker breaker(result, &break_iterator, nullptr,
+                             HarfBuzzShaperCallback, &context);
+  scoped_refptr<const ShapeResultView> line;
   unsigned break_offset = 0;
 
   // Test the case where the entire string fits.
@@ -167,7 +198,9 @@ TEST_F(ShapingLineBreakerTest, ShapeLineLatinMultiLine) {
   scoped_refptr<const ShapeResult> mid_third =
       shaper.Shape(&font, direction, 0, 16);
 
-  ShapingLineBreaker breaker(&shaper, &font, result.get(), &break_iterator);
+  HarfBuzzShaperCallbackContext context{&shaper, &font, result->Direction()};
+  ShapingLineBreaker breaker(result, &break_iterator, nullptr,
+                             HarfBuzzShaperCallback, &context);
   unsigned break_offset = 0;
 
   ShapeLine(&breaker, 0, result->SnappedWidth() - 1, &break_offset);
@@ -194,8 +227,10 @@ TEST_F(ShapingLineBreakerTest, ShapeLineLatinBreakAll) {
   scoped_refptr<const ShapeResult> midpoint =
       shaper.Shape(&font, direction, 0, 16);
 
-  ShapingLineBreaker breaker(&shaper, &font, result.get(), &break_iterator);
-  scoped_refptr<const ShapeResult> line;
+  HarfBuzzShaperCallbackContext context{&shaper, &font, result->Direction()};
+  ShapingLineBreaker breaker(result, &break_iterator, nullptr,
+                             HarfBuzzShaperCallback, &context);
+  scoped_refptr<const ShapeResultView> line;
   unsigned break_offset = 0;
 
   line = ShapeLine(&breaker, 0, midpoint->SnappedWidth(), &break_offset);
@@ -215,8 +250,10 @@ TEST_F(ShapingLineBreakerTest, ShapeLineZeroAvailableWidth) {
   HarfBuzzShaper shaper(string);
   scoped_refptr<const ShapeResult> result = shaper.Shape(&font, direction);
 
-  ShapingLineBreaker breaker(&shaper, &font, result.get(), &break_iterator);
-  scoped_refptr<const ShapeResult> line;
+  HarfBuzzShaperCallbackContext context{&shaper, &font, result->Direction()};
+  ShapingLineBreaker breaker(result, &break_iterator, nullptr,
+                             HarfBuzzShaperCallback, &context);
+  scoped_refptr<const ShapeResultView> line;
   unsigned break_offset = 0;
   LayoutUnit zero(0);
 
@@ -258,7 +295,9 @@ TEST_F(ShapingLineBreakerTest, DISABLED_ShapeLineArabicThaiHanLatin) {
                        });
   LayoutUnit longest_word_width = (*longest_word)->SnappedWidth();
 
-  ShapingLineBreaker breaker(&shaper, &font, result.get(), &break_iterator);
+  HarfBuzzShaperCallbackContext context{&shaper, &font, result->Direction()};
+  ShapingLineBreaker breaker(result, &break_iterator, nullptr,
+                             HarfBuzzShaperCallback, &context);
   scoped_refptr<const ShapeResult> line;
   unsigned break_offset = 0;
 
@@ -287,8 +326,10 @@ TEST_F(ShapingLineBreakerTest, ShapeLineRangeEndMidWord) {
   scoped_refptr<const ShapeResult> result =
       shaper.Shape(&font, direction, 0, 2);
 
-  ShapingLineBreaker breaker(&shaper, &font, result.get(), &break_iterator);
-  scoped_refptr<const ShapeResult> line;
+  HarfBuzzShaperCallbackContext context{&shaper, &font, result->Direction()};
+  ShapingLineBreaker breaker(result, &break_iterator, nullptr,
+                             HarfBuzzShaperCallback, &context);
+  scoped_refptr<const ShapeResultView> line;
   unsigned break_offset = 0;
 
   line = ShapeLine(&breaker, 0, LayoutUnit::Max(), &break_offset);
@@ -296,6 +337,41 @@ TEST_F(ShapingLineBreakerTest, ShapeLineRangeEndMidWord) {
   EXPECT_EQ(result->Width(), line->Width());
 }
 
+TEST_F(ShapingLineBreakerTest, ShapeLineWithLucidaFont) {
+  SelectLucidaFont();
+  FontDescription::VariantLigatures ligatures;
+  ligatures.common = FontDescription::kEnabledLigaturesState;
+
+  //              012345678901234567890123456789012345
+  String string(u"Lorem ipsum, consexx porttitxx. xxx");
+  LazyLineBreakIterator break_iterator(string, "en-US", LineBreakType::kNormal);
+  // In LayoutNG we use kAfterSpaceRun as TextBreakIterator`s default behavior.
+  break_iterator.SetBreakSpace(BreakSpaceType::kAfterSpaceRun);
+  TextDirection direction = TextDirection::kLtr;
+
+  HarfBuzzShaper shaper(string);
+  scoped_refptr<const ShapeResult> result =
+      shaper.Shape(&font, direction, 0, 35);
+  scoped_refptr<const ShapeResult> segment1 =
+      shaper.Shape(&font, direction, 13, 31);
+  scoped_refptr<const ShapeResult> segment2 =
+      shaper.Shape(&font, direction, 13, 32);
+
+  HarfBuzzShaperCallbackContext context{&shaper, &font, result->Direction()};
+  ShapingLineBreaker breaker(result, &break_iterator, nullptr,
+                             HarfBuzzShaperCallback, &context);
+  scoped_refptr<const ShapeResultView> line;
+  unsigned break_offset = 0;
+
+  line = ShapeLine(&breaker, 13, segment1->SnappedWidth(), &break_offset);
+  EXPECT_EQ(31u, break_offset);
+  EXPECT_EQ(segment1->Width(), line->Width());
+
+  line = ShapeLine(&breaker, 13, segment2->SnappedWidth(), &break_offset);
+  EXPECT_EQ(31u, break_offset);
+  EXPECT_EQ(segment1->Width(), line->Width());
+}
+
 struct BreakOpportunityTestData {
   const char16_t* string;
   Vector<unsigned> break_positions;
@@ -306,7 +382,7 @@ class BreakOpportunityTest
     : public ShapingLineBreakerTest,
       public testing::WithParamInterface<BreakOpportunityTestData> {};
 
-INSTANTIATE_TEST_CASE_P(
+INSTANTIATE_TEST_SUITE_P(
     ShapingLineBreakerTest,
     BreakOpportunityTest,
     testing::Values(BreakOpportunityTestData{u"x y z", {1, 3, 5}},
@@ -324,7 +400,9 @@ TEST_P(BreakOpportunityTest, Next) {
   scoped_refptr<const ShapeResult> result =
       shaper.Shape(&font, TextDirection::kLtr);
 
-  ShapingLineBreaker breaker(&shaper, &font, result.get(), &break_iterator);
+  HarfBuzzShaperCallbackContext context{&shaper, &font, result->Direction()};
+  ShapingLineBreaker breaker(result, &break_iterator, nullptr,
+                             HarfBuzzShaperCallback, &context);
   EXPECT_THAT(BreakPositionsByNext(breaker, string),
               testing::ElementsAreArray(data.break_positions));
 
@@ -344,7 +422,9 @@ TEST_P(BreakOpportunityTest, Previous) {
   scoped_refptr<const ShapeResult> result =
       shaper.Shape(&font, TextDirection::kLtr);
 
-  ShapingLineBreaker breaker(&shaper, &font, result.get(), &break_iterator);
+  HarfBuzzShaperCallbackContext context{&shaper, &font, result->Direction()};
+  ShapingLineBreaker breaker(result, &break_iterator, nullptr,
+                             HarfBuzzShaperCallback, &context);
   EXPECT_THAT(BreakPositionsByPrevious(breaker, string),
               testing::ElementsAreArray(data.break_positions));
 
diff --git a/third_party/blink/renderer/platform/fonts/shaping/stretchy_operator_shaper.cc b/third_party/blink/renderer/platform/fonts/shaping/stretchy_operator_shaper.cc
new file mode 100644
index 000000000000..dc3e1e7371e3
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/stretchy_operator_shaper.cc
@@ -0,0 +1,202 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/shaping/stretchy_operator_shaper.h"
+
+#include <hb-ot.h>
+#include <hb.h>
+#include <unicode/uchar.h>
+
+#include "third_party/blink/renderer/platform/fonts/canvas_rotation_in_vertical.h"
+#include "third_party/blink/renderer/platform/fonts/font.h"
+#include "third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_face.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h"
+#include "third_party/blink/renderer/platform/geometry/float_rect.h"
+#include "third_party/blink/renderer/platform/wtf/text/unicode.h"
+#include "ui/gfx/skia_util.h"
+
+namespace blink {
+
+namespace {
+
+// HarfBuzz' hb_position_t is a 16.16 fixed-point value.
+inline float HarfBuzzUnitsToFloat(hb_position_t value) {
+  static const float kFloatToHbRatio = 1.0f / (1 << 16);
+  return kFloatToHbRatio * value;
+}
+
+base::Optional<OpenTypeMathStretchData::AssemblyParameters>
+GetAssemblyParameters(const HarfBuzzFace* harfbuzz_face,
+                      Glyph base_glyph,
+                      OpenTypeMathStretchData::StretchAxis stretch_axis,
+                      float target_size,
+                      float* italic_correction) {
+  Vector<OpenTypeMathStretchData::GlyphPartRecord> parts =
+      OpenTypeMathSupport::GetGlyphPartRecords(harfbuzz_face, base_glyph,
+                                               stretch_axis, italic_correction);
+  if (parts.IsEmpty())
+    return base::nullopt;
+
+  hb_font_t* hb_font =
+      harfbuzz_face->GetScaledFont(nullptr, HarfBuzzFace::NoVerticalLayout);
+
+  auto hb_stretch_axis =
+      stretch_axis == OpenTypeMathStretchData::StretchAxis::Horizontal
+          ? HB_DIRECTION_LTR
+          : HB_DIRECTION_BTT;
+
+  // Go over the assembly parts and determine parameters used below.
+  // https://mathml-refresh.github.io/mathml-core/#the-glyphassembly-table
+  float min_connector_overlap = HarfBuzzUnitsToFloat(
+      hb_ot_math_get_min_connector_overlap(hb_font, hb_stretch_axis));
+  float max_connector_overlap = std::numeric_limits<float>::max();
+  float non_extender_advance_sum = 0, extender_advance_sum = 0;
+  unsigned non_extender_count = 0, extender_count = 0;
+
+  for (auto& part : parts) {
+    // Calculate the count and advance sums of extender and non-extender glyphs.
+    if (part.is_extender) {
+      extender_count++;
+      extender_advance_sum += part.full_advance;
+    } else {
+      non_extender_count++;
+      non_extender_advance_sum += part.full_advance;
+    }
+
+    // Take into account start connector length for all but the first glyph.
+    if (part.is_extender || &part != &parts.front()) {
+      max_connector_overlap =
+          std::min(max_connector_overlap, part.start_connector_length);
+    }
+
+    // Take into account end connector length for all but the last glyph.
+    if (part.is_extender || &part != &parts.back()) {
+      max_connector_overlap =
+          std::min(max_connector_overlap, part.end_connector_length);
+    }
+  }
+
+  // Check validity conditions indicated in MathML core.
+  float extender_non_overlapping_advance_sum =
+      extender_advance_sum - min_connector_overlap * extender_count;
+  if (extender_count == 0 || max_connector_overlap < min_connector_overlap ||
+      extender_non_overlapping_advance_sum <= 0)
+    return base::nullopt;
+
+  // Calculate the minimal number of repetitions needed to obtain an assembly
+  // size of size at least target size (r_min in MathML Core).
+  unsigned repetition_count = std::max<float>(
+      std::ceil((target_size - non_extender_advance_sum +
+                 min_connector_overlap * (non_extender_count - 1)) /
+                extender_non_overlapping_advance_sum),
+      0);
+
+  // Calculate the number of glyphs, limiting repetition_count to ensure the
+  // assembly does not have more than HarfBuzzRunGlyphData::kMaxGlyphs.
+  DCHECK_LE(non_extender_count, HarfBuzzRunGlyphData::kMaxGlyphs);
+  repetition_count = std::min<unsigned>(
+      repetition_count,
+      (HarfBuzzRunGlyphData::kMaxGlyphs - non_extender_count) / extender_count);
+  unsigned glyph_count = non_extender_count + repetition_count * extender_count;
+  DCHECK_LE(glyph_count, HarfBuzzRunGlyphData::kMaxGlyphs);
+
+  // Calculate the maximum overlap (called o_max in MathML Core) and the number
+  // of glyph in such an assembly (called N in MathML Core).
+  float connector_overlap = max_connector_overlap;
+  if (glyph_count > 1) {
+    float max_connector_overlap_theorical =
+        (non_extender_advance_sum + repetition_count * extender_advance_sum -
+         target_size) /
+        (glyph_count - 1);
+    connector_overlap =
+        std::max(min_connector_overlap,
+                 std::min(connector_overlap, max_connector_overlap_theorical));
+  }
+
+  // Calculate the assembly size (called  AssemblySize(o, r) in MathML Core).
+  float stretch_size = non_extender_advance_sum +
+                       repetition_count * extender_advance_sum -
+                       connector_overlap * (glyph_count - 1);
+
+  return base::Optional<OpenTypeMathStretchData::AssemblyParameters>(
+      {connector_overlap, repetition_count, glyph_count, stretch_size,
+       std::move(parts)});
+}
+
+}  // namespace
+
+scoped_refptr<ShapeResult> StretchyOperatorShaper::Shape(
+    const Font* font,
+    float target_size,
+    Metrics* metrics) const {
+  const SimpleFontData* primary_font = font->PrimaryFont();
+  const HarfBuzzFace* harfbuzz_face =
+      primary_font->PlatformData().GetHarfBuzzFace();
+  Glyph base_glyph = primary_font->GlyphForCharacter(stretchy_character_);
+  float italic_correction = 0.0;
+  if (metrics)
+    *metrics = Metrics();
+
+  Glyph glyph_variant;
+  float glyph_variant_stretch_size;
+  TextDirection direction = TextDirection::kLtr;
+
+  // Try different glyph variants.
+  for (auto& variant : OpenTypeMathSupport::GetGlyphVariantRecords(
+           harfbuzz_face, base_glyph, stretch_axis_)) {
+    glyph_variant = variant;
+    FloatRect bounds = primary_font->BoundsForGlyph(glyph_variant);
+    if (metrics) {
+      italic_correction =
+          OpenTypeMathSupport::MathItalicCorrection(harfbuzz_face, variant)
+              .value_or(0);
+      *metrics = {primary_font->WidthForGlyph(variant), -bounds.Y(),
+                  bounds.MaxY(), italic_correction};
+    }
+    glyph_variant_stretch_size =
+        stretch_axis_ == OpenTypeMathStretchData::StretchAxis::Horizontal
+            ? bounds.Width()
+            : bounds.Height();
+    if (glyph_variant_stretch_size >= target_size) {
+      return ShapeResult::CreateForStretchyMathOperator(
+          font, direction, glyph_variant, glyph_variant_stretch_size);
+    }
+  }
+
+  // Try a glyph assembly.
+  auto params = GetAssemblyParameters(harfbuzz_face, base_glyph, stretch_axis_,
+                                      target_size,
+                                      metrics ? &italic_correction : nullptr);
+  if (!params) {
+    return ShapeResult::CreateForStretchyMathOperator(
+        font, direction, glyph_variant, glyph_variant_stretch_size);
+  }
+
+  scoped_refptr<ShapeResult> shape_result_for_glyph_assembly =
+      ShapeResult::CreateForStretchyMathOperator(font, direction, stretch_axis_,
+                                                 std::move(*params));
+  if (metrics) {
+    // The OpenType MATH specification does provide any distinction between
+    // the advance width and ink width, so the latter is returned here.
+    FloatRect bounds = shape_result_for_glyph_assembly->ComputeInkBounds();
+    if (stretch_axis_ == OpenTypeMathStretchData::StretchAxis::Horizontal) {
+      *metrics = {bounds.Width(), -bounds.Y(), bounds.MaxY(),
+                  italic_correction};
+    } else {
+      // For assemblies growing in the vertical direction, the distribution of
+      // height between ascent and descent is not defined by the OpenType MATH
+      // specification. This code uses MathML Core's convention of
+      // ascent = height and descent = 0.
+      // Additionally, ShapeResult::CreateForStretchyMathOperator uses a text
+      // run that is HB_DIRECTION_TTB in order to stack the parts vertically but
+      // the actual glyph assembly is still horizontal text, so height and width
+      // are inverted.
+      *metrics = {bounds.Height(), bounds.Width(), 0, italic_correction};
+    }
+  }
+  return shape_result_for_glyph_assembly;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/stretchy_operator_shaper.h b/third_party/blink/renderer/platform/fonts/shaping/stretchy_operator_shaper.h
new file mode 100644
index 000000000000..0e77f50cbf33
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/stretchy_operator_shaper.h
@@ -0,0 +1,57 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_STRETCHY_OPERATOR_SHAPER_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_STRETCHY_OPERATOR_SHAPER_H_
+
+#include <base/memory/scoped_refptr.h>
+#include <unicode/uchar.h>
+#include "third_party/blink/renderer/platform/fonts/glyph.h"
+#include "third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.h"
+#include "third_party/blink/renderer/platform/text/text_direction.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
+
+namespace blink {
+
+class Font;
+class ShapeResult;
+class StretchyOperatorShaper;
+
+// TODO(https://crbug.com/1057589): Add a TextDirection parameter, so that it's
+// possible to perform glyph-level (rtlm feature) or character-level mirroring
+// before stretching.
+// https://mathml-refresh.github.io/mathml-core/#algorithms-for-glyph-stretching
+class PLATFORM_EXPORT StretchyOperatorShaper final {
+  DISALLOW_NEW();
+
+ public:
+  StretchyOperatorShaper(UChar stretchy_character,
+                         OpenTypeMathStretchData::StretchAxis stretch_axis)
+      : stretchy_character_(stretchy_character), stretch_axis_(stretch_axis) {}
+
+  struct Metrics {
+    float advance { 0.0f };
+    float ascent { 0.0f };
+    float descent { 0.0f };
+    float italic_correction { 0.0f };
+  };
+  // Shape the stretched operator. The coordinates of the glyph(s) use the same
+  // origin as the rectangle assigned to the optional OUT Metrics parameter.
+  // May be called multiple times; font and direction may vary between calls.
+  // https://mathml-refresh.github.io/mathml-core/#dfn-shape-a-stretchy-glyph
+  // https://mathml-refresh.github.io/mathml-core/#dfn-box-metrics-of-a-stretchy-glyph
+  scoped_refptr<ShapeResult> Shape(const Font*,
+                                   float target_size,
+                                   Metrics* metrics = nullptr) const;
+
+  ~StretchyOperatorShaper() = default;
+
+ private:
+  const UChar stretchy_character_;
+  const OpenTypeMathStretchData::StretchAxis stretch_axis_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_STRETCHY_OPERATOR_SHAPER_H_
diff --git a/third_party/blink/renderer/platform/fonts/shaping/stretchy_operator_shaper_test.cc b/third_party/blink/renderer/platform/fonts/shaping/stretchy_operator_shaper_test.cc
new file mode 100644
index 000000000000..3d9827ddb56e
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/stretchy_operator_shaper_test.cc
@@ -0,0 +1,308 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/shaping/stretchy_operator_shaper.h"
+#include "base/memory/scoped_refptr.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/fonts/font.h"
+#include "third_party/blink/renderer/platform/fonts/opentype/open_type_types.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_inline_headers.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_test_info.h"
+#include "third_party/blink/renderer/platform/testing/font_test_helpers.h"
+#include "third_party/blink/renderer/platform/testing/unit_test_helpers.h"
+
+namespace blink {
+
+namespace {
+
+const UChar32 kLeftBraceCodePoint = '{';
+const UChar32 kOverBraceCodePoint = 0x23DE;
+const UChar32 kRightwardsFrontTiltedShadowedWhiteArrowCodePoint = 0x1F8AB;
+const UChar32 kNAryWhiteVerticalBarCodePoint = 0x2AFF;
+float kSizeError = .1;
+
+ShapeResultTestInfo* TestInfo(const scoped_refptr<ShapeResult>& result) {
+  return static_cast<ShapeResultTestInfo*>(result.get());
+}
+
+}  // namespace
+
+class StretchyOperatorShaperTest : public testing::Test {
+ protected:
+  void SetUp() override {
+    font_description.SetComputedSize(10.0);
+    font = Font(font_description);
+  }
+
+  void TearDown() override {}
+
+  Font CreateMathFont(const String& name, float size = 1000) {
+    FontDescription::VariantLigatures ligatures;
+    return blink::test::CreateTestFont(
+        "MathTestFont",
+        blink::test::BlinkWebTestsFontsTestDataPath(String("math/") + name),
+        size, &ligatures);
+  }
+
+  FontDescription font_description;
+  Font font;
+};
+
+// See createStretchy() in
+// third_party/blink/web_tests/external/wpt/mathml/tools/operator-dictionary.py
+TEST_F(StretchyOperatorShaperTest, GlyphVariants) {
+  Font math = CreateMathFont("operators.woff");
+
+  StretchyOperatorShaper vertical_shaper(
+      kLeftBraceCodePoint, OpenTypeMathStretchData::StretchAxis::Vertical);
+  StretchyOperatorShaper horizontal_shaper(
+      kOverBraceCodePoint, OpenTypeMathStretchData::StretchAxis::Horizontal);
+
+  auto left_brace = math.PrimaryFont()->GlyphForCharacter(kLeftBraceCodePoint);
+  auto over_brace = math.PrimaryFont()->GlyphForCharacter(kOverBraceCodePoint);
+
+  // Calculate glyph indices from the last unicode character in the font.
+  // TODO(https://crbug.com/1057596): Find a better way to access these glyph
+  // indices.
+  auto v0 = math.PrimaryFont()->GlyphForCharacter(
+                kRightwardsFrontTiltedShadowedWhiteArrowCodePoint) +
+            1;
+  auto h0 = v0 + 1;
+  auto v1 = h0 + 1;
+  auto h1 = v1 + 1;
+  auto v2 = h1 + 1;
+  auto h2 = v2 + 1;
+
+  // Stretch operators to target sizes (in font units) 125, 250, 375, 500, 625,
+  // 750, 875, 1000, 1125, ..., 3750, 3875, 4000.
+  //
+  // Shaper tries glyphs over_brace/left_brace, h0/v0, h1/v1, h2/v2, h3/v3 of
+  // respective sizes 1000, 1000, 2000, 3000 and 4000. It returns the smallest
+  // glyph larger than the target size.
+  const unsigned size_count = 4;
+  const unsigned subdivision = 8;
+  for (unsigned i = 0; i < size_count; i++) {
+    for (unsigned j = 1; j <= subdivision; j++) {
+      // Due to floating-point errors, the actual metrics of the size variants
+      // might actually be slightly smaller than expected. Reduce the
+      // target_size by kSizeError to ensure that the shaper picks the desired
+      // size variant.
+      float target_size = i * 1000 + (j * 1000 / subdivision) - kSizeError;
+
+      // Metrics of horizontal size variants.
+      {
+        StretchyOperatorShaper::Metrics metrics;
+        horizontal_shaper.Shape(&math, target_size, &metrics);
+        EXPECT_NEAR(metrics.advance, (i + 1) * 1000, kSizeError);
+        EXPECT_NEAR(metrics.ascent, 1000, kSizeError);
+        EXPECT_FLOAT_EQ(metrics.descent, 0);
+      }
+
+      // Metrics of vertical size variants.
+
+      {
+        StretchyOperatorShaper::Metrics metrics;
+        vertical_shaper.Shape(&math, target_size, &metrics);
+        EXPECT_NEAR(metrics.advance, 1000, kSizeError);
+        EXPECT_NEAR(metrics.ascent, (i + 1) * 1000, kSizeError);
+        EXPECT_FLOAT_EQ(metrics.descent, 0);
+      }
+
+      // Shaping of horizontal size variants.
+      {
+        scoped_refptr<ShapeResult> result =
+            horizontal_shaper.Shape(&math, target_size);
+        EXPECT_EQ(TestInfo(result)->NumberOfRunsForTesting(), 1u);
+        EXPECT_EQ(TestInfo(result)->RunInfoForTesting(0).NumGlyphs(), 1u);
+        Glyph expected_variant = i ? h0 + 2 * i : over_brace;
+        EXPECT_EQ(TestInfo(result)->GlyphForTesting(0, 0), expected_variant);
+        EXPECT_NEAR(TestInfo(result)->AdvanceForTesting(0, 0), (i + 1) * 1000,
+                    kSizeError);
+      }
+
+      // Shaping of vertical size variants.
+      {
+        scoped_refptr<ShapeResult> result =
+            vertical_shaper.Shape(&math, target_size);
+        EXPECT_EQ(TestInfo(result)->NumberOfRunsForTesting(), 1u);
+        EXPECT_EQ(TestInfo(result)->RunInfoForTesting(0).NumGlyphs(), 1u);
+        Glyph expected_variant = i ? v0 + 2 * i : left_brace;
+        EXPECT_EQ(TestInfo(result)->GlyphForTesting(0, 0), expected_variant);
+        EXPECT_NEAR(TestInfo(result)->AdvanceForTesting(0, 0), (i + 1) * 1000,
+                    kSizeError);
+      }
+    }
+  }
+
+  // Stretch an operator to target sizes (in font units) much larger than 4000.
+  //
+  // This will force an assembly with the following parts:
+  // _____________________________________________________________
+  // Part  | MaxStartOverlap | MaxEndOverlap | Advance | Extender |
+  // h2/v2 |     0           |    1000       | 3000    |   false  |
+  // h1/v1 |    1000         |    1000       | 2000    |   true   |
+  //
+  // For an assembly made of one non-extender glyph h2/v2 and repetition_count
+  // copies of extenders h1/v1, the size is
+  // advance(h2/v2) + repetition_count * (advance(h1/v1) - overlap).
+  //
+  // For repetition_count = k and overlap = 750, the size is X = 1250k + 3000.
+  //
+  // Since the font min overlap is 500, for repetition_count = k - 1 the size
+  // is at most Y = 1500k + 1500.
+  //
+  // Since the max overlap of parts is 1000, for repetition_count = k + 1 the
+  // size is at least Z = 1000k + 4000.
+  //
+  // { X - 4000 = 1250k - 1000 >= 250 >> kSizeError for k >= 1.
+  // { X - Y = 1500 - 250k >= 250 >> kSizeError for k <= 5.
+  // Hence setting the target size to 1250k + 3000 will ensure an assembly of
+  // k + 1 glyphs and overlap close to 750 for 1 <= k <= 5.
+  //
+  // Additionally, X - Z = 250k - 1000 = 250 >> kSizeError for k = 5 so this
+  // case also verifies that the minimal number of repetitions is actually used.
+  //
+  for (unsigned repetition_count = 1; repetition_count <= 5;
+       repetition_count++) {
+    // It is not necessary to decrease the target_size by kSizeError here. The
+    // shaper can just increase overlap by kSizeError / repetition_count to
+    // reduce the actual size of the assembly.
+    float overlap = 750;
+    float target_size = 3000 + repetition_count * (2000 - overlap);
+
+    // Metrics of horizontal assembly.
+    {
+      StretchyOperatorShaper::Metrics metrics;
+      horizontal_shaper.Shape(&math, target_size, &metrics);
+      EXPECT_NEAR(metrics.advance, target_size, kSizeError);
+      EXPECT_NEAR(metrics.ascent, 1000, kSizeError);
+      EXPECT_FLOAT_EQ(metrics.descent, 0);
+    }
+
+    // Metrics of vertical assembly.
+    {
+      StretchyOperatorShaper::Metrics metrics;
+      vertical_shaper.Shape(&math, target_size, &metrics);
+      EXPECT_NEAR(metrics.advance, 1000, kSizeError);
+      EXPECT_NEAR(metrics.ascent, target_size, kSizeError);
+      EXPECT_FLOAT_EQ(metrics.descent, 0);
+    }
+
+    // Shaping of horizontal assembly.
+    // From left to right: h2, h1, h1, h1, ...
+    {
+      scoped_refptr<ShapeResult> result =
+          horizontal_shaper.Shape(&math, target_size);
+
+      EXPECT_EQ(TestInfo(result)->NumberOfRunsForTesting(), 1u);
+      EXPECT_EQ(TestInfo(result)->RunInfoForTesting(0).NumGlyphs(),
+                repetition_count + 1);
+      EXPECT_EQ(TestInfo(result)->GlyphForTesting(0, 0), h2);
+      EXPECT_NEAR(TestInfo(result)->AdvanceForTesting(0, 0), 3000 - overlap,
+                  kSizeError);
+      for (unsigned i = 0; i < repetition_count - 1; i++) {
+        EXPECT_EQ(TestInfo(result)->GlyphForTesting(0, i + 1), h1);
+        EXPECT_NEAR(TestInfo(result)->AdvanceForTesting(0, i + 1),
+                    2000 - overlap, kSizeError);
+      }
+      EXPECT_EQ(TestInfo(result)->GlyphForTesting(0, repetition_count), h1);
+      EXPECT_NEAR(TestInfo(result)->AdvanceForTesting(0, repetition_count),
+                  2000, kSizeError);
+    }
+
+    // Shaping of vertical assembly.
+    // From bottom to top: v2, v1, v1, v1, ...
+    {
+      scoped_refptr<ShapeResult> result =
+          vertical_shaper.Shape(&math, target_size);
+
+      EXPECT_EQ(TestInfo(result)->NumberOfRunsForTesting(), 1u);
+      EXPECT_EQ(TestInfo(result)->RunInfoForTesting(0).NumGlyphs(),
+                repetition_count + 1);
+      for (unsigned i = 0; i < repetition_count; i++) {
+        EXPECT_EQ(TestInfo(result)->GlyphForTesting(0, i), v1);
+        EXPECT_NEAR(TestInfo(result)->AdvanceForTesting(0, i), 2000 - overlap,
+                    kSizeError);
+      }
+      EXPECT_EQ(TestInfo(result)->GlyphForTesting(0, repetition_count), v2);
+      EXPECT_NEAR(TestInfo(result)->AdvanceForTesting(0, repetition_count),
+                  3000, kSizeError);
+    }
+  }
+
+  // Stretch an operator to edge target size values.
+  //
+  // These tests verify that it does not cause any assertion or crashes.
+  {
+    // Zero.
+    float target_size = 0;
+    horizontal_shaper.Shape(&math, target_size);
+    vertical_shaper.Shape(&math, target_size);
+
+    // Negative.
+    target_size = -5500;
+    horizontal_shaper.Shape(&math, target_size);
+    vertical_shaper.Shape(&math, target_size);
+
+    // Max limit.
+    target_size = std::numeric_limits<float>::max();
+    horizontal_shaper.Shape(&math, target_size);
+    vertical_shaper.Shape(&math, target_size);
+
+    // Min limit.
+    target_size = std::numeric_limits<float>::min();
+    horizontal_shaper.Shape(&math, target_size);
+    vertical_shaper.Shape(&math, target_size);
+
+    // More than the max number of glyphs.
+    // The size of an assembly with one non-extender v2/h2 and k - 1 extenders
+    // h1/v1 and minimal overlap 500 is Y = 1500k + 1500.
+    // So target_size - Y >= 250 >> kSizeError if the assembly does not have
+    // more than the max number of glyphs.
+    target_size = 1500 * HarfBuzzRunGlyphData::kMaxGlyphs + 1750;
+    horizontal_shaper.Shape(&math, target_size);
+    vertical_shaper.Shape(&math, target_size);
+  }
+}
+
+// See third_party/blink/web_tests/external/wpt/mathml/tools/largeop.py
+TEST_F(StretchyOperatorShaperTest, MathItalicCorrection) {
+  {
+    Font math = CreateMathFont(
+        "largeop-displayoperatorminheight2000-2AFF-italiccorrection3000.woff");
+    StretchyOperatorShaper shaper(
+        kNAryWhiteVerticalBarCodePoint,
+        OpenTypeMathStretchData::StretchAxis::Vertical);
+
+    // Base size.
+    StretchyOperatorShaper::Metrics metrics;
+    shaper.Shape(&math, 0, &metrics);
+    EXPECT_EQ(metrics.italic_correction, 0);
+
+    // Larger variant.
+    float target_size = 2000 - kSizeError;
+    shaper.Shape(&math, target_size, &metrics);
+    EXPECT_EQ(metrics.italic_correction, 3000);
+  }
+
+  {
+    Font math = CreateMathFont(
+        "largeop-displayoperatorminheight7000-2AFF-italiccorrection5000.woff");
+    StretchyOperatorShaper shaper(
+        kNAryWhiteVerticalBarCodePoint,
+        OpenTypeMathStretchData::StretchAxis::Vertical);
+
+    // Base size.
+    StretchyOperatorShaper::Metrics metrics;
+    shaper.Shape(&math, 0, &metrics);
+    EXPECT_EQ(metrics.italic_correction, 0);
+
+    // Glyph assembly.
+    float target_size = 7000;
+    shaper.Shape(&math, target_size, &metrics);
+    EXPECT_EQ(metrics.italic_correction, 5000);
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/simple_font_data.cc b/third_party/blink/renderer/platform/fonts/simple_font_data.cc
index 4b93a9241623..f87d93cb92b6 100644
--- a/third_party/blink/renderer/platform/fonts/simple_font_data.cc
+++ b/third_party/blink/renderer/platform/fonts/simple_font_data.cc
@@ -35,10 +35,6 @@
 #include <memory>
 #include <utility>
 
-#include "SkPath.h"
-#include "SkTypeface.h"
-#include "SkTypes.h"
-
 #include "base/memory/ptr_util.h"
 #include "base/sys_byteorder.h"
 #include "build/build_config.h"
@@ -50,6 +46,10 @@
 #include "third_party/blink/renderer/platform/wtf/math_extras.h"
 #include "third_party/blink/renderer/platform/wtf/text/character_names.h"
 #include "third_party/blink/renderer/platform/wtf/text/unicode.h"
+#include "third_party/skia/include/core/SkFontMetrics.h"
+#include "third_party/skia/include/core/SkPath.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+#include "third_party/skia/include/core/SkTypes.h"
 
 namespace blink {
 
@@ -58,18 +58,20 @@ const float kEmphasisMarkFontSizeMultiplier = 0.5f;
 
 SimpleFontData::SimpleFontData(const FontPlatformData& platform_data,
                                scoped_refptr<CustomFontData> custom_data,
-                               bool subpixel_ascent_descent)
+                               bool subpixel_ascent_descent,
+                               const FontMetricsOverride& metrics_override)
     : max_char_width_(-1),
       avg_char_width_(-1),
       platform_data_(platform_data),
       custom_font_data_(std::move(custom_data)),
       visual_overflow_inflation_for_ascent_(0),
       visual_overflow_inflation_for_descent_(0) {
-  PlatformInit(subpixel_ascent_descent);
+  PlatformInit(subpixel_ascent_descent, metrics_override);
   PlatformGlyphInit();
 }
 
-void SimpleFontData::PlatformInit(bool subpixel_ascent_descent) {
+void SimpleFontData::PlatformInit(bool subpixel_ascent_descent,
+                                  const FontMetricsOverride& metrics_override) {
   if (!platform_data_.size()) {
     font_metrics_.Reset();
     avg_char_width_ = 0;
@@ -77,29 +79,34 @@ void SimpleFontData::PlatformInit(bool subpixel_ascent_descent) {
     return;
   }
 
-  SkPaint::FontMetrics metrics;
+  SkFontMetrics metrics;
 
-  PaintFont font;
-  platform_data_.SetupPaintFont(&font);
-  font.SetTextEncoding(SkPaint::kGlyphID_TextEncoding);
-  paint_ = font.ToSkPaint();
-  paint_.getFontMetrics(&metrics);
+  font_ = SkFont();
+  platform_data_.SetupSkFont(&font_);
+  font_.getMetrics(&metrics);
 
   float ascent;
   float descent;
 
   FontMetrics::AscentDescentWithHacks(
       ascent, descent, visual_overflow_inflation_for_ascent_,
-      visual_overflow_inflation_for_descent_, platform_data_, paint_,
-      subpixel_ascent_descent);
+      visual_overflow_inflation_for_descent_, platform_data_, font_,
+      subpixel_ascent_descent, metrics_override.ascent_override,
+      metrics_override.descent_override);
 
   font_metrics_.SetAscent(ascent);
   font_metrics_.SetDescent(descent);
 
+  float skia_underline_value;
+  if (metrics.hasUnderlinePosition(&skia_underline_value))
+    font_metrics_.SetUnderlinePosition(skia_underline_value);
+  if (metrics.hasUnderlineThickness(&skia_underline_value))
+    font_metrics_.SetUnderlineThickness(skia_underline_value);
+
   float x_height;
   if (metrics.fXHeight) {
     x_height = metrics.fXHeight;
-#if defined(OS_MACOSX)
+#if defined(OS_MAC)
     // Mac OS CTFontGetXHeight reports the bounding box height of x,
     // including parts extending below the baseline and apparently no x-height
     // value from the OS/2 table. However, the CSS ex unit
@@ -119,7 +126,12 @@ void SimpleFontData::PlatformInit(bool subpixel_ascent_descent) {
     font_metrics_.SetHasXHeight(false);
   }
 
-  float line_gap = SkScalarToFloat(metrics.fLeading);
+  float line_gap;
+  if (metrics_override.line_gap_override) {
+    line_gap = *metrics_override.line_gap_override * platform_data_.size();
+  } else {
+    line_gap = SkScalarToFloat(metrics.fLeading);
+  }
   font_metrics_.SetLineGap(line_gap);
   font_metrics_.SetLineSpacing(lroundf(ascent) + lroundf(descent) +
                                lroundf(line_gap));
@@ -135,7 +147,7 @@ void SimpleFontData::PlatformInit(bool subpixel_ascent_descent) {
   // arbitrary but comes pretty close to the expected value in most cases.
   if (max_char_width_ < 1)
     max_char_width_ = ascent * 2;
-#elif defined(OS_MACOSX)
+#elif defined(OS_MAC)
   // FIXME: The current avg/max character width calculation is not ideal,
   // it should check either the OS2 table or, better yet, query FontMetrics.
   // Sadly FontMetrics provides incorrect data on Mac at the moment.
@@ -148,7 +160,7 @@ void SimpleFontData::PlatformInit(bool subpixel_ascent_descent) {
 
 #endif
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MAC)
   if (metrics.fAvgCharWidth) {
     avg_char_width_ = SkScalarRoundToInt(metrics.fAvgCharWidth);
   } else {
@@ -158,14 +170,18 @@ void SimpleFontData::PlatformInit(bool subpixel_ascent_descent) {
     if (x_glyph) {
       avg_char_width_ = WidthForGlyph(x_glyph);
     }
-#if !defined(OS_MACOSX)
+#if !defined(OS_MAC)
   }
 #endif
 
-  SkTypeface* face = paint_.getTypeface();
+  SkTypeface* face = font_.getTypeface();
   DCHECK(face);
   if (int units_per_em = face->getUnitsPerEm())
     font_metrics_.SetUnitsPerEm(units_per_em);
+
+  advance_override_ = metrics_override.advance_override;
+  advance_override_vertical_upright_ =
+      metrics_override.advance_override_vertical_upright;
 }
 
 void SimpleFontData::PlatformGlyphInit() {
@@ -192,11 +208,9 @@ const SimpleFontData* SimpleFontData::FontDataForCharacter(UChar32) const {
 }
 
 Glyph SimpleFontData::GlyphForCharacter(UChar32 codepoint) const {
-  uint16_t glyph;
   SkTypeface* typeface = PlatformData().Typeface();
   CHECK(typeface);
-  typeface->charsToGlyphs(&codepoint, SkTypeface::kUTF32_Encoding, &glyph, 1);
-  return glyph;
+  return typeface->unicharToGlyph(codepoint);
 }
 
 bool SimpleFontData::IsSegmented() const {
@@ -206,7 +220,7 @@ bool SimpleFontData::IsSegmented() const {
 scoped_refptr<SimpleFontData> SimpleFontData::SmallCapsFontData(
     const FontDescription& font_description) const {
   if (!derived_font_data_)
-    derived_font_data_ = DerivedFontData::Create();
+    derived_font_data_ = std::make_unique<DerivedFontData>();
   if (!derived_font_data_->small_caps)
     derived_font_data_->small_caps =
         CreateScaledFontData(font_description, kSmallCapsFontSizeMultiplier);
@@ -217,7 +231,7 @@ scoped_refptr<SimpleFontData> SimpleFontData::SmallCapsFontData(
 scoped_refptr<SimpleFontData> SimpleFontData::EmphasisMarkFontData(
     const FontDescription& font_description) const {
   if (!derived_font_data_)
-    derived_font_data_ = DerivedFontData::Create();
+    derived_font_data_ = std::make_unique<DerivedFontData>();
   if (!derived_font_data_->emphasis_mark)
     derived_font_data_->emphasis_mark =
         CreateScaledFontData(font_description, kEmphasisMarkFontSizeMultiplier);
@@ -225,11 +239,6 @@ scoped_refptr<SimpleFontData> SimpleFontData::EmphasisMarkFontData(
   return derived_font_data_->emphasis_mark;
 }
 
-std::unique_ptr<SimpleFontData::DerivedFontData>
-SimpleFontData::DerivedFontData::Create() {
-  return base::WrapUnique(new DerivedFontData);
-}
-
 scoped_refptr<SimpleFontData> SimpleFontData::CreateScaledFontData(
     const FontDescription& font_description,
     float scale_factor) const {
@@ -240,6 +249,13 @@ scoped_refptr<SimpleFontData> SimpleFontData::CreateScaledFontData(
       IsCustomFont() ? CustomFontData::Create() : nullptr);
 }
 
+scoped_refptr<SimpleFontData> SimpleFontData::MetricsOverriddenFontData(
+    const FontMetricsOverride& metrics_override) const {
+  return base::AdoptRef(new SimpleFontData(platform_data_, custom_font_data_,
+                                           false /* subpixel_ascent_descent */,
+                                           metrics_override));
+}
+
 // Internal leadings can be distributed to ascent and descent.
 // -------------------------------------------
 //           | - Internal Leading (in ascent)
@@ -252,24 +268,26 @@ scoped_refptr<SimpleFontData> SimpleFontData::CreateScaledFontData(
 // Descent - |--------------------------------
 //           | - Internal Leading (in descent)
 // -------------------------------------------
-LayoutUnit SimpleFontData::EmHeightAscent(FontBaseline baseline_type) const {
+FontHeight SimpleFontData::NormalizedTypoAscentAndDescent(
+    FontBaseline baseline_type) const {
   if (baseline_type == kAlphabeticBaseline) {
-    if (!em_height_ascent_)
-      ComputeEmHeightMetrics();
-    return em_height_ascent_;
+    if (!normalized_typo_ascent_descent_.ascent)
+      ComputeNormalizedTypoAscentAndDescent();
+    return normalized_typo_ascent_descent_;
   }
-  LayoutUnit em_height = LayoutUnit::FromFloatRound(PlatformData().size());
-  return em_height - em_height / 2;
+  const LayoutUnit normalized_height =
+      LayoutUnit::FromFloatRound(PlatformData().size());
+  return {normalized_height - normalized_height / 2, normalized_height / 2};
 }
 
-LayoutUnit SimpleFontData::EmHeightDescent(FontBaseline baseline_type) const {
-  if (baseline_type == kAlphabeticBaseline) {
-    if (!em_height_descent_)
-      ComputeEmHeightMetrics();
-    return em_height_descent_;
-  }
-  LayoutUnit em_height = LayoutUnit::FromFloatRound(PlatformData().size());
-  return em_height / 2;
+LayoutUnit SimpleFontData::NormalizedTypoAscent(
+    FontBaseline baseline_type) const {
+  return NormalizedTypoAscentAndDescent(baseline_type).ascent;
+}
+
+LayoutUnit SimpleFontData::NormalizedTypoDescent(
+    FontBaseline baseline_type) const {
+  return NormalizedTypoAscentAndDescent(baseline_type).descent;
 }
 
 static std::pair<int16_t, int16_t> TypoAscenderAndDescender(
@@ -286,27 +304,30 @@ static std::pair<int16_t, int16_t> TypoAscenderAndDescender(
   return std::make_pair(0, 0);
 }
 
-void SimpleFontData::ComputeEmHeightMetrics() const {
+void SimpleFontData::ComputeNormalizedTypoAscentAndDescent() const {
   // Compute em height metrics from OS/2 sTypoAscender and sTypoDescender.
   SkTypeface* typeface = platform_data_.Typeface();
   int16_t typo_ascender, typo_descender;
   std::tie(typo_ascender, typo_descender) = TypoAscenderAndDescender(typeface);
   if (typo_ascender > 0 &&
-      NormalizeEmHeightMetrics(typo_ascender, typo_ascender + typo_descender)) {
+      TrySetNormalizedTypoAscentAndDescent(typo_ascender, typo_descender)) {
     return;
   }
 
   // As the last resort, compute em height metrics from our ascent/descent.
   const FontMetrics& font_metrics = GetFontMetrics();
-  if (NormalizeEmHeightMetrics(font_metrics.FloatAscent(),
-                               font_metrics.FloatHeight())) {
+  if (TrySetNormalizedTypoAscentAndDescent(font_metrics.FloatAscent(),
+                                           font_metrics.FloatDescent())) {
     return;
   }
-  NOTREACHED();
+
+  // We shouldn't be here unless the height is zero or lower.
+  DCHECK_LE(font_metrics.Height(), 0);
 }
 
-bool SimpleFontData::NormalizeEmHeightMetrics(float ascent,
-                                              float height) const {
+bool SimpleFontData::TrySetNormalizedTypoAscentAndDescent(float ascent,
+                                                          float descent) const {
+  const float height = ascent + descent;
   if (height <= 0 || ascent < 0 || ascent > height)
     return false;
   // While the OpenType specification recommends the sum of sTypoAscender and
@@ -317,10 +338,12 @@ bool SimpleFontData::NormalizeEmHeightMetrics(float ascent,
   // keeping the ratio of sTypoAscender:sTypoDescender.
   // This matches to how Gecko computes "em height":
   // https://github.com/whatwg/html/issues/2470#issuecomment-291425136
-  float em_height = PlatformData().size();
-  em_height_ascent_ = LayoutUnit::FromFloatRound(ascent * em_height / height);
-  em_height_descent_ =
-      LayoutUnit::FromFloatRound(em_height) - em_height_ascent_;
+  const float em_height = PlatformData().size();
+  const LayoutUnit normalized_ascent =
+      LayoutUnit::FromFloatRound(ascent * em_height / height);
+  normalized_typo_ascent_descent_ = {
+      normalized_ascent,
+      LayoutUnit::FromFloatRound(em_height) - normalized_ascent};
   return true;
 }
 
@@ -335,9 +358,9 @@ LayoutUnit SimpleFontData::VerticalPosition(
     case FontVerticalPositionType::TextBottom:
       return LayoutUnit(-GetFontMetrics().Descent(baseline_type));
     case FontVerticalPositionType::TopOfEmHeight:
-      return EmHeightAscent(baseline_type);
+      return NormalizedTypoAscent(baseline_type);
     case FontVerticalPositionType::BottomOfEmHeight:
-      return -EmHeightDescent(baseline_type);
+      return -NormalizedTypoDescent(baseline_type);
   }
   NOTREACHED();
   return LayoutUnit();
@@ -350,17 +373,28 @@ FloatRect SimpleFontData::PlatformBoundsForGlyph(Glyph glyph) const {
   static_assert(sizeof(glyph) == 2, "Glyph id should not be truncated.");
 
   SkRect bounds;
-  SkiaTextMetrics(&paint_).GetSkiaBoundsForGlyph(glyph, &bounds);
+  SkFontGetBoundsForGlyph(font_, glyph, &bounds);
   return FloatRect(bounds);
 }
 
+void SimpleFontData::BoundsForGlyphs(const Vector<Glyph, 256>& glyphs,
+                                     Vector<SkRect, 256>* bounds) const {
+  DCHECK_EQ(glyphs.size(), bounds->size());
+
+  if (!platform_data_.size())
+    return;
+
+  DCHECK_EQ(bounds->size(), glyphs.size());
+  SkFontGetBoundsForGlyphs(font_, glyphs, bounds->data());
+}
+
 float SimpleFontData::PlatformWidthForGlyph(Glyph glyph) const {
   if (!platform_data_.size())
     return 0;
 
   static_assert(sizeof(glyph) == 2, "Glyph id should not be truncated.");
 
-  return SkiaTextMetrics(&paint_).GetSkiaWidthForGlyph(glyph);
+  return SkFontGetWidthForGlyph(font_, glyph);
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/simple_font_data.h b/third_party/blink/renderer/platform/fonts/simple_font_data.h
index 0c159ad61611..4b75aa2fa6f8 100644
--- a/third_party/blink/renderer/platform/fonts/simple_font_data.h
+++ b/third_party/blink/renderer/platform/fonts/simple_font_data.h
@@ -24,8 +24,6 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SIMPLE_FONT_DATA_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SIMPLE_FONT_DATA_H_
 
-#include <SkPaint.h>
-
 #include <memory>
 #include <utility>
 
@@ -35,15 +33,18 @@
 #include "third_party/blink/renderer/platform/fonts/font_baseline.h"
 #include "third_party/blink/renderer/platform/fonts/font_data.h"
 #include "third_party/blink/renderer/platform/fonts/font_metrics.h"
+#include "third_party/blink/renderer/platform/fonts/font_metrics_override.h"
 #include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
 #include "third_party/blink/renderer/platform/fonts/font_vertical_position_type.h"
 #include "third_party/blink/renderer/platform/fonts/glyph.h"
 #include "third_party/blink/renderer/platform/fonts/typesetting_features.h"
 #include "third_party/blink/renderer/platform/geometry/float_rect.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/wtf/casting.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
+#include "third_party/skia/include/core/SkFont.h"
 
-#if defined(OS_MACOSX)
+#if defined(OS_MAC)
 #include "third_party/blink/renderer/platform/fonts/glyph_metrics_map.h"
 #endif
 
@@ -54,6 +55,8 @@ namespace blink {
 // character.
 struct GlyphData {
   STACK_ALLOCATED();
+
+ public:
   GlyphData(
       Glyph g = 0,
       const SimpleFontData* f = nullptr,
@@ -81,6 +84,8 @@ class PLATFORM_EXPORT SimpleFontData : public FontData {
 
   scoped_refptr<SimpleFontData> SmallCapsFontData(const FontDescription&) const;
   scoped_refptr<SimpleFontData> EmphasisMarkFontData(const FontDescription&) const;
+  scoped_refptr<SimpleFontData> MetricsOverriddenFontData(
+      const FontMetricsOverride&) const;
 
   FontMetrics& GetFontMetrics() { return font_metrics_; }
   const FontMetrics& GetFontMetrics() const { return font_metrics_; }
@@ -92,10 +97,14 @@ class PLATFORM_EXPORT SimpleFontData : public FontData {
     return GetFontMetrics().FloatHeight() - PlatformData().size();
   }
 
-  // "em height" metrics.
-  // https://drafts.css-houdini.org/font-metrics-api-1/#fontmetrics
-  LayoutUnit EmHeightAscent(FontBaseline = kAlphabeticBaseline) const;
-  LayoutUnit EmHeightDescent(FontBaseline = kAlphabeticBaseline) const;
+  // |sTypoAscender| and |sTypoDescender| in |OS/2| table, normalized to 1em.
+  // This metrics can simulate ideographics em-box when the font doesn't have
+  // better ways to compute it.
+  // https://docs.microsoft.com/en-us/typography/opentype/spec/baselinetags#ideoembox
+  FontHeight NormalizedTypoAscentAndDescent(
+      FontBaseline baseline_type = kAlphabeticBaseline) const;
+  LayoutUnit NormalizedTypoAscent(FontBaseline = kAlphabeticBaseline) const;
+  LayoutUnit NormalizedTypoDescent(FontBaseline = kAlphabeticBaseline) const;
 
   LayoutUnit VerticalPosition(FontVerticalPositionType, FontBaseline) const;
 
@@ -110,6 +119,7 @@ class PLATFORM_EXPORT SimpleFontData : public FontData {
   }
 
   FloatRect BoundsForGlyph(Glyph) const;
+  void BoundsForGlyphs(const Vector<Glyph, 256>&, Vector<SkRect, 256>*) const;
   FloatRect PlatformBoundsForGlyph(Glyph) const;
   float WidthForGlyph(Glyph) const;
   float PlatformWidthForGlyph(Glyph) const;
@@ -147,27 +157,38 @@ class PLATFORM_EXPORT SimpleFontData : public FontData {
     return visual_overflow_inflation_for_descent_;
   }
 
+  bool HasAdvanceOverride() const override {
+    return advance_override_.has_value();
+  }
+
+  float GetAdvanceOverride() const { return advance_override_.value_or(1); }
+  float GetAdvanceOverrideVerticalUpright() const {
+    return advance_override_vertical_upright_.value_or(1);
+  }
+
  protected:
-  SimpleFontData(const FontPlatformData&,
-                 scoped_refptr<CustomFontData> custom_data,
-                 bool subpixel_ascent_descent = false);
+  SimpleFontData(
+      const FontPlatformData&,
+      scoped_refptr<CustomFontData> custom_data,
+      bool subpixel_ascent_descent = false,
+      const FontMetricsOverride& metrics_override = FontMetricsOverride());
 
  private:
-  void PlatformInit(bool subpixel_ascent_descent);
+  void PlatformInit(bool subpixel_ascent_descent, const FontMetricsOverride&);
   void PlatformGlyphInit();
 
   scoped_refptr<SimpleFontData> CreateScaledFontData(const FontDescription&,
                                               float scale_factor) const;
 
-  void ComputeEmHeightMetrics() const;
-  bool NormalizeEmHeightMetrics(float, float) const;
+  void ComputeNormalizedTypoAscentAndDescent() const;
+  bool TrySetNormalizedTypoAscentAndDescent(float ascent, float descent) const;
 
   FontMetrics font_metrics_;
   float max_char_width_;
   float avg_char_width_;
 
   FontPlatformData platform_data_;
-  SkPaint paint_;
+  SkFont font_;
 
   Glyph space_glyph_;
   float space_width_;
@@ -175,16 +196,14 @@ class PLATFORM_EXPORT SimpleFontData : public FontData {
 
   struct DerivedFontData {
     USING_FAST_MALLOC(DerivedFontData);
-    WTF_MAKE_NONCOPYABLE(DerivedFontData);
 
    public:
-    static std::unique_ptr<DerivedFontData> Create();
+    DerivedFontData() = default;
 
     scoped_refptr<SimpleFontData> small_caps;
     scoped_refptr<SimpleFontData> emphasis_mark;
 
-   private:
-    DerivedFontData() = default;
+    DISALLOW_COPY_AND_ASSIGN(DerivedFontData);
   };
 
   mutable std::unique_ptr<DerivedFontData> derived_font_data_;
@@ -197,21 +216,25 @@ class PLATFORM_EXPORT SimpleFontData : public FontData {
   unsigned visual_overflow_inflation_for_ascent_;
   unsigned visual_overflow_inflation_for_descent_;
 
-  mutable LayoutUnit em_height_ascent_;
-  mutable LayoutUnit em_height_descent_;
+  // The multiplier to the advance of each letter as defined by the
+  // advance-override value in @font-face.
+  base::Optional<float> advance_override_;
+  base::Optional<float> advance_override_vertical_upright_;
+
+  mutable FontHeight normalized_typo_ascent_descent_;
 
 // See discussion on crbug.com/631032 and Skiaissue
 // https://bugs.chromium.org/p/skia/issues/detail?id=5328 :
 // On Mac we're still using path based glyph metrics, and they seem to be
 // too slow to be able to remove the caching layer we have here.
-#if defined(OS_MACOSX)
+#if defined(OS_MAC)
   mutable std::unique_ptr<GlyphMetricsMap<FloatRect>> glyph_to_bounds_map_;
   mutable GlyphMetricsMap<float> glyph_to_width_map_;
 #endif
 };
 
 ALWAYS_INLINE FloatRect SimpleFontData::BoundsForGlyph(Glyph glyph) const {
-#if !defined(OS_MACOSX)
+#if !defined(OS_MAC)
   return PlatformBoundsForGlyph(glyph);
 #else
   FloatRect bounds_result;
@@ -231,7 +254,7 @@ ALWAYS_INLINE FloatRect SimpleFontData::BoundsForGlyph(Glyph glyph) const {
 }
 
 ALWAYS_INLINE float SimpleFontData::WidthForGlyph(Glyph glyph) const {
-#if !defined(OS_MACOSX)
+#if !defined(OS_MAC)
   return PlatformWidthForGlyph(glyph);
 #else
   float width = glyph_to_width_map_.MetricsForGlyph(glyph);
@@ -245,7 +268,12 @@ ALWAYS_INLINE float SimpleFontData::WidthForGlyph(Glyph glyph) const {
 #endif
 }
 
-DEFINE_FONT_DATA_TYPE_CASTS(SimpleFontData, false);
+template <>
+struct DowncastTraits<SimpleFontData> {
+  static bool AllowFrom(const FontData& fontData) {
+    return !fontData.IsSegmented();
+  }
+};
 
 }  // namespace blink
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SIMPLE_FONT_DATA_H_
diff --git a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
index 5781cafc4ff9..b962b210a9ab 100644
--- a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
+++ b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
@@ -1,4 +1,3 @@
-
 /*
  * Copyright (c) 2006, 2007, 2008, 2009 Google Inc. All rights reserved.
  *
@@ -34,21 +33,24 @@
 #include <memory>
 #include <utility>
 
+#include "base/check_op.h"
+#include "base/notreached.h"
 #include "build/build_config.h"
 #include "third_party/blink/public/platform/linux/web_sandbox_support.h"
 #include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/renderer/platform/font_family_names.h"
 #include "third_party/blink/renderer/platform/fonts/alternate_font_family.h"
-#include "third_party/blink/renderer/platform/fonts/bitmap_glyphs_blacklist.h"
+#include "third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
 #include "third_party/blink/renderer/platform/fonts/font_face_creation_params.h"
+#include "third_party/blink/renderer/platform/fonts/font_global_context.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
-#include "third_party/blink/renderer/platform/graphics/skia/skia_utils.h"
+#include "third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.h"
 #include "third_party/blink/renderer/platform/language.h"
+#include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/blink/renderer/platform/wtf/assertions.h"
 #include "third_party/blink/renderer/platform/wtf/text/atomic_string.h"
-#include "third_party/blink/renderer/platform/wtf/text/cstring.h"
 #include "third_party/skia/include/core/SkFontMgr.h"
 #include "third_party/skia/include/core/SkStream.h"
 #include "third_party/skia/include/core/SkTypeface.h"
@@ -59,13 +61,7 @@ AtomicString ToAtomicString(const SkString& str) {
   return AtomicString::FromUTF8(str.c_str(), str.size());
 }
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_FUCHSIA)
-// Android special locale for retrieving the color emoji font
-// based on the proposed changes in UTR #51 for introducing
-// an Emoji script code:
-// http://www.unicode.org/reports/tr51/proposed.html#Emoji_Script
-static const char kAndroidColorEmojiLocale[] = "und-Zsye";
-
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
 // This function is called on android or when we are emulating android fonts on
 // linux and the embedder has overriden the default fontManager with
 // WebFontRendering::setSkiaFontMgr.
@@ -77,25 +73,10 @@ AtomicString FontCache::GetFamilyNameForCharacter(
     FontFallbackPriority fallback_priority) {
   DCHECK(fm);
 
-  const size_t kMaxLocales = 4;
-  const char* bcp47_locales[kMaxLocales];
-  size_t locale_count = 0;
-
-  // Fill in the list of locales in the reverse priority order.
-  // Skia expects the highest array index to be the first priority.
-  const LayoutLocale* content_locale = font_description.Locale();
-  if (const LayoutLocale* han_locale =
-          LayoutLocale::LocaleForHan(content_locale))
-    bcp47_locales[locale_count++] = han_locale->LocaleForHanForSkFontMgr();
-  bcp47_locales[locale_count++] =
-      LayoutLocale::GetDefault().LocaleForSkFontMgr();
-  if (content_locale)
-    bcp47_locales[locale_count++] = content_locale->LocaleForSkFontMgr();
-  if (fallback_priority == FontFallbackPriority::kEmojiEmoji)
-    bcp47_locales[locale_count++] = kAndroidColorEmojiLocale;
-  SECURITY_DCHECK(locale_count <= kMaxLocales);
+  Bcp47Vector locales =
+      GetBcp47LocaleForRequest(font_description, fallback_priority);
   sk_sp<SkTypeface> typeface(fm->matchFamilyStyleCharacter(
-      nullptr, SkFontStyle(), bcp47_locales, locale_count, c));
+      nullptr, SkFontStyle(), locales.data(), locales.size(), c));
   if (!typeface)
     return g_empty_atom;
 
@@ -103,7 +84,7 @@ AtomicString FontCache::GetFamilyNameForCharacter(
   typeface->getFamilyName(&skia_family_name);
   return ToAtomicString(skia_family_name);
 }
-#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_FUCHSIA)
+#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
 
 void FontCache::PlatformInit() {}
 
@@ -145,14 +126,14 @@ scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
   if (!font_platform_data) {
     DEFINE_THREAD_SAFE_STATIC_LOCAL(const FontFaceCreationParams,
                                     sans_creation_params,
-                                    (FontFamilyNames::Sans));
+                                    (font_family_names::kSans));
     font_platform_data = GetFontPlatformData(description, sans_creation_params,
                                              AlternateFontName::kLastResort);
   }
   if (!font_platform_data) {
     DEFINE_THREAD_SAFE_STATIC_LOCAL(const FontFaceCreationParams,
                                     arial_creation_params,
-                                    (FontFamilyNames::Arial));
+                                    (font_family_names::kArial));
     font_platform_data = GetFontPlatformData(description, arial_creation_params,
                                              AlternateFontName::kLastResort);
   }
@@ -161,7 +142,7 @@ scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
   if (!font_platform_data) {
     DEFINE_THREAD_SAFE_STATIC_LOCAL(const FontFaceCreationParams,
                                     msuigothic_creation_params,
-                                    (FontFamilyNames::MS_UI_Gothic));
+                                    (font_family_names::kMSUIGothic));
     font_platform_data =
         GetFontPlatformData(description, msuigothic_creation_params,
                             AlternateFontName::kLastResort);
@@ -169,7 +150,7 @@ scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
   if (!font_platform_data) {
     DEFINE_THREAD_SAFE_STATIC_LOCAL(const FontFaceCreationParams,
                                     mssansserif_creation_params,
-                                    (FontFamilyNames::Microsoft_Sans_Serif));
+                                    (font_family_names::kMicrosoftSansSerif));
     font_platform_data =
         GetFontPlatformData(description, mssansserif_creation_params,
                             AlternateFontName::kLastResort);
@@ -177,21 +158,21 @@ scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
   if (!font_platform_data) {
     DEFINE_THREAD_SAFE_STATIC_LOCAL(const FontFaceCreationParams,
                                     segoeui_creation_params,
-                                    (FontFamilyNames::Segoe_UI));
+                                    (font_family_names::kSegoeUI));
     font_platform_data = GetFontPlatformData(
         description, segoeui_creation_params, AlternateFontName::kLastResort);
   }
   if (!font_platform_data) {
     DEFINE_THREAD_SAFE_STATIC_LOCAL(const FontFaceCreationParams,
                                     calibri_creation_params,
-                                    (FontFamilyNames::Calibri));
+                                    (font_family_names::kCalibri));
     font_platform_data = GetFontPlatformData(
         description, calibri_creation_params, AlternateFontName::kLastResort);
   }
   if (!font_platform_data) {
     DEFINE_THREAD_SAFE_STATIC_LOCAL(const FontFaceCreationParams,
                                     timesnewroman_creation_params,
-                                    (FontFamilyNames::Times_New_Roman));
+                                    (font_family_names::kTimesNewRoman));
     font_platform_data =
         GetFontPlatformData(description, timesnewroman_creation_params,
                             AlternateFontName::kLastResort);
@@ -199,7 +180,7 @@ scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
   if (!font_platform_data) {
     DEFINE_THREAD_SAFE_STATIC_LOCAL(const FontFaceCreationParams,
                                     couriernew_creation_params,
-                                    (FontFamilyNames::Courier_New));
+                                    (font_family_names::kCourierNew));
     font_platform_data =
         GetFontPlatformData(description, couriernew_creation_params,
                             AlternateFontName::kLastResort);
@@ -210,25 +191,25 @@ scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
   return FontDataFromFontPlatformData(font_platform_data, should_retain);
 }
 
-PaintTypeface FontCache::CreateTypeface(
+sk_sp<SkTypeface> FontCache::CreateTypeface(
     const FontDescription& font_description,
     const FontFaceCreationParams& creation_params,
-    CString& name) {
+    std::string& name) {
 #if !defined(OS_WIN) && !defined(OS_ANDROID) && !defined(OS_FUCHSIA)
   // TODO(fuchsia): Revisit this and other font code for Fuchsia.
 
   if (creation_params.CreationType() == kCreateFontByFciIdAndTtcIndex) {
     if (Platform::Current()->GetSandboxSupport()) {
-      return PaintTypeface::FromFontConfigInterfaceIdAndTtcIndex(
+      return SkTypeface_Factory::FromFontConfigInterfaceIdAndTtcIndex(
           creation_params.FontconfigInterfaceId(), creation_params.TtcIndex());
     }
-    return PaintTypeface::FromFilenameAndTtcIndex(
+    return SkTypeface_Factory::FromFilenameAndTtcIndex(
         creation_params.Filename().data(), creation_params.TtcIndex());
   }
 #endif
 
   AtomicString family = creation_params.Family();
-  DCHECK_NE(family, FontFamilyNames::system_ui);
+  DCHECK_NE(family, font_family_names::kSystemUi);
   // If we're creating a fallback font (e.g. "-webkit-monospace"), convert the
   // name into the fallback name (like "monospace") that fontconfig understands.
   if (!family.length() || family.StartsWith("-webkit-")) {
@@ -241,32 +222,29 @@ PaintTypeface FontCache::CreateTypeface(
 #if defined(OS_WIN)
   // TODO(vmpstr): Deal with paint typeface here.
   if (sideloaded_fonts_) {
-    HashMap<String, sk_sp<SkTypeface>>::iterator sideloaded_font =
-        sideloaded_fonts_->find(name.data());
+    HashMap<String, sk_sp<SkTypeface>, CaseFoldingHash>::iterator
+        sideloaded_font = sideloaded_fonts_->find(name.c_str());
     if (sideloaded_font != sideloaded_fonts_->end())
-      return PaintTypeface::FromSkTypeface(sideloaded_font->value);
+      return sideloaded_font->value;
   }
 #endif
 
-#if defined(OS_LINUX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_WIN)
   // On linux if the fontManager has been overridden then we should be calling
   // the embedder provided font Manager rather than calling
   // SkTypeface::CreateFromName which may redirect the call to the default font
   // Manager.  On Windows the font manager is always present.
   if (font_manager_) {
-    // TODO(vmpstr): Handle creating paint typefaces here directly. We need to
-    // figure out whether it's safe to give |font_manager_| to PaintTypeface and
-    // what that means on the GPU side.
     auto tf = sk_sp<SkTypeface>(font_manager_->matchFamilyStyle(
-        name.data(), font_description.SkiaFontStyle()));
-    return PaintTypeface::FromSkTypeface(std::move(tf));
+        name.c_str(), font_description.SkiaFontStyle()));
+    return tf;
   }
 #endif
 
   // FIXME: Use m_fontManager, matchFamilyStyle instead of
   // legacyCreateTypeface on all platforms.
-  return PaintTypeface::FromFamilyNameAndFontStyle(
-      name.data(), font_description.SkiaFontStyle());
+  return SkTypeface_Factory::FromFamilyNameAndFontStyle(
+      name.c_str(), font_description.SkiaFontStyle());
 }
 
 #if !defined(OS_WIN)
@@ -274,28 +252,38 @@ std::unique_ptr<FontPlatformData> FontCache::CreateFontPlatformData(
     const FontDescription& font_description,
     const FontFaceCreationParams& creation_params,
     float font_size,
-    AlternateFontName) {
-  CString name;
-  PaintTypeface paint_tf =
-      CreateTypeface(font_description, creation_params, name);
-  if (!paint_tf)
+    AlternateFontName alternate_name) {
+  std::string name;
+
+  sk_sp<SkTypeface> typeface;
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+  if (alternate_name == AlternateFontName::kLocalUniqueFace &&
+      RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled()) {
+    typeface = CreateTypefaceFromUniqueName(creation_params);
+  } else {
+    typeface = CreateTypeface(font_description, creation_params, name);
+  }
+#else
+  typeface = CreateTypeface(font_description, creation_params, name);
+#endif
+
+  if (!typeface)
     return nullptr;
 
-  const auto& tf = paint_tf.ToSkTypeface();
   std::unique_ptr<FontPlatformData> font_platform_data =
       std::make_unique<FontPlatformData>(
-          paint_tf, name, font_size,
+          typeface, name, font_size,
           (font_description.Weight() >
                FontSelectionValue(200) +
-                   FontSelectionValue(tf->fontStyle().weight()) ||
+                   FontSelectionValue(typeface->fontStyle().weight()) ||
            font_description.IsSyntheticBold()),
           ((font_description.Style() == ItalicSlopeValue()) &&
-           !tf->isItalic()) ||
+           !typeface->isItalic()) ||
               font_description.IsSyntheticItalic(),
           font_description.Orientation());
 
   font_platform_data->SetAvoidEmbeddedBitmaps(
-      BitmapGlyphsBlacklist::AvoidEmbeddedBitmapsForTypeface(tf.get()));
+      BitmapGlyphsBlockList::ShouldAvoidEmbeddedBitmapsForTypeface(*typeface));
 
   return font_platform_data;
 }
diff --git a/third_party/blink/renderer/platform/fonts/skia/skia_text_metrics.cc b/third_party/blink/renderer/platform/fonts/skia/skia_text_metrics.cc
index 47ee36d7fae2..085519d3131b 100644
--- a/third_party/blink/renderer/platform/fonts/skia/skia_text_metrics.cc
+++ b/third_party/blink/renderer/platform/fonts/skia/skia_text_metrics.cc
@@ -6,44 +6,101 @@
 
 #include "build/build_config.h"
 #include "third_party/blink/renderer/platform/wtf/math_extras.h"
-
-#include <SkPath.h>
+#include "third_party/skia/include/core/SkFont.h"
+#include "third_party/skia/include/core/SkPath.h"
 
 namespace blink {
 
-SkiaTextMetrics::SkiaTextMetrics(const SkPaint* paint) : paint_(paint) {
-  CHECK(paint_->getTextEncoding() == SkPaint::kGlyphID_TextEncoding);
+namespace {
+
+template <class T>
+T* advance_by_byte_size(T* p, unsigned byte_size) {
+  return reinterpret_cast<T*>(reinterpret_cast<uint8_t*>(p) + byte_size);
 }
 
-void SkiaTextMetrics::GetGlyphWidthForHarfBuzz(hb_codepoint_t codepoint,
-                                               hb_position_t* width) {
+template <class T>
+const T* advance_by_byte_size(const T* p, unsigned byte_size) {
+  return reinterpret_cast<const T*>(reinterpret_cast<const uint8_t*>(p) +
+                                    byte_size);
+}
+
+}  // namespace
+
+void SkFontGetGlyphWidthForHarfBuzz(const SkFont& font,
+                                    hb_codepoint_t codepoint,
+                                    hb_position_t* width) {
   DCHECK_LE(codepoint, 0xFFFFu);
   CHECK(width);
 
   SkScalar sk_width;
   uint16_t glyph = codepoint;
 
-  paint_->getTextWidths(&glyph, sizeof(glyph), &sk_width, nullptr);
-  if (!paint_->isSubpixelText())
+  font.getWidths(&glyph, 1, &sk_width);
+  if (!font.isSubpixel())
     sk_width = SkScalarRoundToInt(sk_width);
   *width = SkiaScalarToHarfBuzzPosition(sk_width);
 }
 
-void SkiaTextMetrics::GetGlyphExtentsForHarfBuzz(hb_codepoint_t codepoint,
-                                                 hb_glyph_extents_t* extents) {
+void SkFontGetGlyphWidthForHarfBuzz(const SkFont& font,
+                                    unsigned count,
+                                    const hb_codepoint_t* glyphs,
+                                    const unsigned glyph_stride,
+                                    hb_position_t* advances,
+                                    unsigned advance_stride) {
+  // Batch the call to getWidths because its function entry cost is not
+  // cheap. getWidths accepts multiple glyphd ID, but not from a sparse
+  // array that copy them to a regular array.
+  Vector<Glyph, 256> glyph_array(count);
+  for (unsigned i = 0; i < count;
+       i++, glyphs = advance_by_byte_size(glyphs, glyph_stride)) {
+    glyph_array[i] = *glyphs;
+  }
+  Vector<SkScalar, 256> sk_width_array(count);
+  font.getWidths(glyph_array.data(), count, sk_width_array.data());
+
+  if (!font.isSubpixel()) {
+    for (unsigned i = 0; i < count; i++)
+      sk_width_array[i] = SkScalarRoundToInt(sk_width_array[i]);
+  }
+
+  // Copy the results back to the sparse array.
+  for (unsigned i = 0; i < count;
+       i++, advances = advance_by_byte_size(advances, advance_stride)) {
+    *advances = SkiaScalarToHarfBuzzPosition(sk_width_array[i]);
+  }
+}
+
+// HarfBuzz callback to retrieve glyph extents, mainly used by HarfBuzz for
+// fallback mark positioning, i.e. the situation when the font does not have
+// mark anchors or other mark positioning rules, but instead HarfBuzz is
+// supposed to heuristically place combining marks around base glyphs. HarfBuzz
+// does this by measuring "ink boxes" of glyphs, and placing them according to
+// Unicode mark classes. Above, below, centered or left or right, etc.
+void SkFontGetGlyphExtentsForHarfBuzz(const SkFont& font,
+                                      hb_codepoint_t codepoint,
+                                      hb_glyph_extents_t* extents) {
   DCHECK_LE(codepoint, 0xFFFFu);
   CHECK(extents);
 
   SkRect sk_bounds;
   uint16_t glyph = codepoint;
 
-  paint_->getTextWidths(&glyph, sizeof(glyph), nullptr, &sk_bounds);
-  if (!paint_->isSubpixelText()) {
+#if defined(OS_MAC)
+  // TODO(drott): Remove this once we have better metrics bounds
+  // on Mac, https://bugs.chromium.org/p/skia/issues/detail?id=5328
+  SkPath path;
+  if (font.getPath(glyph, &path)) {
+    sk_bounds = path.getBounds();
+  } else {
+    font.getBounds(&glyph, 1, &sk_bounds, nullptr);
+  }
+#else
+  font.getBounds(&glyph, 1, &sk_bounds, nullptr);
+#endif
+  if (!font.isSubpixel()) {
     // Use roundOut() rather than round() to avoid rendering glyphs
     // outside the visual overflow rect. crbug.com/452914.
-    SkIRect ir;
-    sk_bounds.roundOut(&ir);
-    sk_bounds.set(ir);
+    sk_bounds.set(sk_bounds.roundOut());
   }
 
   // Invert y-axis because Skia is y-grows-down but we set up HarfBuzz to be
@@ -54,35 +111,60 @@ void SkiaTextMetrics::GetGlyphExtentsForHarfBuzz(hb_codepoint_t codepoint,
   extents->height = SkiaScalarToHarfBuzzPosition(-sk_bounds.height());
 }
 
-void SkiaTextMetrics::GetSkiaBoundsForGlyph(Glyph glyph, SkRect* bounds) {
-#if defined(OS_MACOSX)
+void SkFontGetBoundsForGlyph(const SkFont& font, Glyph glyph, SkRect* bounds) {
+#if defined(OS_MAC)
   // TODO(drott): Remove this once we have better metrics bounds
   // on Mac, https://bugs.chromium.org/p/skia/issues/detail?id=5328
   SkPath path;
-  paint_->getTextPath(&glyph, sizeof(glyph), 0, 0, &path);
-  *bounds = path.getBounds();
+  if (font.getPath(glyph, &path)) {
+    *bounds = path.getBounds();
+  } else {
+    // Fonts like Apple Color Emoji have no paths, fall back to bounds here.
+    font.getBounds(&glyph, 1, bounds, nullptr);
+  }
 #else
-  paint_->getTextWidths(&glyph, sizeof(glyph), nullptr, bounds);
+  font.getBounds(&glyph, 1, bounds, nullptr);
 #endif
 
-  if (!paint_->isSubpixelText()) {
+  if (!font.isSubpixel()) {
     SkIRect ir;
     bounds->roundOut(&ir);
     bounds->set(ir);
   }
 }
 
-float SkiaTextMetrics::GetSkiaWidthForGlyph(Glyph glyph) {
-  SkScalar sk_width;
-  paint_->getTextWidths(&glyph, sizeof(glyph), &sk_width, nullptr);
+void SkFontGetBoundsForGlyphs(const SkFont& font,
+                              const Vector<Glyph, 256>& glyphs,
+                              SkRect* bounds) {
+#if defined(OS_MAC)
+  for (unsigned i = 0; i < glyphs.size(); i++) {
+    SkFontGetBoundsForGlyph(font, glyphs[i], &bounds[i]);
+  }
+#else
+  static_assert(sizeof(Glyph) == 2, "Skia expects 2 bytes glyph id.");
+  font.getBounds(glyphs.data(), glyphs.size(), bounds, nullptr);
 
-  if (!paint_->isSubpixelText())
+  if (!font.isSubpixel()) {
+    for (unsigned i = 0; i < glyphs.size(); i++) {
+      SkIRect ir;
+      bounds[i].roundOut(&ir);
+      bounds[i].set(ir);
+    }
+  }
+#endif
+}
+
+float SkFontGetWidthForGlyph(const SkFont& font, Glyph glyph) {
+  SkScalar sk_width;
+  font.getWidths(&glyph, 1, &sk_width);
+
+  if (!font.isSubpixel())
     sk_width = SkScalarRoundToInt(sk_width);
 
   return SkScalarToFloat(sk_width);
 }
 
-hb_position_t SkiaTextMetrics::SkiaScalarToHarfBuzzPosition(SkScalar value) {
+hb_position_t SkiaScalarToHarfBuzzPosition(SkScalar value) {
   // We treat HarfBuzz hb_position_t as 16.16 fixed-point.
   static const int kHbPosition1 = 1 << 16;
   return clampTo<int>(value * kHbPosition1);
diff --git a/third_party/blink/renderer/platform/fonts/skia/skia_text_metrics.h b/third_party/blink/renderer/platform/fonts/skia/skia_text_metrics.h
index e8a38f94142a..f638f1c83938 100644
--- a/third_party/blink/renderer/platform/fonts/skia/skia_text_metrics.h
+++ b/third_party/blink/renderer/platform/fonts/skia/skia_text_metrics.h
@@ -7,26 +7,38 @@
 
 #include "third_party/blink/renderer/platform/fonts/glyph.h"
 
-#include <SkPaint.h>
 #include <hb.h>
+#include "third_party/blink/renderer/platform/wtf/vector.h"
+#include "third_party/skia/include/core/SkRect.h"
+
+class SkFont;
 
 namespace blink {
 
-class SkiaTextMetrics final {
- public:
-  SkiaTextMetrics(const SkPaint*);
+// TODO: Width functions are affected by issue
+// https://bugs.chromium.org/p/skia/issues/detail?id=10123 in Skia, which
+// currently does not return trak-free advances on Mac OS 10.15.
 
-  void GetGlyphWidthForHarfBuzz(hb_codepoint_t, hb_position_t* width);
-  void GetGlyphExtentsForHarfBuzz(hb_codepoint_t, hb_glyph_extents_t*);
+void SkFontGetGlyphWidthForHarfBuzz(const SkFont&,
+                                    hb_codepoint_t,
+                                    hb_position_t* width);
+void SkFontGetGlyphWidthForHarfBuzz(const SkFont&,
+                                    unsigned count,
+                                    const hb_codepoint_t* first_glyph,
+                                    unsigned glyph_stride,
+                                    hb_position_t* first_advance,
+                                    unsigned advance_stride);
+void SkFontGetGlyphExtentsForHarfBuzz(const SkFont&,
+                                      hb_codepoint_t,
+                                      hb_glyph_extents_t*);
 
-  void GetSkiaBoundsForGlyph(Glyph, SkRect* bounds);
-  float GetSkiaWidthForGlyph(Glyph);
+void SkFontGetBoundsForGlyph(const SkFont&, Glyph, SkRect* bounds);
+void SkFontGetBoundsForGlyphs(const SkFont&,
+                              const Vector<Glyph, 256>&,
+                              SkRect*);
+float SkFontGetWidthForGlyph(const SkFont&, Glyph);
 
-  static hb_position_t SkiaScalarToHarfBuzzPosition(SkScalar value);
-
- private:
-  const SkPaint* paint_;
-};
+hb_position_t SkiaScalarToHarfBuzzPosition(SkScalar value);
 
 }  // namespace blink
 
diff --git a/third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.cc b/third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.cc
new file mode 100644
index 000000000000..1537330f5b5e
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.cc
@@ -0,0 +1,57 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.h"
+
+#include "base/notreached.h"
+#include "build/build_config.h"
+#include "third_party/skia/include/core/SkFontMgr.h"
+#include "third_party/skia/include/ports/SkFontConfigInterface.h"
+
+namespace blink {
+
+// static
+sk_sp<SkTypeface> SkTypeface_Factory::FromFontConfigInterfaceIdAndTtcIndex(
+    int config_id,
+    int ttc_index) {
+#if !defined(OS_MAC) && !defined(OS_ANDROID) && !defined(OS_WIN) && \
+    !defined(OS_FUCHSIA)
+  sk_sp<SkFontConfigInterface> fci(SkFontConfigInterface::RefGlobal());
+  SkFontConfigInterface::FontIdentity font_identity;
+  font_identity.fID = config_id;
+  font_identity.fTTCIndex = ttc_index;
+  return fci->makeTypeface(font_identity);
+#else
+  NOTREACHED();
+  return nullptr;
+#endif
+}
+
+// static
+sk_sp<SkTypeface> SkTypeface_Factory::FromFilenameAndTtcIndex(
+    const std::string& filename,
+    int ttc_index) {
+#if !defined(OS_WIN) && !defined(OS_ANDROID) && !defined(OS_FUCHSIA) && \
+    !defined(OS_MAC)
+  return SkTypeface::MakeFromFile(filename.c_str(), ttc_index);
+#else
+  NOTREACHED();
+  return nullptr;
+#endif
+}
+
+// static
+sk_sp<SkTypeface> SkTypeface_Factory::FromFamilyNameAndFontStyle(
+    const std::string& family_name,
+    const SkFontStyle& font_style) {
+#if !defined(OS_MAC)
+  auto fm(SkFontMgr::RefDefault());
+  return fm->legacyMakeTypeface(family_name.c_str(), font_style);
+#else
+  NOTREACHED();
+  return nullptr;
+#endif
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.h b/third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.h
new file mode 100644
index 000000000000..65f9d4a750c5
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.h
@@ -0,0 +1,33 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SKIA_SKTYPEFACE_FACTORY_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SKIA_SKTYPEFACE_FACTORY_H_
+
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace blink {
+
+// Class to bundle all typeface creation method and hopefully harmonize them in
+// the future. Result of reverting the PaintTypeface abstraction, which has the
+// benefit of bundling typeface instantiation in one place but needlessly
+// introduces a wrapper for SkTypeface.
+class SkTypeface_Factory {
+  STATIC_ONLY(SkTypeface_Factory);
+
+ public:
+  static sk_sp<SkTypeface> FromFontConfigInterfaceIdAndTtcIndex(int config_id,
+                                                                int ttc_index);
+  static sk_sp<SkTypeface> FromFilenameAndTtcIndex(const std::string& filename,
+                                                   int ttc_index);
+  static sk_sp<SkTypeface> FromFamilyNameAndFontStyle(
+      const std::string& family_name,
+      const SkFontStyle& font_style);
+};
+
+}  // namespace blink
+
+#endif
diff --git a/third_party/blink/renderer/platform/fonts/small_caps_iterator.h b/third_party/blink/renderer/platform/fonts/small_caps_iterator.h
index 6753fcaf6d0b..e6108628e2e1 100644
--- a/third_party/blink/renderer/platform/fonts/small_caps_iterator.h
+++ b/third_party/blink/renderer/platform/fonts/small_caps_iterator.h
@@ -6,17 +6,17 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SMALL_CAPS_ITERATOR_H_
 
 #include <memory>
+
+#include "base/macros.h"
 #include "third_party/blink/renderer/platform/fonts/font_orientation.h"
 #include "third_party/blink/renderer/platform/fonts/script_run_iterator.h"
 #include "third_party/blink/renderer/platform/fonts/utf16_text_iterator.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
-#include "third_party/blink/renderer/platform/wtf/noncopyable.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
 namespace blink {
 
 class PLATFORM_EXPORT SmallCapsIterator {
   USING_FAST_MALLOC(SmallCapsIterator);
-  WTF_MAKE_NONCOPYABLE(SmallCapsIterator);
 
  public:
   enum SmallCapsBehavior {
@@ -37,6 +37,8 @@ class PLATFORM_EXPORT SmallCapsIterator {
 
   SmallCapsBehavior current_small_caps_behavior_;
   SmallCapsBehavior previous_small_caps_behavior_;
+
+  DISALLOW_COPY_AND_ASSIGN(SmallCapsIterator);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/small_caps_iterator_test.cc b/third_party/blink/renderer/platform/fonts/small_caps_iterator_test.cc
index be0bbc64bd3f..312d4ab3d041 100644
--- a/third_party/blink/renderer/platform/fonts/small_caps_iterator_test.cc
+++ b/third_party/blink/renderer/platform/fonts/small_caps_iterator_test.cc
@@ -5,12 +5,13 @@
 #include "third_party/blink/renderer/platform/fonts/small_caps_iterator.h"
 
 #include "testing/gtest/include/gtest/gtest.h"
-#include <string>
+
+#include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
 
 namespace blink {
 
 struct SmallCapsTestRun {
-  std::string text;
+  const char* const text;
   SmallCapsIterator::SmallCapsBehavior code;
 };
 
@@ -27,10 +28,11 @@ struct SmallCapsExpectedRun {
 class SmallCapsIteratorTest : public testing::Test {
  protected:
   void CheckRuns(const Vector<SmallCapsTestRun>& runs) {
-    String text(g_empty_string16_bit);
+    StringBuilder text;
+    text.Ensure16Bit();
     Vector<SmallCapsExpectedRun> expect;
     for (auto& run : runs) {
-      text.append(String::FromUTF8(run.text.c_str()));
+      text.Append(String::FromUTF8(run.text));
       expect.push_back(SmallCapsExpectedRun(text.length(), run.code));
     }
     SmallCapsIterator small_caps_iterator(text.Characters16(), text.length());
@@ -41,7 +43,7 @@ class SmallCapsIteratorTest : public testing::Test {
                   const Vector<SmallCapsExpectedRun>& expect) {
     unsigned limit;
     SmallCapsIterator::SmallCapsBehavior small_caps_behavior;
-    unsigned long run_count = 0;
+    size_t run_count = 0;
     while (small_caps_iterator->Consume(&limit, &small_caps_behavior)) {
       ASSERT_LT(run_count, expect.size());
       ASSERT_EQ(expect[run_count].limit, limit);
diff --git a/third_party/blink/renderer/platform/fonts/string_truncator.h b/third_party/blink/renderer/platform/fonts/string_truncator.h
index 0a8b2d1d8e0d..fc5fa490e493 100644
--- a/third_party/blink/renderer/platform/fonts/string_truncator.h
+++ b/third_party/blink/renderer/platform/fonts/string_truncator.h
@@ -30,7 +30,7 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_STRING_TRUNCATOR_H_
 
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/forward.h"
 
 namespace blink {
diff --git a/third_party/blink/renderer/platform/fonts/symbols_iterator.cc b/third_party/blink/renderer/platform/fonts/symbols_iterator.cc
index 61d35e0b4c23..83420c17ddd2 100644
--- a/third_party/blink/renderer/platform/fonts/symbols_iterator.cc
+++ b/third_party/blink/renderer/platform/fonts/symbols_iterator.cc
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "third_party/blink/renderer/platform/fonts/symbols_iterator.h"
+#include "third_party/blink/renderer/platform/fonts/utf16_ragel_iterator.h"
 
 #include <unicode/uchar.h>
 #include <unicode/uniset.h>
@@ -10,121 +11,49 @@
 
 namespace blink {
 
+namespace {
+using emoji_text_iter_t = UTF16RagelIterator;
+// Scanner gode generated by Ragel and imported from third_party.
+#include "third_party/emoji-segmenter/src/emoji_presentation_scanner.c"
+}  // namespace
+
 SymbolsIterator::SymbolsIterator(const UChar* buffer, unsigned buffer_size)
-    : utf16_iterator_(std::make_unique<UTF16TextIterator>(buffer, buffer_size)),
-      buffer_size_(buffer_size),
-      next_char_(0),
-      at_end_(buffer_size == 0),
-      current_font_fallback_priority_(FontFallbackPriority::kInvalid) {}
-
-FontFallbackPriority SymbolsIterator::FontFallbackPriorityForCharacter(
-    UChar32 codepoint) {
-  // Those should only be Emoji presentation as combinations of two.
-  if (Character::IsEmojiKeycapBase(codepoint) ||
-      Character::IsRegionalIndicator(codepoint))
-    return FontFallbackPriority::kText;
-
-  if (codepoint == kCombiningEnclosingKeycapCharacter)
-    return FontFallbackPriority::kEmojiEmoji;
-
-  if (Character::IsEmojiEmojiDefault(codepoint) ||
-      Character::IsEmojiModifierBase(codepoint) ||
-      Character::IsModifier(codepoint))
-    return FontFallbackPriority::kEmojiEmoji;
-
-  if (Character::IsEmojiTextDefault(codepoint))
-    return FontFallbackPriority::kEmojiText;
-
-  // Here we could segment into Symbols and Math categories as well, similar
-  // to what the Windows font fallback does. Map the math Unicode and Symbols
-  // blocks to Text for now since we don't have a good cross-platform way to
-  // select suitable math fonts.
-  return FontFallbackPriority::kText;
+    : cursor_(0), next_token_end_(0), next_token_emoji_(false) {
+  if (buffer_size) {
+    buffer_iterator_ = UTF16RagelIterator(buffer, buffer_size, cursor_);
+    next_token_end_ = cursor_ + (scan_emoji_presentation(buffer_iterator_,
+                                                         buffer_iterator_.end(),
+                                                         &next_token_emoji_) -
+                                 buffer_iterator_);
+  }
 }
 
 bool SymbolsIterator::Consume(unsigned* symbols_limit,
                               FontFallbackPriority* font_fallback_priority) {
-  if (at_end_)
+  if (cursor_ >= buffer_iterator_.end().Cursor())
     return false;
 
-  while (utf16_iterator_->Consume(next_char_)) {
-    previous_font_fallback_priority_ = current_font_fallback_priority_;
-    unsigned iterator_offset = utf16_iterator_->Offset();
-    utf16_iterator_->Advance();
+  bool current_token_emoji = false;
+  do {
+    cursor_ = next_token_end_;
+    current_token_emoji = next_token_emoji_;
 
-    // Except at the beginning, ZWJ just carries over the emoji or neutral
-    // text type, VS15 & VS16 we just carry over as well, since we already
-    // resolved those through lookahead. Also, don't downgrade to text
-    // presentation for emoji that are part of a ZWJ sequence, example
-    // U+1F441 U+200D U+1F5E8, eye (text presentation) + ZWJ + left speech
-    // bubble, see below.
-    if ((!(next_char_ == kZeroWidthJoinerCharacter &&
-           previous_font_fallback_priority_ ==
-               FontFallbackPriority::kEmojiEmoji) &&
-         next_char_ != kVariationSelector15Character &&
-         next_char_ != kVariationSelector16Character &&
-         next_char_ != kCombiningEnclosingCircleBackslashCharacter &&
-         !Character::IsRegionalIndicator(next_char_) &&
-         !((next_char_ == kLeftSpeechBubbleCharacter ||
-            next_char_ == kRainbowCharacter ||
-            next_char_ == kMaleSignCharacter ||
-            next_char_ == kFemaleSignCharacter ||
-            next_char_ == kStaffOfAesculapiusCharacter) &&
-           previous_font_fallback_priority_ ==
-               FontFallbackPriority::kEmojiEmoji) &&
-         !Character::IsEmojiFlagSequenceTag(next_char_)) ||
-        current_font_fallback_priority_ == FontFallbackPriority::kInvalid) {
-      current_font_fallback_priority_ =
-          FontFallbackPriorityForCharacter(next_char_);
-    }
+    if (cursor_ >= buffer_iterator_.end().Cursor())
+      break;
 
-    UChar32 peek_char = 0;
-    if (utf16_iterator_->Consume(peek_char) && peek_char != 0) {
-      // Variation Selectors
-      if (current_font_fallback_priority_ ==
-              FontFallbackPriority::kEmojiEmoji &&
-          peek_char == kVariationSelector15Character) {
-        current_font_fallback_priority_ = FontFallbackPriority::kEmojiText;
-      }
+    buffer_iterator_.SetCursor(cursor_);
+    next_token_end_ = cursor_ + (scan_emoji_presentation(buffer_iterator_,
+                                                         buffer_iterator_.end(),
+                                                         &next_token_emoji_) -
+                                 buffer_iterator_);
 
-      if ((current_font_fallback_priority_ ==
-               FontFallbackPriority::kEmojiText ||
-           Character::IsEmojiKeycapBase(next_char_)) &&
-          peek_char == kVariationSelector16Character) {
-        current_font_fallback_priority_ = FontFallbackPriority::kEmojiEmoji;
-      }
+  } while (current_token_emoji == next_token_emoji_);
 
-      // Combining characters Keycap...
-      if (Character::IsEmojiKeycapBase(next_char_) &&
-          peek_char == kCombiningEnclosingKeycapCharacter) {
-        current_font_fallback_priority_ = FontFallbackPriority::kEmojiEmoji;
-      };
+  *font_fallback_priority = current_token_emoji
+                                ? FontFallbackPriority::kEmojiEmoji
+                                : FontFallbackPriority::kText;
+  *symbols_limit = cursor_;
 
-      // Regional indicators
-      if (Character::IsRegionalIndicator(next_char_) &&
-          Character::IsRegionalIndicator(peek_char)) {
-        current_font_fallback_priority_ = FontFallbackPriority::kEmojiEmoji;
-      }
-
-      // Upgrade text presentation emoji to emoji presentation when followed by
-      // ZWJ, Example U+1F441 U+200D U+1F5E8, eye + ZWJ + left speech bubble.
-      if ((next_char_ == kEyeCharacter ||
-           next_char_ == kWavingWhiteFlagCharacter) &&
-          peek_char == kZeroWidthJoinerCharacter) {
-        current_font_fallback_priority_ = FontFallbackPriority::kEmojiEmoji;
-      }
-    }
-
-    if (previous_font_fallback_priority_ != current_font_fallback_priority_ &&
-        (previous_font_fallback_priority_ != FontFallbackPriority::kInvalid)) {
-      *symbols_limit = iterator_offset;
-      *font_fallback_priority = previous_font_fallback_priority_;
-      return true;
-    }
-  }
-  *symbols_limit = buffer_size_;
-  *font_fallback_priority = current_font_fallback_priority_;
-  at_end_ = true;
   return true;
 }
 
diff --git a/third_party/blink/renderer/platform/fonts/symbols_iterator.h b/third_party/blink/renderer/platform/fonts/symbols_iterator.h
index 7484c12683a9..665845ec6645 100644
--- a/third_party/blink/renderer/platform/fonts/symbols_iterator.h
+++ b/third_party/blink/renderer/platform/fonts/symbols_iterator.h
@@ -6,18 +6,16 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SYMBOLS_ITERATOR_H_
 
 #include <memory>
+
+#include "base/macros.h"
 #include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
-#include "third_party/blink/renderer/platform/fonts/font_orientation.h"
-#include "third_party/blink/renderer/platform/fonts/script_run_iterator.h"
-#include "third_party/blink/renderer/platform/fonts/utf16_text_iterator.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
-#include "third_party/blink/renderer/platform/wtf/noncopyable.h"
+#include "third_party/blink/renderer/platform/fonts/utf16_ragel_iterator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
 namespace blink {
 
 class PLATFORM_EXPORT SymbolsIterator {
   USING_FAST_MALLOC(SymbolsIterator);
-  WTF_MAKE_NONCOPYABLE(SymbolsIterator);
 
  public:
   SymbolsIterator(const UChar* buffer, unsigned buffer_size);
@@ -25,17 +23,15 @@ class PLATFORM_EXPORT SymbolsIterator {
   bool Consume(unsigned* symbols_limit, FontFallbackPriority*);
 
  private:
-  FontFallbackPriority FontFallbackPriorityForCharacter(UChar32);
+  UTF16RagelIterator buffer_iterator_;
+  unsigned cursor_;
 
-  std::unique_ptr<UTF16TextIterator> utf16_iterator_;
-  unsigned buffer_size_;
-  UChar32 next_char_;
-  bool at_end_;
+  unsigned next_token_end_;
+  bool next_token_emoji_;
 
-  FontFallbackPriority current_font_fallback_priority_;
-  FontFallbackPriority previous_font_fallback_priority_;
+  DISALLOW_COPY_AND_ASSIGN(SymbolsIterator);
 };
 
 }  // namespace blink
 
-#endif
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SYMBOLS_ITERATOR_H_
diff --git a/third_party/blink/renderer/platform/fonts/symbols_iterator_test.cc b/third_party/blink/renderer/platform/fonts/symbols_iterator_test.cc
index 7abfaf8ea307..cf4937bb719e 100644
--- a/third_party/blink/renderer/platform/fonts/symbols_iterator_test.cc
+++ b/third_party/blink/renderer/platform/fonts/symbols_iterator_test.cc
@@ -4,9 +4,13 @@
 
 #include "third_party/blink/renderer/platform/fonts/symbols_iterator.h"
 
-#include "testing/gtest/include/gtest/gtest.h"
 #include <string>
 
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/blink/renderer/platform/wtf/vector.h"
+
 namespace blink {
 
 struct FallbackTestRun {
@@ -26,10 +30,11 @@ struct FallbackExpectedRun {
 class SymbolsIteratorTest : public testing::Test {
  protected:
   void CheckRuns(const Vector<FallbackTestRun>& runs) {
-    String text(g_empty_string16_bit);
+    StringBuilder text;
+    text.Ensure16Bit();
     Vector<FallbackExpectedRun> expect;
     for (auto& run : runs) {
-      text.append(String::FromUTF8(run.text.c_str()));
+      text.Append(String::FromUTF8(run.text.c_str()));
       expect.push_back(
           FallbackExpectedRun(text.length(), run.font_fallback_priority));
     }
@@ -41,7 +46,7 @@ class SymbolsIteratorTest : public testing::Test {
                   const Vector<FallbackExpectedRun>& expect) {
     unsigned limit;
     FontFallbackPriority font_fallback_priority;
-    unsigned long run_count = 0;
+    size_t run_count = 0;
     while (symbols_iterator->Consume(&limit, &font_fallback_priority)) {
       ASSERT_LT(run_count, expect.size());
       ASSERT_EQ(expect[run_count].limit, limit);
@@ -71,10 +76,14 @@ TEST_F(SymbolsIteratorTest, Latin) {
   CheckRuns({{"Aa", FontFallbackPriority::kText}});
 }
 
+TEST_F(SymbolsIteratorTest, BMPEmoji) {
+  CheckRuns({{"", FontFallbackPriority::kEmojiEmoji}});
+}
+
 TEST_F(SymbolsIteratorTest, LatinColorEmojiTextEmoji) {
   CheckRuns({{"a", FontFallbackPriority::kText},
              {"", FontFallbackPriority::kEmojiEmoji},
-             {"", FontFallbackPriority::kEmojiText}});
+             {"", FontFallbackPriority::kText}});
 }
 
 TEST_F(SymbolsIteratorTest, IgnoreVSInMath) {
@@ -97,16 +106,37 @@ TEST_F(SymbolsIteratorTest, AllHexValuesText) {
 
 TEST_F(SymbolsIteratorTest, NumbersAndHashNormalAndEmoji) {
   CheckRuns({{"0123456789#*", FontFallbackPriority::kText},
-             {"0123456789*", FontFallbackPriority::kEmojiEmoji},
+             {"0\uFE0F1\uFE0F2\uFE0F3\uFE0F4\uFE0F5\uFE0F6\uFE0F7\uFE0F8\uFE0F9"
+              "\uFE0F*\uFE0F",
+              FontFallbackPriority::kEmojiEmoji},
              {"0123456789#*", FontFallbackPriority::kText}});
 }
 
 TEST_F(SymbolsIteratorTest, VS16onDigits) {
   CheckRuns({{"#", FontFallbackPriority::kText},
-             {"#\uFE0F#\uFE0F\u20E3", FontFallbackPriority::kEmojiEmoji},
+             {"#\uFE0F\u20E3", FontFallbackPriority::kEmojiEmoji},
              {"#", FontFallbackPriority::kText}});
 }
 
+TEST_F(SymbolsIteratorTest, EmojiVS15AndVS16) {
+  CheckRuns({{u8"\U0001F642", FontFallbackPriority::kEmojiEmoji},
+             {u8"\U0001F642\U0000FE0E", FontFallbackPriority::kText},
+             {u8"\U0001F642\U0000FE0F", FontFallbackPriority::kEmojiEmoji}});
+}
+
+TEST_F(SymbolsIteratorTest, MultipleMisplacedVS) {
+  CheckRuns({
+      {u8"\U0000FE0E\U0000FE0F", FontFallbackPriority::kText},
+      {u8"\U0001F642\U0000FE0F", FontFallbackPriority::kEmojiEmoji},
+      {u8"\U0001F642\U0000FE0E", FontFallbackPriority::kText},
+      {u8"\U0001F642\U0000FE0F", FontFallbackPriority::kEmojiEmoji},
+      {u8"\U0000FE0E\U0000FE0F", FontFallbackPriority::kText},
+      {u8"\U0001F642\U0000FE0F", FontFallbackPriority::kEmojiEmoji},
+      {u8"\U0001F642\U0000FE0E\U0000FE0E\U0000FE0F",
+       FontFallbackPriority::kText},
+  });
+}
+
 TEST_F(SymbolsIteratorTest, SingleFlag) {
   CheckRuns({{"", FontFallbackPriority::kText}});
 }
@@ -117,33 +147,33 @@ TEST_F(SymbolsIteratorTest, CombiningCircle) {
 
 TEST_F(SymbolsIteratorTest, CombiningEnclosingCircleBackslash) {
   CheckRuns({{"ABC", FontFallbackPriority::kText},
-             {"", FontFallbackPriority::kEmojiEmoji},
-             {"", FontFallbackPriority::kEmojiText},
-             {"", FontFallbackPriority::kEmojiEmoji},
+             {"",
+              FontFallbackPriority::kEmojiEmoji},
              {"abc", FontFallbackPriority::kText}});
 }
 
 // TODO: Perhaps check for invalid country indicator combinations?
 
 TEST_F(SymbolsIteratorTest, FlagsVsNonFlags) {
-  CheckRuns({{"", FontFallbackPriority::kEmojiEmoji},  // "US"
-             {"abc", FontFallbackPriority::kText},
+  CheckRuns({{"", FontFallbackPriority::kEmojiEmoji},  // "US"
+             {"abc", FontFallbackPriority::kText},
              {"", FontFallbackPriority::kEmojiEmoji},
              {"a", FontFallbackPriority::kText}});
 }
 
 TEST_F(SymbolsIteratorTest, EmojiVS15) {
   // A VS15 after the anchor must trigger text display.
-  CheckRuns({{"\U0000FE0E", FontFallbackPriority::kEmojiText},
+  CheckRuns({{"\U0000FE0E", FontFallbackPriority::kText},
              {"", FontFallbackPriority::kEmojiEmoji}});
 }
 
 TEST_F(SymbolsIteratorTest, EmojiZWSSequences) {
-  CheckRuns({{"",
-              FontFallbackPriority::kEmojiEmoji},
-             {"abcd", FontFallbackPriority::kText},
-             {"", FontFallbackPriority::kEmojiEmoji},
-             {"efgh", FontFallbackPriority::kText}});
+  CheckRuns(
+      {{"",
+        FontFallbackPriority::kEmojiEmoji},
+       {"abcd", FontFallbackPriority::kText},
+       {u8"\U0001F469\U0000200D\U0001F469", FontFallbackPriority::kEmojiEmoji},
+       {u8"\U0000200Defgh", FontFallbackPriority::kText}});
 }
 
 TEST_F(SymbolsIteratorTest, AllEmojiZWSSequences) {
@@ -170,7 +200,7 @@ TEST_F(SymbolsIteratorTest, ModifierPlusGender) {
 }
 
 TEST_F(SymbolsIteratorTest, TextMemberZwjSequence) {
-  CheckRuns({{"", FontFallbackPriority::kEmojiEmoji}});
+  CheckRuns({{"", FontFallbackPriority::kEmojiEmoji}});
 }
 
 TEST_F(SymbolsIteratorTest, FacepalmCartwheelShrugModifierFemale) {
@@ -180,8 +210,7 @@ TEST_F(SymbolsIteratorTest, FacepalmCartwheelShrugModifierFemale) {
 
 TEST_F(SymbolsIteratorTest, AesculapiusMaleFemalEmoji) {
   // Emoji Data 4 has upgraded those three characters to Emoji.
-  CheckRuns({{"a", FontFallbackPriority::kText},
-             {"", FontFallbackPriority::kEmojiText}});
+  CheckRuns({{"a", FontFallbackPriority::kText}});
 }
 
 TEST_F(SymbolsIteratorTest, EyeSpeechBubble) {
@@ -203,6 +232,16 @@ TEST_F(SymbolsIteratorTest, ExtraZWJPrefix) {
               FontFallbackPriority::kEmojiEmoji}});
 }
 
+TEST_F(SymbolsIteratorTest, StrayZWJAndVS) {
+  CheckRuns({{u8"\U0000200D\U0000FE0E\U0000FE0E\U0000FE0E\U0000200D\U0000200D",
+              FontFallbackPriority::kText},
+             {u8"\U0001F469\U0000200D\U00002764\U0000FE0F\U0000200D\U0001F48B"
+              u8"\U0000200D\U0001F468",
+              FontFallbackPriority::kEmojiEmoji},
+             {u8"\U0000200D\U0000FE0E\U0000FE0E\U0000FE0E\U0000200D\U0000200D",
+              FontFallbackPriority::kText}});
+}
+
 TEST_F(SymbolsIteratorTest, Arrows) {
   CheckRuns({{"xx", FontFallbackPriority::kText}});
 }
@@ -212,6 +251,10 @@ TEST_F(SymbolsIteratorTest, JudgePilot) {
               FontFallbackPriority::kEmojiEmoji}});
 }
 
+TEST_F(SymbolsIteratorTest, EmojiPunctuationText) {
+  CheckRuns({{"", FontFallbackPriority::kText}});
+}
+
 // Extracted from http://unicode.org/emoji/charts/emoji-released.html for Emoji
 // v5.0, except for the subdivision-flag section.
 // Before ICU 59 new emoji sequences and new single emoji are not detected as
@@ -331,9 +374,12 @@ TEST_F(SymbolsIteratorTest, Emoji5AdditionsExceptFlags) {
 }
 
 TEST_F(SymbolsIteratorTest, EmojiSubdivisionFlags) {
-  CheckRuns(
-      {{"",
-        FontFallbackPriority::kEmojiEmoji}});
+  CheckRuns({{u8"\U0001F3F4\U000E0067\U000E0062\U000E0077\U000E006C\U000E0073"
+              u8"\U000E007F\U0001F3F4\U000E0067\U000E0062\U000E0073\U000E0063"
+              u8"\U000E0074\U000E007F\U0001F3F4",
+              FontFallbackPriority::kEmojiEmoji},
+             // Tag sequences on their own do not mean they're emoji.
+             {u8"\U000E0067\U000E0062", FontFallbackPriority::kText}});
 }
 
 // Extracted from http://unicode.org/emoji/charts/emoji-released.html for Emoji
diff --git a/third_party/blink/renderer/platform/fonts/text_run_paint_info.h b/third_party/blink/renderer/platform/fonts/text_run_paint_info.h
index 01d5332985a3..260fbdbd9420 100644
--- a/third_party/blink/renderer/platform/fonts/text_run_paint_info.h
+++ b/third_party/blink/renderer/platform/fonts/text_run_paint_info.h
@@ -21,7 +21,6 @@ struct TextRunPaintInfo {
   const TextRun& run;
   unsigned from;
   unsigned to;
-  FloatRect bounds;
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/unicode_range_set.cc b/third_party/blink/renderer/platform/fonts/unicode_range_set.cc
index 1721b041ac7d..5122b6a2d292 100644
--- a/third_party/blink/renderer/platform/fonts/unicode_range_set.cc
+++ b/third_party/blink/renderer/platform/fonts/unicode_range_set.cc
@@ -39,8 +39,8 @@ UnicodeRangeSet::UnicodeRangeSet(const Vector<UnicodeRange>& ranges)
   // Unify overlapping ranges.
   UChar32 from = ranges_[0].From();
   UChar32 to = ranges_[0].To();
-  size_t target_index = 0;
-  for (size_t i = 1; i < ranges_.size(); i++) {
+  wtf_size_t target_index = 0;
+  for (wtf_size_t i = 1; i < ranges_.size(); i++) {
     if (to + 1 >= ranges_[i].From()) {
       to = std::max(to, ranges_[i].To());
     } else {
@@ -86,7 +86,7 @@ bool UnicodeRangeSet::operator==(const UnicodeRangeSet& other) const {
     return false;
   }
   bool equal = true;
-  for (size_t i = 0; i < ranges_.size(); ++i) {
+  for (wtf_size_t i = 0; i < ranges_.size(); ++i) {
     equal = equal && ranges_[i] == other.ranges_[i];
   }
   return equal;
diff --git a/third_party/blink/renderer/platform/fonts/unicode_range_set.h b/third_party/blink/renderer/platform/fonts/unicode_range_set.h
index 2336355441d1..634eb99fe11e 100644
--- a/third_party/blink/renderer/platform/fonts/unicode_range_set.h
+++ b/third_party/blink/renderer/platform/fonts/unicode_range_set.h
@@ -27,7 +27,7 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_UNICODE_RANGE_SET_H_
 
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/ref_counted.h"
 #include "third_party/blink/renderer/platform/wtf/text/character_names.h"
 #include "third_party/blink/renderer/platform/wtf/text/unicode.h"
@@ -37,7 +37,7 @@
 namespace blink {
 
 struct PLATFORM_EXPORT UnicodeRange final {
-  DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
+  DISALLOW_NEW();
   UnicodeRange(UChar32 from, UChar32 to) : from_(from), to_(to) {}
 
   UChar32 From() const { return from_; }
@@ -49,7 +49,7 @@ struct PLATFORM_EXPORT UnicodeRange final {
   bool operator<(UChar32 c) const { return to_ < c; }
   bool operator==(const UnicodeRange& other) const {
     return other.from_ == from_ && other.to_ == to_;
-  };
+  }
 
  private:
   UChar32 from_;
@@ -57,15 +57,17 @@ struct PLATFORM_EXPORT UnicodeRange final {
 };
 
 class PLATFORM_EXPORT UnicodeRangeSet : public RefCounted<UnicodeRangeSet> {
+  USING_FAST_MALLOC(UnicodeRangeSet);
+
  public:
   explicit UnicodeRangeSet(const Vector<UnicodeRange>&);
   UnicodeRangeSet() = default;
-  ;
+
   bool Contains(UChar32) const;
   bool IntersectsWith(const String&) const;
   bool IsEntireRange() const { return ranges_.IsEmpty(); }
-  size_t size() const { return ranges_.size(); }
-  const UnicodeRange& RangeAt(size_t i) const { return ranges_[i]; }
+  wtf_size_t size() const { return ranges_.size(); }
+  const UnicodeRange& RangeAt(wtf_size_t i) const { return ranges_[i]; }
   bool operator==(const UnicodeRangeSet& other) const;
 
  private:
diff --git a/third_party/blink/renderer/platform/fonts/utf16_ragel_iterator.cc b/third_party/blink/renderer/platform/fonts/utf16_ragel_iterator.cc
new file mode 100644
index 000000000000..a482b0a65f70
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/utf16_ragel_iterator.cc
@@ -0,0 +1,77 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/utf16_ragel_iterator.h"
+
+#include "third_party/blink/renderer/platform/text/character.h"
+#include "third_party/blink/renderer/platform/wtf/text/character_names.h"
+
+namespace blink {
+
+namespace {
+
+char EmojiSegmentationCategory(UChar32 codepoint) {
+  if (codepoint <= 0x7F) {
+    if (Character::IsEmojiKeycapBase(codepoint))
+      return UTF16RagelIterator::KEYCAP_BASE;
+    return UTF16RagelIterator::kMaxEmojiScannerCategory;
+  }
+  // For the grammar to work, we need to check for more specific character
+  // classes first, then expand towards more generic ones. So we match single
+  // characters and small ranges first, then return EMOJI and
+  // EMOJI_TEXT_PRESENTATION for the remaining ones.
+  if (codepoint == kCombiningEnclosingKeycapCharacter)
+    return UTF16RagelIterator::COMBINING_ENCLOSING_KEYCAP;
+  if (codepoint == kCombiningEnclosingCircleBackslashCharacter)
+    return UTF16RagelIterator::COMBINING_ENCLOSING_CIRCLE_BACKSLASH;
+  if (codepoint == kZeroWidthJoinerCharacter)
+    return UTF16RagelIterator::ZWJ;
+  if (codepoint == kVariationSelector15Character)
+    return UTF16RagelIterator::VS15;
+  if (codepoint == kVariationSelector16Character)
+    return UTF16RagelIterator::VS16;
+  if (codepoint == 0x1F3F4)
+    return UTF16RagelIterator::TAG_BASE;
+  if (Character::IsEmojiTagSequence(codepoint))
+    return UTF16RagelIterator::TAG_SEQUENCE;
+  if (codepoint == kCancelTag) {
+    // http://www.unicode.org/reports/tr51/#def_emoji_tag_sequence
+    // defines a TAG_TERM grammar rule for U+E007F CANCEL TAG.
+    return UTF16RagelIterator::TAG_TERM;
+  }
+  if (Character::IsEmojiModifierBase(codepoint))
+    return UTF16RagelIterator::EMOJI_MODIFIER_BASE;
+  if (Character::IsModifier(codepoint))
+    return UTF16RagelIterator::EMOJI_MODIFIER;
+  if (Character::IsRegionalIndicator(codepoint))
+    return UTF16RagelIterator::REGIONAL_INDICATOR;
+
+  if (Character::IsEmojiEmojiDefault(codepoint))
+    return UTF16RagelIterator::EMOJI_EMOJI_PRESENTATION;
+  if (Character::IsEmojiTextDefault(codepoint))
+    return UTF16RagelIterator::EMOJI_TEXT_PRESENTATION;
+  if (Character::IsEmoji(codepoint))
+    return UTF16RagelIterator::EMOJI;
+
+  // Ragel state machine will interpret unknown category as "any".
+  return UTF16RagelIterator::kMaxEmojiScannerCategory;
+}
+
+}  // namespace
+
+UTF16RagelIterator& UTF16RagelIterator::SetCursor(unsigned new_cursor) {
+  CHECK_GE(new_cursor, 0u);
+  CHECK_LT(new_cursor, buffer_size_);
+  cursor_ = new_cursor;
+  UpdateCachedCategory();
+  return *this;
+}
+
+void UTF16RagelIterator::UpdateCachedCategory() {
+  if (cursor_ >= buffer_size_)
+    return;
+  cached_category_ = EmojiSegmentationCategory(Codepoint());
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/utf16_ragel_iterator.h b/third_party/blink/renderer/platform/fonts/utf16_ragel_iterator.h
new file mode 100644
index 000000000000..1e8b1c225f79
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/utf16_ragel_iterator.h
@@ -0,0 +1,163 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_UTF16_RAGEL_ITERATOR_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_UTF16_RAGEL_ITERATOR_H_
+
+#include <unicode/uchar.h>
+
+#include "base/check_op.h"
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
+
+namespace blink {
+
+// UTF16RagelIterator is set up on top of a UTF-16 UChar* buffer iterating over
+// a Blink internal text string and as such is used as an adapter between Blink
+// strings and the Ragel-based emoji scanner. It supports forwarding and
+// reversing using arithmetic operators. Dereferencing the iterator means
+// retrieving a character class as defined in the Ragel grammar of
+// third-party/emoji-segmenter. The dereferenced character category is cached
+// since Ragel dereferences multiple times without moving the iterator's cursor.
+class PLATFORM_EXPORT UTF16RagelIterator {
+  DISALLOW_NEW();
+
+ public:
+  UTF16RagelIterator() : buffer_(nullptr), buffer_size_(0), cursor_(0) {}
+
+  UTF16RagelIterator(const UChar* buffer,
+                     unsigned buffer_size,
+                     unsigned cursor = 0)
+      : buffer_(buffer),
+        buffer_size_(buffer_size),
+        cursor_(cursor),
+        cached_category_(kMaxEmojiScannerCategory) {
+    UpdateCachedCategory();
+  }
+
+  UTF16RagelIterator end() {
+    UTF16RagelIterator ret = *this;
+    ret.cursor_ = buffer_size_;
+    return ret;
+  }
+
+  UTF16RagelIterator& SetCursor(unsigned new_cursor);
+
+  unsigned Cursor() { return cursor_; }
+
+  UTF16RagelIterator& operator+=(int v) {
+    if (v > 0) {
+      U16_FWD_N(buffer_, cursor_, buffer_size_, v);
+    } else if (v < 0) {
+      U16_BACK_N(buffer_, 0, cursor_, -v);
+    }
+    UpdateCachedCategory();
+    return *this;
+  }
+
+  UTF16RagelIterator& operator-=(int v) { return *this += -v; }
+
+  UTF16RagelIterator operator+(int v) {
+    UTF16RagelIterator ret = *this;
+    return ret += v;
+  }
+
+  UTF16RagelIterator operator-(int v) { return *this + -v; }
+
+  int operator-(const UTF16RagelIterator& other) {
+    DCHECK_EQ(buffer_, other.buffer_);
+    return cursor_ - other.cursor_;
+  }
+
+  UTF16RagelIterator& operator++() {
+    DCHECK_LT(cursor_, buffer_size_);
+    U16_FWD_1(buffer_, cursor_, buffer_size_);
+    UpdateCachedCategory();
+    return *this;
+  }
+
+  UTF16RagelIterator& operator--() {
+    DCHECK_GT(cursor_, 0u);
+    U16_BACK_1(buffer_, 0, cursor_);
+    UpdateCachedCategory();
+    return *this;
+  }
+
+  UTF16RagelIterator operator++(int) {
+    UTF16RagelIterator ret = *this;
+    ++(*this);
+    return ret;
+  }
+
+  UTF16RagelIterator operator--(int) {
+    UTF16RagelIterator ret = *this;
+    --(*this);
+    return ret;
+  }
+
+  UTF16RagelIterator operator=(int v) {
+    // We need this integer assignment operator because Ragel has initialization
+    // code for assigning 0 to ts, te.
+    DCHECK_EQ(v, 0);
+    UTF16RagelIterator ret = *this;
+    ret.cursor_ = v;
+    return ret;
+  }
+
+  UChar32 operator*() {
+    CHECK(buffer_size_);
+    return cached_category_;
+  }
+
+  bool operator==(const UTF16RagelIterator& other) const {
+    return buffer_ == other.buffer_ && buffer_size_ == other.buffer_size_ &&
+           cursor_ == other.cursor_;
+  }
+
+  bool operator!=(const UTF16RagelIterator& other) const {
+    return !(*this == other);
+  }
+
+  // Must match the categories defined in third-party/emoji-segmenter/.
+  // TODO(drott): Add static asserts once emoji-segmenter is imported to
+  // third-party.
+  enum EmojiScannerCharacterClass {
+    EMOJI = 0,
+    EMOJI_TEXT_PRESENTATION = 1,
+    EMOJI_EMOJI_PRESENTATION = 2,
+    EMOJI_MODIFIER_BASE = 3,
+    EMOJI_MODIFIER = 4,
+    EMOJI_VS_BASE = 5,
+    REGIONAL_INDICATOR = 6,
+    KEYCAP_BASE = 7,
+    COMBINING_ENCLOSING_KEYCAP = 8,
+    COMBINING_ENCLOSING_CIRCLE_BACKSLASH = 9,
+    ZWJ = 10,
+    VS15 = 11,
+    VS16 = 12,
+    TAG_BASE = 13,
+    TAG_SEQUENCE = 14,
+    TAG_TERM = 15,
+    kMaxEmojiScannerCategory = 16
+  };
+
+ private:
+  UChar32 Codepoint() const {
+    DCHECK_GT(buffer_size_, 0u);
+    UChar32 output;
+    U16_GET(buffer_, 0, cursor_, buffer_size_, output);
+    return output;
+  }
+
+  void UpdateCachedCategory();
+
+  const UChar* buffer_;
+  unsigned buffer_size_;
+  unsigned cursor_;
+  unsigned char cached_category_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_UTF16_RAGEL_ITERATOR_H_
diff --git a/third_party/blink/renderer/platform/fonts/utf16_ragel_iterator_test.cc b/third_party/blink/renderer/platform/fonts/utf16_ragel_iterator_test.cc
new file mode 100644
index 000000000000..fe01532716b0
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/utf16_ragel_iterator_test.cc
@@ -0,0 +1,140 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/utf16_ragel_iterator.h"
+
+#include <unicode/unistr.h>
+
+#include "base/stl_util.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/text/character.h"
+#include "third_party/blink/renderer/platform/wtf/text/character_names.h"
+
+namespace blink {
+
+TEST(UTF16RagelIteratorTest, CharacterClasses) {
+  UChar32 class_examples_codepoints[] = {
+      kCombiningEnclosingKeycapCharacter,
+      kCombiningEnclosingCircleBackslashCharacter,
+      kZeroWidthJoinerCharacter,
+      kVariationSelector15Character,
+      kVariationSelector16Character,
+      0x1f3f4,
+      0xE0030,
+      kCancelTag,
+      0x261D,
+      0x1F3FB,
+      0x1F1E6,
+      0x0030,
+      0x231A,
+      0x00A9};
+  icu::UnicodeString class_examples_unicode_string =
+      icu::UnicodeString::fromUTF32(class_examples_codepoints,
+                                    base::size(class_examples_codepoints));
+  char categories[] = {UTF16RagelIterator::COMBINING_ENCLOSING_KEYCAP,
+                       UTF16RagelIterator::COMBINING_ENCLOSING_CIRCLE_BACKSLASH,
+                       UTF16RagelIterator::ZWJ,
+                       UTF16RagelIterator::VS15,
+                       UTF16RagelIterator::VS16,
+                       UTF16RagelIterator::TAG_BASE,
+                       UTF16RagelIterator::TAG_SEQUENCE,
+                       UTF16RagelIterator::TAG_TERM,
+                       UTF16RagelIterator::EMOJI_MODIFIER_BASE,
+                       UTF16RagelIterator::EMOJI_MODIFIER,
+                       UTF16RagelIterator::REGIONAL_INDICATOR,
+                       UTF16RagelIterator::KEYCAP_BASE,
+                       UTF16RagelIterator::EMOJI_EMOJI_PRESENTATION,
+                       UTF16RagelIterator::EMOJI_TEXT_PRESENTATION};
+  UTF16RagelIterator ragel_iterator(
+      reinterpret_cast<const UChar*>(class_examples_unicode_string.getBuffer()),
+      class_examples_unicode_string.length());
+  for (char& category : categories) {
+    CHECK_EQ(category, *ragel_iterator);
+    ragel_iterator++;
+  }
+
+  UTF16RagelIterator reverse_ragel_iterator(
+      reinterpret_cast<const UChar*>(class_examples_unicode_string.getBuffer()),
+      class_examples_unicode_string.length(),
+      class_examples_unicode_string.length() - 1);
+  size_t i = base::size(categories) - 1;
+  while (reverse_ragel_iterator.Cursor() > 0) {
+    CHECK_EQ(categories[i], *reverse_ragel_iterator);
+    i--;
+    reverse_ragel_iterator--;
+  };
+}
+
+TEST(UTF16RagelIteratorTest, ArithmeticOperators) {
+  UChar32 class_examples_codepoints[] = {
+      kVariationSelector15Character, kVariationSelector15Character,
+      kVariationSelector15Character, kVariationSelector16Character,
+      kVariationSelector16Character, kVariationSelector16Character,
+  };
+  icu::UnicodeString class_examples_unicode_string =
+      icu::UnicodeString::fromUTF32(class_examples_codepoints,
+                                    base::size(class_examples_codepoints));
+
+  UTF16RagelIterator ragel_iterator(
+      reinterpret_cast<const UChar*>(class_examples_unicode_string.getBuffer()),
+      class_examples_unicode_string.length());
+
+  CHECK_EQ(*ragel_iterator, UTF16RagelIterator::VS15);
+  CHECK_EQ(*(ragel_iterator + 2), UTF16RagelIterator::VS15);
+  CHECK_EQ(*(ragel_iterator + 3), UTF16RagelIterator::VS16);
+  CHECK_EQ(*(ragel_iterator + 5), UTF16RagelIterator::VS16);
+
+  CHECK_EQ(*(ragel_iterator += 3), UTF16RagelIterator::VS16);
+  CHECK_EQ(*(ragel_iterator += 2), UTF16RagelIterator::VS16);
+  CHECK_EQ(*(ragel_iterator -= 4), UTF16RagelIterator::VS15);
+  CHECK_EQ(*(ragel_iterator += 1), UTF16RagelIterator::VS15);
+
+  ragel_iterator += 3;
+
+  UTF16RagelIterator ragel_iterator_begin = ragel_iterator - 5;
+  CHECK(ragel_iterator != ragel_iterator_begin);
+  CHECK(ragel_iterator == ragel_iterator.end() - 1);
+
+  CHECK_EQ(*ragel_iterator, UTF16RagelIterator::VS16);
+  CHECK_EQ(*(ragel_iterator - 2), UTF16RagelIterator::VS16);
+  CHECK_EQ(*(ragel_iterator - 3), UTF16RagelIterator::VS15);
+  CHECK_EQ(*(ragel_iterator - 5), UTF16RagelIterator::VS15);
+}
+
+TEST(UTF16RagelIteratorTest, InvalidOperationOnEmpty) {
+  UTF16RagelIterator ragel_iterator;
+  CHECK_EQ(ragel_iterator.Cursor(), 0u);
+#if DCHECK_IS_ON()
+  EXPECT_DEATH_IF_SUPPORTED(ragel_iterator++, "");
+  EXPECT_DEATH_IF_SUPPORTED(ragel_iterator--, "");
+  EXPECT_DEATH_IF_SUPPORTED(*ragel_iterator, "");
+#endif
+}
+
+TEST(UTF16RagelIteratorTest, CursorPositioning) {
+  UChar32 flags_codepoints[] = {0x1F99E, 0x1F99E, 0x1F99E,
+                                kLeftSpeechBubbleCharacter};
+
+  icu::UnicodeString flags_unicode_string = icu::UnicodeString::fromUTF32(
+      flags_codepoints, base::size(flags_codepoints));
+  UTF16RagelIterator ragel_iterator(
+      reinterpret_cast<const UChar*>(flags_unicode_string.getBuffer()),
+      flags_unicode_string.length());
+
+  CHECK_EQ(ragel_iterator.end().Cursor(), 8u);
+
+  CHECK_EQ(*ragel_iterator, UTF16RagelIterator::EMOJI_EMOJI_PRESENTATION);
+  CHECK_EQ(*(ragel_iterator.SetCursor(4)),
+           UTF16RagelIterator::EMOJI_EMOJI_PRESENTATION);
+  CHECK_EQ(*(ragel_iterator.SetCursor(6)),
+           UTF16RagelIterator::EMOJI_TEXT_PRESENTATION);
+
+#if DCHECK_IS_ON()
+  EXPECT_DEATH_IF_SUPPORTED(ragel_iterator.SetCursor(-1), "");
+  EXPECT_DEATH_IF_SUPPORTED(
+      ragel_iterator.SetCursor(ragel_iterator.end().Cursor()), "");
+#endif
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/utf16_text_iterator.cc b/third_party/blink/renderer/platform/fonts/utf16_text_iterator.cc
index 3f175552aead..abceeae6a9ad 100644
--- a/third_party/blink/renderer/platform/fonts/utf16_text_iterator.cc
+++ b/third_party/blink/renderer/platform/fonts/utf16_text_iterator.cc
@@ -53,7 +53,7 @@ bool UTF16TextIterator::ConsumeSurrogatePair(UChar32& character) {
   DCHECK(U16_IS_SURROGATE(character));
 
   if (!IsValidSurrogatePair(character)) {
-    character = WTF::Unicode::kReplacementCharacter;
+    character = WTF::unicode::kReplacementCharacter;
     return true;
   }
 
diff --git a/third_party/blink/renderer/platform/fonts/utf16_text_iterator.h b/third_party/blink/renderer/platform/fonts/utf16_text_iterator.h
index f5e8ecabfde3..8544383187c7 100644
--- a/third_party/blink/renderer/platform/fonts/utf16_text_iterator.h
+++ b/third_party/blink/renderer/platform/fonts/utf16_text_iterator.h
@@ -23,7 +23,7 @@
 
 #include "base/macros.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/text/character_names.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 
diff --git a/third_party/blink/renderer/platform/fonts/vdmx_parser.cc b/third_party/blink/renderer/platform/fonts/vdmx_parser.cc
index cb178d56feca..ab4caf560753 100644
--- a/third_party/blink/renderer/platform/fonts/vdmx_parser.cc
+++ b/third_party/blink/renderer/platform/fonts/vdmx_parser.cc
@@ -30,9 +30,9 @@
 
 #include "third_party/blink/renderer/platform/fonts/vdmx_parser.h"
 
+#include "base/macros.h"
 #include "base/sys_byteorder.h"
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
-#include "third_party/blink/renderer/platform/wtf/noncopyable.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
 #include <stdlib.h>
 #include <string.h>
@@ -47,7 +47,6 @@ namespace {
 // updating the current offset otherwise.
 class Buffer {
   STACK_ALLOCATED();
-  WTF_MAKE_NONCOPYABLE(Buffer);
 
  public:
   Buffer(const uint8_t* buffer, size_t length)
@@ -89,6 +88,8 @@ class Buffer {
   const uint8_t* const buffer_;
   const size_t length_;
   size_t offset_;
+
+  DISALLOW_COPY_AND_ASSIGN(Buffer);
 };
 
 }  // namespace
@@ -130,7 +131,7 @@ bool ParseVDMX(int* y_max,
   // of this second table.
   //
   // Range 6 <= x <= 262146
-  unsigned long offset_table_offset =
+  size_t offset_table_offset =
       buf.Offset() + 4 /* sizeof struct ratio */ * num_ratios;
 
   unsigned desired_ratio = 0xffffffff;
diff --git a/third_party/blink/renderer/platform/fonts/web_font_decoder.cc b/third_party/blink/renderer/platform/fonts/web_font_decoder.cc
index e99687127a4a..6e388c9135c6 100644
--- a/third_party/blink/renderer/platform/fonts/web_font_decoder.cc
+++ b/third_party/blink/renderer/platform/fonts/web_font_decoder.cc
@@ -34,12 +34,10 @@
 #include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #include "third_party/blink/renderer/platform/fonts/web_font_typeface_factory.h"
-#include "third_party/blink/renderer/platform/graphics/skia/skia_utils.h"
-#include "third_party/blink/renderer/platform/histogram.h"
 #include "third_party/blink/renderer/platform/instrumentation/tracing/trace_event.h"
-#include "third_party/blink/renderer/platform/shared_buffer.h"
-#include "third_party/blink/renderer/platform/wtf/time.h"
-#include "third_party/ots/include/ots-memory-stream.h"
+#include "third_party/blink/renderer/platform/wtf/shared_buffer.h"
+
+#include "third_party/ots/src/include/ots-memory-stream.h"
 #include "third_party/skia/include/core/SkStream.h"
 
 #include <hb.h>
@@ -144,38 +142,6 @@ ots::TableAction BlinkOTSContext::GetTableAction(uint32_t tag) {
   }
 }
 
-void RecordDecodeSpeedHistogram(const char* data,
-                                size_t length,
-                                double decode_time,
-                                size_t decoded_size) {
-  if (decode_time <= 0)
-    return;
-
-  double kb_per_second = decoded_size / (1000 * decode_time);
-  if (length >= 4) {
-    if (data[0] == 'w' && data[1] == 'O' && data[2] == 'F' && data[3] == 'F') {
-      DEFINE_THREAD_SAFE_STATIC_LOCAL(
-          CustomCountHistogram, woff_histogram,
-          ("WebFont.DecodeSpeed.WOFF", 1000, 300000, 50));
-      woff_histogram.Count(kb_per_second);
-      return;
-    }
-
-    if (data[0] == 'w' && data[1] == 'O' && data[2] == 'F' && data[3] == '2') {
-      DEFINE_THREAD_SAFE_STATIC_LOCAL(
-          CustomCountHistogram, woff2_histogram,
-          ("WebFont.DecodeSpeed.WOFF2", 1000, 300000, 50));
-      woff2_histogram.Count(kb_per_second);
-      return;
-    }
-  }
-
-  DEFINE_THREAD_SAFE_STATIC_LOCAL(
-      CustomCountHistogram, sfnt_histogram,
-      ("WebFont.DecodeSpeed.SFNT", 1000, 300000, 50));
-  sfnt_histogram.Count(kb_per_second);
-}
-
 }  // namespace
 
 sk_sp<SkTypeface> WebFontDecoder::Decode(SharedBuffer* buffer) {
@@ -195,14 +161,13 @@ sk_sp<SkTypeface> WebFontDecoder::Decode(SharedBuffer* buffer) {
   // Most web fonts are compressed, so the result can be much larger than
   // the original.
   ots::ExpandingMemoryStream output(buffer->size(), kMaxWebFontSize);
-  double start = CurrentTime();
   BlinkOTSContext ots_context;
   SharedBuffer::DeprecatedFlatData flattened_buffer(buffer);
-  const char* data = flattened_buffer.Data();
 
   TRACE_EVENT_BEGIN0("blink", "DecodeFont");
-  bool ok = ots_context.Process(&output, reinterpret_cast<const uint8_t*>(data),
-                                buffer->size());
+  bool ok = ots_context.Process(
+      &output, reinterpret_cast<const uint8_t*>(flattened_buffer.Data()),
+      buffer->size());
   TRACE_EVENT_END0("blink", "DecodeFont");
 
   if (!ok) {
@@ -210,10 +175,7 @@ sk_sp<SkTypeface> WebFontDecoder::Decode(SharedBuffer* buffer) {
     return nullptr;
   }
 
-  const size_t decoded_length = output.Tell();
-  RecordDecodeSpeedHistogram(data, buffer->size(), CurrentTime() - start,
-                             decoded_length);
-
+  const size_t decoded_length = SafeCast<size_t>(output.Tell());
   sk_sp<SkData> sk_data = SkData::MakeWithCopy(output.get(), decoded_length);
 
   sk_sp<SkTypeface> new_typeface;
diff --git a/third_party/blink/renderer/platform/fonts/web_font_decoder.h b/third_party/blink/renderer/platform/fonts/web_font_decoder.h
index 4d5578ae899e..e8c1996fbbbc 100644
--- a/third_party/blink/renderer/platform/fonts/web_font_decoder.h
+++ b/third_party/blink/renderer/platform/fonts/web_font_decoder.h
@@ -31,7 +31,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WEB_FONT_DECODER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WEB_FONT_DECODER_H_
 
-#include "third_party/blink/renderer/platform/wtf/allocator.h"
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 #include "third_party/skia/include/core/SkRefCnt.h"
 
@@ -39,8 +39,6 @@ class SkTypeface;
 
 namespace blink {
 
-class SharedBuffer;
-
 class WebFontDecoder final {
   STACK_ALLOCATED();
 
diff --git a/third_party/blink/renderer/platform/fonts/web_font_render_style.cc b/third_party/blink/renderer/platform/fonts/web_font_render_style.cc
index 86636e7e3609..a8b68cd62f51 100644
--- a/third_party/blink/renderer/platform/fonts/web_font_render_style.cc
+++ b/third_party/blink/renderer/platform/fonts/web_font_render_style.cc
@@ -7,14 +7,14 @@
 #include "build/build_config.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
-#include "third_party/blink/renderer/platform/graphics/paint/paint_font.h"
-#include "third_party/blink/renderer/platform/layout_test_support.h"
+#include "third_party/blink/renderer/platform/web_test_support.h"
+#include "third_party/skia/include/core/SkFont.h"
 
 namespace blink {
 
 namespace {
 
-SkPaint::Hinting g_skia_hinting = SkPaint::kNormal_Hinting;
+SkFontHinting g_skia_hinting = SkFontHinting::kNormal;
 bool g_use_skia_auto_hint = true;
 bool g_use_skia_bitmaps = true;
 bool g_use_skia_anti_alias = true;
@@ -28,7 +28,7 @@ void WebFontRenderStyle::SetSkiaFontManager(sk_sp<SkFontMgr> font_mgr) {
 }
 
 // static
-void WebFontRenderStyle::SetHinting(SkPaint::Hinting hinting) {
+void WebFontRenderStyle::SetHinting(SkFontHinting hinting) {
   g_skia_hinting = hinting;
 }
 
@@ -66,8 +66,7 @@ void WebFontRenderStyle::SetSystemFontFamily(const WebString& name) {
 WebFontRenderStyle WebFontRenderStyle::GetDefault() {
   WebFontRenderStyle result;
   result.use_anti_alias = g_use_skia_anti_alias;
-  result.hint_style = SkPaint::kNo_Hinting;
-  result.hint_style = g_skia_hinting;
+  result.hint_style = static_cast<char>(g_skia_hinting);
   result.use_bitmaps = g_use_skia_bitmaps;
   result.use_auto_hint = g_use_skia_auto_hint;
   result.use_anti_alias = g_use_skia_anti_alias;
@@ -97,23 +96,29 @@ void WebFontRenderStyle::OverrideWith(const WebFontRenderStyle& other) {
     use_subpixel_positioning = other.use_subpixel_positioning;
 }
 
-void WebFontRenderStyle::ApplyToPaintFont(PaintFont& font,
-                                          float device_scale_factor) const {
-  auto sk_hint_style = static_cast<SkPaint::Hinting>(hint_style);
-  font.SetAntiAlias(use_anti_alias);
-  font.SetHinting(sk_hint_style);
-  font.SetEmbeddedBitmapText(use_bitmaps);
-  font.SetAutohinted(use_auto_hint);
-  if (use_anti_alias)
-    font.SetLcdRenderText(use_subpixel_rendering);
+void WebFontRenderStyle::ApplyToSkFont(SkFont* font,
+                                       float device_scale_factor) const {
+  auto sk_hint_style = static_cast<SkFontHinting>(hint_style);
+  font->setHinting(sk_hint_style);
+  font->setEmbeddedBitmaps(use_bitmaps);
+  font->setForceAutoHinting(use_auto_hint);
+  if (use_anti_alias && use_subpixel_rendering) {
+    font->setEdging(SkFont::Edging::kSubpixelAntiAlias);
+  } else if (use_anti_alias) {
+    font->setEdging(SkFont::Edging::kAntiAlias);
+  } else {
+    font->setEdging(SkFont::Edging::kAlias);
+  }
 
   // Force-enable subpixel positioning, except when full hinting is requested on
-  // low-dpi screen or when running layout tests.
+  // low-dpi screen or when running web tests.
   bool force_subpixel_positioning =
-      !LayoutTestSupport::IsRunningLayoutTest() &&
-      (sk_hint_style != SkPaint::kFull_Hinting || device_scale_factor > 1.0f);
+      !WebTestSupport::IsRunningWebTest() &&
+      (sk_hint_style != SkFontHinting::kFull || device_scale_factor > 1.0f);
 
-  font.SetSubpixelText(force_subpixel_positioning || use_subpixel_positioning);
+  font->setSubpixel(force_subpixel_positioning || use_subpixel_positioning);
+
+  font->setLinearMetrics(use_subpixel_positioning == 1);
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc b/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc
index 1cefc86a44ed..bb6ef79ff02a 100644
--- a/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc
+++ b/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc
@@ -4,17 +4,26 @@
 
 #include "third_party/blink/renderer/platform/fonts/web_font_typeface_factory.h"
 
+#include "base/logging.h"
+#include "base/metrics/histogram_macros.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #include "third_party/blink/renderer/platform/fonts/opentype/font_format_check.h"
-#include "third_party/blink/renderer/platform/histogram.h"
+#include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/blink/renderer/platform/wtf/assertions.h"
 #include "third_party/skia/include/core/SkStream.h"
 #include "third_party/skia/include/core/SkTypeface.h"
-#if defined(OS_WIN) || defined(OS_MACOSX)
+
+#if defined(OS_WIN)
+#include "third_party/blink/public/common/dwrite_rasterizer_support/dwrite_rasterizer_support.h"
+#include "third_party/blink/renderer/platform/fonts/win/dwrite_font_format_support.h"
+#endif
+
+#if defined(OS_WIN) || defined(OS_MAC)
 #include "third_party/skia/include/ports/SkFontMgr_empty.h"
 #endif
-#if defined(OS_MACOSX)
-#include "third_party/blink/renderer/platform/fonts/mac/core_text_variations_support.h"
+
+#if defined(OS_MAC)
+#include "third_party/blink/renderer/platform/fonts/mac/core_text_font_format_support.h"
 #endif
 
 namespace blink {
@@ -27,11 +36,11 @@ bool WebFontTypefaceFactory::CreateTypeface(sk_sp<SkData> sk_data,
 
   std::unique_ptr<SkStreamAsset> stream(new SkMemoryStream(sk_data));
 
-  if (!format_check.IsVariableFont() && !format_check.IsCbdtCblcColorFont() &&
-      !format_check.IsCff2OutlineFont() && !format_check.IsSbixColorFont()) {
+  if (!format_check.IsVariableFont() && !format_check.IsColorFont()) {
     typeface = DefaultFontManager()->makeFromStream(std::move(stream));
     if (typeface) {
-      ReportWebFontInstantiationResult(kSuccessConventionalWebFont);
+      ReportInstantiationResult(
+          InstantiationResult::kSuccessConventionalWebFont);
       return true;
     }
     // Not UMA reporting general decoding errors as these are already recorded
@@ -39,42 +48,76 @@ bool WebFontTypefaceFactory::CreateTypeface(sk_sp<SkData> sk_data,
     return false;
   }
 
+  // We don't expect variable CBDT/CBLC or Sbix variable fonts for now.
   if (format_check.IsCbdtCblcColorFont()) {
     typeface = FreeTypeFontManager()->makeFromStream(std::move(stream));
-    if (typeface)
-      ReportWebFontInstantiationResult(kSuccessCbdtCblcColorFont);
+    if (typeface) {
+      ReportInstantiationResult(InstantiationResult::kSuccessCbdtCblcColorFont);
+    }
+    return typeface.get();
+  }
+
+  if (format_check.IsColrCpalColorFontV1()) {
+    if (RuntimeEnabledFeatures::COLRV1FontsEnabled()) {
+      typeface = FreeTypeFontManager()->makeFromStream(std::move(stream));
+      if (typeface) {
+        ReportInstantiationResult(InstantiationResult::kSuccessColrV1Font);
+      }
+      return typeface.get();
+    } else {
+      // Always reject COLRv1 fonts when the feature is off.
+      return false;
+    }
   }
 
   if (format_check.IsSbixColorFont()) {
     typeface = FontManagerForSbix()->makeFromStream(std::move(stream));
     if (typeface) {
-      ReportWebFontInstantiationResult(kSuccessSbixFont);
+      ReportInstantiationResult(InstantiationResult::kSuccessSbixFont);
     }
+    return typeface.get();
   }
 
+  // CFF2 must always go through the FreeTypeFontManager, even on Mac OS, as it
+  // is not natively supported.
   if (format_check.IsCff2OutlineFont()) {
     typeface = FreeTypeFontManager()->makeFromStream(std::move(stream));
     if (typeface)
-      ReportWebFontInstantiationResult(kSuccessCff2Font);
+      ReportInstantiationResult(InstantiationResult::kSuccessCff2Font);
+    return typeface.get();
   }
 
-  // Variable CFF2 fonts must go through FreeType.
-  if (format_check.IsVariableFont() && !format_check.IsCff2OutlineFont()) {
+  // Variable COLR/CPAL fonts must go through the Variations
+  // FontManager, which is FreeType on Windows.
+  if (format_check.IsVariableFont()) {
     typeface = FontManagerForVariations()->makeFromStream(std::move(stream));
-    if (typeface)
-      ReportWebFontInstantiationResult(kSuccessVariableWebFont);
-    else
-      ReportWebFontInstantiationResult(kErrorInstantiatingVariableFont);
+    if (typeface) {
+      ReportInstantiationResult(InstantiationResult::kSuccessVariableWebFont);
+    } else {
+      ReportInstantiationResult(
+          InstantiationResult::kErrorInstantiatingVariableFont);
+    }
+    return typeface.get();
   }
 
-  return true;
+  if (format_check.IsColrCpalColorFontV0()) {
+    typeface = FontManagerForColrCpal()->makeFromStream(std::move(stream));
+    if (typeface) {
+      ReportInstantiationResult(InstantiationResult::kSuccessColrCpalFont);
+    }
+    return typeface.get();
+  }
+
+  return false;
 }
 
 sk_sp<SkFontMgr> WebFontTypefaceFactory::FontManagerForVariations() {
 #if defined(OS_WIN)
+  if (DWriteVersionSupportsVariations())
+    return DefaultFontManager();
   return FreeTypeFontManager();
 #else
-#if defined(OS_MACOSX)
+#if defined(OS_MAC)
   if (!CoreTextVersionSupportsVariations())
     return FreeTypeFontManager();
 #endif
@@ -83,7 +126,7 @@ sk_sp<SkFontMgr> WebFontTypefaceFactory::FontManagerForVariations() {
 }
 
 sk_sp<SkFontMgr> WebFontTypefaceFactory::FontManagerForSbix() {
-#if defined(OS_MACOSX)
+#if defined(OS_MAC)
   return DefaultFontManager();
 #endif
   return FreeTypeFontManager();
@@ -98,19 +141,28 @@ sk_sp<SkFontMgr> WebFontTypefaceFactory::DefaultFontManager() {
 }
 
 sk_sp<SkFontMgr> WebFontTypefaceFactory::FreeTypeFontManager() {
-#if defined(OS_WIN) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_MAC)
   return sk_sp<SkFontMgr>(SkFontMgr_New_Custom_Empty());
 #else
   return DefaultFontManager();
 #endif
 }
 
-void WebFontTypefaceFactory::ReportWebFontInstantiationResult(
-    WebFontInstantiationResult result) {
-  DEFINE_THREAD_SAFE_STATIC_LOCAL(
-      EnumerationHistogram, web_font_variable_fonts_ratio,
-      ("Blink.Fonts.VariableFontsRatio", kMaxWebFontInstantiationResult));
-  web_font_variable_fonts_ratio.Count(result);
+sk_sp<SkFontMgr> WebFontTypefaceFactory::FontManagerForColrCpal() {
+#if defined(OS_WIN)
+  if (!blink::DWriteRasterizerSupport::IsDWriteFactory2Available())
+    return FreeTypeFontManager();
+#endif
+#if defined(OS_MAC)
+  if (!CoreTextVersionSupportsColrCpal())
+    return FreeTypeFontManager();
+#endif
+  return DefaultFontManager();
+}
+
+void WebFontTypefaceFactory::ReportInstantiationResult(
+    InstantiationResult result) {
+  UMA_HISTOGRAM_ENUMERATION("Blink.Fonts.VariableFontsRatio", result);
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.h b/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.h
index 89aac4d88ed2..ee3ea75e48cb 100644
--- a/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.h
+++ b/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.h
@@ -8,7 +8,8 @@
 #include "third_party/skia/include/core/SkFontMgr.h"
 
 #include "build/build_config.h"
-#if defined(OS_WIN) || defined(OS_MACOSX)
+#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
+#if defined(OS_WIN) || defined(OS_MAC)
 #include "third_party/skia/include/ports/SkFontMgr_empty.h"
 #endif
 
@@ -19,6 +20,8 @@ namespace blink {
 // However, for variable fonts, color bitmap font formats and CFF2 fonts we want
 // to use FreeType on Windows and Mac.
 class WebFontTypefaceFactory {
+  STACK_ALLOCATED();
+
  public:
   static bool CreateTypeface(const sk_sp<SkData>, sk_sp<SkTypeface>&);
 
@@ -27,23 +30,26 @@ class WebFontTypefaceFactory {
   static sk_sp<SkFontMgr> FontManagerForVariations();
   static sk_sp<SkFontMgr> FontManagerForSbix();
   static sk_sp<SkFontMgr> FreeTypeFontManager();
+  static sk_sp<SkFontMgr> FontManagerForColrCpal();
 
  private:
   // These values are written to logs.  New enum values can be added, but
   // existing enums must never be renumbered or deleted and reused.
-  enum WebFontInstantiationResult {
+  enum class InstantiationResult {
     kErrorInstantiatingVariableFont = 0,
     kSuccessConventionalWebFont = 1,
     kSuccessVariableWebFont = 2,
     kSuccessCbdtCblcColorFont = 3,
     kSuccessCff2Font = 4,
     kSuccessSbixFont = 5,
-    kMaxWebFontInstantiationResult = 6
+    kSuccessColrCpalFont = 6,
+    kSuccessColrV1Font = 7,
+    kMaxValue = kSuccessColrV1Font
   };
 
   static sk_sp<SkFontMgr> DefaultFontManager();
 
-  static void ReportWebFontInstantiationResult(WebFontInstantiationResult);
+  static void ReportInstantiationResult(InstantiationResult);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/dwrite_font_format_support.cc b/third_party/blink/renderer/platform/fonts/win/dwrite_font_format_support.cc
new file mode 100644
index 000000000000..e3db68d0e0ed
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/dwrite_font_format_support.cc
@@ -0,0 +1,38 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/win/dwrite_font_format_support.h"
+
+#include "third_party/skia/include/core/SkFontMgr.h"
+#include "third_party/skia/include/core/SkFontStyle.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace blink {
+
+bool DWriteVersionSupportsVariations() {
+  // We're instantiating a default typeface. The usage of legacyMakeTypeface()
+  // is intentional here to access a basic default font. Its implementation will
+  // ultimately use the first font face from the first family in the system font
+  // collection. Use this probe type face to ask Skia for the variation design
+  // position. Internally, Skia then tests whether the DWrite interfaces for
+  // accessing variable font information are available, in other words, if
+  // QueryInterface for IDWriteFontFace5 succeeds. If it doesn't it returns -1
+  // and we know DWrite on this system does not support OpenType variations. If
+  // the response is 0 or larger, it means, DWrite was able to determine if this
+  // is a variable font or not and Variations are supported.
+  static bool variations_supported = []() {
+    auto fm(SkFontMgr::RefDefault());
+    sk_sp<SkTypeface> probe_typeface =
+        fm->legacyMakeTypeface(nullptr, SkFontStyle());
+    if (!probe_typeface)
+      return false;
+    int variation_design_position_result =
+        probe_typeface->getVariationDesignPosition(nullptr, 0);
+
+    return variation_design_position_result > -1;
+  }();
+  return variations_supported;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/dwrite_font_format_support.h b/third_party/blink/renderer/platform/fonts/win/dwrite_font_format_support.h
new file mode 100644
index 000000000000..2eeddc88ac87
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/dwrite_font_format_support.h
@@ -0,0 +1,15 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_DWRITE_FONT_FORMAT_SUPPORT_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_DWRITE_FONT_FORMAT_SUPPORT_H_
+
+namespace blink {
+
+// Return whether DirectWrite on this system supports variable fonts for
+// retrieving metrics and performing rasterization.
+bool DWriteVersionSupportsVariations();
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_DWRITE_FONT_FORMAT_SUPPORT_H_
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc
new file mode 100644
index 000000000000..9544a0ed0abb
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc
@@ -0,0 +1,90 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+
+#include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
+
+namespace blink {
+
+namespace {
+
+const wtf_size_t kMaxCacheSlots = 16;
+
+String makeCacheKey(FontDescription::GenericFamilyType generic_family,
+                    String bcp47_language_tag,
+                    FontFallbackPriority fallback_priority) {
+  StringBuilder cache_key;
+  cache_key.Append(bcp47_language_tag);
+  cache_key.AppendNumber(
+      static_cast<
+          std::underlying_type<FontDescription::GenericFamilyType>::type>(
+          generic_family));
+  cache_key.AppendNumber(
+      static_cast<std::underlying_type<FontFallbackPriority>::type>(
+          fallback_priority));
+  return cache_key.ToString();
+}
+
+void getFallbackFamilyAndStyle(SkTypeface* typeface,
+                               String* fallback_family,
+                               SkFontStyle* fallback_style) {
+  SkString family;
+  typeface->getFamilyName(&family);
+  *fallback_family = family.c_str();
+
+  *fallback_style = typeface->fontStyle();
+}
+}  // namespace
+
+FallbackFamilyStyleCache::FallbackFamilyStyleCache()
+    : recent_fallback_fonts_(kMaxCacheSlots) {}
+
+void FallbackFamilyStyleCache::Put(
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority fallback_priority,
+    SkTypeface* typeface) {
+  String cache_key =
+      makeCacheKey(generic_family, bcp47_language_tag, fallback_priority);
+
+  TypefaceVector* existing_typefaces = recent_fallback_fonts_.Get(cache_key);
+  if (existing_typefaces) {
+    existing_typefaces->insert(0, sk_ref_sp(typeface));
+  } else {
+    TypefaceVector typefaces;
+    typefaces.push_back(sk_ref_sp(typeface));
+    recent_fallback_fonts_.Put(std::move(cache_key), std::move(typefaces));
+  }
+}
+
+void FallbackFamilyStyleCache::Get(
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority fallback_priority,
+    UChar32 character,
+    String* fallback_family,
+    SkFontStyle* fallback_style) {
+  TypefaceVector* typefaces = recent_fallback_fonts_.Get(
+      makeCacheKey(generic_family, bcp47_language_tag, fallback_priority));
+  if (!typefaces)
+    return;
+
+  for (wtf_size_t i = 0; i < typefaces->size(); ++i) {
+    sk_sp<SkTypeface>& typeface = typefaces->at(i);
+    if (typeface->unicharToGlyph(character)) {
+      getFallbackFamilyAndStyle(typeface.get(), fallback_family,
+                                fallback_style);
+      sk_sp<SkTypeface> tmp_typeface(typeface);
+      // For the vector of typefaces for this specific language tag, since this
+      // SkTypeface had a glyph, move it to the beginning to accelerate
+      // subsequent lookups.
+      typefaces->EraseAt(i);
+      typefaces->insert(0, std::move(tmp_typeface));
+      return;
+    }
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h
new file mode 100644
index 000000000000..770702feb39b
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h
@@ -0,0 +1,59 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
+
+#include "third_party/blink/renderer/platform/fonts/font_description.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
+#include "third_party/blink/renderer/platform/wtf/lru_cache.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace blink {
+
+using TypefaceVector = Vector<sk_sp<SkTypeface>>;
+using FallbackLruCache = WTF::LruCache<String, TypefaceVector>;
+
+class FallbackFamilyStyleCache {
+  USING_FAST_MALLOC(FallbackFamilyStyleCache);
+
+ public:
+  FallbackFamilyStyleCache();
+
+  // Places a SkTypeface object in the cache for specified language tag and
+  // fallback priority, taking a reference on SkTypeface. Adds the |SkTypeface|
+  // to the beginning of a list of typefaces if previous |SkTypefaces| objects
+  // where added for this set of parameters. Note, the internal list of
+  // typefaces for a language tag and fallback priority is not checked for
+  // duplicates when adding a |typeface| object.
+  void Put(FontDescription::GenericFamilyType generic_family,
+           String bcp47_language_tag,
+           FontFallbackPriority fallback_priority,
+           SkTypeface* typeface);
+
+  // Fetches a |fallback_family| and |fallback_style| for a given language tag,
+  // fallback priority and codepoint. Checks the internal cache for whether a
+  // fallback font with glyph coverage for |character| is available for the
+  // given parameters, then returns its family name and style.
+  void Get(FontDescription::GenericFamilyType generic_family,
+           String bcp47_language_tag,
+           FontFallbackPriority fallback_priority,
+           UChar32 character,
+           String* fallback_family,
+           SkFontStyle* fallback_style);
+
+  // Empties the internal cache, deleting keys and unrefing the typefaces that
+  // were placed in the cache.
+  void Clear();
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(FallbackFamilyStyleCache);
+
+  FallbackLruCache recent_fallback_fonts_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc b/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc
new file mode 100644
index 000000000000..917f0111235e
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc
@@ -0,0 +1,99 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/wtf/text/character_names.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkFontMgr.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace {
+
+const char kHanSimplifiedLocale[] = "zh-Hans";
+const size_t kLruCacheTestSize = 5;
+const char kFontFamilyNameArial[] = "Arial";
+const UChar32 kFirstCJKIdeograph = 0x4E00;
+const UChar32 kSecondCJKIdeograph = kFirstCJKIdeograph + 1;
+
+sk_sp<SkTypeface> fallbackForLocale(String locale, UChar32 codepoint) {
+  sk_sp<SkFontMgr> font_mgr = SkFontMgr::RefDefault();
+  std::string locale_string(locale.Ascii());
+  const char* locale_char = locale_string.c_str();
+  return sk_sp<SkTypeface>(font_mgr->matchFamilyStyleCharacter(
+      kFontFamilyNameArial, SkFontStyle(), &locale_char, 1, codepoint));
+}
+
+void fillCacheWithDummies(blink::FallbackLruCache& lru_cache,
+                          const char* format_string,
+                          size_t count) {
+  for (size_t i = 0; i < count; ++i) {
+    blink::TypefaceVector dummy_typefaces;
+    dummy_typefaces.push_back(
+        SkTypeface::MakeFromName(kFontFamilyNameArial, SkFontStyle()));
+    lru_cache.Put(String::Format(format_string, i), std::move(dummy_typefaces));
+  }
+}
+
+}  // namespace
+
+namespace blink {
+
+TEST(FallbackLruCacheTest, KeepChineseWhenFetched) {
+  // Put a Chinese font in the cache, add size - 1 more dummy fallback fonts so
+  // that the cache is full. Get() and verify typeface for Chinese to move them
+  // up to the top of the cache. Then fill again with size - 1 items and verify
+  // that Chinese is still in the cache. Then fill with # size items to evict
+  // the Chinese font and ensure it's gone.
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  TypefaceVector fallback_typefaces_zh;
+  fallback_typefaces_zh.push_back(
+      fallbackForLocale(kHanSimplifiedLocale, kFirstCJKIdeograph));
+  lru_cache.Put(kHanSimplifiedLocale, std::move(fallback_typefaces_zh));
+
+  EXPECT_EQ(lru_cache.size(), 1u);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_%zu", kLruCacheTestSize - 1);
+  TypefaceVector* chinese_typefaces = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(chinese_typefaces);
+  EXPECT_TRUE(chinese_typefaces->at(0)->unicharToGlyph(0x4E01));
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_2nd_%zu",
+                       kLruCacheTestSize - 1);
+  chinese_typefaces = nullptr;
+  chinese_typefaces = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(chinese_typefaces);
+  EXPECT_EQ(chinese_typefaces->size(), 1u);
+  EXPECT_TRUE(chinese_typefaces->at(0)->unicharToGlyph(kSecondCJKIdeograph));
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_3rd_%zu", kLruCacheTestSize);
+  chinese_typefaces = nullptr;
+  chinese_typefaces = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_FALSE(chinese_typefaces);
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+}
+
+TEST(FallbackLruCacheTest, LargeFillAndClear) {
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  fillCacheWithDummies(lru_cache, "dummy_locale_%zu", 1000);
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+  lru_cache.Clear();
+  EXPECT_EQ(lru_cache.size(), 0u);
+}
+
+TEST(FallbackLruCacheTest, KeyOverride) {
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  fillCacheWithDummies(lru_cache, "same_locale", 10);
+  EXPECT_EQ(lru_cache.size(), 1u);
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc b/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
index 539575b81ba9..316f90f11ef5 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
@@ -31,23 +31,37 @@
 
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 
+#include <ft2build.h>
+#include <freetype/freetype.h>
+#include <unicode/uscript.h>
+
 #include <memory>
+#include <string>
 #include <utility>
 
 #include "base/debug/alias.h"
-#include "third_party/blink/renderer/platform/fonts/bitmap_glyphs_blacklist.h"
+#include "base/metrics/histogram_functions.h"
+#include "base/stl_util.h"
+#include "base/trace_event/trace_event.h"
+#include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
+#include "third_party/blink/public/platform/platform.h"
+#include "third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
 #include "third_party/blink/renderer/platform/fonts/font_face_creation_params.h"
 #include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
 #include "third_party/blink/renderer/platform/fonts/win/font_fallback_win.h"
 #include "third_party/blink/renderer/platform/language.h"
+#include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/skia/include/core/SkFontMgr.h"
+#include "third_party/skia/include/core/SkStream.h"
 #include "third_party/skia/include/ports/SkTypeface_win.h"
 
+
 namespace blink {
 
-HashMap<String, sk_sp<SkTypeface>>* FontCache::sideloaded_fonts_ = nullptr;
+HashMap<String, sk_sp<SkTypeface>, CaseFoldingHash>*
+    FontCache::sideloaded_fonts_ = nullptr;
 
 // Cached system font metrics.
 AtomicString* FontCache::menu_font_family_name_ = nullptr;
@@ -59,6 +73,36 @@ int32_t FontCache::status_font_height_ = 0;
 
 namespace {
 
+enum FallbackAgreementError {
+  kNoneFound,
+  kLegacyNoneFound,
+  kWinAPINoneFound,
+  kLegacyWinAPIDisagree
+};
+
+void LogUmaHistogramFallbackAgreemenError(
+    FallbackAgreementError agreement_error,
+    UBlockCode block_code) {
+  switch (agreement_error) {
+    case kLegacyNoneFound:
+      base::UmaHistogramSparse("Blink.Fonts.WinFallback.LegacyNoneFound",
+                               block_code);
+      break;
+    case kWinAPINoneFound:
+      base::UmaHistogramSparse("Blink.Fonts.WinFallback.WinAPINoneFound",
+                               block_code);
+      break;
+    case kLegacyWinAPIDisagree:
+      base::UmaHistogramSparse("Blink.Fonts.WinFallback.LegacyWinAPIDisagree",
+                               block_code);
+      break;
+    case kNoneFound:
+      base::UmaHistogramSparse("Blink.Fonts.WinFallback.NoFallbackFound",
+                               block_code);
+      break;
+  }
+}
+
 int32_t EnsureMinimumFontHeightIfNeeded(int32_t font_height) {
   // Adjustment for codepage 936 to make the fonts more legible in Simplified
   // Chinese.  Please refer to LayoutThemeFontProviderWin.cpp for more
@@ -66,15 +110,95 @@ int32_t EnsureMinimumFontHeightIfNeeded(int32_t font_height) {
   return (font_height < 12.0f) && (GetACP() == 936) ? 12.0f : font_height;
 }
 
+// Test-only code for matching sideloaded fonts by postscript name. This
+// implementation is incomplete, as it does not match the full font name and
+// only uses FT_Get_Postscript_Name, which returns an ASCII font name. This is
+// intended to pass tests on Windows, where for example src: local(Ahem) is used
+// in @font-face CSS declarations.  Skia does not expose getAdvancedMetrics, so
+// we use FreeType here to parse the font's postscript name.
+sk_sp<SkTypeface> FindUniqueFontNameFromSideloadedFonts(
+    const String& font_name,
+    HashMap<String, sk_sp<SkTypeface>, CaseFoldingHash>* sideloaded_fonts) {
+  CHECK(sideloaded_fonts);
+  FT_Library library;
+  FT_Init_FreeType(&library);
+
+  sk_sp<SkTypeface> return_typeface(nullptr);
+  for (auto& sideloaded_font : sideloaded_fonts->Values()) {
+    // Open ttc index zero as we can assume that we do not sideload TrueType
+    // collections.
+    std::unique_ptr<SkStreamAsset> typeface_stream(
+        sideloaded_font->openStream(nullptr));
+    CHECK(typeface_stream->getMemoryBase());
+    std::string font_family_name;
+    FT_Face font_face;
+    FT_Open_Args open_args = {
+        FT_OPEN_MEMORY,
+        reinterpret_cast<const FT_Byte*>(typeface_stream->getMemoryBase()),
+        typeface_stream->getLength()};
+    CHECK_EQ(FT_Err_Ok, FT_Open_Face(library, &open_args, 0, &font_face));
+    font_family_name = FT_Get_Postscript_Name(font_face);
+    FT_Done_Face(font_face);
+
+    if (font_name.FoldCase() == String(font_family_name.c_str()).FoldCase()) {
+      return_typeface = sideloaded_font;
+      break;
+    }
+  }
+  FT_Done_FreeType(library);
+  return return_typeface;
+}
+
+static const char kChineseSimplified[] = "zh-Hant";
+
+// For Windows out-of-process fallback calls, there is a limiation: only one
+// passed locale is taken into account when requesting a fallback font from the
+// DWrite API via Skia API. If we request fallback for a Han ideograph without a
+// disambiguating locale, results from DWrite are unpredictable and caching such
+// a font under the ambiguous locale leads to returning wrong fonts for
+// subsequent requests in font_fallback_win, hence prioritize a
+// Han-disambiguating locale for CJK characters.
+const LayoutLocale* FallbackLocaleForCharacter(
+    const FontDescription& font_description,
+    const FontFallbackPriority& fallback_priority,
+    const UChar32 codepoint) {
+  if (fallback_priority == FontFallbackPriority::kEmojiEmoji)
+    return LayoutLocale::Get(kColorEmojiLocale);
+
+  UErrorCode error_code = U_ZERO_ERROR;
+  const UScriptCode char_script = uscript_getScript(codepoint, &error_code);
+  if (U_SUCCESS(error_code) && char_script == USCRIPT_HAN) {
+    // If we were unable to disambiguate the requested Han ideograph from the
+    // content locale, the Accept-Language headers or system locale, assume it's
+    // simplified Chinese. It's important to pass a CJK locale to the fallback
+    // call in order to avoid priming the browser side cache incorrectly with an
+    // ambiguous locale for Han fallback requests.
+    const LayoutLocale* han_locale =
+        LayoutLocale::LocaleForHan(font_description.Locale());
+    return han_locale ? han_locale : LayoutLocale::Get(kChineseSimplified);
+  }
+
+  return font_description.Locale() ? font_description.Locale()
+                                   : &LayoutLocale::GetDefault();
+}
+
 }  // namespace
 
 // static
 void FontCache::AddSideloadedFontForTesting(sk_sp<SkTypeface> typeface) {
   if (!sideloaded_fonts_)
-    sideloaded_fonts_ = new HashMap<String, sk_sp<SkTypeface>>;
+    sideloaded_fonts_ = new HashMap<String, sk_sp<SkTypeface>, CaseFoldingHash>;
   SkString name;
   typeface->getFamilyName(&name);
-  sideloaded_fonts_->Set(name.c_str(), std::move(typeface));
+  String name_wtf(name.c_str());
+  sideloaded_fonts_->Set(name_wtf, std::move(typeface));
+}
+
+//static
+void FontCache::SetSystemFontFamily(const AtomicString&) {
+  // TODO(https://crbug.com/808221) Use this instead of
+  // SetMenuFontMetrics for the system font family.
+  NOTREACHED();
 }
 
 // static
@@ -83,38 +207,200 @@ const AtomicString& FontCache::SystemFontFamily() {
 }
 
 // static
-void FontCache::SetMenuFontMetrics(const wchar_t* family_name,
+void FontCache::SetMenuFontMetrics(const AtomicString& family_name,
                                    int32_t font_height) {
   menu_font_family_name_ = new AtomicString(family_name);
   menu_font_height_ = EnsureMinimumFontHeightIfNeeded(font_height);
 }
 
 // static
-void FontCache::SetSmallCaptionFontMetrics(const wchar_t* family_name,
+void FontCache::SetSmallCaptionFontMetrics(const AtomicString& family_name,
                                            int32_t font_height) {
   small_caption_font_family_name_ = new AtomicString(family_name);
   small_caption_font_height_ = EnsureMinimumFontHeightIfNeeded(font_height);
 }
 
 // static
-void FontCache::SetStatusFontMetrics(const wchar_t* family_name,
+void FontCache::SetStatusFontMetrics(const AtomicString& family_name,
                                      int32_t font_height) {
   status_font_family_name_ = new AtomicString(family_name);
   status_font_height_ = EnsureMinimumFontHeightIfNeeded(font_height);
 }
 
-FontCache::FontCache() : purge_prevent_count_(0) {
-  font_manager_ = sk_ref_sp(static_font_manager_);
-  if (!font_manager_) {
-    // This code path is only for unit tests. This SkFontMgr does not work in
-    // sandboxed environments, but injecting this initialization code to all
-    // unit tests isn't easy.
-    font_manager_ = SkFontMgr_New_DirectWrite();
-    // Set |is_test_font_mgr_| to capture if this is not happening in the
-    // production code. crbug.com/561873
-    is_test_font_mgr_ = true;
+void FontCache::EnsureServiceConnected() {
+  if (service_)
+    return;
+  Platform::Current()->GetBrowserInterfaceBroker()->GetInterface(
+      service_.BindNewPipeAndPassReceiver());
+}
+
+// TODO(https://crbug.com/976737): This function is deprecated and only intended
+// to run in parallel with the API based OOP font fallback calls to compare the
+// results and track them in UMA for a while until we decide to remove this
+// completely.
+scoped_refptr<SimpleFontData>
+FontCache::GetFallbackFamilyNameFromHardcodedChoices(
+    const FontDescription& font_description,
+    UChar32 codepoint,
+    FontFallbackPriority fallback_priority) {
+  UScriptCode script;
+  const UChar* legacy_fallback_family = GetFallbackFamily(
+      codepoint, font_description.GenericFamily(), font_description.Locale(),
+      &script, fallback_priority, font_manager_.get());
+
+  if (legacy_fallback_family) {
+    FontFaceCreationParams create_by_family(legacy_fallback_family);
+    FontPlatformData* data =
+        GetFontPlatformData(font_description, create_by_family);
+    if (data && data->FontContainsCharacter(codepoint)) {
+      return FontDataFromFontPlatformData(data, kDoNotRetain);
+    }
   }
-  DCHECK(font_manager_.get());
+
+  // If instantiating the returned fallback family was not successful, probe for
+  // a set of potential fonts with wide coverage.
+
+  // Last resort font list : PanUnicode. CJK fonts have a pretty
+  // large repertoire. Eventually, we need to scan all the fonts
+  // on the system to have a Firefox-like coverage.
+  // Make sure that all of them are lowercased.
+  const static UChar* const kCjkFonts[] = {
+      u"arial unicode ms", u"ms pgothic", u"simsun", u"gulim", u"pmingliu",
+      u"wenquanyi zen hei",  // Partial CJK Ext. A coverage but more widely
+                             // known to Chinese users.
+      u"ar pl shanheisun uni", u"ar pl zenkai uni",
+      u"han nom a",  // Complete CJK Ext. A coverage.
+      u"code2000"    // Complete CJK Ext. A coverage.
+      // CJK Ext. B fonts are not listed here because it's of no use
+      // with our current non-BMP character handling because we use
+      // Uniscribe for it and that code path does not go through here.
+  };
+
+  const static UChar* const kCommonFonts[] = {
+      u"tahoma", u"arial unicode ms", u"lucida sans unicode",
+      u"microsoft sans serif", u"palatino linotype",
+      // Six fonts below (and code2000 at the end) are not from MS, but
+      // once installed, cover a very wide range of characters.
+      u"dejavu serif", u"dejavu sasns", u"freeserif", u"freesans", u"gentium",
+      u"gentiumalt", u"ms pgothic", u"simsun", u"gulim", u"pmingliu",
+      u"code2000"};
+
+  const UChar* const* pan_uni_fonts = nullptr;
+  int num_fonts = 0;
+  if (script == USCRIPT_HAN) {
+    pan_uni_fonts = kCjkFonts;
+    num_fonts = base::size(kCjkFonts);
+  } else {
+    pan_uni_fonts = kCommonFonts;
+    num_fonts = base::size(kCommonFonts);
+  }
+  // Font returned from getFallbackFamily may not cover |character|
+  // because it's based on script to font mapping. This problem is
+  // critical enough for non-Latin scripts (especially Han) to
+  // warrant an additional (real coverage) check with fontCotainsCharacter.
+  for (int i = 0; i < num_fonts; ++i) {
+    legacy_fallback_family = pan_uni_fonts[i];
+    FontFaceCreationParams create_by_family(legacy_fallback_family);
+    FontPlatformData* data =
+        GetFontPlatformData(font_description, create_by_family);
+    if (data && data->FontContainsCharacter(codepoint))
+      return FontDataFromFontPlatformData(data, kDoNotRetain);
+  }
+  return nullptr;
+}
+
+scoped_refptr<SimpleFontData> FontCache::GetDWriteFallbackFamily(
+    const FontDescription& font_description,
+    UChar32 codepoint,
+    FontFallbackPriority fallback_priority) {
+  const LayoutLocale* fallback_locale = FallbackLocaleForCharacter(
+      font_description, fallback_priority, codepoint);
+  DCHECK(fallback_locale);
+
+  // On Pre Windows 8.1 (where use_skia_font_fallback_ is false) we cannot call
+  // the Skia version, as there is no IDWriteFontFallback (which is
+  // proxyable). If no IDWriteFontFallback API exists in the DWrite Skia
+  // SkTypeface implemnetation it will proceed to call the layoutFallback method
+  // of SkTypeface DWrite implementation. This method we must not call in the
+  // renderer as it causes stability issues due to reaching a path that will try
+  // to load the system font collection in-process and thus load DLLs that are
+  // blocked in the renderer, see comment in dwrite_font_proxy_init_impl_win.cc
+  // InitializeDWriteFontProxy(). Hence, for Windows pre 8.1 we add a
+  // DWriteFontProxy code path to retrieve a family name as string for a
+  // character + language tag and call matchFamilyStyleCharacter on the browser
+  // side, where we can do that.
+  if (!use_skia_font_fallback_) {
+    String fallback_family;
+    SkFontStyle fallback_style;
+
+    if (UNLIKELY(!fallback_params_cache_)) {
+      fallback_params_cache_ = std::make_unique<FallbackFamilyStyleCache>();
+    }
+
+    fallback_params_cache_->Get(
+        font_description.GenericFamily(), fallback_locale->LocaleForSkFontMgr(),
+        fallback_priority, codepoint, &fallback_family, &fallback_style);
+    bool result_from_cache = !fallback_family.IsNull();
+
+    if (!result_from_cache) {
+      EnsureServiceConnected();
+
+      // After Mojo IPC, on the browser side, this ultimately reaches
+      // Skia's matchFamilyStyleCharacter for Windows, which does not implement
+      // traversing the language tag stack but only processes the most important
+      // one, so we use FallbackLocaleForCharacter() to determine what locale to
+      // choose to achieve the best possible result.
+
+      if (!GetOutOfProcessFallbackFamily(
+              codepoint, font_description.GenericFamily(),
+              fallback_locale->LocaleForSkFontMgr(), fallback_priority,
+              service_, &fallback_family, &fallback_style))
+        return nullptr;
+
+      if (fallback_family.IsEmpty())
+        return nullptr;
+    }
+
+    FontFaceCreationParams create_by_family((AtomicString(fallback_family)));
+    FontDescription fallback_updated_font_description(font_description);
+    fallback_updated_font_description.UpdateFromSkiaFontStyle(fallback_style);
+    FontPlatformData* data = GetFontPlatformData(
+        fallback_updated_font_description, create_by_family);
+    if (!data || !data->FontContainsCharacter(codepoint))
+      return nullptr;
+
+    if (!result_from_cache) {
+      fallback_params_cache_->Put(font_description.GenericFamily(),
+                                  fallback_locale->LocaleForSkFontMgr(),
+                                  fallback_priority, data->Typeface());
+    }
+    return FontDataFromFontPlatformData(data, kDoNotRetain);
+  } else {
+    std::string family_name = font_description.Family().Family().Utf8();
+
+    Bcp47Vector locales;
+    locales.push_back(fallback_locale->LocaleForSkFontMgr());
+    SkTypeface* typeface = font_manager_->matchFamilyStyleCharacter(
+        family_name.c_str(), font_description.SkiaFontStyle(), locales.data(),
+        locales.size(), codepoint);
+
+    if (!typeface)
+      return nullptr;
+
+    SkString skia_family;
+    typeface->getFamilyName(&skia_family);
+    FontDescription fallback_updated_font_description(font_description);
+    fallback_updated_font_description.UpdateFromSkiaFontStyle(
+        typeface->fontStyle());
+    FontFaceCreationParams create_by_family(ToAtomicString(skia_family));
+    FontPlatformData* data = GetFontPlatformData(
+        fallback_updated_font_description, create_by_family);
+    if (!data || !data->FontContainsCharacter(codepoint))
+      return nullptr;
+    return FontDataFromFontPlatformData(data, kDoNotRetain);
+  }
+  NOTREACHED();
+  return nullptr;
 }
 
 // Given the desired base font, this will create a SimpleFontData for a specific
@@ -124,6 +410,8 @@ scoped_refptr<SimpleFontData> FontCache::PlatformFallbackFontForCharacter(
     UChar32 character,
     const SimpleFontData* original_font_data,
     FontFallbackPriority fallback_priority) {
+  TRACE_EVENT0("ui", "FontCache::PlatformFallbackFontForCharacter");
+
   // First try the specified font with standard style & weight.
   if (fallback_priority != FontFallbackPriority::kEmojiEmoji &&
       (font_description.Style() == ItalicSlopeValue() ||
@@ -134,104 +422,44 @@ scoped_refptr<SimpleFontData> FontCache::PlatformFallbackFontForCharacter(
       return font_data;
   }
 
-  UScriptCode script;
-  const UChar* family = GetFallbackFamily(
-      character, font_description.GenericFamily(), font_description.Locale(),
-      &script, fallback_priority, font_manager_.get());
-  if (family) {
-    FontFaceCreationParams create_by_family(family);
-    FontPlatformData* data =
-        GetFontPlatformData(font_description, create_by_family);
-    if (data && data->FontContainsCharacter(character))
-      return FontDataFromFontPlatformData(data, kDoNotRetain);
-  }
+  scoped_refptr<SimpleFontData> hardcoded_list_fallback_font =
+      GetFallbackFamilyNameFromHardcodedChoices(font_description, character,
+                                                fallback_priority);
 
-  if (use_skia_font_fallback_) {
-    const char* bcp47_locale = nullptr;
-    int locale_count = 0;
-    // If the font description has a locale, use that. Otherwise, Skia will
-    // fall back on the user's default locale.
-    // TODO(kulshin): extract locale fallback logic from
-    //   FontCacheAndroid.cpp and share that code
-    if (font_description.Locale()) {
-      bcp47_locale = font_description.Locale()->LocaleForSkFontMgr();
-      locale_count = 1;
+  // Fall through to running the API based fallback on Windows 8.1 and above
+  // where API fallback was previously available.
+  if (RuntimeEnabledFeatures::LegacyWindowsDWriteFontFallbackEnabled() ||
+      (!hardcoded_list_fallback_font && use_skia_font_fallback_)) {
+    scoped_refptr<SimpleFontData> dwrite_fallback_font =
+        GetDWriteFallbackFamily(font_description, character, fallback_priority);
+    if (dwrite_fallback_font) {
+      String dwrite_name =
+          dwrite_fallback_font->PlatformData().FontFamilyName();
     }
 
-    CString family_name = font_description.Family().Family().Utf8();
-
-    SkTypeface* typeface = font_manager_->matchFamilyStyleCharacter(
-        family_name.data(), font_description.SkiaFontStyle(), &bcp47_locale,
-        locale_count, character);
-    if (typeface) {
-      SkString skia_family;
-      typeface->getFamilyName(&skia_family);
-      FontFaceCreationParams create_by_family(ToAtomicString(skia_family));
-      FontPlatformData* data =
-          GetFontPlatformData(font_description, create_by_family);
-      if (data && data->FontContainsCharacter(character))
-        return FontDataFromFontPlatformData(data, kDoNotRetain);
+    UBlockCode block_code = ublock_getCode(character);
+    if (!hardcoded_list_fallback_font) {
+      LogUmaHistogramFallbackAgreemenError(kLegacyNoneFound, block_code);
     }
+    if (!dwrite_fallback_font) {
+      LogUmaHistogramFallbackAgreemenError(kWinAPINoneFound, block_code);
+    }
+    if (hardcoded_list_fallback_font && dwrite_fallback_font) {
+      String hardcoded_family_name =
+          hardcoded_list_fallback_font->PlatformData().FontFamilyName();
+      String dwrite_family_name =
+          dwrite_fallback_font->PlatformData().FontFamilyName();
+      if (hardcoded_family_name != dwrite_family_name) {
+        LogUmaHistogramFallbackAgreemenError(kLegacyWinAPIDisagree, block_code);
+      }
+    }
+    if (!hardcoded_list_fallback_font && !dwrite_fallback_font) {
+      LogUmaHistogramFallbackAgreemenError(kNoneFound, block_code);
+    }
+    return dwrite_fallback_font;
   }
 
-  // In production, these 3 font managers must match.
-  // They don't match in unit tests or in single process mode.
-  // Capture them in minidump for crbug.com/409784
-  SkFontMgr* font_mgr = font_manager_.get();
-  SkFontMgr* static_font_mgr = static_font_manager_;
-  SkFontMgr* skia_default_font_mgr = SkFontMgr::RefDefault().get();
-  base::debug::Alias(&font_mgr);
-  base::debug::Alias(&static_font_mgr);
-  base::debug::Alias(&skia_default_font_mgr);
-
-  // Last resort font list : PanUnicode. CJK fonts have a pretty
-  // large repertoire. Eventually, we need to scan all the fonts
-  // on the system to have a Firefox-like coverage.
-  // Make sure that all of them are lowercased.
-  const static wchar_t* const kCjkFonts[] = {
-      L"arial unicode ms", L"ms pgothic", L"simsun", L"gulim", L"pmingliu",
-      L"wenquanyi zen hei",  // Partial CJK Ext. A coverage but more widely
-                             // known to Chinese users.
-      L"ar pl shanheisun uni", L"ar pl zenkai uni",
-      L"han nom a",  // Complete CJK Ext. A coverage.
-      L"code2000"    // Complete CJK Ext. A coverage.
-      // CJK Ext. B fonts are not listed here because it's of no use
-      // with our current non-BMP character handling because we use
-      // Uniscribe for it and that code path does not go through here.
-  };
-
-  const static wchar_t* const kCommonFonts[] = {
-      L"tahoma", L"arial unicode ms", L"lucida sans unicode",
-      L"microsoft sans serif", L"palatino linotype",
-      // Six fonts below (and code2000 at the end) are not from MS, but
-      // once installed, cover a very wide range of characters.
-      L"dejavu serif", L"dejavu sasns", L"freeserif", L"freesans", L"gentium",
-      L"gentiumalt", L"ms pgothic", L"simsun", L"gulim", L"pmingliu",
-      L"code2000"};
-
-  const wchar_t* const* pan_uni_fonts = nullptr;
-  int num_fonts = 0;
-  if (script == USCRIPT_HAN) {
-    pan_uni_fonts = kCjkFonts;
-    num_fonts = arraysize(kCjkFonts);
-  } else {
-    pan_uni_fonts = kCommonFonts;
-    num_fonts = arraysize(kCommonFonts);
-  }
-  // Font returned from getFallbackFamily may not cover |character|
-  // because it's based on script to font mapping. This problem is
-  // critical enough for non-Latin scripts (especially Han) to
-  // warrant an additional (real coverage) check with fontCotainsCharacter.
-  for (int i = 0; i < num_fonts; ++i) {
-    family = pan_uni_fonts[i];
-    FontFaceCreationParams create_by_family(family);
-    FontPlatformData* data =
-        GetFontPlatformData(font_description, create_by_family);
-    if (data && data->FontContainsCharacter(character))
-      return FontDataFromFontPlatformData(data, kDoNotRetain);
-  }
-
-  return nullptr;
+  return hardcoded_list_fallback_font;
 }
 
 static inline bool DeprecatedEqualIgnoringCase(const AtomicString& a,
@@ -273,26 +501,26 @@ static bool TypefacesHasWeightSuffix(const AtomicString& family,
                                      AtomicString& adjusted_name,
                                      FontSelectionValue& variant_weight) {
   struct FamilyWeightSuffix {
-    const wchar_t* suffix;
+    const UChar* suffix;
     size_t length;
     FontSelectionValue weight;
   };
   // Mapping from suffix to weight from the DirectWrite documentation.
   // http://msdn.microsoft.com/en-us/library/windows/desktop/dd368082.aspx
   const static FamilyWeightSuffix kVariantForSuffix[] = {
-      {L" thin", 5, FontSelectionValue(100)},
-      {L" extralight", 11, FontSelectionValue(200)},
-      {L" ultralight", 11, FontSelectionValue(200)},
-      {L" light", 6, FontSelectionValue(300)},
-      {L" regular", 8, FontSelectionValue(400)},
-      {L" medium", 7, FontSelectionValue(500)},
-      {L" demibold", 9, FontSelectionValue(600)},
-      {L" semibold", 9, FontSelectionValue(600)},
-      {L" extrabold", 10, FontSelectionValue(800)},
-      {L" ultrabold", 10, FontSelectionValue(800)},
-      {L" black", 6, FontSelectionValue(900)},
-      {L" heavy", 6, FontSelectionValue(900)}};
-  size_t num_variants = arraysize(kVariantForSuffix);
+      {u" thin", 5, FontSelectionValue(100)},
+      {u" extralight", 11, FontSelectionValue(200)},
+      {u" ultralight", 11, FontSelectionValue(200)},
+      {u" light", 6, FontSelectionValue(300)},
+      {u" regular", 8, FontSelectionValue(400)},
+      {u" medium", 7, FontSelectionValue(500)},
+      {u" demibold", 9, FontSelectionValue(600)},
+      {u" semibold", 9, FontSelectionValue(600)},
+      {u" extrabold", 10, FontSelectionValue(800)},
+      {u" ultrabold", 10, FontSelectionValue(800)},
+      {u" black", 6, FontSelectionValue(900)},
+      {u" heavy", 6, FontSelectionValue(900)}};
+  size_t num_variants = base::size(kVariantForSuffix);
   for (size_t i = 0; i < num_variants; i++) {
     const FamilyWeightSuffix& entry = kVariantForSuffix[i];
     if (family.EndsWith(entry.suffix, kTextCaseUnicodeInsensitive)) {
@@ -311,7 +539,7 @@ static bool TypefacesHasStretchSuffix(const AtomicString& family,
                                       AtomicString& adjusted_name,
                                       FontSelectionValue& variant_stretch) {
   struct FamilyStretchSuffix {
-    const wchar_t* suffix;
+    const UChar* suffix;
     size_t length;
     FontSelectionValue stretch;
   };
@@ -320,16 +548,16 @@ static bool TypefacesHasStretchSuffix(const AtomicString& family,
   // Also includes Narrow as a synonym for Condensed to to support Arial
   // Narrow and other fonts following the same naming scheme.
   const static FamilyStretchSuffix kVariantForSuffix[] = {
-      {L" ultracondensed", 15, UltraCondensedWidthValue()},
-      {L" extracondensed", 15, ExtraCondensedWidthValue()},
-      {L" condensed", 10, CondensedWidthValue()},
-      {L" narrow", 7, CondensedWidthValue()},
-      {L" semicondensed", 14, SemiCondensedWidthValue()},
-      {L" semiexpanded", 13, SemiExpandedWidthValue()},
-      {L" expanded", 9, ExpandedWidthValue()},
-      {L" extraexpanded", 14, ExtraExpandedWidthValue()},
-      {L" ultraexpanded", 14, UltraExpandedWidthValue()}};
-  size_t num_variants = arraysize(kVariantForSuffix);
+      {u" ultracondensed", 15, UltraCondensedWidthValue()},
+      {u" extracondensed", 15, ExtraCondensedWidthValue()},
+      {u" condensed", 10, CondensedWidthValue()},
+      {u" narrow", 7, CondensedWidthValue()},
+      {u" semicondensed", 14, SemiCondensedWidthValue()},
+      {u" semiexpanded", 13, SemiExpandedWidthValue()},
+      {u" expanded", 9, ExpandedWidthValue()},
+      {u" extraexpanded", 14, ExtraExpandedWidthValue()},
+      {u" ultraexpanded", 14, UltraExpandedWidthValue()}};
+  size_t num_variants = base::size(kVariantForSuffix);
   for (size_t i = 0; i < num_variants; i++) {
     const FamilyStretchSuffix& entry = kVariantForSuffix[i];
     if (family.EndsWith(entry.suffix, kTextCaseUnicodeInsensitive)) {
@@ -349,76 +577,96 @@ std::unique_ptr<FontPlatformData> FontCache::CreateFontPlatformData(
     const FontFaceCreationParams& creation_params,
     float font_size,
     AlternateFontName alternate_font_name) {
+  TRACE_EVENT0("ui", "FontCache::CreateFontPlatformData");
+
   DCHECK_EQ(creation_params.CreationType(), kCreateFontByFamily);
+  sk_sp<SkTypeface> typeface;
 
-  CString name;
-  PaintTypeface paint_tf =
-      CreateTypeface(font_description, creation_params, name);
-  // Windows will always give us a valid pointer here, even if the face name
-  // is non-existent. We have to double-check and see if the family name was
-  // really used.
-  if (!paint_tf || !TypefacesMatchesFamily(paint_tf.ToSkTypeface().get(),
-                                           creation_params.Family())) {
-    AtomicString adjusted_name;
-    FontSelectionValue variant_weight;
-    FontSelectionValue variant_stretch;
+  std::string name;
 
-    // TODO: crbug.com/627143 LocalFontFaceSource.cpp, which implements
-    // retrieving src: local() font data uses getFontData, which in turn comes
-    // here, to retrieve fonts from the cache and specifies the argument to
-    // local() as family name. So we do not match by full font name or
-    // postscript name as the spec says:
-    // https://drafts.csswg.org/css-fonts-3/#src-desc
+  if (alternate_font_name == AlternateFontName::kLocalUniqueFace &&
+      RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled()) {
+    typeface = CreateTypefaceFromUniqueName(creation_params);
 
-    // Prevent one side effect of the suffix translation below where when
-    // matching local("Roboto Regular") it tries to find the closest match even
-    // though that can be a bold font in case of Roboto Bold.
-    if (alternate_font_name == AlternateFontName::kLocalUniqueFace) {
-      return nullptr;
+    if (!typeface && sideloaded_fonts_) {
+      typeface = FindUniqueFontNameFromSideloadedFonts(creation_params.Family(),
+                                                       sideloaded_fonts_);
     }
 
-    if (alternate_font_name == AlternateFontName::kLastResort) {
-      if (!paint_tf)
-        return nullptr;
-    } else if (TypefacesHasWeightSuffix(creation_params.Family(), adjusted_name,
-                                        variant_weight)) {
-      FontFaceCreationParams adjusted_params(adjusted_name);
-      FontDescription adjusted_font_description = font_description;
-      adjusted_font_description.SetWeight(variant_weight);
-      paint_tf =
-          CreateTypeface(adjusted_font_description, adjusted_params, name);
-      if (!paint_tf || !TypefacesMatchesFamily(paint_tf.ToSkTypeface().get(),
-                                               adjusted_name)) {
+    // We do not need to try any heuristic around the font name, as below, for
+    // family matching.
+    if (!typeface)
+      return nullptr;
+
+  } else {
+    typeface = CreateTypeface(font_description, creation_params, name);
+
+    // For a family match, Windows will always give us a valid pointer here,
+    // even if the face name is non-existent. We have to double-check and see if
+    // the family name was really used.
+    if (!typeface ||
+        !TypefacesMatchesFamily(typeface.get(), creation_params.Family())) {
+      AtomicString adjusted_name;
+      FontSelectionValue variant_weight;
+      FontSelectionValue variant_stretch;
+
+      // TODO: crbug.com/627143 LocalFontFaceSource.cpp, which implements
+      // retrieving src: local() font data uses getFontData, which in turn comes
+      // here, to retrieve fonts from the cache and specifies the argument to
+      // local() as family name. So we do not match by full font name or
+      // postscript name as the spec says:
+      // https://drafts.csswg.org/css-fonts-3/#src-desc
+
+      // Prevent one side effect of the suffix translation below where when
+      // matching local("Roboto Regular") it tries to find the closest match
+      // even though that can be a bold font in case of Roboto Bold.
+      if (alternate_font_name == AlternateFontName::kLocalUniqueFace) {
         return nullptr;
       }
 
-    } else if (TypefacesHasStretchSuffix(creation_params.Family(),
-                                         adjusted_name, variant_stretch)) {
-      FontFaceCreationParams adjusted_params(adjusted_name);
-      FontDescription adjusted_font_description = font_description;
-      adjusted_font_description.SetStretch(variant_stretch);
-      paint_tf =
-          CreateTypeface(adjusted_font_description, adjusted_params, name);
-      if (!paint_tf || !TypefacesMatchesFamily(paint_tf.ToSkTypeface().get(),
-                                               adjusted_name)) {
+      if (alternate_font_name == AlternateFontName::kLastResort) {
+        if (!typeface)
+          return nullptr;
+      } else if (TypefacesHasWeightSuffix(creation_params.Family(),
+                                          adjusted_name, variant_weight)) {
+        FontFaceCreationParams adjusted_params(adjusted_name);
+        FontDescription adjusted_font_description = font_description;
+        adjusted_font_description.SetWeight(variant_weight);
+        typeface =
+            CreateTypeface(adjusted_font_description, adjusted_params, name);
+        if (!typeface ||
+            !TypefacesMatchesFamily(typeface.get(), adjusted_name)) {
+          return nullptr;
+        }
+
+      } else if (TypefacesHasStretchSuffix(creation_params.Family(),
+                                           adjusted_name, variant_stretch)) {
+        FontFaceCreationParams adjusted_params(adjusted_name);
+        FontDescription adjusted_font_description = font_description;
+        adjusted_font_description.SetStretch(variant_stretch);
+        typeface =
+            CreateTypeface(adjusted_font_description, adjusted_params, name);
+        if (!typeface ||
+            !TypefacesMatchesFamily(typeface.get(), adjusted_name)) {
+          return nullptr;
+        }
+      } else {
         return nullptr;
       }
-    } else {
-      return nullptr;
     }
   }
 
-  const auto& tf = paint_tf.ToSkTypeface();
   std::unique_ptr<FontPlatformData> result = std::make_unique<FontPlatformData>(
-      paint_tf, name.data(), font_size,
-      (font_description.Weight() >= BoldThreshold() && !tf->isBold()) ||
+      typeface, name.data(), font_size,
+      (font_description.Weight() >= BoldThreshold() && !typeface->isBold()) ||
           font_description.IsSyntheticBold(),
-      ((font_description.Style() == ItalicSlopeValue()) && !tf->isItalic()) ||
+      ((font_description.Style() == ItalicSlopeValue()) &&
+       !typeface->isItalic()) ||
           font_description.IsSyntheticItalic(),
       font_description.Orientation());
 
   result->SetAvoidEmbeddedBitmaps(
-      BitmapGlyphsBlacklist::AvoidEmbeddedBitmapsForTypeface(tf.get()));
+      BitmapGlyphsBlockList::ShouldAvoidEmbeddedBitmapsForTypeface(*typeface));
 
   return result;
 }
diff --git a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
index ecb970bdd705..7eb9e4a51fbf 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
@@ -32,8 +32,10 @@
 #include "third_party/blink/renderer/platform/fonts/win/font_fallback_win.h"
 
 #include <unicode/uchar.h>
+
 #include <limits>
 
+#include "base/stl_util.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #include "third_party/blink/renderer/platform/text/icu_error.h"
 #include "third_party/blink/renderer/platform/wtf/hash_map.h"
@@ -46,11 +48,15 @@ namespace blink {
 
 namespace {
 
+const char kArial[] = "Arial";
+const char kCourierNew[] = "Courier New";
+const char kTimesNewRoman[] = "Times New Roman";
+
 static inline bool IsFontPresent(const UChar* font_name,
                                  SkFontMgr* font_manager) {
   String family = font_name;
   sk_sp<SkTypeface> tf(
-      font_manager->matchFamilyStyle(family.Utf8().data(), SkFontStyle()));
+      font_manager->matchFamilyStyle(family.Utf8().c_str(), SkFontStyle()));
   if (!tf)
     return false;
 
@@ -85,7 +91,8 @@ const UChar* FindMonospaceFontForScript(UScriptCode script) {
   };
 
   static const FontMap kFontMap[] = {
-      {USCRIPT_HEBREW, L"courier new"}, {USCRIPT_ARABIC, L"courier new"},
+      {USCRIPT_HEBREW, u"courier new"},
+      {USCRIPT_ARABIC, u"courier new"},
   };
 
   for (const auto& font_family : kFontMap) {
@@ -111,112 +118,112 @@ void InitializeScriptFontMap(ScriptToFontMap& script_font_map) {
   // Based on the "Script and Font Support in Windows" MSDN documentation [1]
   // with overrides and additional fallbacks as needed.
   // 1: https://msdn.microsoft.com/en-us/goglobal/bb688099.aspx
-  static const UChar* const kArabicFonts[] = {L"Tahoma", L"Segoe UI", 0};
-  static const UChar* const kArmenianFonts[] = {L"Segoe UI", L"Sylfaen", 0};
-  static const UChar* const kBengaliFonts[] = {L"Nirmala UI", L"Vrinda", 0};
-  static const UChar* const kBrahmiFonts[] = {L"Segoe UI Historic", 0};
-  static const UChar* const kBrailleFonts[] = {L"Segoe UI Symbol", 0};
-  static const UChar* const kBugineseFonts[] = {L"Leelawadee UI", 0};
-  static const UChar* const kCanadianAaboriginalFonts[] = {L"Gadugi",
-                                                           L"Euphemia", 0};
-  static const UChar* const kCarianFonts[] = {L"Segoe UI Historic", 0};
-  static const UChar* const kCherokeeFonts[] = {L"Gadugi", L"Plantagenet", 0};
-  static const UChar* const kCopticFonts[] = {L"Segoe UI Symbol", 0};
-  static const UChar* const kCuneiformFonts[] = {L"Segoe UI Historic", 0};
-  static const UChar* const kCypriotFonts[] = {L"Segoe UI Historic", 0};
-  static const UChar* const kCyrillicFonts[] = {L"Times New Roman", 0};
-  static const UChar* const kDeseretFonts[] = {L"Segoe UI Symbol", 0};
-  static const UChar* const kDevanagariFonts[] = {L"Nirmala UI", L"Mangal", 0};
-  static const UChar* const kEgyptianHieroglyphsFonts[] = {L"Segoe UI Historic",
+  static const UChar* const kArabicFonts[] = {u"Tahoma", u"Segoe UI", 0};
+  static const UChar* const kArmenianFonts[] = {u"Segoe UI", u"Sylfaen", 0};
+  static const UChar* const kBengaliFonts[] = {u"Nirmala UI", u"Vrinda", 0};
+  static const UChar* const kBrahmiFonts[] = {u"Segoe UI Historic", 0};
+  static const UChar* const kBrailleFonts[] = {u"Segoe UI Symbol", 0};
+  static const UChar* const kBugineseFonts[] = {u"Leelawadee UI", 0};
+  static const UChar* const kCanadianAaboriginalFonts[] = {u"Gadugi",
+                                                           u"Euphemia", 0};
+  static const UChar* const kCarianFonts[] = {u"Segoe UI Historic", 0};
+  static const UChar* const kCherokeeFonts[] = {u"Gadugi", u"Plantagenet", 0};
+  static const UChar* const kCopticFonts[] = {u"Segoe UI Symbol", 0};
+  static const UChar* const kCuneiformFonts[] = {u"Segoe UI Historic", 0};
+  static const UChar* const kCypriotFonts[] = {u"Segoe UI Historic", 0};
+  static const UChar* const kCyrillicFonts[] = {u"Times New Roman", 0};
+  static const UChar* const kDeseretFonts[] = {u"Segoe UI Symbol", 0};
+  static const UChar* const kDevanagariFonts[] = {u"Nirmala UI", u"Mangal", 0};
+  static const UChar* const kEgyptianHieroglyphsFonts[] = {u"Segoe UI Historic",
                                                            0};
-  static const UChar* const kEthiopicFonts[] = {L"Nyala",
-                                                L"Abyssinica SIL",
-                                                L"Ethiopia Jiret",
-                                                L"Visual Geez Unicode",
-                                                L"GF Zemen Unicode",
-                                                L"Ebrima",
+  static const UChar* const kEthiopicFonts[] = {u"Nyala",
+                                                u"Abyssinica SIL",
+                                                u"Ethiopia Jiret",
+                                                u"Visual Geez Unicode",
+                                                u"GF Zemen Unicode",
+                                                u"Ebrima",
                                                 0};
-  static const UChar* const kGeorgianFonts[] = {L"Sylfaen", L"Segoe UI", 0};
-  static const UChar* const kGlagoliticFonts[] = {L"Segoe UI Historic",
-                                                  L"Segoe UI Symbol", 0};
-  static const UChar* const kGothicFonts[] = {L"Segoe UI Historic",
-                                              L"Segoe UI Symbol", 0};
-  static const UChar* const kGreekFonts[] = {L"Times New Roman", 0};
-  static const UChar* const kGujaratiFonts[] = {L"Nirmala UI", L"Shruti", 0};
-  static const UChar* const kGurmukhiFonts[] = {L"Nirmala UI", L"Raavi", 0};
-  static const UChar* const kHangulFonts[] = {L"Malgun Gothic", L"Gulim", 0};
-  static const UChar* const kHebrewFonts[] = {L"David", L"Segoe UI", 0};
-  static const UChar* const kImperialAramaicFonts[] = {L"Segoe UI Historic", 0};
+  static const UChar* const kGeorgianFonts[] = {u"Sylfaen", u"Segoe UI", 0};
+  static const UChar* const kGlagoliticFonts[] = {u"Segoe UI Historic",
+                                                  u"Segoe UI Symbol", 0};
+  static const UChar* const kGothicFonts[] = {u"Segoe UI Historic",
+                                              u"Segoe UI Symbol", 0};
+  static const UChar* const kGreekFonts[] = {u"Times New Roman", 0};
+  static const UChar* const kGujaratiFonts[] = {u"Nirmala UI", u"Shruti", 0};
+  static const UChar* const kGurmukhiFonts[] = {u"Nirmala UI", u"Raavi", 0};
+  static const UChar* const kHangulFonts[] = {u"Malgun Gothic", u"Gulim", 0};
+  static const UChar* const kHebrewFonts[] = {u"David", u"Segoe UI", 0};
+  static const UChar* const kImperialAramaicFonts[] = {u"Segoe UI Historic", 0};
   static const UChar* const kInscriptionalPahlaviFonts[] = {
-      L"Segoe UI Historic", 0};
+      u"Segoe UI Historic", 0};
   static const UChar* const kInscriptionalParthianFonts[] = {
-      L"Segoe UI Historic", 0};
-  static const UChar* const kJavaneseFonts[] = {L"Javanese Text", 0};
-  static const UChar* const kKannadaFonts[] = {L"Tunga", L"Nirmala UI", 0};
+      u"Segoe UI Historic", 0};
+  static const UChar* const kJavaneseFonts[] = {u"Javanese Text", 0};
+  static const UChar* const kKannadaFonts[] = {u"Tunga", u"Nirmala UI", 0};
   static const UChar* const kKatakanaOrHiraganaFonts[] = {
-      L"Meiryo", L"Yu Gothic", L"MS PGothic", L"Microsoft YaHei", 0};
-  static const UChar* const kKharoshthiFonts[] = {L"Segoe UI Historic", 0};
+      u"Meiryo", u"Yu Gothic", u"MS PGothic", u"Microsoft YaHei", 0};
+  static const UChar* const kKharoshthiFonts[] = {u"Segoe UI Historic", 0};
   // Try Khmer OS before Vista fonts as it goes along better with Latin
   // and looks better/larger for the same size.
   static const UChar* const kKhmerFonts[] = {
-      L"Leelawadee UI", L"Khmer UI", L"Khmer OS", L"MoolBoran", L"DaunPenh", 0};
-  static const UChar* const kLaoFonts[] = {L"Leelawadee UI",
-                                           L"Lao UI",
-                                           L"DokChampa",
-                                           L"Saysettha OT",
-                                           L"Phetsarath OT",
-                                           L"Code2000",
+      u"Leelawadee UI", u"Khmer UI", u"Khmer OS", u"MoolBoran", u"DaunPenh", 0};
+  static const UChar* const kLaoFonts[] = {u"Leelawadee UI",
+                                           u"Lao UI",
+                                           u"DokChampa",
+                                           u"Saysettha OT",
+                                           u"Phetsarath OT",
+                                           u"Code2000",
                                            0};
-  static const UChar* const kLatinFonts[] = {L"Times New Roman", 0};
-  static const UChar* const kLisuFonts[] = {L"Segoe UI", 0};
-  static const UChar* const kLycianFonts[] = {L"Segoe UI Historic", 0};
-  static const UChar* const kLydianFonts[] = {L"Segoe UI Historic", 0};
-  static const UChar* const kMalayalamFonts[] = {L"Nirmala UI", L"Kartika", 0};
-  static const UChar* const kMeroiticCursiveFonts[] = {L"Segoe UI Historic",
-                                                       L"Segoe UI Symbol", 0};
-  static const UChar* const kMongolianFonts[] = {L"Mongolian Baiti", 0};
+  static const UChar* const kLatinFonts[] = {u"Times New Roman", 0};
+  static const UChar* const kLisuFonts[] = {u"Segoe UI", 0};
+  static const UChar* const kLycianFonts[] = {u"Segoe UI Historic", 0};
+  static const UChar* const kLydianFonts[] = {u"Segoe UI Historic", 0};
+  static const UChar* const kMalayalamFonts[] = {u"Nirmala UI", u"Kartika", 0};
+  static const UChar* const kMeroiticCursiveFonts[] = {u"Segoe UI Historic",
+                                                       u"Segoe UI Symbol", 0};
+  static const UChar* const kMongolianFonts[] = {u"Mongolian Baiti", 0};
   static const UChar* const kMyanmarFonts[] = {
-      L"Myanmar Text", L"Padauk", L"Parabaik", L"Myanmar3", L"Code2000", 0};
-  static const UChar* const kNewTaiLueFonts[] = {L"Microsoft New Tai Lue", 0};
-  static const UChar* const kNkoFonts[] = {L"Ebrima", 0};
-  static const UChar* const kOghamFonts[] = {L"Segoe UI Historic",
-                                             L"Segoe UI Symbol", 0};
-  static const UChar* const kOlChikiFonts[] = {L"Nirmala UI", 0};
-  static const UChar* const kOldItalicFonts[] = {L"Segoe UI Historic",
-                                                 L"Segoe UI Symbol", 0};
-  static const UChar* const kOldPersianFonts[] = {L"Segoe UI Historic", 0};
-  static const UChar* const kOldSouthArabianFonts[] = {L"Segoe UI Historic", 0};
-  static const UChar* const kOriyaFonts[] = {L"Kalinga", L"ori1Uni",
-                                             L"Lohit Oriya", L"Nirmala UI", 0};
-  static const UChar* const kOrkhonFonts[] = {L"Segoe UI Historic",
-                                              L"Segoe UI Symbol", 0};
-  static const UChar* const kOsmanyaFonts[] = {L"Ebrima", 0};
-  static const UChar* const kPhagsPaFonts[] = {L"Microsoft PhagsPa", 0};
-  static const UChar* const kRunicFonts[] = {L"Segoe UI Historic",
-                                             L"Segoe UI Symbol", 0};
-  static const UChar* const kShavianFonts[] = {L"Segoe UI Historic", 0};
-  static const UChar* const kSimplifiedHanFonts[] = {L"simsun",
-                                                     L"Microsoft YaHei", 0};
+      u"Myanmar Text", u"Padauk", u"Parabaik", u"Myanmar3", u"Code2000", 0};
+  static const UChar* const kNewTaiLueFonts[] = {u"Microsoft New Tai Lue", 0};
+  static const UChar* const kNkoFonts[] = {u"Ebrima", 0};
+  static const UChar* const kOghamFonts[] = {u"Segoe UI Historic",
+                                             u"Segoe UI Symbol", 0};
+  static const UChar* const kOlChikiFonts[] = {u"Nirmala UI", 0};
+  static const UChar* const kOldItalicFonts[] = {u"Segoe UI Historic",
+                                                 u"Segoe UI Symbol", 0};
+  static const UChar* const kOldPersianFonts[] = {u"Segoe UI Historic", 0};
+  static const UChar* const kOldSouthArabianFonts[] = {u"Segoe UI Historic", 0};
+  static const UChar* const kOriyaFonts[] = {u"Kalinga", u"ori1Uni",
+                                             u"Lohit Oriya", u"Nirmala UI", 0};
+  static const UChar* const kOrkhonFonts[] = {u"Segoe UI Historic",
+                                              u"Segoe UI Symbol", 0};
+  static const UChar* const kOsmanyaFonts[] = {u"Ebrima", 0};
+  static const UChar* const kPhagsPaFonts[] = {u"Microsoft PhagsPa", 0};
+  static const UChar* const kRunicFonts[] = {u"Segoe UI Historic",
+                                             u"Segoe UI Symbol", 0};
+  static const UChar* const kShavianFonts[] = {u"Segoe UI Historic", 0};
+  static const UChar* const kSimplifiedHanFonts[] = {u"Microsoft YaHei",
+                                                     u"simsun", 0};
   static const UChar* const kSinhalaFonts[] = {
-      L"Iskoola Pota", L"AksharUnicode", L"Nirmala UI", 0};
-  static const UChar* const kSoraSompengFonts[] = {L"Nirmala UI", 0};
-  static const UChar* const kSymbolsFonts[] = {L"Segoe UI Symbol", 0};
+      u"Iskoola Pota", u"AksharUnicode", u"Nirmala UI", 0};
+  static const UChar* const kSoraSompengFonts[] = {u"Nirmala UI", 0};
+  static const UChar* const kSymbolsFonts[] = {u"Segoe UI Symbol", 0};
   static const UChar* const kSyriacFonts[] = {
-      L"Estrangelo Edessa", L"Estrangelo Nisibin", L"Code2000", 0};
-  static const UChar* const kTaiLeFonts[] = {L"Microsoft Tai Le", 0};
-  static const UChar* const kTamilFonts[] = {L"Nirmala UI", L"Latha", 0};
-  static const UChar* const kTeluguFonts[] = {L"Nirmala UI", L"Gautami", 0};
-  static const UChar* const kThaanaFonts[] = {L"MV Boli", 0};
-  static const UChar* const kThaiFonts[] = {L"Tahoma", L"Leelawadee UI",
-                                            L"Leelawadee", 0};
+      u"Estrangelo Edessa", u"Estrangelo Nisibin", u"Code2000", 0};
+  static const UChar* const kTaiLeFonts[] = {u"Microsoft Tai Le", 0};
+  static const UChar* const kTamilFonts[] = {u"Nirmala UI", u"Latha", 0};
+  static const UChar* const kTeluguFonts[] = {u"Nirmala UI", u"Gautami", 0};
+  static const UChar* const kThaanaFonts[] = {u"MV Boli", 0};
+  static const UChar* const kThaiFonts[] = {u"Tahoma", u"Leelawadee UI",
+                                            u"Leelawadee", 0};
   static const UChar* const kTibetanFonts[] = {
-      L"Microsoft Himalaya", L"Jomolhari", L"Tibetan Machine Uni", 0};
-  static const UChar* const kTifinaghFonts[] = {L"Ebrima", 0};
-  static const UChar* const kTraditionalHanFonts[] = {L"pmingliu",
-                                                      L"Microsoft JhengHei", 0};
-  static const UChar* const kVaiFonts[] = {L"Ebrima", 0};
-  static const UChar* const kYiFonts[] = {L"Microsoft Yi Baiti", L"Nuosu SIL",
-                                          L"Code2000", 0};
+      u"Microsoft Himalaya", u"Jomolhari", u"Tibetan Machine Uni", 0};
+  static const UChar* const kTifinaghFonts[] = {u"Ebrima", 0};
+  static const UChar* const kTraditionalHanFonts[] = {u"Microsoft JhengHei",
+                                                      u"pmingliu", 0};
+  static const UChar* const kVaiFonts[] = {u"Ebrima", 0};
+  static const UChar* const kYiFonts[] = {u"Microsoft Yi Baiti", u"Nuosu SIL",
+                                          u"Code2000", 0};
 
   static const ScriptToFontFamilies kScriptToFontFamilies[] = {
       {USCRIPT_ARABIC, kArabicFonts},
@@ -367,22 +374,22 @@ UScriptCode GetScript(int ucs4) {
 
 const UChar* GetFontBasedOnUnicodeBlock(UBlockCode block_code,
                                         SkFontMgr* font_manager) {
-  static const UChar* const kEmojiFonts[] = {L"Segoe UI Emoji",
-                                             L"Segoe UI Symbol"};
-  static const UChar* const kMathFonts[] = {L"Cambria Math", L"Segoe UI Symbol",
-                                            L"Code2000"};
-  static const UChar* const kSymbolFont = L"Segoe UI Symbol";
+  static const UChar* const kEmojiFonts[] = {u"Segoe UI Emoji",
+                                             u"Segoe UI Symbol"};
+  static const UChar* const kMathFonts[] = {u"Cambria Math", u"Segoe UI Symbol",
+                                            u"Code2000"};
+  static const UChar* const kSymbolFont = u"Segoe UI Symbol";
   static const UChar* emoji_font = 0;
   static const UChar* math_font = 0;
   static bool initialized = false;
   if (!initialized) {
-    for (size_t i = 0; i < arraysize(kEmojiFonts); i++) {
+    for (size_t i = 0; i < base::size(kEmojiFonts); i++) {
       if (IsFontPresent(kEmojiFonts[i], font_manager)) {
         emoji_font = kEmojiFonts[i];
         break;
       }
     }
-    for (size_t i = 0; i < arraysize(kMathFonts); i++) {
+    for (size_t i = 0; i < base::size(kMathFonts); i++) {
       if (IsFontPresent(kMathFonts[i], font_manager)) {
         math_font = kMathFonts[i];
         break;
@@ -519,7 +526,7 @@ const UChar* GetFallbackFamily(UChar32 character,
     int plane = character >> 16;
     switch (plane) {
       case 1:
-        family = L"code2001";
+        family = u"code2001";
         break;
       case 2:
         // Use a Traditional Chinese ExtB font if in Traditional Chinese locale.
@@ -528,12 +535,12 @@ const UChar* GetFallbackFamily(UChar32 character,
         // 0213), but its coverage is rather sparse.
         // Eventually, this should be controlled by lang/xml:lang.
         if (icu::Locale::getDefault() == icu::Locale::getTraditionalChinese())
-          family = L"pmingliu-extb";
+          family = u"pmingliu-extb";
         else
-          family = L"simsun-extb";
+          family = u"simsun-extb";
         break;
       default:
-        family = L"lucida sans unicode";
+        family = u"lucida sans unicode";
     }
   }
 
@@ -542,4 +549,38 @@ const UChar* GetFallbackFamily(UChar32 character,
   return family;
 }
 
+bool GetOutOfProcessFallbackFamily(
+    UChar32 character,
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority,
+    const mojo::Remote<mojom::blink::DWriteFontProxy>& service,
+    String* fallback_family,
+    SkFontStyle* fallback_style) {
+  String base_family_name_approximation;
+  switch (generic_family) {
+    case FontDescription::kMonospaceFamily:
+      base_family_name_approximation = kCourierNew;
+      break;
+    case FontDescription::kSansSerifFamily:
+      base_family_name_approximation = kArial;
+      break;
+    default:
+      base_family_name_approximation = kTimesNewRoman;
+  }
+
+  mojom::blink::FallbackFamilyAndStylePtr fallback_family_and_style;
+  bool mojo_result = service->FallbackFamilyAndStyleForCodepoint(
+      base_family_name_approximation, bcp47_language_tag, character,
+      &fallback_family_and_style);
+
+  SECURITY_DCHECK(fallback_family);
+  SECURITY_DCHECK(fallback_style);
+  *fallback_family = fallback_family_and_style->fallback_family_name;
+  *fallback_style = SkFontStyle(
+      fallback_family_and_style->weight, fallback_family_and_style->width,
+      static_cast<SkFontStyle::Slant>(fallback_family_and_style->slant));
+  return mojo_result;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
index 55681fae2643..254eba78a363 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
+++ b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
@@ -33,21 +33,23 @@
 
 #include <unicode/locid.h>
 #include <unicode/uscript.h>
-#include <usp10.h>
-#include <wchar.h>
-#include <windows.h>
+
+#include "mojo/public/cpp/bindings/remote.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink-forward.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
 #include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkFontStyle.h"
 
 class SkFontMgr;
 
 namespace blink {
 
 // Return a font family that can render |character| based on what script
-// that characters belong to.
-// When scriptChecked is non-zero, the script used to determine
-// the family is returned.
+// that characters belong to based on hard-coded tables that have been curated
+// over time. When scriptChecked is non-zero, the script used to determine the
+// family is returned.
 PLATFORM_EXPORT const UChar* GetFallbackFamily(
     UChar32 character,
     FontDescription::GenericFamilyType,
@@ -56,6 +58,19 @@ PLATFORM_EXPORT const UChar* GetFallbackFamily(
     FontFallbackPriority,
     SkFontMgr* font_manager);
 
+// Return a font family that can render |character| based on what script
+// that characters belong to by performing an out of process lookup and using
+// system fallback API based on IDWriteTextLayout. This method is only to be
+// used on pre Windows 8.1, as otherwise IDWriteFontFallback API is available.
+PLATFORM_EXPORT bool GetOutOfProcessFallbackFamily(
+    UChar32 character,
+    FontDescription::GenericFamilyType,
+    String bcp47_language_tag,
+    FontFallbackPriority,
+    const mojo::Remote<mojom::blink::DWriteFontProxy>& font_proxy,
+    String* fallback_family,
+    SkFontStyle* fallback_style);
+
 }  // namespace blink
 
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FONT_FALLBACK_WIN_H_
diff --git a/third_party/blink/renderer/platform/fonts/win/font_platform_data_win.cc b/third_party/blink/renderer/platform/fonts/win/font_platform_data_win.cc
index c655c41c2b32..c66f83f2ea0c 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_platform_data_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_platform_data_win.cc
@@ -29,39 +29,31 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
-
 #include <windows.h>
-#include "SkTypeface.h"
+
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
-#include "third_party/blink/renderer/platform/graphics/graphics_context.h"
-#include "third_party/blink/renderer/platform/graphics/skia/skia_utils.h"
-#include "third_party/blink/renderer/platform/layout_test_support.h"
+#include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
+#include "third_party/blink/renderer/platform/web_test_support.h"
+#include "third_party/skia/include/core/SkFont.h"
+#include "third_party/skia/include/core/SkTypeface.h"
 
 namespace blink {
 
-// Maximum font size, in pixels, at which embedded bitmaps will be used
-// if available.
-const float kMaxSizeForEmbeddedBitmap = 24.0f;
+void FontPlatformData::SetupSkFont(SkFont* font,
+                                   float,
+                                   const FontDescription*) const {
+  font->setSize(SkFloatToScalar(text_size_));
+  font->setTypeface(typeface_);
+  font->setEmbolden(synthetic_bold_);
+  font->setSkewX(synthetic_italic_ ? -SK_Scalar1 / 4 : 0);
 
-void FontPlatformData::SetupPaintFont(PaintFont* font,
-                                      float,
-                                      const Font*) const {
-  const float ts = text_size_ >= 0 ? text_size_ : 12;
-  font->SetTextSize(SkFloatToScalar(text_size_));
-  font->SetTypeface(paint_typeface_);
-  font->SetFakeBoldText(synthetic_bold_);
-  font->SetTextSkewX(synthetic_italic_ ? -SK_Scalar1 / 4 : 0);
-
-  uint32_t text_flags = PaintTextFlags();
-  uint32_t flags = font->flags();
-  static const uint32_t kTextFlagsMask =
-      SkPaint::kAntiAlias_Flag | SkPaint::kLCDRenderText_Flag |
-      SkPaint::kEmbeddedBitmapText_Flag | SkPaint::kSubpixelText_Flag;
-  flags &= ~kTextFlagsMask;
-
-  if (ts <= kMaxSizeForEmbeddedBitmap)
-    flags |= SkPaint::kEmbeddedBitmapText_Flag;
+  if (style_.use_subpixel_rendering) {
+    font->setEdging(SkFont::Edging::kSubpixelAntiAlias);
+  } else if (style_.use_anti_alias) {
+    font->setEdging(SkFont::Edging::kAntiAlias);
+  } else {
+    font->setEdging(SkFont::Edging::kAlias);
+  }
 
   // Only use sub-pixel positioning if anti aliasing is enabled. Otherwise,
   // without font smoothing, subpixel text positioning leads to uneven spacing
@@ -69,55 +61,34 @@ void FontPlatformData::SetupPaintFont(PaintFont* font,
   // only has non-antialiased glyphs to draw, so they necessarily get clamped at
   // pixel positions, which leads to uneven spacing, either too close or too far
   // away from adjacent glyphs. We avoid this by linking the two flags.
-  if (text_flags & SkPaint::kAntiAlias_Flag)
-    flags |= SkPaint::kSubpixelText_Flag;
+  if (style_.use_anti_alias)
+    font->setSubpixel(true);
 
-  if (LayoutTestSupport::IsRunningLayoutTest() &&
-      !LayoutTestSupport::IsTextSubpixelPositioningAllowedForTest())
-    flags &= ~SkPaint::kSubpixelText_Flag;
+  if (WebTestSupport::IsRunningWebTest() &&
+      !WebTestSupport::IsTextSubpixelPositioningAllowedForTest())
+    font->setSubpixel(false);
 
-  SkASSERT(!(text_flags & ~kTextFlagsMask));
-  flags |= text_flags;
-
-  font->SetFlags(flags);
-
-  font->SetEmbeddedBitmapText(!avoid_embedded_bitmaps_);
+  font->setEmbeddedBitmaps(!avoid_embedded_bitmaps_);
 }
 
-static bool IsWebFont(const String& family_name) {
-  // Web-fonts have artifical names constructed to always be:
-  // 1. 24 characters, followed by a '\0'
-  // 2. the last two characters are '=='
-  return family_name.length() == 24 && '=' == family_name[22] &&
-         '=' == family_name[23];
-}
+WebFontRenderStyle FontPlatformData::QuerySystemForRenderStyle() {
+  WebFontRenderStyle style;
+  style.use_anti_alias = 0;
+  style.use_subpixel_rendering = 0;
 
-static int ComputePaintTextFlags(String font_family_name) {
-  if (LayoutTestSupport::IsRunningLayoutTest())
-    return LayoutTestSupport::IsFontAntialiasingEnabledForTest()
-               ? SkPaint::kAntiAlias_Flag
-               : 0;
-
-  int text_flags = 0;
-  if (FontCache::GetFontCache()->AntialiasedTextEnabled()) {
-    int lcd_flag = FontCache::GetFontCache()->LcdTextEnabled()
-                       ? SkPaint::kLCDRenderText_Flag
-                       : 0;
-    text_flags = SkPaint::kAntiAlias_Flag | lcd_flag;
+  if (WebTestSupport::IsRunningWebTest()) {
+    if (WebTestSupport::IsFontAntialiasingEnabledForTest())
+      style.use_anti_alias = 1;
+    return style;
   }
 
-  // Many web-fonts are so poorly hinted that they are terrible to read when
-  // drawn in BW.  In these cases, we have decided to FORCE these fonts to be
-  // drawn with at least grayscale AA, even when the System (getSystemTextFlags)
-  // tells us to draw only in BW.
-  if (IsWebFont(font_family_name))
-    text_flags |= SkPaint::kAntiAlias_Flag;
+  if (FontCache::GetFontCache()->AntialiasedTextEnabled()) {
+    style.use_anti_alias = 1;
+    if (FontCache::GetFontCache()->LcdTextEnabled())
+      style.use_subpixel_rendering = 1;
+  }
 
-  return text_flags;
-}
-
-void FontPlatformData::QuerySystemForRenderStyle() {
-  paint_text_flags_ = ComputePaintTextFlags(FontFamilyName());
+  return style;
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
new file mode 100644
index 000000000000..d8fa9c55ac4c
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
@@ -0,0 +1,202 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/files/file_path.h"
+#include "base/metrics/histogram_macros.h"
+#include "mojo/public/mojom/base/shared_memory.mojom-blink.h"
+#include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
+#include "third_party/blink/public/platform/platform.h"
+#include "third_party/blink/renderer/platform/runtime_enabled_features.h"
+#include "third_party/skia/include/ports/SkTypeface_win.h"
+
+namespace {
+
+// These enum values correspond to the
+// "Blink.Fonts.WindowsUniqueLocalFontInstantiationResult" histogram, new values
+// can be added, but old values should never be reused.
+enum class InstantiationResult {
+  kSuccess = 0,
+  kErrorOutsideWindowsFontsDirectory = 1,
+  kErrorOther = 2,
+  kMaxValue = kErrorOther,
+};
+
+}  // namespace
+
+namespace blink {
+
+FontUniqueNameLookupWin::FontUniqueNameLookupWin() = default;
+
+FontUniqueNameLookupWin::~FontUniqueNameLookupWin() = default;
+
+sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueName(
+    const String& font_unique_name) {
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups)
+    return MatchUniqueNameSingleLookup(font_unique_name);
+  return MatchUniqueNameLookupTable(font_unique_name);
+}
+
+sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
+    const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups);
+  base::FilePath font_file_path;
+  uint32_t ttc_index = 0;
+
+  EnsureServiceConnected();
+
+  bool matching_mojo_success =
+      service_->MatchUniqueFont(font_unique_name, &font_file_path, &ttc_index);
+  DCHECK(matching_mojo_success);
+
+  if (!font_file_path.value().size())
+    return nullptr;
+
+  return InstantiateFromPathAndTtcIndex(font_file_path, ttc_index);
+}
+
+sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameLookupTable(
+    const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  if (!IsFontUniqueNameLookupReadyForSyncLookup())
+    return nullptr;
+
+  base::Optional<FontTableMatcher::MatchResult> match_result =
+      font_table_matcher_->MatchName(font_unique_name.Utf8());
+  if (!match_result)
+    return nullptr;
+
+  base::FilePath file_path =
+      base::FilePath::FromUTF8Unsafe(match_result->font_path.c_str());
+  return InstantiateFromPathAndTtcIndex(file_path, match_result->ttc_index);
+}
+
+sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromPathAndTtcIndex(
+    base::FilePath font_file_path,
+    uint32_t ttc_index) {
+  // Record here when a locally uniquely matched font could not be
+  // instantiated. One reason could be that the font was outside the
+  // C:\Windows\Fonts directory and thus not accessible due to sandbox
+  // restrictions.
+  sk_sp<SkTypeface> local_typeface = SkTypeface::MakeFromFile(
+      font_file_path.AsUTF8Unsafe().c_str(), ttc_index);
+
+  InstantiationResult result = InstantiationResult::kSuccess;
+
+  // There is a chance that some systems have managed to register fonts into the
+  // Windows system font collection outside the C:\Windows\Fonts directory. For
+  // sandboxing reasons, we are unable to access them here. This histogram
+  // serves to quantify how often this case occurs and whether we need and
+  // additional sandbox helper to open the file handle on the browser process
+  // side.
+  if (!local_typeface) {
+    base::FilePath windows_fonts_path(L"C:\\WINDOWS\\FONTS");
+    if (!windows_fonts_path.IsParent(font_file_path))
+      result = InstantiationResult::kErrorOutsideWindowsFontsDirectory;
+    else
+      result = InstantiationResult::kErrorOther;
+  }
+
+  UMA_HISTOGRAM_ENUMERATION(
+      "Blink.Fonts.WindowsUniqueLocalFontInstantiationResult", result);
+
+  return local_typeface;
+}
+
+bool FontUniqueNameLookupWin::IsFontUniqueNameLookupReadyForSyncLookup() {
+  if (!RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled())
+    return true;
+
+  EnsureServiceConnected();
+
+  if (!lookup_mode_.has_value()) {
+    blink::mojom::UniqueFontLookupMode lookup_mode_from_mojo;
+    service_->GetUniqueFontLookupMode(&lookup_mode_from_mojo);
+    lookup_mode_ = lookup_mode_from_mojo;
+  }
+
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups) {
+    return true;
+  }
+
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  // If we have the table already, we're ready for sync lookups.
+  if (font_table_matcher_.get())
+    return true;
+
+  // We have previously determined via IPC whether the table is sync available.
+  // Return what we found out before.
+  if (sync_available_.has_value())
+    return sync_available_.value();
+
+  // If we haven't asked the browser before, probe synchronously - if the table
+  // is available on the browser side, we can continue with sync operation.
+
+  bool sync_available_from_mojo = false;
+  base::ReadOnlySharedMemoryRegion shared_memory_region;
+  service_->GetUniqueNameLookupTableIfAvailable(&sync_available_from_mojo,
+                                                &shared_memory_region);
+  sync_available_ = sync_available_from_mojo;
+
+  if (*sync_available_) {
+    // Adopt the shared memory region, do not notify anyone in callbacks as
+    // PrepareFontUniqueNameLookup must not have been called yet. Just return
+    // true from this function.
+    DCHECK_EQ(pending_callbacks_.size(), 0u);
+    ReceiveReadOnlySharedMemoryRegion(std::move(shared_memory_region));
+  }
+
+  // If it wasn't available synchronously LocalFontFaceSource has to call
+  // PrepareFontUniqueNameLookup.
+  return *sync_available_;
+}
+
+void FontUniqueNameLookupWin::EnsureServiceConnected() {
+  if (service_)
+    return;
+  Platform::Current()->GetBrowserInterfaceBroker()->GetInterface(
+      service_.BindNewPipeAndPassReceiver());
+}
+
+void FontUniqueNameLookupWin::PrepareFontUniqueNameLookup(
+    NotifyFontUniqueNameLookupReady callback) {
+  DCHECK(!font_table_matcher_.get());
+  DCHECK(RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled());
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  pending_callbacks_.push_back(std::move(callback));
+
+  // We bind the service on the first call to PrepareFontUniqueNameLookup. After
+  // that we do not need to make additional IPC requests to retrieve the table.
+  // The observing callback was added to the list, so all clients will be
+  // informed when the lookup table has arrived.
+  if (pending_callbacks_.size() > 1)
+    return;
+
+  EnsureServiceConnected();
+
+  service_->GetUniqueNameLookupTable(base::BindOnce(
+      &FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion,
+      base::Unretained(this)));
+}
+
+void FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion(
+    base::ReadOnlySharedMemoryRegion shared_memory_region) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+  font_table_matcher_ =
+      std::make_unique<FontTableMatcher>(shared_memory_region.Map());
+  while (!pending_callbacks_.IsEmpty()) {
+    NotifyFontUniqueNameLookupReady callback = pending_callbacks_.TakeFirst();
+    std::move(callback).Run();
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
new file mode 100644
index 000000000000..eb7c881a05df
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
@@ -0,0 +1,58 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FONT_UNIQUE_NAME_LOOKUP_WIN_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FONT_UNIQUE_NAME_LOOKUP_WIN_H_
+
+#include "mojo/public/cpp/bindings/remote.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
+#include "third_party/blink/renderer/platform/fonts/font_unique_name_lookup.h"
+#include "third_party/blink/renderer/platform/wtf/deque.h"
+
+namespace blink {
+
+// Performs the IPC towards the browser process for font unique name
+// matching. This class operates in one of two lookup modes, depending on
+// lookup_mode_. On Windows 10 or when IDWriteFontFactory3 is available, direct
+// individual sync Mojo IPC calls are made too lookup fonts - and the class
+// reponds synchronously.  On Windows 7 & 8, a shared memory region is retrieved
+// asynchronously, then lookups are performed against that table. When the
+// asynchronous request to retrieve the table completes, the clients are
+// notified. And once the table was retrieved, this class returns to operating
+// in synchronous mode as matching can be performed instantly.
+class FontUniqueNameLookupWin : public FontUniqueNameLookup {
+ public:
+  FontUniqueNameLookupWin();
+  ~FontUniqueNameLookupWin() override;
+  sk_sp<SkTypeface> MatchUniqueName(const String& font_unique_name) override;
+
+  bool IsFontUniqueNameLookupReadyForSyncLookup() override;
+
+  void PrepareFontUniqueNameLookup(
+      NotifyFontUniqueNameLookupReady callback) override;
+
+ private:
+  void EnsureServiceConnected();
+
+  sk_sp<SkTypeface> MatchUniqueNameLookupTable(const String& font_unique_name);
+  sk_sp<SkTypeface> MatchUniqueNameSingleLookup(const String& font_unique_name);
+
+  sk_sp<SkTypeface> InstantiateFromPathAndTtcIndex(
+      base::FilePath font_file_path,
+      uint32_t ttc_index);
+
+  mojo::Remote<mojom::blink::DWriteFontProxy> service_;
+  WTF::Deque<NotifyFontUniqueNameLookupReady> pending_callbacks_;
+  base::Optional<blink::mojom::UniqueFontLookupMode> lookup_mode_;
+  base::Optional<bool> sync_available_;
+  void ReceiveReadOnlySharedMemoryRegion(
+      base::ReadOnlySharedMemoryRegion shared_memory_region);
+
+  DISALLOW_COPY_AND_ASSIGN(FontUniqueNameLookupWin);
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FONT_UNIQUE_NAME_LOOKUP_WIN_H_
diff --git a/third_party/expat/0001-Do-not-claim-getrandom.patch b/third_party/expat/0001-Do-not-claim-getrandom.patch
new file mode 100644
index 000000000000..df931d25af72
--- /dev/null
+++ b/third_party/expat/0001-Do-not-claim-getrandom.patch
@@ -0,0 +1,22 @@
+diff --git a/third_party/expat/include/expat_config/expat_config.h b/third_party/expat/include/expat_config/expat_config.h
+index 278d7a8..c693a14a 100644
+--- a/third_party/expat/include/expat_config/expat_config.h
++++ b/third_party/expat/include/expat_config/expat_config.h
+@@ -23,7 +23,7 @@
+ #define HAVE_GETPAGESIZE 1
+ 
+ /* Define to 1 if you have the `getrandom' function. */
+-#define HAVE_GETRANDOM 1
++/* #define HAVE_GETRANDOM 1 */
+ 
+ /* Define to 1 if you have the <inttypes.h> header file. */
+ #define HAVE_INTTYPES_H 1
+@@ -50,7 +50,7 @@
+ #define HAVE_STRING_H 1
+ 
+ /* Define to 1 if you have `syscall' and `SYS_getrandom'. */
+-#define HAVE_SYSCALL_GETRANDOM 1
++/* #define HAVE_SYSCALL_GETRANDOM 1 */
+ 
+ /* Define to 1 if you have the <sys/param.h> header file. */
+ #define HAVE_SYS_PARAM_H 1
diff --git a/third_party/expat/0001-Expat-external-symbol-visibility.patch b/third_party/expat/0001-Expat-external-symbol-visibility.patch
deleted file mode 100644
index d8fbadff66de..000000000000
--- a/third_party/expat/0001-Expat-external-symbol-visibility.patch
+++ /dev/null
@@ -1,26 +0,0 @@
-From 7ee3787b1e73a381f5fd5314f7059f0c680115b5 Mon Sep 17 00:00:00 2001
-From: Dominic Cooney <dominicc@chromium.org>
-Date: Thu, 10 Aug 2017 15:07:02 +0900
-Subject: [PATCH] Expat external symbol visibility.
-
----
- third_party/expat/files/lib/expat_external.h | 3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
-diff --git a/third_party/expat/files/lib/expat_external.h b/third_party/expat/files/lib/expat_external.h
-index 892eb4bbed71..292014daf786 100644
---- a/third_party/expat/files/lib/expat_external.h
-+++ b/third_party/expat/files/lib/expat_external.h
-@@ -65,7 +65,8 @@
- #endif
- #endif  /* not defined XML_STATIC */
- 
--#if !defined(XMLIMPORT) && defined(__GNUC__) && (__GNUC__ >= 4)
-+/* Don't change symbol visibility if used as a static link libraray */
-+#if !defined(XML_STATIC) && !defined(XMLIMPORT) && defined(__GNUC__) && (__GNUC__ >= 4)
- #define XMLIMPORT __attribute__ ((visibility ("default")))
- #endif
- 
--- 
-2.14.0.434.g98096fd7a8-goog
-
diff --git a/third_party/expat/0002-Do-not-redefine-lean-and-mean.patch b/third_party/expat/0002-Do-not-redefine-lean-and-mean.patch
deleted file mode 100644
index 595e071f4bfc..000000000000
--- a/third_party/expat/0002-Do-not-redefine-lean-and-mean.patch
+++ /dev/null
@@ -1,26 +0,0 @@
-From 98180a6d1333d62175ce553cdecce110009b86bc Mon Sep 17 00:00:00 2001
-From: Dominic Cooney <dominicc@chromium.org>
-Date: Thu, 10 Aug 2017 17:39:39 +0900
-Subject: [PATCH] Do not redefine lean and mean.
-
----
- third_party/expat/files/lib/winconfig.h | 2 ++
- 1 file changed, 2 insertions(+)
-
-diff --git a/third_party/expat/files/lib/winconfig.h b/third_party/expat/files/lib/winconfig.h
-index 9bf014d7fbab..125b6b332406 100644
---- a/third_party/expat/files/lib/winconfig.h
-+++ b/third_party/expat/files/lib/winconfig.h
-@@ -10,7 +10,9 @@
- #ifndef WINCONFIG_H
- #define WINCONFIG_H
- 
-+#ifndef WIN32_LEAN_AND_MEAN
- #define WIN32_LEAN_AND_MEAN
-+#endif
- #include <windows.h>
- #undef WIN32_LEAN_AND_MEAN
- 
--- 
-2.14.0.434.g98096fd7a8-goog
-
diff --git a/third_party/expat/0003-Add-missing-include-for-malloc-free.patch b/third_party/expat/0003-Add-missing-include-for-malloc-free.patch
deleted file mode 100644
index 55201b5b9d6c..000000000000
--- a/third_party/expat/0003-Add-missing-include-for-malloc-free.patch
+++ /dev/null
@@ -1,24 +0,0 @@
-From 5e60caed029825a7e5d2d1d30af446612ad34d6c Mon Sep 17 00:00:00 2001
-From: Dominic Cooney <dominicc@chromium.org>
-Date: Mon, 14 Aug 2017 10:44:50 +0900
-Subject: [PATCH] Add missing include for malloc/free.
-
----
- third_party/expat/files/lib/loadlibrary.c | 1 +
- 1 file changed, 1 insertion(+)
-
-diff --git a/third_party/expat/files/lib/loadlibrary.c b/third_party/expat/files/lib/loadlibrary.c
-index ffce868399b3..d05bf59c4537 100644
---- a/third_party/expat/files/lib/loadlibrary.c
-+++ b/third_party/expat/files/lib/loadlibrary.c
-@@ -31,6 +31,7 @@
- #if defined(_WIN32)
- 
- #include <windows.h>
-+#include <stdlib.h>
- #include <tchar.h>
- 
- 
--- 
-2.14.0.434.g98096fd7a8-goog
-
diff --git a/third_party/expat/0004-Remove-truncating-cast-of-constant.patch b/third_party/expat/0004-Remove-truncating-cast-of-constant.patch
deleted file mode 100644
index a17b5ccc81f9..000000000000
--- a/third_party/expat/0004-Remove-truncating-cast-of-constant.patch
+++ /dev/null
@@ -1,25 +0,0 @@
-From cb2bfbc298b8b7561bbe8d055785be8682323ca5 Mon Sep 17 00:00:00 2001
-From: Dominic Cooney <dominicc@chromium.org>
-Date: Mon, 14 Aug 2017 11:54:45 +0900
-Subject: [PATCH] Remove truncating cast of constant.
-
----
- third_party/expat/files/lib/xmlparse.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/third_party/expat/files/lib/xmlparse.c b/third_party/expat/files/lib/xmlparse.c
-index b703e61a0404..6d8dc1e33591 100644
---- a/third_party/expat/files/lib/xmlparse.c
-+++ b/third_party/expat/files/lib/xmlparse.c
-@@ -951,7 +951,7 @@ generate_hash_secret_salt(XML_Parser parser)
-     return ENTROPY_DEBUG("fallback(4)", entropy * 2147483647);
-   } else {
-     return ENTROPY_DEBUG("fallback(8)",
--        entropy * (unsigned long)2305843009213693951ULL);
-+        (unsigned long)(entropy * 2305843009213693951ULL));
-   }
- #endif
- }
--- 
-2.14.0.434.g98096fd7a8-goog
-
diff --git a/third_party/expat/0005-Fix-Win-Clang-Wsign-compare-warning.patch b/third_party/expat/0005-Fix-Win-Clang-Wsign-compare-warning.patch
deleted file mode 100644
index 0a543bff1687..000000000000
--- a/third_party/expat/0005-Fix-Win-Clang-Wsign-compare-warning.patch
+++ /dev/null
@@ -1,25 +0,0 @@
-commit 85c5c356b9409cd92220519aab3ba88b5edd16e6
-Author: Hans Wennborg <hans@chromium.org>
-Date:   Mon Oct 23 08:54:35 2017 -0700
-
-    Fix Win/Clang -Wsign-compare warning
-    
-    enums are backed by signed integers by default on Windows, and Clang
-    (after r316268) would warn about comparing 'code', which is signed, with
-    sizeof(..) which is unsigned.
-    
-    Bug: 777363
-
-diff --git a/third_party/expat/files/lib/xmlparse.c b/third_party/expat/files/lib/xmlparse.c
-index 6d8dc1e33591..6ff81029ce29 100644
---- a/third_party/expat/files/lib/xmlparse.c
-+++ b/third_party/expat/files/lib/xmlparse.c
-@@ -2426,7 +2426,7 @@ XML_ErrorString(enum XML_Error code)
-     XML_L("reserved prefix (xmlns) must not be declared or undeclared"),
-     XML_L("prefix must not be bound to one of the reserved namespace names")
-   };
--  if (code > 0 && code < sizeof(message)/sizeof(message[0]))
-+  if (code > 0 && (size_t)code < sizeof(message)/sizeof(message[0]))
-     return message[code];
-   return NULL;
- }
diff --git a/third_party/expat/BUILD.gn b/third_party/expat/BUILD.gn
index f2f8514aed3a..2dc7964a8686 100644
--- a/third_party/expat/BUILD.gn
+++ b/third_party/expat/BUILD.gn
@@ -9,7 +9,7 @@ import("//testing/libfuzzer/fuzzer_test.gni")
 # let's not pull it in twice.
 # Chromecast doesn't ship expat as a system library.
 # Libfuzzer and AFL need to build library from sources.
-if (is_linux && !is_chromecast && !use_fuzzing_engine) {
+if ((is_linux || is_chromeos) && !is_chromecast && !use_fuzzing_engine) {
   config("expat_config") {
     libs = [ "expat" ]
   }
@@ -18,29 +18,33 @@ if (is_linux && !is_chromecast && !use_fuzzing_engine) {
     public_configs = [ ":expat_config" ]
   }
 } else {
-  config("expat_config") {
-    include_dirs = [ "files/lib" ]
+  config("expat_public_config") {
+    include_dirs = [
+      "src/expat/lib",
+      "include/expat_config",
+    ]
     defines = [ "XML_STATIC" ]
   }
+  config("expat_internal_config") {
+    # xmlparse.c has some |if (0 && ...)| statements.
+    cflags = [ "-Wno-unreachable-code" ]
+  }
 
   static_library("expat") {
     sources = [
-      "files/lib/expat.h",
-      "files/lib/loadlibrary.c",
-      "files/lib/xmlparse.c",
-      "files/lib/xmlrole.c",
-      "files/lib/xmltok.c",
+      "src/expat/lib/expat.h",
+      "src/expat/lib/xmlparse.c",
+      "src/expat/lib/xmlrole.c",
+      "src/expat/lib/xmltok.c",
     ]
 
-    public_configs = [ ":expat_config" ]
-
-    # TODO(thakis): Remove this once clang no longer crashes when building
-    # libexpat with -Oz.
-    configs -= [ "//build/config/compiler:default_optimization" ]
-    configs += [ "//build/config/compiler:optimize_max" ]
+    public_configs = [ ":expat_public_config" ]
+    configs += [ ":expat_internal_config" ]
 
     defines = [ "_LIB" ]
     if (is_win) {
+      # expat expects to define WIN32_LEAN_AND_MEAN itself
+      configs -= [ "//build/config/win:lean_and_mean" ]
       defines += [ "COMPILED_FROM_DSP" ]
     } else {
       defines += [ "HAVE_EXPAT_CONFIG_H" ]
@@ -49,11 +53,8 @@ if (is_linux && !is_chromecast && !use_fuzzing_engine) {
 }
 
 fuzzer_test("expat_xml_parse_fuzzer") {
-  sources = [
-    "fuzz/expat_xml_parse_fuzzer.cc",
-  ]
-  deps = [
-    ":expat",
-  ]
-  dict = "//testing/libfuzzer/fuzzers/dicts/xml.dict"
+  sources = [ "fuzz/expat_xml_parse_fuzzer.cc" ]
+  deps = [ ":expat" ]
+  dict = "//third_party/libxml/fuzz/xml.dict"
+  seed_corpus = "//third_party/libxml/fuzz/seed_corpus"
 }
diff --git a/third_party/expat/DIR_METADATA b/third_party/expat/DIR_METADATA
new file mode 100644
index 000000000000..a224a6417178
--- /dev/null
+++ b/third_party/expat/DIR_METADATA
@@ -0,0 +1,4 @@
+monorail {
+  component: "Blink>XML"
+}
+team_email: "skia-discuss@googlegroups.com"
diff --git a/third_party/expat/OWNERS b/third_party/expat/OWNERS
index 9b4088909861..ae8e6d39f284 100644
--- a/third_party/expat/OWNERS
+++ b/third_party/expat/OWNERS
@@ -1,2 +1,2 @@
-nick@chromium.org
-dominicc@chromium.org
+bungeman@chromium.org
+dcheng@chromium.org
\ No newline at end of file
diff --git a/third_party/expat/README.chromium b/third_party/expat/README.chromium
index f7cf556316d6..e10862aa3c08 100644
--- a/third_party/expat/README.chromium
+++ b/third_party/expat/README.chromium
@@ -1,50 +1,36 @@
 Name: Expat XML Parser
 Short Name: expat
-URL: http://sourceforge.net/projects/expat/
-Version: 2.2.3
-License: MIT
-License File: files/COPYING
+URL: https://github.com/libexpat/libexpat
+Version: R_2_2_9-91-ge976867
+CPEPrefix: cpe:/a:libexpat:expat:2.2.9
+Date: 20200420
+Revision: e976867fb57a0cd87e3b0fe05d59e0ed63c6febb
 Security Critical: yes
+License: MIT
+License File: src/expat/COPYING
 
 Description:
   This is Expat XML parser - very lightweight C library for parsing XML.
-  Expat is distributed under an MIT license detailed in files/COPYING.
+  Expat is distributed under an MIT license detailed in src/expat/COPYING.
 
   We include it here because libjingle depends on it.
 
-Local Modifications:
-  Removed files that Chromium didn't need:
-    CMake.README
-    CMakeLists.txt
-    ConfigureChecks.cmake
-    Makefile.in
-    aclocal.m4
-    configure
-    configure.ac
-    conftools/
-    doc/
-    examples/
-    expat.pc.in
-    expat_config.h.cmake
-    expat_config.h.in
-    m4/
-    run.sh.in
-    tests/
-    win32/
-    xmlwf/
+Roll process:
+  cd $CHROMIUM_SRC
+  roll-dep --roll-to origin/upstream/master src/third_party/expat/src/
+  cd $CHROMIUM_SRC/third_party/expat/src/expat
+  ./buildconf.sh
+  ./configure
+  cp expat_config.h $CHROMIUM_SRC/third_party/expat/include/expat_config/
+  cd $CHROMIUM_SRC/third_party/expat
+  patch -p3 < 0001-Do-not-claim-getrandom.patch
+
+  Then update the README.chromium and BUILD.gn as needed.
+  This can usually by handled by running roll-expat.sh from $CHROMIUM_SRC.
 
 Patches:
-    0001-Expat-external-symbol-visibility.patch:
-      * Disallow adding symbol visibility attribute automatically to
-        function for static linked library.
-    0002-Do-not-redefine-lean-and-mean.patch:
-      * Do not redefine WIN32_LEAN_AND_MEAN which breaks the Windows
-        build because it uses -Werror,-Wmacro-redefined .
-    0003-Add-missing-include-for-malloc-free.patch:
-      * Include stdlib.h for declaration of malloc, free.
-    0004-Remove-truncating-cast-of-constant.patch:
-      * Truncate after multiplying when doing random number stuff.
-    0005-Fix-Win-Clang-Wsign-compare-warning.patch
-      * Adds a cast to fix Clang -Wsign-compare warning.
-  Added files:
-    lib/expat_config.h (a generated config file)
+    0001-Do-not-claim-getrandom.patch:
+      * Not all platforms have getrandom.
+
+Added files:
+  include/expat_config/expat_config.h (a generated config file)
diff --git a/third_party/expat/files/AUTHORS b/third_party/expat/files/AUTHORS
deleted file mode 100644
index 99475bb1b2ef..000000000000
--- a/third_party/expat/files/AUTHORS
+++ /dev/null
@@ -1,10 +0,0 @@
-Expat is brought to you by:
-
-Clark Cooper
-Fred L. Drake, Jr.
-Greg Stein
-James Clark
-Karl Waclawek
-Rhodri James
-Sebastian Pipping
-Steven Solie
diff --git a/third_party/expat/files/COPYING b/third_party/expat/files/COPYING
deleted file mode 100644
index 8d288f0f28fd..000000000000
--- a/third_party/expat/files/COPYING
+++ /dev/null
@@ -1,21 +0,0 @@
-Copyright (c) 1998-2000 Thai Open Source Software Center Ltd and Clark Cooper
-Copyright (c) 2001-2017 Expat maintainers
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/third_party/expat/files/Changes b/third_party/expat/files/Changes
deleted file mode 100644
index 147f48288aaa..000000000000
--- a/third_party/expat/files/Changes
+++ /dev/null
@@ -1,479 +0,0 @@
-NOTE: We are looking for help with a few things:
-      https://github.com/libexpat/libexpat/labels/help%20wanted
-      If you can help, please get in touch.  Thanks!
-
-Release 2.2.3 Wed August 2 2017
-        Security fixes:
-             #82  CVE-2017-11742 -- Windows: Fix DLL hijacking vulnerability
-                    using Steve Holme's LoadLibrary wrapper for/of cURL
-
-        Bug fixes:
-             #85  Fix a dangling pointer issue related to realloc
-
-        Other changes:
-                  Increase code coverage
-             #91  Linux: Allow getrandom to fail if nonblocking pool has not
-                    yet been initialized and read /dev/urandom then, instead.
-                    This is in line with what recent Python does.
-             #81  Pre-10.7/Lion macOS: Support entropy from arc4random
-             #86  Check that a UTF-16 encoding in an XML declaration has the
-                    right endianness
-        #4 #5 #7  Recover correctly when some reallocations fail
-                  Repair "./configure && make" for systems without any
-                    provider of high quality entropy
-                    and try reading /dev/urandom on those
-                  Ensure that user-defined character encodings have converter
-                    functions when they are needed
-                  Fix mis-leading description of argument -c in xmlwf.1
-                  Rely on macro HAVE_ARC4RANDOM_BUF (rather than __CloudABI__)
-                    for CloudABI
-            #100  Fix use of SIPHASH_MAIN in siphash.h
-             #23  Test suite: Fix memory leaks
-                  Version info bumped from 7:4:6 to 7:5:6
-
-        Special thanks to:
-            Chanho Park
-            Joe Orton
-            Pascal Cuoq
-            Rhodri James
-            Simon McVittie
-            Vadim Zeitlin
-            Viktor Szakats
-                 and
-            Core Infrastructure Initiative
-
-Release 2.2.2 Wed July 12 2017
-        Security fixes:
-             #43  Protect against compilation without any source of high
-                    quality entropy enabled, e.g. with CMake build system;
-                    commit ff0207e6076e9828e536b8d9cd45c9c92069b895
-             #60  Windows with _UNICODE:
-                    Unintended use of LoadLibraryW with a non-wide string
-                    resulted in failure to load advapi32.dll and degradation
-                    in quality of used entropy when compiled with _UNICODE for
-                    Windows; you can launch existing binaries with
-                    EXPAT_ENTROPY_DEBUG=1 in the environment to inspect the
-                    quality of entropy used during runtime; commits
-                    * 95b95032f907ef1cd17ee7a9a1768010a825d61d
-                    * 73a5a2e9c081f49f2d775cf7ced864158b68dc80
-   [MOX-006]      Fix non-NULL parser parameter validation in XML_Parse;
-                    resulted in NULL dereference, previously;
-                    commit ac256dafdffc9622ab0dc2c62fcecb0dfcfa71fe
-
-        Bug fixes:
-             #69  Fix improper use of unsigned long long integer literals
-
-        Other changes:
-             #73  Start requiring a C99 compiler
-             #49  Fix "==" Bashism in configure script
-             #50  Fix too eager getrandom detection for Debian GNU/kFreeBSD
-             #52    and macOS
-             #51  Address lack of stdint.h in Visual Studio 2003 to 2008
-             #58  Address compile warnings
-             #68  Fix "./buildconf.sh && ./configure" for some versions
-                    of Dash for /bin/sh
-             #72  CMake: Ease use of Expat in context of a parent project
-                    with multipe CMakeLists.txt files
-             #72  CMake: Resolve mistaken executable permissions
-             #76  Address compile warning with -DNDEBUG (not recommended!)
-             #77  Address compile warning about macro redefinition
-
-        Special thanks to:
-            Alexander Bluhm
-            Ben Boeckel
-            Ctlin Rceanu
-            Kerin Millar
-            Lszl Bszrmnyi
-            S. P. Zeidler
-            Segev Finer
-            Vclav Slavk
-            Victor Stinner
-            Viktor Szakats
-                 and
-            Radically Open Security
-
-Release 2.2.1 Sat June 17 2017
-        Security fixes:
-                  CVE-2017-9233 -- External entity infinite loop DoS
-                    Details: https://libexpat.github.io/doc/cve-2017-9233/
-                    Commit c4bf96bb51dd2a1b0e185374362ee136fe2c9d7f
-   [MOX-002]      CVE-2016-9063 -- Detect integer overflow; commit
-                    d4f735b88d9932bd5039df2335eefdd0723dbe20
-                    (Fixed version of existing downstream patches!)
-   (SF.net) #539  Fix regression from fix to CVE-2016-0718 cutting off
-                    longer tag names; commits
-                    * 896b6c1fd3b842f377d1b62135dccf0a579cf65d
-                    * af507cef2c93cb8d40062a0abe43a4f4e9158fb2
-             #16    * 0dbbf43fdb20f593ddf4fa1ff67288000dd4a7fd
-             #25  More integer overflow detection (function poolGrow); commits
-                    * 810b74e4703dcfdd8f404e3cb177d44684775143
-                    * 44178553f3539ce69d34abee77a05e879a7982ac
-   [MOX-002]      Detect overflow from len=INT_MAX call to XML_Parse; commits
-                    * 4be2cb5afcc018d996f34bbbce6374b7befad47f
-                    * 7e5b71b748491b6e459e5c9a1d090820f94544d8
-   [MOX-005] #30  Use high quality entropy for hash initialization:
-                    * arc4random_buf on BSD, systems with libbsd
-                      (when configured with --with-libbsd), CloudABI
-                    * RtlGenRandom on Windows XP / Server 2003 and later
-                    * getrandom on Linux 3.17+
-                    In a way, that's still part of CVE-2016-5300.
-                    https://github.com/libexpat/libexpat/pull/30/commits
-   [MOX-005]      For the low quality entropy extraction fallback code,
-                    the parser instance address can no longer leak, commit
-                    04ad658bd3079dd15cb60fc67087900f0ff4b083
-   [MOX-003]      Prevent use of uninitialised variable; commit
-   [MOX-004]        a4dc944f37b664a3ca7199c624a98ee37babdb4b
-                  Add missing parameter validation to public API functions
-                    and dedicated error code XML_ERROR_INVALID_ARGUMENT:
-   [MOX-006]        * NULL checks; commits
-                      * d37f74b2b7149a3a95a680c4c4cd2a451a51d60a (merge/many)
-                      * 9ed727064b675b7180c98cb3d4f75efba6966681
-                      * 6a747c837c50114dfa413994e07c0ba477be4534
-                    * Negative length (XML_Parse); commit
-   [MOX-002]          70db8d2538a10f4c022655d6895e4c3e78692e7f
-   [MOX-001] #35  Change hash algorithm to William Ahern's version of SipHash
-                    to go further with fixing CVE-2012-0876.
-                    https://github.com/libexpat/libexpat/pull/39/commits
-
-        Bug fixes:
-             #32  Fix sharing of hash salt across parsers;
-                    relevant where XML_ExternalEntityParserCreate is called
-                    prior to XML_Parse, in particular (e.g. FBReader)
-             #28  xmlwf: Auto-disable use of memory-mapping (and parsing
-                    as a single chunk) for files larger than ~1 GB (2^30 bytes)
-                    rather than failing with error "out of memory"
-              #3  Fix double free after malloc failure in DTD code; commit
-                    7ae9c3d3af433cd4defe95234eae7dc8ed15637f
-             #17  Fix memory leak on parser error for unbound XML attribute
-                    prefix with new namespaces defined in the same tag;
-                    found by Google's OSS-Fuzz; commits
-                    * 16f87daae5a16132e479e4f71862128c7a915c73
-                    * b47dbc9745932c160893d433220e462bd605f8cd
-                  xmlwf on Windows: Add missing calls to CloseHandle
-
-        New features:
-             #30  Introduced environment switch EXPAT_ENTROPY_DEBUG=1
-                    for runtime debugging of entropy extraction
-
-        Other changes:
-                  Increase code coverage
-             #33  Reject use of XML_UNICODE_WCHAR_T with sizeof(wchar_t) != 2;
-                    XML_UNICODE_WCHAR_T was never meant to be used outside
-                    of Windows; 4-byte wchar_t is common on Linux
-   (SF.net) #538  Start using -fno-strict-aliasing
-   (SF.net) #540  Support compilation against cloudlibc of CloudABI
-                  Allow MinGW cross-compilation
-   (SF.net) #534  CMake: Introduce option "BUILD_doc" (enabled by default)
-                    to bypass compilation of the xmlwf.1 man page
-   (SF.net)  pr2  CMake: Introduce option "INSTALL" (enabled by default)
-                    to bypass installation of expat files
-                  CMake: Fix ninja support
-                  Autotools: Add parameters --enable-xml-context [COUNT]
-                    and --disable-xml-context; default of context of 1024
-                    bytes enabled unchanged
-             #14  Drop AmigaOS 4.x code and includes
-             #14  Drop ancient build systems:
-                    * Borland C++ Builder
-                    * OpenVMS
-                    * Open Watcom
-                    * Visual Studio 6.0
-                    * Pre-X Mac OS (MPW Makefile)
-                    If you happen to rely on some of these, please get in
-                    touch for joining with maintenance.
-             #10  Move from WIN32 to _WIN32
-             #13  Fix "make run-xmltest" order instability
-                  Address compile warnings
-                  Bump version info from 7:2:6 to 7:3:6
-                  Add AUTHORS file
-
-        Infrastructure:
-              #1  Migrate from SourceForge to GitHub (except downloads):
-                    https://github.com/libexpat/
-              #1  Re-create http://libexpat.org/ project website
-                  Start utilizing Travis CI
-
-        Special thanks to:
-            Andy Wang
-            Don Lewis
-            Ed Schouten
-            Karl Waclawek
-            Pascal Cuoq
-            Rhodri James
-            Sergei Nikulov
-            Tobias Taschner
-            Viktor Szakats
-                 and
-            Core Infrastructure Initiative
-            Mozilla Foundation (MOSS Track 3: Secure Open Source)
-            Radically Open Security
-
-Release 2.2.0 Tue June 21 2016
-        Security fixes:
-            #537  CVE-2016-0718 -- Fix crash on malformed input
-                  CVE-2016-4472 -- Improve insufficient fix to CVE-2015-1283 /
-                                   CVE-2015-2716 introduced with Expat 2.1.1
-            #499  CVE-2016-5300 -- Use more entropy for hash initialization
-                                   than the original fix to CVE-2012-0876
-            #519  CVE-2012-6702 -- Resolve troublesome internal call to srand
-                                   that was introduced with Expat 2.1.0
-                                   when addressing CVE-2012-0876 (issue #496)
-
-        Bug fixes:
-                  Fix uninitialized reads of size 1
-                    (e.g. in little2_updatePosition)
-                  Fix detection of UTF-8 character boundaries
-
-        Other changes:
-            #532  Fix compilation for Visual Studio 2010 (keyword "C99")
-                  Autotools: Resolve use of "$<" to better support bmake
-                  Autotools: Add QA script "qa.sh" (and make target "qa")
-                  Autotools: Respect CXXFLAGS if given
-                  Autotools: Fix "make run-xmltest"
-                  Autotools: Have "make run-xmltest" check for expected output
-             p90  CMake: Fix static build (BUILD_shared=OFF) on Windows
-            #536  CMake: Add soversion, support -DNO_SONAME=yes to bypass
-            #323  CMake: Add suffix "d" to differentiate debug from release
-                  CMake: Define WIN32 with CMake on Windows
-                  Annotate memory allocators for GCC
-                  Address all currently known compile warnings
-                  Make sure that API symbols remain visible despite
-                    -fvisibility=hidden
-                  Remove executable flag from source files
-                  Resolve COMPILED_FROM_DSP in favor of WIN32
-
-        Special thanks to:
-            Bjrn Lindahl
-            Christian Heimes
-            Cristian Rodrguez
-            Daniel Krgler
-            Gustavo Grieco
-            Karl Waclawek
-            Lszl Bszrmnyi
-            Marco Grassi
-            Pascal Cuoq
-            Sergei Nikulov
-            Thomas Beutlich
-            Warren Young
-            Yann Droneaud
-
-Release 2.1.1 Sat March 12 2016
-        Security fixes:
-            #582: CVE-2015-1283 - Multiple integer overflows in XML_GetBuffer
-
-        Bug fixes:
-            #502: Fix potential null pointer dereference
-            #520: Symbol XML_SetHashSalt was not exported
-            Output of "xmlwf -h" was incomplete
-
-        Other changes:
-            #503: Document behavior of calling XML_SetHashSalt with salt 0
-            Minor improvements to man page xmlwf(1)
-            Improvements to the experimental CMake build system
-            libtool now invoked with --verbose
-
-Release 2.1.0 Sat March 24 2012
-        - Security fixes:
-          #2958794: CVE-2012-1148 - Memory leak in poolGrow.
-          #2895533: CVE-2012-1147 - Resource leak in readfilemap.c.
-          #3496608: CVE-2012-0876 - Hash DOS attack.
-          #2894085: CVE-2009-3560 - Buffer over-read and crash in big2_toUtf8().
-          #1990430: CVE-2009-3720 - Parser crash with special UTF-8 sequences.
-        - Bug Fixes:
-          #1742315: Harmful XML_ParserCreateNS suggestion.
-          #1785430: Expat build fails on linux-amd64 with gcc version>=4.1 -O3.
-          #1983953, 2517952, 2517962, 2649838: 
-                Build modifications using autoreconf instead of buildconf.sh.
-          #2815947, #2884086: OBJEXT and EXEEXT support while building.
-          #2517938: xmlwf should return non-zero exit status if not well-formed.
-          #2517946: Wrong statement about XMLDecl in xmlwf.1 and xmlwf.sgml.
-          #2855609: Dangling positionPtr after error.
-          #2990652: CMake support.
-          #3010819: UNEXPECTED_STATE with a trailing "%" in entity value.
-          #3206497: Unitialized memory returned from XML_Parse.
-          #3287849: make check fails on mingw-w64.
-        - Patches:
-          #1749198: pkg-config support.
-          #3010222: Fix for bug #3010819.
-          #3312568: CMake support.
-          #3446384: Report byte offsets for attr names and values.
-        - New Features / API changes:
-          Added new API member XML_SetHashSalt() that allows setting an initial
-                value (salt) for hash calculations. This is part of the fix for
-                bug #3496608 to randomize hash parameters.
-          When compiled with XML_ATTR_INFO defined, adds new API member
-                XML_GetAttributeInfo() that allows retrieving the byte
-                offsets for attribute names and values (patch #3446384).
-          Added CMake build system.
-                See bug #2990652 and patch #3312568.
-          Added run-benchmark target to Makefile.in - relies on testdata module
-                present in the same relative location as in the repository.
-          
-Release 2.0.1 Tue June 5 2007
-        - Fixed bugs #1515266, #1515600: The character data handler's calling
-          of XML_StopParser() was not handled properly; if the parser was
-          stopped and the handler set to NULL, the parser would segfault.
-        - Fixed bug #1690883: Expat failed on EBCDIC systems as it assumed
-          some character constants to be ASCII encoded.
-        - Minor cleanups of the test harness.
-        - Fixed xmlwf bug #1513566: "out of memory" error on file size zero.
-        - Fixed outline.c bug #1543233: missing a final XML_ParserFree() call.
-        - Fixes and improvements for Windows platform:
-          bugs #1409451, #1476160, #1548182, #1602769, #1717322.
-        - Build fixes for various platforms:
-          HP-UX, Tru64, Solaris 9: patch #1437840, bug #1196180.
-          All Unix: #1554618 (refreshed config.sub/config.guess).
-                    #1490371, #1613457: support both, DESTDIR and INSTALL_ROOT,
-                    without relying on GNU-Make specific features.
-          #1647805: Patched configure.in to work better with Intel compiler.
-        - Fixes to Makefile.in to have make check work correctly:
-          bugs #1408143, #1535603, #1536684.
-        - Added Open Watcom support: patch #1523242.
-
-Release 2.0.0 Wed Jan 11 2006
-        - We no longer use the "check" library for C unit testing; we
-          always use the (partial) internal implementation of the API.
-        - Report XML_NS setting via XML_GetFeatureList().
-        - Fixed headers for use from C++.
-        - XML_GetCurrentLineNumber() and  XML_GetCurrentColumnNumber()
-          now return unsigned integers.
-        - Added XML_LARGE_SIZE switch to enable 64-bit integers for
-          byte indexes and line/column numbers.
-        - Updated to use libtool 1.5.22 (the most recent).
-        - Added support for AmigaOS.
-        - Some mostly minor bug fixes. SF issues include: #1006708,
-          #1021776, #1023646, #1114960, #1156398, #1221160, #1271642.
-
-Release 1.95.8 Fri Jul 23 2004
-        - Major new feature: suspend/resume.  Handlers can now request
-          that a parse be suspended for later resumption or aborted
-          altogether.  See "Temporarily Stopping Parsing" in the
-          documentation for more details.
-        - Some mostly minor bug fixes, but compilation should no
-          longer generate warnings on most platforms.  SF issues
-          include: #827319, #840173, #846309, #888329, #896188, #923913,
-          #928113, #961698, #985192.
-
-Release 1.95.7 Mon Oct 20 2003
-        - Fixed enum XML_Status issue (reported on SourceForge many
-          times), so compilers that are properly picky will be happy.
-        - Introduced an XMLCALL macro to control the calling
-          convention used by the Expat API; this macro should be used
-          to annotate prototypes and definitions of callback
-          implementations in code compiled with a calling convention
-          other than the default convention for the host platform.
-        - Improved ability to build without the configure-generated
-          expat_config.h header.  This is useful for applications
-          which embed Expat rather than linking in the library.
-        - Fixed a variety of bugs: see SF issues #458907, #609603,
-          #676844, #679754, #692878, #692964, #695401, #699323, #699487,
-          #820946.
-        - Improved hash table lookups.
-        - Added more regression tests and improved documentation.
-
-Release 1.95.6 Tue Jan 28 2003
-        - Added XML_FreeContentModel().
-        - Added XML_MemMalloc(), XML_MemRealloc(), XML_MemFree().
-        - Fixed a variety of bugs: see SF issues #615606, #616863,
-          #618199, #653180, #673791.
-        - Enhanced the regression test suite.
-        - Man page improvements: includes SF issue #632146.
-
-Release 1.95.5 Fri Sep 6 2002
-        - Added XML_UseForeignDTD() for improved SAX2 support.
-        - Added XML_GetFeatureList().
-        - Defined XML_Bool type and the values XML_TRUE and XML_FALSE.
-        - Use an incomplete struct instead of a void* for the parser
-          (may not retain).
-        - Fixed UTF-8 decoding bug that caused legal UTF-8 to be rejected.
-        - Finally fixed bug where default handler would report DTD
-          events that were already handled by another handler.
-          Initial patch contributed by Darryl Miles.
-        - Removed unnecessary DllMain() function that caused static
-          linking into a DLL to be difficult.
-        - Added VC++ projects for building static libraries.
-        - Reduced line-length for all source code and headers to be
-          no longer than 80 characters, to help with AS/400 support.
-        - Reduced memory copying during parsing (SF patch #600964).
-        - Fixed a variety of bugs: see SF issues #580793, #434664,
-          #483514, #580503, #581069, #584041, #584183, #584832, #585537,
-          #596555, #596678, #598352, #598944, #599715, #600479, #600971.
-
-Release 1.95.4 Fri Jul 12 2002
-        - Added support for VMS, contributed by Craig Berry.  See
-          vms/README.vms for more information.
-        - Added Mac OS (classic) support, with a makefile for MPW,
-          contributed by Thomas Wegner and Daryle Walker.
-        - Added Borland C++ Builder 5 / BCC 5.5 support, contributed
-          by Patrick McConnell (SF patch #538032).
-        - Fixed a variety of bugs: see SF issues #441449, #563184,
-          #564342, #566334, #566901, #569461, #570263, #575168, #579196.
-        - Made skippedEntityHandler conform to SAX2 (see source comment)
-        - Re-implemented WFC: Entity Declared from XML 1.0 spec and
-          added a new error "entity declared in parameter entity":
-          see SF bug report #569461 and SF patch #578161
-        - Re-implemented section 5.1 from XML 1.0 spec:
-          see SF bug report #570263 and SF patch #578161
-
-Release 1.95.3 Mon Jun 3 2002
-        - Added a project to the MSVC workspace to create a wchar_t
-          version of the library; the DLLs are named libexpatw.dll.
-        - Changed the name of the Windows DLLs from expat.dll to
-          libexpat.dll; this fixes SF bug #432456.
-        - Added the XML_ParserReset() API function.
-        - Fixed XML_SetReturnNSTriplet() to work for element names.
-        - Made the XML_UNICODE builds usable (thanks, Karl!).
-        - Allow xmlwf to read from standard input.
-        - Install a man page for xmlwf on Unix systems.
-        - Fixed many bugs; see SF bug reports #231864, #461380, #464837,
-          #466885, #469226, #477667, #484419, #487840, #494749, #496505,
-          #547350.  Other bugs which we can't test as easily may also
-          have been fixed, especially in the area of build support.
-
-Release 1.95.2 Fri Jul 27 2001
-        - More changes to make MSVC happy with the build; add a single
-          workspace to support both the library and xmlwf application.
-        - Added a Windows installer for Windows users; includes
-          xmlwf.exe.
-        - Added compile-time constants that can be used to determine the
-          Expat version
-        - Removed a lot of GNU-specific dependencies to aide portability
-          among the various Unix flavors.
-        - Fix the UTF-8 BOM bug.
-        - Cleaned up warning messages for several compilers.
-        - Added the -Wall, -Wstrict-prototypes options for GCC.
-
-Release 1.95.1 Sun Oct 22 15:11:36 EDT 2000
-        - Changes to get expat to build under Microsoft compiler
-        - Removed all aborts and instead return an UNEXPECTED_STATE error.
-        - Fixed a bug where a stray '%' in an entity value would cause an
-          abort.
-        - Defined XML_SetEndNamespaceDeclHandler. Thanks to Darryl Miles for
-          finding this oversight.
-        - Changed default patterns in lib/Makefile.in to fit non-GNU makes
-          Thanks to robin@unrated.net for reporting and providing an
-          account to test on.
-        - The reference had the wrong label for XML_SetStartNamespaceDecl.
-          Reported by an anonymous user.
-
-Release 1.95.0 Fri Sep 29 2000
-        - XML_ParserCreate_MM
-                Allows you to set a memory management suite to replace the
-                standard malloc,realloc, and free.
-        - XML_SetReturnNSTriplet
-                If you turn this feature on when namespace processing is in
-                effect, then qualified, prefixed element and attribute names
-                are returned as "uri|name|prefix" where '|' is whatever
-                separator character is used in namespace processing.
-        - Merged in features from perl-expat
-                o XML_SetElementDeclHandler
-                o XML_SetAttlistDeclHandler
-                o XML_SetXmlDeclHandler
-                o XML_SetEntityDeclHandler
-                o StartDoctypeDeclHandler takes 3 additional parameters:
-                        sysid, pubid, has_internal_subset
-                o Many paired handler setters (like XML_SetElementHandler)
-                  now have corresponding individual handler setters
-                o XML_GetInputContext for getting the input context of
-                  the current parse position.
-        - Added reference material
-        - Packaged into a distribution that builds a sharable library
diff --git a/third_party/expat/files/MANIFEST b/third_party/expat/files/MANIFEST
deleted file mode 100644
index f602b4b206ad..000000000000
--- a/third_party/expat/files/MANIFEST
+++ /dev/null
@@ -1,90 +0,0 @@
-AUTHORS
-doc/expat.png
-doc/reference.html
-doc/style.css
-doc/valid-xhtml10.png
-doc/xmlwf.1
-doc/xmlwf.xml
-CMakeLists.txt
-CMake.README
-COPYING
-Changes
-ConfigureChecks.cmake
-MANIFEST
-Makefile.in
-README.md
-configure
-configure.ac
-expat_config.h.in
-expat_config.h.cmake
-expat.pc.in
-aclocal.m4
-run.sh.in
-conftools/PrintPath
-conftools/ac_c_bigendian_cross.m4
-conftools/expat.m4
-conftools/get-version.sh
-conftools/mkinstalldirs
-conftools/config.guess
-conftools/config.sub
-conftools/install-sh
-conftools/ltmain.sh
-m4/libtool.m4
-m4/ltversion.m4
-m4/ltoptions.m4
-m4/ltsugar.m4
-m4/lt~obsolete.m4
-examples/elements.c
-examples/outline.c
-lib/ascii.h
-lib/asciitab.h
-lib/expat.h
-lib/expat_external.h
-lib/iasciitab.h
-lib/internal.h
-lib/latin1tab.h
-lib/libexpat.def
-lib/libexpatw.def
-lib/loadlibrary.c
-lib/nametab.h
-lib/siphash.h
-lib/utf8tab.h
-lib/winconfig.h
-lib/xmlparse.c
-lib/xmlrole.c
-lib/xmlrole.h
-lib/xmltok.c
-lib/xmltok.h
-lib/xmltok_impl.c
-lib/xmltok_impl.h
-lib/xmltok_ns.c
-tests/benchmark/README.txt
-tests/benchmark/benchmark.c
-tests/README.txt
-tests/chardata.c
-tests/chardata.h
-tests/memcheck.c
-tests/memcheck.h
-tests/minicheck.c
-tests/minicheck.h
-tests/runtests.c
-tests/runtestspp.cpp
-tests/xmltest.sh
-win32/MANIFEST.txt
-win32/README.txt
-win32/expat.iss
-xmlwf/codepage.c
-xmlwf/codepage.h
-xmlwf/ct.c
-xmlwf/filemap.h
-xmlwf/readfilemap.c
-xmlwf/unixfilemap.c
-xmlwf/win32filemap.c
-xmlwf/xmlfile.c
-xmlwf/xmlfile.h
-xmlwf/xmlmime.c
-xmlwf/xmlmime.h
-xmlwf/xmltchar.h
-xmlwf/xmlurl.h
-xmlwf/xmlwf.c
-xmlwf/xmlwin32url.cxx
diff --git a/third_party/expat/files/README.md b/third_party/expat/files/README.md
deleted file mode 100644
index 0a1777e7eac8..000000000000
--- a/third_party/expat/files/README.md
+++ /dev/null
@@ -1,126 +0,0 @@
-# Expat, Release 2.2.3
-
-This is Expat, a C library for parsing XML, started by
-[James Clark](https://en.wikipedia.org/wiki/James_Clark_(programmer)) in 1997.
-Expat is a stream-oriented XML parser.  This means that you register
-handlers with the parser before starting the parse.  These handlers
-are called when the parser discovers the associated structures in the
-document being parsed.  A start tag is an example of the kind of
-structures for which you may register handlers.
-
-Windows users should use the
-[`expat_win32` package](https://sourceforge.net/projects/expat/files/expat_win32/),
-which includes both precompiled libraries and executables, and source code for
-developers.
-
-Expat is [free software](https://www.gnu.org/philosophy/free-sw.en.html).
-You may copy, distribute, and modify it under the terms of the License
-contained in the file
-[`COPYING`](https://github.com/libexpat/libexpat/blob/master/expat/COPYING)
-distributed with this package.
-This license is the same as the MIT/X Consortium license.
-
-If you are building Expat from a check-out from the
-[Git repository](https://github.com/libexpat/libexpat/),
-you need to run a script that generates the configure script using the
-GNU autoconf and libtool tools.  To do this, you need to have
-autoconf 2.58 or newer. Run the script like this:
-
-```console
-./buildconf.sh
-```
-
-Once this has been done, follow the same instructions as for building
-from a source distribution.
-
-To build Expat from a source distribution, you first run the
-configuration shell script in the top level distribution directory:
-
-```console
-./configure
-```
-
-There are many options which you may provide to configure (which you
-can discover by running configure with the `--help` option).  But the
-one of most interest is the one that sets the installation directory.
-By default, the configure script will set things up to install
-libexpat into `/usr/local/lib`, `expat.h` into `/usr/local/include`, and
-`xmlwf` into `/usr/local/bin`.  If, for example, you'd prefer to install
-into `/home/me/mystuff/lib`, `/home/me/mystuff/include`, and
-`/home/me/mystuff/bin`, you can tell `configure` about that with:
-
-```console
-./configure --prefix=/home/me/mystuff
-```
-
-Another interesting option is to enable 64-bit integer support for
-line and column numbers and the over-all byte index:
-
-```console
-./configure CPPFLAGS=-DXML_LARGE_SIZE
-```
-
-However, such a modification would be a breaking change to the ABI
-and is therefore not recommended for general use &mdash; e.g. as part of
-a Linux distribution &mdash; but rather for builds with special requirements.
-
-After running the configure script, the `make` command will build
-things and `make install` will install things into their proper
-location.  Have a look at the `Makefile` to learn about additional
-`make` options.  Note that you need to have write permission into
-the directories into which things will be installed.
-
-If you are interested in building Expat to provide document
-information in UTF-16 encoding rather than the default UTF-8, follow
-these instructions (after having run `make distclean`):
-
-1. For UTF-16 output as unsigned short (and version/error strings as char),
-   run:<br/>
-   `./configure CPPFLAGS=-DXML_UNICODE`<br/>
-   For UTF-16 output as `wchar_t` (incl. version/error strings), run:<br/>
-   `./configure CFLAGS="-g -O2 -fshort-wchar" CPPFLAGS=-DXML_UNICODE_WCHAR_T`
-   <br/>Note: The latter requires libc compiled with `-fshort-wchar`, as well.
-
-1. Edit `Makefile`, changing:<br/>
-   `LIBRARY = libexpat.la`<br/>
-   to:<br/>
-   `LIBRARY = libexpatw.la`<br/>
-   (Note the additional "w" in the library name.)
-
-1. Run `make buildlib` (which builds the library only).
-   Or, to save step 2, run `make buildlib LIBRARY=libexpatw.la`.
-
-1. Run `make installlib` (which installs the library only).
-   Or, if step 2 was omitted, run `make installlib LIBRARY=libexpatw.la`.
-
-Using `DESTDIR` or `INSTALL_ROOT` is enabled, with `INSTALL_ROOT` being the
-default value for `DESTDIR`, and the rest of the make file using only
-`DESTDIR`.  It works as follows:
-
-```console
-make install DESTDIR=/path/to/image
-```
-
-overrides the in-makefile set `DESTDIR`, while both
-
-```console
-INSTALL_ROOT=/path/to/image make install
-make install INSTALL_ROOT=/path/to/image
-```
-
-use `DESTDIR=$(INSTALL_ROOT)`, even if `DESTDIR` eventually is defined in the
-environment, because variable-setting priority is
-1. commandline
-2. in-makefile
-3. environment
-
-Note: This only applies to the Expat library itself, building UTF-16 versions
-of xmlwf and the tests is currently not supported.
-
-When using Expat with a project using autoconf for configuration, you
-can use the probing macro in `conftools/expat.m4` to determine how to
-include Expat.  See the comments at the top of that file for more
-information.
-
-A reference manual is available in the file `doc/reference.html` in this
-distribution.
diff --git a/third_party/expat/files/lib/ascii.h b/third_party/expat/files/lib/ascii.h
deleted file mode 100644
index d10530b09bde..000000000000
--- a/third_party/expat/files/lib/ascii.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-*/
-
-#define ASCII_A 0x41
-#define ASCII_B 0x42
-#define ASCII_C 0x43
-#define ASCII_D 0x44
-#define ASCII_E 0x45
-#define ASCII_F 0x46
-#define ASCII_G 0x47
-#define ASCII_H 0x48
-#define ASCII_I 0x49
-#define ASCII_J 0x4A
-#define ASCII_K 0x4B
-#define ASCII_L 0x4C
-#define ASCII_M 0x4D
-#define ASCII_N 0x4E
-#define ASCII_O 0x4F
-#define ASCII_P 0x50
-#define ASCII_Q 0x51
-#define ASCII_R 0x52
-#define ASCII_S 0x53
-#define ASCII_T 0x54
-#define ASCII_U 0x55
-#define ASCII_V 0x56
-#define ASCII_W 0x57
-#define ASCII_X 0x58
-#define ASCII_Y 0x59
-#define ASCII_Z 0x5A
-
-#define ASCII_a 0x61
-#define ASCII_b 0x62
-#define ASCII_c 0x63
-#define ASCII_d 0x64
-#define ASCII_e 0x65
-#define ASCII_f 0x66
-#define ASCII_g 0x67
-#define ASCII_h 0x68
-#define ASCII_i 0x69
-#define ASCII_j 0x6A
-#define ASCII_k 0x6B
-#define ASCII_l 0x6C
-#define ASCII_m 0x6D
-#define ASCII_n 0x6E
-#define ASCII_o 0x6F
-#define ASCII_p 0x70
-#define ASCII_q 0x71
-#define ASCII_r 0x72
-#define ASCII_s 0x73
-#define ASCII_t 0x74
-#define ASCII_u 0x75
-#define ASCII_v 0x76
-#define ASCII_w 0x77
-#define ASCII_x 0x78
-#define ASCII_y 0x79
-#define ASCII_z 0x7A
-
-#define ASCII_0 0x30
-#define ASCII_1 0x31
-#define ASCII_2 0x32
-#define ASCII_3 0x33
-#define ASCII_4 0x34
-#define ASCII_5 0x35
-#define ASCII_6 0x36
-#define ASCII_7 0x37
-#define ASCII_8 0x38
-#define ASCII_9 0x39
-
-#define ASCII_TAB 0x09
-#define ASCII_SPACE 0x20
-#define ASCII_EXCL 0x21
-#define ASCII_QUOT 0x22
-#define ASCII_AMP 0x26
-#define ASCII_APOS 0x27
-#define ASCII_MINUS 0x2D
-#define ASCII_PERIOD 0x2E
-#define ASCII_COLON 0x3A
-#define ASCII_SEMI 0x3B
-#define ASCII_LT 0x3C
-#define ASCII_EQUALS 0x3D
-#define ASCII_GT 0x3E
-#define ASCII_LSQB 0x5B
-#define ASCII_RSQB 0x5D
-#define ASCII_UNDERSCORE 0x5F
-#define ASCII_LPAREN 0x28
-#define ASCII_RPAREN 0x29
-#define ASCII_FF 0x0C
-#define ASCII_SLASH 0x2F
-#define ASCII_HASH 0x23
-#define ASCII_PIPE 0x7C
-#define ASCII_COMMA 0x2C
diff --git a/third_party/expat/files/lib/asciitab.h b/third_party/expat/files/lib/asciitab.h
deleted file mode 100644
index 79a15c28ca14..000000000000
--- a/third_party/expat/files/lib/asciitab.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-*/
-
-/* 0x00 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0x04 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0x08 */ BT_NONXML, BT_S, BT_LF, BT_NONXML,
-/* 0x0C */ BT_NONXML, BT_CR, BT_NONXML, BT_NONXML,
-/* 0x10 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0x14 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0x18 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0x1C */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0x20 */ BT_S, BT_EXCL, BT_QUOT, BT_NUM,
-/* 0x24 */ BT_OTHER, BT_PERCNT, BT_AMP, BT_APOS,
-/* 0x28 */ BT_LPAR, BT_RPAR, BT_AST, BT_PLUS,
-/* 0x2C */ BT_COMMA, BT_MINUS, BT_NAME, BT_SOL,
-/* 0x30 */ BT_DIGIT, BT_DIGIT, BT_DIGIT, BT_DIGIT,
-/* 0x34 */ BT_DIGIT, BT_DIGIT, BT_DIGIT, BT_DIGIT,
-/* 0x38 */ BT_DIGIT, BT_DIGIT, BT_COLON, BT_SEMI,
-/* 0x3C */ BT_LT, BT_EQUALS, BT_GT, BT_QUEST,
-/* 0x40 */ BT_OTHER, BT_HEX, BT_HEX, BT_HEX,
-/* 0x44 */ BT_HEX, BT_HEX, BT_HEX, BT_NMSTRT,
-/* 0x48 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x4C */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x50 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x54 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x58 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_LSQB,
-/* 0x5C */ BT_OTHER, BT_RSQB, BT_OTHER, BT_NMSTRT,
-/* 0x60 */ BT_OTHER, BT_HEX, BT_HEX, BT_HEX,
-/* 0x64 */ BT_HEX, BT_HEX, BT_HEX, BT_NMSTRT,
-/* 0x68 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x6C */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x70 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x74 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x78 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_OTHER,
-/* 0x7C */ BT_VERBAR, BT_OTHER, BT_OTHER, BT_OTHER,
diff --git a/third_party/expat/files/lib/expat.h b/third_party/expat/files/lib/expat.h
deleted file mode 100644
index 7e5bbb7e3935..000000000000
--- a/third_party/expat/files/lib/expat.h
+++ /dev/null
@@ -1,1057 +0,0 @@
-/* Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-*/
-
-#ifndef Expat_INCLUDED
-#define Expat_INCLUDED 1
-
-#ifdef __VMS
-/*      0        1         2         3      0        1         2         3
-        1234567890123456789012345678901     1234567890123456789012345678901 */
-#define XML_SetProcessingInstructionHandler XML_SetProcessingInstrHandler
-#define XML_SetUnparsedEntityDeclHandler    XML_SetUnparsedEntDeclHandler
-#define XML_SetStartNamespaceDeclHandler    XML_SetStartNamespcDeclHandler
-#define XML_SetExternalEntityRefHandlerArg  XML_SetExternalEntRefHandlerArg
-#endif
-
-#include <stdlib.h>
-#include "expat_external.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-struct XML_ParserStruct;
-typedef struct XML_ParserStruct *XML_Parser;
-
-typedef unsigned char XML_Bool;
-#define XML_TRUE   ((XML_Bool) 1)
-#define XML_FALSE  ((XML_Bool) 0)
-
-/* The XML_Status enum gives the possible return values for several
-   API functions.  The preprocessor #defines are included so this
-   stanza can be added to code that still needs to support older
-   versions of Expat 1.95.x:
-
-   #ifndef XML_STATUS_OK
-   #define XML_STATUS_OK    1
-   #define XML_STATUS_ERROR 0
-   #endif
-
-   Otherwise, the #define hackery is quite ugly and would have been
-   dropped.
-*/
-enum XML_Status {
-  XML_STATUS_ERROR = 0,
-#define XML_STATUS_ERROR XML_STATUS_ERROR
-  XML_STATUS_OK = 1,
-#define XML_STATUS_OK XML_STATUS_OK
-  XML_STATUS_SUSPENDED = 2
-#define XML_STATUS_SUSPENDED XML_STATUS_SUSPENDED
-};
-
-enum XML_Error {
-  XML_ERROR_NONE,
-  XML_ERROR_NO_MEMORY,
-  XML_ERROR_SYNTAX,
-  XML_ERROR_NO_ELEMENTS,
-  XML_ERROR_INVALID_TOKEN,
-  XML_ERROR_UNCLOSED_TOKEN,
-  XML_ERROR_PARTIAL_CHAR,
-  XML_ERROR_TAG_MISMATCH,
-  XML_ERROR_DUPLICATE_ATTRIBUTE,
-  XML_ERROR_JUNK_AFTER_DOC_ELEMENT,
-  XML_ERROR_PARAM_ENTITY_REF,
-  XML_ERROR_UNDEFINED_ENTITY,
-  XML_ERROR_RECURSIVE_ENTITY_REF,
-  XML_ERROR_ASYNC_ENTITY,
-  XML_ERROR_BAD_CHAR_REF,
-  XML_ERROR_BINARY_ENTITY_REF,
-  XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF,
-  XML_ERROR_MISPLACED_XML_PI,
-  XML_ERROR_UNKNOWN_ENCODING,
-  XML_ERROR_INCORRECT_ENCODING,
-  XML_ERROR_UNCLOSED_CDATA_SECTION,
-  XML_ERROR_EXTERNAL_ENTITY_HANDLING,
-  XML_ERROR_NOT_STANDALONE,
-  XML_ERROR_UNEXPECTED_STATE,
-  XML_ERROR_ENTITY_DECLARED_IN_PE,
-  XML_ERROR_FEATURE_REQUIRES_XML_DTD,
-  XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING,
-  /* Added in 1.95.7. */
-  XML_ERROR_UNBOUND_PREFIX,
-  /* Added in 1.95.8. */
-  XML_ERROR_UNDECLARING_PREFIX,
-  XML_ERROR_INCOMPLETE_PE,
-  XML_ERROR_XML_DECL,
-  XML_ERROR_TEXT_DECL,
-  XML_ERROR_PUBLICID,
-  XML_ERROR_SUSPENDED,
-  XML_ERROR_NOT_SUSPENDED,
-  XML_ERROR_ABORTED,
-  XML_ERROR_FINISHED,
-  XML_ERROR_SUSPEND_PE,
-  /* Added in 2.0. */
-  XML_ERROR_RESERVED_PREFIX_XML,
-  XML_ERROR_RESERVED_PREFIX_XMLNS,
-  XML_ERROR_RESERVED_NAMESPACE_URI,
-  /* Added in 2.2.1. */
-  XML_ERROR_INVALID_ARGUMENT
-};
-
-enum XML_Content_Type {
-  XML_CTYPE_EMPTY = 1,
-  XML_CTYPE_ANY,
-  XML_CTYPE_MIXED,
-  XML_CTYPE_NAME,
-  XML_CTYPE_CHOICE,
-  XML_CTYPE_SEQ
-};
-
-enum XML_Content_Quant {
-  XML_CQUANT_NONE,
-  XML_CQUANT_OPT,
-  XML_CQUANT_REP,
-  XML_CQUANT_PLUS
-};
-
-/* If type == XML_CTYPE_EMPTY or XML_CTYPE_ANY, then quant will be
-   XML_CQUANT_NONE, and the other fields will be zero or NULL.
-   If type == XML_CTYPE_MIXED, then quant will be NONE or REP and
-   numchildren will contain number of elements that may be mixed in
-   and children point to an array of XML_Content cells that will be
-   all of XML_CTYPE_NAME type with no quantification.
-
-   If type == XML_CTYPE_NAME, then the name points to the name, and
-   the numchildren field will be zero and children will be NULL. The
-   quant fields indicates any quantifiers placed on the name.
-
-   CHOICE and SEQ will have name NULL, the number of children in
-   numchildren and children will point, recursively, to an array
-   of XML_Content cells.
-
-   The EMPTY, ANY, and MIXED types will only occur at top level.
-*/
-
-typedef struct XML_cp XML_Content;
-
-struct XML_cp {
-  enum XML_Content_Type         type;
-  enum XML_Content_Quant        quant;
-  XML_Char *                    name;
-  unsigned int                  numchildren;
-  XML_Content *                 children;
-};
-
-
-/* This is called for an element declaration. See above for
-   description of the model argument. It's the caller's responsibility
-   to free model when finished with it.
-*/
-typedef void (XMLCALL *XML_ElementDeclHandler) (void *userData,
-                                                const XML_Char *name,
-                                                XML_Content *model);
-
-XMLPARSEAPI(void)
-XML_SetElementDeclHandler(XML_Parser parser,
-                          XML_ElementDeclHandler eldecl);
-
-/* The Attlist declaration handler is called for *each* attribute. So
-   a single Attlist declaration with multiple attributes declared will
-   generate multiple calls to this handler. The "default" parameter
-   may be NULL in the case of the "#IMPLIED" or "#REQUIRED"
-   keyword. The "isrequired" parameter will be true and the default
-   value will be NULL in the case of "#REQUIRED". If "isrequired" is
-   true and default is non-NULL, then this is a "#FIXED" default.
-*/
-typedef void (XMLCALL *XML_AttlistDeclHandler) (
-                                    void            *userData,
-                                    const XML_Char  *elname,
-                                    const XML_Char  *attname,
-                                    const XML_Char  *att_type,
-                                    const XML_Char  *dflt,
-                                    int              isrequired);
-
-XMLPARSEAPI(void)
-XML_SetAttlistDeclHandler(XML_Parser parser,
-                          XML_AttlistDeclHandler attdecl);
-
-/* The XML declaration handler is called for *both* XML declarations
-   and text declarations. The way to distinguish is that the version
-   parameter will be NULL for text declarations. The encoding
-   parameter may be NULL for XML declarations. The standalone
-   parameter will be -1, 0, or 1 indicating respectively that there
-   was no standalone parameter in the declaration, that it was given
-   as no, or that it was given as yes.
-*/
-typedef void (XMLCALL *XML_XmlDeclHandler) (void           *userData,
-                                            const XML_Char *version,
-                                            const XML_Char *encoding,
-                                            int             standalone);
-
-XMLPARSEAPI(void)
-XML_SetXmlDeclHandler(XML_Parser parser,
-                      XML_XmlDeclHandler xmldecl);
-
-
-typedef struct {
-  void *(*malloc_fcn)(size_t size);
-  void *(*realloc_fcn)(void *ptr, size_t size);
-  void (*free_fcn)(void *ptr);
-} XML_Memory_Handling_Suite;
-
-/* Constructs a new parser; encoding is the encoding specified by the
-   external protocol or NULL if there is none specified.
-*/
-XMLPARSEAPI(XML_Parser)
-XML_ParserCreate(const XML_Char *encoding);
-
-/* Constructs a new parser and namespace processor.  Element type
-   names and attribute names that belong to a namespace will be
-   expanded; unprefixed attribute names are never expanded; unprefixed
-   element type names are expanded only if there is a default
-   namespace. The expanded name is the concatenation of the namespace
-   URI, the namespace separator character, and the local part of the
-   name.  If the namespace separator is '\0' then the namespace URI
-   and the local part will be concatenated without any separator.
-   It is a programming error to use the separator '\0' with namespace
-   triplets (see XML_SetReturnNSTriplet).
-*/
-XMLPARSEAPI(XML_Parser)
-XML_ParserCreateNS(const XML_Char *encoding, XML_Char namespaceSeparator);
-
-
-/* Constructs a new parser using the memory management suite referred to
-   by memsuite. If memsuite is NULL, then use the standard library memory
-   suite. If namespaceSeparator is non-NULL it creates a parser with
-   namespace processing as described above. The character pointed at
-   will serve as the namespace separator.
-
-   All further memory operations used for the created parser will come from
-   the given suite.
-*/
-XMLPARSEAPI(XML_Parser)
-XML_ParserCreate_MM(const XML_Char *encoding,
-                    const XML_Memory_Handling_Suite *memsuite,
-                    const XML_Char *namespaceSeparator);
-
-/* Prepare a parser object to be re-used.  This is particularly
-   valuable when memory allocation overhead is disproportionatly high,
-   such as when a large number of small documnents need to be parsed.
-   All handlers are cleared from the parser, except for the
-   unknownEncodingHandler. The parser's external state is re-initialized
-   except for the values of ns and ns_triplets.
-
-   Added in Expat 1.95.3.
-*/
-XMLPARSEAPI(XML_Bool)
-XML_ParserReset(XML_Parser parser, const XML_Char *encoding);
-
-/* atts is array of name/value pairs, terminated by 0;
-   names and values are 0 terminated.
-*/
-typedef void (XMLCALL *XML_StartElementHandler) (void *userData,
-                                                 const XML_Char *name,
-                                                 const XML_Char **atts);
-
-typedef void (XMLCALL *XML_EndElementHandler) (void *userData,
-                                               const XML_Char *name);
-
-
-/* s is not 0 terminated. */
-typedef void (XMLCALL *XML_CharacterDataHandler) (void *userData,
-                                                  const XML_Char *s,
-                                                  int len);
-
-/* target and data are 0 terminated */
-typedef void (XMLCALL *XML_ProcessingInstructionHandler) (
-                                                void *userData,
-                                                const XML_Char *target,
-                                                const XML_Char *data);
-
-/* data is 0 terminated */
-typedef void (XMLCALL *XML_CommentHandler) (void *userData,
-                                            const XML_Char *data);
-
-typedef void (XMLCALL *XML_StartCdataSectionHandler) (void *userData);
-typedef void (XMLCALL *XML_EndCdataSectionHandler) (void *userData);
-
-/* This is called for any characters in the XML document for which
-   there is no applicable handler.  This includes both characters that
-   are part of markup which is of a kind that is not reported
-   (comments, markup declarations), or characters that are part of a
-   construct which could be reported but for which no handler has been
-   supplied. The characters are passed exactly as they were in the XML
-   document except that they will be encoded in UTF-8 or UTF-16.
-   Line boundaries are not normalized. Note that a byte order mark
-   character is not passed to the default handler. There are no
-   guarantees about how characters are divided between calls to the
-   default handler: for example, a comment might be split between
-   multiple calls.
-*/
-typedef void (XMLCALL *XML_DefaultHandler) (void *userData,
-                                            const XML_Char *s,
-                                            int len);
-
-/* This is called for the start of the DOCTYPE declaration, before
-   any DTD or internal subset is parsed.
-*/
-typedef void (XMLCALL *XML_StartDoctypeDeclHandler) (
-                                            void *userData,
-                                            const XML_Char *doctypeName,
-                                            const XML_Char *sysid,
-                                            const XML_Char *pubid,
-                                            int has_internal_subset);
-
-/* This is called for the start of the DOCTYPE declaration when the
-   closing > is encountered, but after processing any external
-   subset.
-*/
-typedef void (XMLCALL *XML_EndDoctypeDeclHandler)(void *userData);
-
-/* This is called for entity declarations. The is_parameter_entity
-   argument will be non-zero if the entity is a parameter entity, zero
-   otherwise.
-
-   For internal entities (<!ENTITY foo "bar">), value will
-   be non-NULL and systemId, publicID, and notationName will be NULL.
-   The value string is NOT nul-terminated; the length is provided in
-   the value_length argument. Since it is legal to have zero-length
-   values, do not use this argument to test for internal entities.
-
-   For external entities, value will be NULL and systemId will be
-   non-NULL. The publicId argument will be NULL unless a public
-   identifier was provided. The notationName argument will have a
-   non-NULL value only for unparsed entity declarations.
-
-   Note that is_parameter_entity can't be changed to XML_Bool, since
-   that would break binary compatibility.
-*/
-typedef void (XMLCALL *XML_EntityDeclHandler) (
-                              void *userData,
-                              const XML_Char *entityName,
-                              int is_parameter_entity,
-                              const XML_Char *value,
-                              int value_length,
-                              const XML_Char *base,
-                              const XML_Char *systemId,
-                              const XML_Char *publicId,
-                              const XML_Char *notationName);
-
-XMLPARSEAPI(void)
-XML_SetEntityDeclHandler(XML_Parser parser,
-                         XML_EntityDeclHandler handler);
-
-/* OBSOLETE -- OBSOLETE -- OBSOLETE
-   This handler has been superseded by the EntityDeclHandler above.
-   It is provided here for backward compatibility.
-
-   This is called for a declaration of an unparsed (NDATA) entity.
-   The base argument is whatever was set by XML_SetBase. The
-   entityName, systemId and notationName arguments will never be
-   NULL. The other arguments may be.
-*/
-typedef void (XMLCALL *XML_UnparsedEntityDeclHandler) (
-                                    void *userData,
-                                    const XML_Char *entityName,
-                                    const XML_Char *base,
-                                    const XML_Char *systemId,
-                                    const XML_Char *publicId,
-                                    const XML_Char *notationName);
-
-/* This is called for a declaration of notation.  The base argument is
-   whatever was set by XML_SetBase. The notationName will never be
-   NULL.  The other arguments can be.
-*/
-typedef void (XMLCALL *XML_NotationDeclHandler) (
-                                    void *userData,
-                                    const XML_Char *notationName,
-                                    const XML_Char *base,
-                                    const XML_Char *systemId,
-                                    const XML_Char *publicId);
-
-/* When namespace processing is enabled, these are called once for
-   each namespace declaration. The call to the start and end element
-   handlers occur between the calls to the start and end namespace
-   declaration handlers. For an xmlns attribute, prefix will be
-   NULL.  For an xmlns="" attribute, uri will be NULL.
-*/
-typedef void (XMLCALL *XML_StartNamespaceDeclHandler) (
-                                    void *userData,
-                                    const XML_Char *prefix,
-                                    const XML_Char *uri);
-
-typedef void (XMLCALL *XML_EndNamespaceDeclHandler) (
-                                    void *userData,
-                                    const XML_Char *prefix);
-
-/* This is called if the document is not standalone, that is, it has an
-   external subset or a reference to a parameter entity, but does not
-   have standalone="yes". If this handler returns XML_STATUS_ERROR,
-   then processing will not continue, and the parser will return a
-   XML_ERROR_NOT_STANDALONE error.
-   If parameter entity parsing is enabled, then in addition to the
-   conditions above this handler will only be called if the referenced
-   entity was actually read.
-*/
-typedef int (XMLCALL *XML_NotStandaloneHandler) (void *userData);
-
-/* This is called for a reference to an external parsed general
-   entity.  The referenced entity is not automatically parsed.  The
-   application can parse it immediately or later using
-   XML_ExternalEntityParserCreate.
-
-   The parser argument is the parser parsing the entity containing the
-   reference; it can be passed as the parser argument to
-   XML_ExternalEntityParserCreate.  The systemId argument is the
-   system identifier as specified in the entity declaration; it will
-   not be NULL.
-
-   The base argument is the system identifier that should be used as
-   the base for resolving systemId if systemId was relative; this is
-   set by XML_SetBase; it may be NULL.
-
-   The publicId argument is the public identifier as specified in the
-   entity declaration, or NULL if none was specified; the whitespace
-   in the public identifier will have been normalized as required by
-   the XML spec.
-
-   The context argument specifies the parsing context in the format
-   expected by the context argument to XML_ExternalEntityParserCreate;
-   context is valid only until the handler returns, so if the
-   referenced entity is to be parsed later, it must be copied.
-   context is NULL only when the entity is a parameter entity.
-
-   The handler should return XML_STATUS_ERROR if processing should not
-   continue because of a fatal error in the handling of the external
-   entity.  In this case the calling parser will return an
-   XML_ERROR_EXTERNAL_ENTITY_HANDLING error.
-
-   Note that unlike other handlers the first argument is the parser,
-   not userData.
-*/
-typedef int (XMLCALL *XML_ExternalEntityRefHandler) (
-                                    XML_Parser parser,
-                                    const XML_Char *context,
-                                    const XML_Char *base,
-                                    const XML_Char *systemId,
-                                    const XML_Char *publicId);
-
-/* This is called in two situations:
-   1) An entity reference is encountered for which no declaration
-      has been read *and* this is not an error.
-   2) An internal entity reference is read, but not expanded, because
-      XML_SetDefaultHandler has been called.
-   Note: skipped parameter entities in declarations and skipped general
-         entities in attribute values cannot be reported, because
-         the event would be out of sync with the reporting of the
-         declarations or attribute values
-*/
-typedef void (XMLCALL *XML_SkippedEntityHandler) (
-                                    void *userData,
-                                    const XML_Char *entityName,
-                                    int is_parameter_entity);
-
-/* This structure is filled in by the XML_UnknownEncodingHandler to
-   provide information to the parser about encodings that are unknown
-   to the parser.
-
-   The map[b] member gives information about byte sequences whose
-   first byte is b.
-
-   If map[b] is c where c is >= 0, then b by itself encodes the
-   Unicode scalar value c.
-
-   If map[b] is -1, then the byte sequence is malformed.
-
-   If map[b] is -n, where n >= 2, then b is the first byte of an
-   n-byte sequence that encodes a single Unicode scalar value.
-
-   The data member will be passed as the first argument to the convert
-   function.
-
-   The convert function is used to convert multibyte sequences; s will
-   point to a n-byte sequence where map[(unsigned char)*s] == -n.  The
-   convert function must return the Unicode scalar value represented
-   by this byte sequence or -1 if the byte sequence is malformed.
-
-   The convert function may be NULL if the encoding is a single-byte
-   encoding, that is if map[b] >= -1 for all bytes b.
-
-   When the parser is finished with the encoding, then if release is
-   not NULL, it will call release passing it the data member; once
-   release has been called, the convert function will not be called
-   again.
-
-   Expat places certain restrictions on the encodings that are supported
-   using this mechanism.
-
-   1. Every ASCII character that can appear in a well-formed XML document,
-      other than the characters
-
-      $@\^`{}~
-
-      must be represented by a single byte, and that byte must be the
-      same byte that represents that character in ASCII.
-
-   2. No character may require more than 4 bytes to encode.
-
-   3. All characters encoded must have Unicode scalar values <=
-      0xFFFF, (i.e., characters that would be encoded by surrogates in
-      UTF-16 are  not allowed).  Note that this restriction doesn't
-      apply to the built-in support for UTF-8 and UTF-16.
-
-   4. No Unicode character may be encoded by more than one distinct
-      sequence of bytes.
-*/
-typedef struct {
-  int map[256];
-  void *data;
-  int (XMLCALL *convert)(void *data, const char *s);
-  void (XMLCALL *release)(void *data);
-} XML_Encoding;
-
-/* This is called for an encoding that is unknown to the parser.
-
-   The encodingHandlerData argument is that which was passed as the
-   second argument to XML_SetUnknownEncodingHandler.
-
-   The name argument gives the name of the encoding as specified in
-   the encoding declaration.
-
-   If the callback can provide information about the encoding, it must
-   fill in the XML_Encoding structure, and return XML_STATUS_OK.
-   Otherwise it must return XML_STATUS_ERROR.
-
-   If info does not describe a suitable encoding, then the parser will
-   return an XML_UNKNOWN_ENCODING error.
-*/
-typedef int (XMLCALL *XML_UnknownEncodingHandler) (
-                                    void *encodingHandlerData,
-                                    const XML_Char *name,
-                                    XML_Encoding *info);
-
-XMLPARSEAPI(void)
-XML_SetElementHandler(XML_Parser parser,
-                      XML_StartElementHandler start,
-                      XML_EndElementHandler end);
-
-XMLPARSEAPI(void)
-XML_SetStartElementHandler(XML_Parser parser,
-                           XML_StartElementHandler handler);
-
-XMLPARSEAPI(void)
-XML_SetEndElementHandler(XML_Parser parser,
-                         XML_EndElementHandler handler);
-
-XMLPARSEAPI(void)
-XML_SetCharacterDataHandler(XML_Parser parser,
-                            XML_CharacterDataHandler handler);
-
-XMLPARSEAPI(void)
-XML_SetProcessingInstructionHandler(XML_Parser parser,
-                                    XML_ProcessingInstructionHandler handler);
-XMLPARSEAPI(void)
-XML_SetCommentHandler(XML_Parser parser,
-                      XML_CommentHandler handler);
-
-XMLPARSEAPI(void)
-XML_SetCdataSectionHandler(XML_Parser parser,
-                           XML_StartCdataSectionHandler start,
-                           XML_EndCdataSectionHandler end);
-
-XMLPARSEAPI(void)
-XML_SetStartCdataSectionHandler(XML_Parser parser,
-                                XML_StartCdataSectionHandler start);
-
-XMLPARSEAPI(void)
-XML_SetEndCdataSectionHandler(XML_Parser parser,
-                              XML_EndCdataSectionHandler end);
-
-/* This sets the default handler and also inhibits expansion of
-   internal entities. These entity references will be passed to the
-   default handler, or to the skipped entity handler, if one is set.
-*/
-XMLPARSEAPI(void)
-XML_SetDefaultHandler(XML_Parser parser,
-                      XML_DefaultHandler handler);
-
-/* This sets the default handler but does not inhibit expansion of
-   internal entities.  The entity reference will not be passed to the
-   default handler.
-*/
-XMLPARSEAPI(void)
-XML_SetDefaultHandlerExpand(XML_Parser parser,
-                            XML_DefaultHandler handler);
-
-XMLPARSEAPI(void)
-XML_SetDoctypeDeclHandler(XML_Parser parser,
-                          XML_StartDoctypeDeclHandler start,
-                          XML_EndDoctypeDeclHandler end);
-
-XMLPARSEAPI(void)
-XML_SetStartDoctypeDeclHandler(XML_Parser parser,
-                               XML_StartDoctypeDeclHandler start);
-
-XMLPARSEAPI(void)
-XML_SetEndDoctypeDeclHandler(XML_Parser parser,
-                             XML_EndDoctypeDeclHandler end);
-
-XMLPARSEAPI(void)
-XML_SetUnparsedEntityDeclHandler(XML_Parser parser,
-                                 XML_UnparsedEntityDeclHandler handler);
-
-XMLPARSEAPI(void)
-XML_SetNotationDeclHandler(XML_Parser parser,
-                           XML_NotationDeclHandler handler);
-
-XMLPARSEAPI(void)
-XML_SetNamespaceDeclHandler(XML_Parser parser,
-                            XML_StartNamespaceDeclHandler start,
-                            XML_EndNamespaceDeclHandler end);
-
-XMLPARSEAPI(void)
-XML_SetStartNamespaceDeclHandler(XML_Parser parser,
-                                 XML_StartNamespaceDeclHandler start);
-
-XMLPARSEAPI(void)
-XML_SetEndNamespaceDeclHandler(XML_Parser parser,
-                               XML_EndNamespaceDeclHandler end);
-
-XMLPARSEAPI(void)
-XML_SetNotStandaloneHandler(XML_Parser parser,
-                            XML_NotStandaloneHandler handler);
-
-XMLPARSEAPI(void)
-XML_SetExternalEntityRefHandler(XML_Parser parser,
-                                XML_ExternalEntityRefHandler handler);
-
-/* If a non-NULL value for arg is specified here, then it will be
-   passed as the first argument to the external entity ref handler
-   instead of the parser object.
-*/
-XMLPARSEAPI(void)
-XML_SetExternalEntityRefHandlerArg(XML_Parser parser,
-                                   void *arg);
-
-XMLPARSEAPI(void)
-XML_SetSkippedEntityHandler(XML_Parser parser,
-                            XML_SkippedEntityHandler handler);
-
-XMLPARSEAPI(void)
-XML_SetUnknownEncodingHandler(XML_Parser parser,
-                              XML_UnknownEncodingHandler handler,
-                              void *encodingHandlerData);
-
-/* This can be called within a handler for a start element, end
-   element, processing instruction or character data.  It causes the
-   corresponding markup to be passed to the default handler.
-*/
-XMLPARSEAPI(void)
-XML_DefaultCurrent(XML_Parser parser);
-
-/* If do_nst is non-zero, and namespace processing is in effect, and
-   a name has a prefix (i.e. an explicit namespace qualifier) then
-   that name is returned as a triplet in a single string separated by
-   the separator character specified when the parser was created: URI
-   + sep + local_name + sep + prefix.
-
-   If do_nst is zero, then namespace information is returned in the
-   default manner (URI + sep + local_name) whether or not the name
-   has a prefix.
-
-   Note: Calling XML_SetReturnNSTriplet after XML_Parse or
-     XML_ParseBuffer has no effect.
-*/
-
-XMLPARSEAPI(void)
-XML_SetReturnNSTriplet(XML_Parser parser, int do_nst);
-
-/* This value is passed as the userData argument to callbacks. */
-XMLPARSEAPI(void)
-XML_SetUserData(XML_Parser parser, void *userData);
-
-/* Returns the last value set by XML_SetUserData or NULL. */
-#define XML_GetUserData(parser) (*(void **)(parser))
-
-/* This is equivalent to supplying an encoding argument to
-   XML_ParserCreate. On success XML_SetEncoding returns non-zero,
-   zero otherwise.
-   Note: Calling XML_SetEncoding after XML_Parse or XML_ParseBuffer
-     has no effect and returns XML_STATUS_ERROR.
-*/
-XMLPARSEAPI(enum XML_Status)
-XML_SetEncoding(XML_Parser parser, const XML_Char *encoding);
-
-/* If this function is called, then the parser will be passed as the
-   first argument to callbacks instead of userData.  The userData will
-   still be accessible using XML_GetUserData.
-*/
-XMLPARSEAPI(void)
-XML_UseParserAsHandlerArg(XML_Parser parser);
-
-/* If useDTD == XML_TRUE is passed to this function, then the parser
-   will assume that there is an external subset, even if none is
-   specified in the document. In such a case the parser will call the
-   externalEntityRefHandler with a value of NULL for the systemId
-   argument (the publicId and context arguments will be NULL as well).
-   Note: For the purpose of checking WFC: Entity Declared, passing
-     useDTD == XML_TRUE will make the parser behave as if the document
-     had a DTD with an external subset.
-   Note: If this function is called, then this must be done before
-     the first call to XML_Parse or XML_ParseBuffer, since it will
-     have no effect after that.  Returns
-     XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING.
-   Note: If the document does not have a DOCTYPE declaration at all,
-     then startDoctypeDeclHandler and endDoctypeDeclHandler will not
-     be called, despite an external subset being parsed.
-   Note: If XML_DTD is not defined when Expat is compiled, returns
-     XML_ERROR_FEATURE_REQUIRES_XML_DTD.
-   Note: If parser == NULL, returns XML_ERROR_INVALID_ARGUMENT.
-*/
-XMLPARSEAPI(enum XML_Error)
-XML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD);
-
-
-/* Sets the base to be used for resolving relative URIs in system
-   identifiers in declarations.  Resolving relative identifiers is
-   left to the application: this value will be passed through as the
-   base argument to the XML_ExternalEntityRefHandler,
-   XML_NotationDeclHandler and XML_UnparsedEntityDeclHandler. The base
-   argument will be copied.  Returns XML_STATUS_ERROR if out of memory,
-   XML_STATUS_OK otherwise.
-*/
-XMLPARSEAPI(enum XML_Status)
-XML_SetBase(XML_Parser parser, const XML_Char *base);
-
-XMLPARSEAPI(const XML_Char *)
-XML_GetBase(XML_Parser parser);
-
-/* Returns the number of the attribute/value pairs passed in last call
-   to the XML_StartElementHandler that were specified in the start-tag
-   rather than defaulted. Each attribute/value pair counts as 2; thus
-   this correspondds to an index into the atts array passed to the
-   XML_StartElementHandler.  Returns -1 if parser == NULL.
-*/
-XMLPARSEAPI(int)
-XML_GetSpecifiedAttributeCount(XML_Parser parser);
-
-/* Returns the index of the ID attribute passed in the last call to
-   XML_StartElementHandler, or -1 if there is no ID attribute or
-   parser == NULL.  Each attribute/value pair counts as 2; thus this
-   correspondds to an index into the atts array passed to the
-   XML_StartElementHandler.
-*/
-XMLPARSEAPI(int)
-XML_GetIdAttributeIndex(XML_Parser parser);
-
-#ifdef XML_ATTR_INFO
-/* Source file byte offsets for the start and end of attribute names and values.
-   The value indices are exclusive of surrounding quotes; thus in a UTF-8 source
-   file an attribute value of "blah" will yield:
-   info->valueEnd - info->valueStart = 4 bytes.
-*/
-typedef struct {
-  XML_Index  nameStart;  /* Offset to beginning of the attribute name. */
-  XML_Index  nameEnd;    /* Offset after the attribute name's last byte. */
-  XML_Index  valueStart; /* Offset to beginning of the attribute value. */
-  XML_Index  valueEnd;   /* Offset after the attribute value's last byte. */
-} XML_AttrInfo;
-
-/* Returns an array of XML_AttrInfo structures for the attribute/value pairs
-   passed in last call to the XML_StartElementHandler that were specified
-   in the start-tag rather than defaulted. Each attribute/value pair counts
-   as 1; thus the number of entries in the array is
-   XML_GetSpecifiedAttributeCount(parser) / 2.
-*/
-XMLPARSEAPI(const XML_AttrInfo *)
-XML_GetAttributeInfo(XML_Parser parser);
-#endif
-
-/* Parses some input. Returns XML_STATUS_ERROR if a fatal error is
-   detected.  The last call to XML_Parse must have isFinal true; len
-   may be zero for this call (or any other).
-
-   Though the return values for these functions has always been
-   described as a Boolean value, the implementation, at least for the
-   1.95.x series, has always returned exactly one of the XML_Status
-   values.
-*/
-XMLPARSEAPI(enum XML_Status)
-XML_Parse(XML_Parser parser, const char *s, int len, int isFinal);
-
-XMLPARSEAPI(void *)
-XML_GetBuffer(XML_Parser parser, int len);
-
-XMLPARSEAPI(enum XML_Status)
-XML_ParseBuffer(XML_Parser parser, int len, int isFinal);
-
-/* Stops parsing, causing XML_Parse() or XML_ParseBuffer() to return.
-   Must be called from within a call-back handler, except when aborting
-   (resumable = 0) an already suspended parser. Some call-backs may
-   still follow because they would otherwise get lost. Examples:
-   - endElementHandler() for empty elements when stopped in
-     startElementHandler(), 
-   - endNameSpaceDeclHandler() when stopped in endElementHandler(), 
-   and possibly others.
-
-   Can be called from most handlers, including DTD related call-backs,
-   except when parsing an external parameter entity and resumable != 0.
-   Returns XML_STATUS_OK when successful, XML_STATUS_ERROR otherwise.
-   Possible error codes: 
-   - XML_ERROR_SUSPENDED: when suspending an already suspended parser.
-   - XML_ERROR_FINISHED: when the parser has already finished.
-   - XML_ERROR_SUSPEND_PE: when suspending while parsing an external PE.
-
-   When resumable != 0 (true) then parsing is suspended, that is, 
-   XML_Parse() and XML_ParseBuffer() return XML_STATUS_SUSPENDED. 
-   Otherwise, parsing is aborted, that is, XML_Parse() and XML_ParseBuffer()
-   return XML_STATUS_ERROR with error code XML_ERROR_ABORTED.
-
-   *Note*:
-   This will be applied to the current parser instance only, that is, if
-   there is a parent parser then it will continue parsing when the
-   externalEntityRefHandler() returns. It is up to the implementation of
-   the externalEntityRefHandler() to call XML_StopParser() on the parent
-   parser (recursively), if one wants to stop parsing altogether.
-
-   When suspended, parsing can be resumed by calling XML_ResumeParser(). 
-*/
-XMLPARSEAPI(enum XML_Status)
-XML_StopParser(XML_Parser parser, XML_Bool resumable);
-
-/* Resumes parsing after it has been suspended with XML_StopParser().
-   Must not be called from within a handler call-back. Returns same
-   status codes as XML_Parse() or XML_ParseBuffer().
-   Additional error code XML_ERROR_NOT_SUSPENDED possible.   
-
-   *Note*:
-   This must be called on the most deeply nested child parser instance
-   first, and on its parent parser only after the child parser has finished,
-   to be applied recursively until the document entity's parser is restarted.
-   That is, the parent parser will not resume by itself and it is up to the
-   application to call XML_ResumeParser() on it at the appropriate moment.
-*/
-XMLPARSEAPI(enum XML_Status)
-XML_ResumeParser(XML_Parser parser);
-
-enum XML_Parsing {
-  XML_INITIALIZED,
-  XML_PARSING,
-  XML_FINISHED,
-  XML_SUSPENDED
-};
-
-typedef struct {
-  enum XML_Parsing parsing;
-  XML_Bool finalBuffer;
-} XML_ParsingStatus;
-
-/* Returns status of parser with respect to being initialized, parsing,
-   finished, or suspended and processing the final buffer.
-   XXX XML_Parse() and XML_ParseBuffer() should return XML_ParsingStatus,
-   XXX with XML_FINISHED_OK or XML_FINISHED_ERROR replacing XML_FINISHED
-*/
-XMLPARSEAPI(void)
-XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status);
-
-/* Creates an XML_Parser object that can parse an external general
-   entity; context is a '\0'-terminated string specifying the parse
-   context; encoding is a '\0'-terminated string giving the name of
-   the externally specified encoding, or NULL if there is no
-   externally specified encoding.  The context string consists of a
-   sequence of tokens separated by formfeeds (\f); a token consisting
-   of a name specifies that the general entity of the name is open; a
-   token of the form prefix=uri specifies the namespace for a
-   particular prefix; a token of the form =uri specifies the default
-   namespace.  This can be called at any point after the first call to
-   an ExternalEntityRefHandler so longer as the parser has not yet
-   been freed.  The new parser is completely independent and may
-   safely be used in a separate thread.  The handlers and userData are
-   initialized from the parser argument.  Returns NULL if out of memory.
-   Otherwise returns a new XML_Parser object.
-*/
-XMLPARSEAPI(XML_Parser)
-XML_ExternalEntityParserCreate(XML_Parser parser,
-                               const XML_Char *context,
-                               const XML_Char *encoding);
-
-enum XML_ParamEntityParsing {
-  XML_PARAM_ENTITY_PARSING_NEVER,
-  XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE,
-  XML_PARAM_ENTITY_PARSING_ALWAYS
-};
-
-/* Controls parsing of parameter entities (including the external DTD
-   subset). If parsing of parameter entities is enabled, then
-   references to external parameter entities (including the external
-   DTD subset) will be passed to the handler set with
-   XML_SetExternalEntityRefHandler.  The context passed will be 0.
-
-   Unlike external general entities, external parameter entities can
-   only be parsed synchronously.  If the external parameter entity is
-   to be parsed, it must be parsed during the call to the external
-   entity ref handler: the complete sequence of
-   XML_ExternalEntityParserCreate, XML_Parse/XML_ParseBuffer and
-   XML_ParserFree calls must be made during this call.  After
-   XML_ExternalEntityParserCreate has been called to create the parser
-   for the external parameter entity (context must be 0 for this
-   call), it is illegal to make any calls on the old parser until
-   XML_ParserFree has been called on the newly created parser.
-   If the library has been compiled without support for parameter
-   entity parsing (ie without XML_DTD being defined), then
-   XML_SetParamEntityParsing will return 0 if parsing of parameter
-   entities is requested; otherwise it will return non-zero.
-   Note: If XML_SetParamEntityParsing is called after XML_Parse or
-      XML_ParseBuffer, then it has no effect and will always return 0.
-   Note: If parser == NULL, the function will do nothing and return 0.
-*/
-XMLPARSEAPI(int)
-XML_SetParamEntityParsing(XML_Parser parser,
-                          enum XML_ParamEntityParsing parsing);
-
-/* Sets the hash salt to use for internal hash calculations.
-   Helps in preventing DoS attacks based on predicting hash
-   function behavior. This must be called before parsing is started.
-   Returns 1 if successful, 0 when called after parsing has started.
-   Note: If parser == NULL, the function will do nothing and return 0.
-*/
-XMLPARSEAPI(int)
-XML_SetHashSalt(XML_Parser parser,
-                unsigned long hash_salt);
-
-/* If XML_Parse or XML_ParseBuffer have returned XML_STATUS_ERROR, then
-   XML_GetErrorCode returns information about the error.
-*/
-XMLPARSEAPI(enum XML_Error)
-XML_GetErrorCode(XML_Parser parser);
-
-/* These functions return information about the current parse
-   location.  They may be called from any callback called to report
-   some parse event; in this case the location is the location of the
-   first of the sequence of characters that generated the event.  When
-   called from callbacks generated by declarations in the document
-   prologue, the location identified isn't as neatly defined, but will
-   be within the relevant markup.  When called outside of the callback
-   functions, the position indicated will be just past the last parse
-   event (regardless of whether there was an associated callback).
-   
-   They may also be called after returning from a call to XML_Parse
-   or XML_ParseBuffer.  If the return value is XML_STATUS_ERROR then
-   the location is the location of the character at which the error
-   was detected; otherwise the location is the location of the last
-   parse event, as described above.
-
-   Note: XML_GetCurrentLineNumber and XML_GetCurrentColumnNumber
-   return 0 to indicate an error.
-   Note: XML_GetCurrentByteIndex returns -1 to indicate an error.
-*/
-XMLPARSEAPI(XML_Size) XML_GetCurrentLineNumber(XML_Parser parser);
-XMLPARSEAPI(XML_Size) XML_GetCurrentColumnNumber(XML_Parser parser);
-XMLPARSEAPI(XML_Index) XML_GetCurrentByteIndex(XML_Parser parser);
-
-/* Return the number of bytes in the current event.
-   Returns 0 if the event is in an internal entity.
-*/
-XMLPARSEAPI(int)
-XML_GetCurrentByteCount(XML_Parser parser);
-
-/* If XML_CONTEXT_BYTES is defined, returns the input buffer, sets
-   the integer pointed to by offset to the offset within this buffer
-   of the current parse position, and sets the integer pointed to by size
-   to the size of this buffer (the number of input bytes). Otherwise
-   returns a NULL pointer. Also returns a NULL pointer if a parse isn't
-   active.
-
-   NOTE: The character pointer returned should not be used outside
-   the handler that makes the call.
-*/
-XMLPARSEAPI(const char *)
-XML_GetInputContext(XML_Parser parser,
-                    int *offset,
-                    int *size);
-
-/* For backwards compatibility with previous versions. */
-#define XML_GetErrorLineNumber   XML_GetCurrentLineNumber
-#define XML_GetErrorColumnNumber XML_GetCurrentColumnNumber
-#define XML_GetErrorByteIndex    XML_GetCurrentByteIndex
-
-/* Frees the content model passed to the element declaration handler */
-XMLPARSEAPI(void)
-XML_FreeContentModel(XML_Parser parser, XML_Content *model);
-
-/* Exposing the memory handling functions used in Expat */
-XMLPARSEAPI(void *)
-XML_ATTR_MALLOC
-XML_ATTR_ALLOC_SIZE(2)
-XML_MemMalloc(XML_Parser parser, size_t size);
-
-XMLPARSEAPI(void *)
-XML_ATTR_ALLOC_SIZE(3)
-XML_MemRealloc(XML_Parser parser, void *ptr, size_t size);
-
-XMLPARSEAPI(void)
-XML_MemFree(XML_Parser parser, void *ptr);
-
-/* Frees memory used by the parser. */
-XMLPARSEAPI(void)
-XML_ParserFree(XML_Parser parser);
-
-/* Returns a string describing the error. */
-XMLPARSEAPI(const XML_LChar *)
-XML_ErrorString(enum XML_Error code);
-
-/* Return a string containing the version number of this expat */
-XMLPARSEAPI(const XML_LChar *)
-XML_ExpatVersion(void);
-
-typedef struct {
-  int major;
-  int minor;
-  int micro;
-} XML_Expat_Version;
-
-/* Return an XML_Expat_Version structure containing numeric version
-   number information for this version of expat.
-*/
-XMLPARSEAPI(XML_Expat_Version)
-XML_ExpatVersionInfo(void);
-
-/* Added in Expat 1.95.5. */
-enum XML_FeatureEnum {
-  XML_FEATURE_END = 0,
-  XML_FEATURE_UNICODE,
-  XML_FEATURE_UNICODE_WCHAR_T,
-  XML_FEATURE_DTD,
-  XML_FEATURE_CONTEXT_BYTES,
-  XML_FEATURE_MIN_SIZE,
-  XML_FEATURE_SIZEOF_XML_CHAR,
-  XML_FEATURE_SIZEOF_XML_LCHAR,
-  XML_FEATURE_NS,
-  XML_FEATURE_LARGE_SIZE,
-  XML_FEATURE_ATTR_INFO
-  /* Additional features must be added to the end of this enum. */
-};
-
-typedef struct {
-  enum XML_FeatureEnum  feature;
-  const XML_LChar       *name;
-  long int              value;
-} XML_Feature;
-
-XMLPARSEAPI(const XML_Feature *)
-XML_GetFeatureList(void);
-
-
-/* Expat follows the semantic versioning convention.
-   See http://semver.org.
-*/
-#define XML_MAJOR_VERSION 2
-#define XML_MINOR_VERSION 2
-#define XML_MICRO_VERSION 3
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* not Expat_INCLUDED */
diff --git a/third_party/expat/files/lib/expat_external.h b/third_party/expat/files/lib/expat_external.h
deleted file mode 100644
index 292014daf786..000000000000
--- a/third_party/expat/files/lib/expat_external.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/* Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-*/
-
-#ifndef Expat_External_INCLUDED
-#define Expat_External_INCLUDED 1
-
-/* External API definitions */
-
-#if defined(_MSC_EXTENSIONS) && !defined(__BEOS__) && !defined(__CYGWIN__)
-#define XML_USE_MSC_EXTENSIONS 1
-#endif
-
-/* Expat tries very hard to make the API boundary very specifically
-   defined.  There are two macros defined to control this boundary;
-   each of these can be defined before including this header to
-   achieve some different behavior, but doing so it not recommended or
-   tested frequently.
-
-   XMLCALL    - The calling convention to use for all calls across the
-                "library boundary."  This will default to cdecl, and
-                try really hard to tell the compiler that's what we
-                want.
-
-   XMLIMPORT  - Whatever magic is needed to note that a function is
-                to be imported from a dynamically loaded library
-                (.dll, .so, or .sl, depending on your platform).
-
-   The XMLCALL macro was added in Expat 1.95.7.  The only one which is
-   expected to be directly useful in client code is XMLCALL.
-
-   Note that on at least some Unix versions, the Expat library must be
-   compiled with the cdecl calling convention as the default since
-   system headers may assume the cdecl convention.
-*/
-#ifndef XMLCALL
-#if defined(_MSC_VER)
-#define XMLCALL __cdecl
-#elif defined(__GNUC__) && defined(__i386) && !defined(__INTEL_COMPILER)
-#define XMLCALL __attribute__((cdecl))
-#else
-/* For any platform which uses this definition and supports more than
-   one calling convention, we need to extend this definition to
-   declare the convention used on that platform, if it's possible to
-   do so.
-
-   If this is the case for your platform, please file a bug report
-   with information on how to identify your platform via the C
-   pre-processor and how to specify the same calling convention as the
-   platform's malloc() implementation.
-*/
-#define XMLCALL
-#endif
-#endif  /* not defined XMLCALL */
-
-
-#if !defined(XML_STATIC) && !defined(XMLIMPORT)
-#ifndef XML_BUILDING_EXPAT
-/* using Expat from an application */
-
-#ifdef XML_USE_MSC_EXTENSIONS
-#define XMLIMPORT __declspec(dllimport)
-#endif
-
-#endif
-#endif  /* not defined XML_STATIC */
-
-/* Don't change symbol visibility if used as a static link libraray */
-#if !defined(XML_STATIC) && !defined(XMLIMPORT) && defined(__GNUC__) && (__GNUC__ >= 4)
-#define XMLIMPORT __attribute__ ((visibility ("default")))
-#endif
-
-/* If we didn't define it above, define it away: */
-#ifndef XMLIMPORT
-#define XMLIMPORT
-#endif
-
-#if defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96))
-#define XML_ATTR_MALLOC __attribute__((__malloc__))
-#else
-#define XML_ATTR_MALLOC
-#endif
-
-#if defined(__GNUC__) && ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
-#define XML_ATTR_ALLOC_SIZE(x)  __attribute__((__alloc_size__(x)))
-#else
-#define XML_ATTR_ALLOC_SIZE(x)
-#endif
-
-#define XMLPARSEAPI(type) XMLIMPORT type XMLCALL
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifdef XML_UNICODE_WCHAR_T
-# define XML_UNICODE
-# if defined(__SIZEOF_WCHAR_T__) && (__SIZEOF_WCHAR_T__ != 2)
-#  error "sizeof(wchar_t) != 2; Need -fshort-wchar for both Expat and libc"
-# endif
-#endif
-
-#ifdef XML_UNICODE     /* Information is UTF-16 encoded. */
-#ifdef XML_UNICODE_WCHAR_T
-typedef wchar_t XML_Char;
-typedef wchar_t XML_LChar;
-#else
-typedef unsigned short XML_Char;
-typedef char XML_LChar;
-#endif /* XML_UNICODE_WCHAR_T */
-#else                  /* Information is UTF-8 encoded. */
-typedef char XML_Char;
-typedef char XML_LChar;
-#endif /* XML_UNICODE */
-
-#ifdef XML_LARGE_SIZE  /* Use large integers for file/stream positions. */
-#if defined(XML_USE_MSC_EXTENSIONS) && _MSC_VER < 1400
-typedef __int64 XML_Index; 
-typedef unsigned __int64 XML_Size;
-#else
-typedef long long XML_Index;
-typedef unsigned long long XML_Size;
-#endif
-#else
-typedef long XML_Index;
-typedef unsigned long XML_Size;
-#endif /* XML_LARGE_SIZE */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* not Expat_External_INCLUDED */
diff --git a/third_party/expat/files/lib/iasciitab.h b/third_party/expat/files/lib/iasciitab.h
deleted file mode 100644
index 24a1d5ccc9a5..000000000000
--- a/third_party/expat/files/lib/iasciitab.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-*/
-
-/* Like asciitab.h, except that 0xD has code BT_S rather than BT_CR */
-/* 0x00 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0x04 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0x08 */ BT_NONXML, BT_S, BT_LF, BT_NONXML,
-/* 0x0C */ BT_NONXML, BT_S, BT_NONXML, BT_NONXML,
-/* 0x10 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0x14 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0x18 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0x1C */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0x20 */ BT_S, BT_EXCL, BT_QUOT, BT_NUM,
-/* 0x24 */ BT_OTHER, BT_PERCNT, BT_AMP, BT_APOS,
-/* 0x28 */ BT_LPAR, BT_RPAR, BT_AST, BT_PLUS,
-/* 0x2C */ BT_COMMA, BT_MINUS, BT_NAME, BT_SOL,
-/* 0x30 */ BT_DIGIT, BT_DIGIT, BT_DIGIT, BT_DIGIT,
-/* 0x34 */ BT_DIGIT, BT_DIGIT, BT_DIGIT, BT_DIGIT,
-/* 0x38 */ BT_DIGIT, BT_DIGIT, BT_COLON, BT_SEMI,
-/* 0x3C */ BT_LT, BT_EQUALS, BT_GT, BT_QUEST,
-/* 0x40 */ BT_OTHER, BT_HEX, BT_HEX, BT_HEX,
-/* 0x44 */ BT_HEX, BT_HEX, BT_HEX, BT_NMSTRT,
-/* 0x48 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x4C */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x50 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x54 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x58 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_LSQB,
-/* 0x5C */ BT_OTHER, BT_RSQB, BT_OTHER, BT_NMSTRT,
-/* 0x60 */ BT_OTHER, BT_HEX, BT_HEX, BT_HEX,
-/* 0x64 */ BT_HEX, BT_HEX, BT_HEX, BT_NMSTRT,
-/* 0x68 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x6C */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x70 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x74 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0x78 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_OTHER,
-/* 0x7C */ BT_VERBAR, BT_OTHER, BT_OTHER, BT_OTHER,
diff --git a/third_party/expat/files/lib/internal.h b/third_party/expat/files/lib/internal.h
deleted file mode 100644
index 94cb98e15cae..000000000000
--- a/third_party/expat/files/lib/internal.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/* internal.h
-
-   Internal definitions used by Expat.  This is not needed to compile
-   client code.
-
-   The following calling convention macros are defined for frequently
-   called functions:
-
-   FASTCALL    - Used for those internal functions that have a simple
-                 body and a low number of arguments and local variables.
-
-   PTRCALL     - Used for functions called though function pointers.
-
-   PTRFASTCALL - Like PTRCALL, but for low number of arguments.
-
-   inline      - Used for selected internal functions for which inlining
-                 may improve performance on some platforms.
-
-   Note: Use of these macros is based on judgement, not hard rules,
-         and therefore subject to change.
-*/
-
-#if defined(__GNUC__) && defined(__i386__) && !defined(__MINGW32__)
-/* We'll use this version by default only where we know it helps.
-
-   regparm() generates warnings on Solaris boxes.   See SF bug #692878.
-
-   Instability reported with egcs on a RedHat Linux 7.3.
-   Let's comment out:
-   #define FASTCALL __attribute__((stdcall, regparm(3)))
-   and let's try this:
-*/
-#define FASTCALL __attribute__((regparm(3)))
-#define PTRFASTCALL __attribute__((regparm(3)))
-#endif
-
-/* Using __fastcall seems to have an unexpected negative effect under
-   MS VC++, especially for function pointers, so we won't use it for
-   now on that platform. It may be reconsidered for a future release
-   if it can be made more effective.
-   Likely reason: __fastcall on Windows is like stdcall, therefore
-   the compiler cannot perform stack optimizations for call clusters.
-*/
-
-/* Make sure all of these are defined if they aren't already. */
-
-#ifndef FASTCALL
-#define FASTCALL
-#endif
-
-#ifndef PTRCALL
-#define PTRCALL
-#endif
-
-#ifndef PTRFASTCALL
-#define PTRFASTCALL
-#endif
-
-#ifndef XML_MIN_SIZE
-#if !defined(__cplusplus) && !defined(inline)
-#ifdef __GNUC__
-#define inline __inline
-#endif /* __GNUC__ */
-#endif
-#endif /* XML_MIN_SIZE */
-
-#ifdef __cplusplus
-#define inline inline
-#else
-#ifndef inline
-#define inline
-#endif
-#endif
-
-#ifndef UNUSED_P
-# ifdef __GNUC__
-#  define UNUSED_P(p) UNUSED_ ## p __attribute__((__unused__))
-# else
-#  define UNUSED_P(p) UNUSED_ ## p
-# endif
-#endif
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-void
-align_limit_to_full_utf8_characters(const char * from, const char ** fromLimRef);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/third_party/expat/files/lib/latin1tab.h b/third_party/expat/files/lib/latin1tab.h
deleted file mode 100644
index 53c25d76b268..000000000000
--- a/third_party/expat/files/lib/latin1tab.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-*/
-
-/* 0x80 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
-/* 0x84 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
-/* 0x88 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
-/* 0x8C */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
-/* 0x90 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
-/* 0x94 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
-/* 0x98 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
-/* 0x9C */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
-/* 0xA0 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
-/* 0xA4 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
-/* 0xA8 */ BT_OTHER, BT_OTHER, BT_NMSTRT, BT_OTHER,
-/* 0xAC */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
-/* 0xB0 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
-/* 0xB4 */ BT_OTHER, BT_NMSTRT, BT_OTHER, BT_NAME,
-/* 0xB8 */ BT_OTHER, BT_OTHER, BT_NMSTRT, BT_OTHER,
-/* 0xBC */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
-/* 0xC0 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0xC4 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0xC8 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0xCC */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0xD0 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0xD4 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_OTHER,
-/* 0xD8 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0xDC */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0xE0 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0xE4 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0xE8 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0xEC */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0xF0 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0xF4 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_OTHER,
-/* 0xF8 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
-/* 0xFC */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
diff --git a/third_party/expat/files/lib/libexpat.def b/third_party/expat/files/lib/libexpat.def
deleted file mode 100644
index 79b049116dee..000000000000
--- a/third_party/expat/files/lib/libexpat.def
+++ /dev/null
@@ -1,76 +0,0 @@
-; DEF file for MS VC++
-
-LIBRARY
-EXPORTS
-  XML_DefaultCurrent @1
-  XML_ErrorString @2
-  XML_ExpatVersion @3
-  XML_ExpatVersionInfo @4
-  XML_ExternalEntityParserCreate @5
-  XML_GetBase @6
-  XML_GetBuffer @7
-  XML_GetCurrentByteCount @8
-  XML_GetCurrentByteIndex @9
-  XML_GetCurrentColumnNumber @10
-  XML_GetCurrentLineNumber @11
-  XML_GetErrorCode @12
-  XML_GetIdAttributeIndex @13
-  XML_GetInputContext @14
-  XML_GetSpecifiedAttributeCount @15
-  XML_Parse @16
-  XML_ParseBuffer @17
-  XML_ParserCreate @18
-  XML_ParserCreateNS @19
-  XML_ParserCreate_MM @20
-  XML_ParserFree @21
-  XML_SetAttlistDeclHandler @22
-  XML_SetBase @23
-  XML_SetCdataSectionHandler @24
-  XML_SetCharacterDataHandler @25
-  XML_SetCommentHandler @26
-  XML_SetDefaultHandler @27
-  XML_SetDefaultHandlerExpand @28
-  XML_SetDoctypeDeclHandler @29
-  XML_SetElementDeclHandler @30
-  XML_SetElementHandler @31
-  XML_SetEncoding @32
-  XML_SetEndCdataSectionHandler @33
-  XML_SetEndDoctypeDeclHandler @34
-  XML_SetEndElementHandler @35
-  XML_SetEndNamespaceDeclHandler @36
-  XML_SetEntityDeclHandler @37
-  XML_SetExternalEntityRefHandler @38
-  XML_SetExternalEntityRefHandlerArg @39
-  XML_SetNamespaceDeclHandler @40
-  XML_SetNotStandaloneHandler @41
-  XML_SetNotationDeclHandler @42
-  XML_SetParamEntityParsing @43
-  XML_SetProcessingInstructionHandler @44
-  XML_SetReturnNSTriplet @45
-  XML_SetStartCdataSectionHandler @46
-  XML_SetStartDoctypeDeclHandler @47
-  XML_SetStartElementHandler @48
-  XML_SetStartNamespaceDeclHandler @49
-  XML_SetUnknownEncodingHandler @50
-  XML_SetUnparsedEntityDeclHandler @51
-  XML_SetUserData @52
-  XML_SetXmlDeclHandler @53
-  XML_UseParserAsHandlerArg @54
-; added with version 1.95.3
-  XML_ParserReset @55
-  XML_SetSkippedEntityHandler @56
-; added with version 1.95.5
-  XML_GetFeatureList @57
-  XML_UseForeignDTD @58
-; added with version 1.95.6
-  XML_FreeContentModel @59
-  XML_MemMalloc @60
-  XML_MemRealloc @61
-  XML_MemFree @62
-; added with version 1.95.8
-  XML_StopParser @63
-  XML_ResumeParser @64
-  XML_GetParsingStatus @65
-; added with version 2.1.1
-; XML_GetAttributeInfo @66
-  XML_SetHashSalt @67@
diff --git a/third_party/expat/files/lib/libexpatw.def b/third_party/expat/files/lib/libexpatw.def
deleted file mode 100644
index 79b049116dee..000000000000
--- a/third_party/expat/files/lib/libexpatw.def
+++ /dev/null
@@ -1,76 +0,0 @@
-; DEF file for MS VC++
-
-LIBRARY
-EXPORTS
-  XML_DefaultCurrent @1
-  XML_ErrorString @2
-  XML_ExpatVersion @3
-  XML_ExpatVersionInfo @4
-  XML_ExternalEntityParserCreate @5
-  XML_GetBase @6
-  XML_GetBuffer @7
-  XML_GetCurrentByteCount @8
-  XML_GetCurrentByteIndex @9
-  XML_GetCurrentColumnNumber @10
-  XML_GetCurrentLineNumber @11
-  XML_GetErrorCode @12
-  XML_GetIdAttributeIndex @13
-  XML_GetInputContext @14
-  XML_GetSpecifiedAttributeCount @15
-  XML_Parse @16
-  XML_ParseBuffer @17
-  XML_ParserCreate @18
-  XML_ParserCreateNS @19
-  XML_ParserCreate_MM @20
-  XML_ParserFree @21
-  XML_SetAttlistDeclHandler @22
-  XML_SetBase @23
-  XML_SetCdataSectionHandler @24
-  XML_SetCharacterDataHandler @25
-  XML_SetCommentHandler @26
-  XML_SetDefaultHandler @27
-  XML_SetDefaultHandlerExpand @28
-  XML_SetDoctypeDeclHandler @29
-  XML_SetElementDeclHandler @30
-  XML_SetElementHandler @31
-  XML_SetEncoding @32
-  XML_SetEndCdataSectionHandler @33
-  XML_SetEndDoctypeDeclHandler @34
-  XML_SetEndElementHandler @35
-  XML_SetEndNamespaceDeclHandler @36
-  XML_SetEntityDeclHandler @37
-  XML_SetExternalEntityRefHandler @38
-  XML_SetExternalEntityRefHandlerArg @39
-  XML_SetNamespaceDeclHandler @40
-  XML_SetNotStandaloneHandler @41
-  XML_SetNotationDeclHandler @42
-  XML_SetParamEntityParsing @43
-  XML_SetProcessingInstructionHandler @44
-  XML_SetReturnNSTriplet @45
-  XML_SetStartCdataSectionHandler @46
-  XML_SetStartDoctypeDeclHandler @47
-  XML_SetStartElementHandler @48
-  XML_SetStartNamespaceDeclHandler @49
-  XML_SetUnknownEncodingHandler @50
-  XML_SetUnparsedEntityDeclHandler @51
-  XML_SetUserData @52
-  XML_SetXmlDeclHandler @53
-  XML_UseParserAsHandlerArg @54
-; added with version 1.95.3
-  XML_ParserReset @55
-  XML_SetSkippedEntityHandler @56
-; added with version 1.95.5
-  XML_GetFeatureList @57
-  XML_UseForeignDTD @58
-; added with version 1.95.6
-  XML_FreeContentModel @59
-  XML_MemMalloc @60
-  XML_MemRealloc @61
-  XML_MemFree @62
-; added with version 1.95.8
-  XML_StopParser @63
-  XML_ResumeParser @64
-  XML_GetParsingStatus @65
-; added with version 2.1.1
-; XML_GetAttributeInfo @66
-  XML_SetHashSalt @67@
diff --git a/third_party/expat/files/lib/loadlibrary.c b/third_party/expat/files/lib/loadlibrary.c
deleted file mode 100644
index d05bf59c4537..000000000000
--- a/third_party/expat/files/lib/loadlibrary.c
+++ /dev/null
@@ -1,142 +0,0 @@
-/***************************************************************************
- *                                  _   _ ____  _
- *  Project                     ___| | | |  _ \| |
- *                             / __| | | | |_) | |
- *                            | (__| |_| |  _ <| |___
- *                             \___|\___/|_| \_\_____|
- *
- * Copyright (C) 2016 - 2017, Steve Holme, <steve_holme@hotmail.com>.
- *
- * All rights reserved.
- *
- * Permission to  use, copy,  modify, and distribute  this software  for any
- * purpose with  or without fee is  hereby granted, provided that  the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE  SOFTWARE  IS  PROVIDED  "AS  IS",  WITHOUT  WARRANTY  OF  ANY  KIND,
- * EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF
- * MERCHANTABILITY, FITNESS FOR A  PARTICULAR PURPOSE AND NONINFRINGEMENT OF
- * THIRD PARTY RIGHTS. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
- * CONTRACT, TORT OR  OTHERWISE, ARISING FROM, OUT OF OR  IN CONNECTION WITH
- * THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * Except as contained in this notice,  the name of a copyright holder shall
- * not be used in advertising or otherwise to promote the sale, use or other
- * dealings  in this  Software without  prior written  authorization of  the
- * copyright holder.
- *
- ***************************************************************************/
-
-#if defined(_WIN32)
-
-#include <windows.h>
-#include <stdlib.h>
-#include <tchar.h>
-
-
-HMODULE _Expat_LoadLibrary(LPCTSTR filename);
-
-
-#if !defined(LOAD_WITH_ALTERED_SEARCH_PATH)
-#define LOAD_WITH_ALTERED_SEARCH_PATH  0x00000008
-#endif
-
-#if !defined(LOAD_LIBRARY_SEARCH_SYSTEM32)
-#define LOAD_LIBRARY_SEARCH_SYSTEM32   0x00000800
-#endif
-
-/* We use our own typedef here since some headers might lack these */
-typedef HMODULE (APIENTRY *LOADLIBRARYEX_FN)(LPCTSTR, HANDLE, DWORD);
-
-/* See function definitions in winbase.h */
-#ifdef UNICODE
-#  ifdef _WIN32_WCE
-#    define LOADLIBARYEX  L"LoadLibraryExW"
-#  else
-#    define LOADLIBARYEX  "LoadLibraryExW"
-#  endif
-#else
-#  define LOADLIBARYEX    "LoadLibraryExA"
-#endif
-
-
-/*
- * _Expat_LoadLibrary()
- *
- * This is used to dynamically load DLLs using the most secure method available
- * for the version of Windows that we are running on.
- *
- * Parameters:
- *
- * filename  [in] - The filename or full path of the DLL to load. If only the
- *                  filename is passed then the DLL will be loaded from the
- *                  Windows system directory.
- *
- * Returns the handle of the module on success; otherwise NULL.
- */
-HMODULE _Expat_LoadLibrary(LPCTSTR filename)
-{
-  HMODULE hModule = NULL;
-  LOADLIBRARYEX_FN pLoadLibraryEx = NULL;
-
-  /* Get a handle to kernel32 so we can access it's functions at runtime */
-  HMODULE hKernel32 = GetModuleHandle(TEXT("kernel32"));
-  if(!hKernel32)
-    return NULL;
-
-  /* Attempt to find LoadLibraryEx() which is only available on Windows 2000
-     and above */
-  pLoadLibraryEx = (LOADLIBRARYEX_FN) GetProcAddress(hKernel32, LOADLIBARYEX);
-
-  /* Detect if there's already a path in the filename and load the library if
-     there is. Note: Both back slashes and forward slashes have been supported
-     since the earlier days of DOS at an API level although they are not
-     supported by command prompt */
-  if(_tcspbrk(filename, TEXT("\\/"))) {
-    /** !checksrc! disable BANNEDFUNC 1 **/
-    hModule = pLoadLibraryEx ?
-      pLoadLibraryEx(filename, NULL, LOAD_WITH_ALTERED_SEARCH_PATH) :
-      LoadLibrary(filename);
-  }
-  /* Detect if KB2533623 is installed, as LOAD_LIBARY_SEARCH_SYSTEM32 is only
-     supported on Windows Vista, Windows Server 2008, Windows 7 and Windows
-     Server 2008 R2 with this patch or natively on Windows 8 and above */
-  else if(pLoadLibraryEx && GetProcAddress(hKernel32, "AddDllDirectory")) {
-    /* Load the DLL from the Windows system directory */
-    hModule = pLoadLibraryEx(filename, NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
-  }
-  else {
-    /* Attempt to get the Windows system path */
-    UINT systemdirlen = GetSystemDirectory(NULL, 0);
-    if(systemdirlen) {
-      /* Allocate space for the full DLL path (Room for the null terminator
-         is included in systemdirlen) */
-      size_t filenamelen = _tcslen(filename);
-      TCHAR *path = malloc(sizeof(TCHAR) * (systemdirlen + 1 + filenamelen));
-      if(path && GetSystemDirectory(path, systemdirlen)) {
-        /* Calculate the full DLL path */
-        _tcscpy(path + _tcslen(path), TEXT("\\"));
-        _tcscpy(path + _tcslen(path), filename);
-
-        /* Load the DLL from the Windows system directory */
-        /** !checksrc! disable BANNEDFUNC 1 **/
-        hModule = pLoadLibraryEx ?
-          pLoadLibraryEx(path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH) :
-          LoadLibrary(path);
-
-      }
-      free(path);
-    }
-  }
-
-  return hModule;
-}
-
-#else /* defined(_WIN32) */
-
-/* ISO C requires a translation unit to contain at least one declaration
-   [-Wempty-translation-unit] */
-typedef int _TRANSLATION_UNIT_LOAD_LIBRARY_C_NOT_EMTPY;
-
-#endif /* defined(_WIN32) */
diff --git a/third_party/expat/files/lib/nametab.h b/third_party/expat/files/lib/nametab.h
deleted file mode 100644
index b05e62c77a6c..000000000000
--- a/third_party/expat/files/lib/nametab.h
+++ /dev/null
@@ -1,150 +0,0 @@
-static const unsigned namingBitmap[] = {
-0x00000000, 0x00000000, 0x00000000, 0x00000000,
-0x00000000, 0x00000000, 0x00000000, 0x00000000,
-0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-0x00000000, 0x04000000, 0x87FFFFFE, 0x07FFFFFE,
-0x00000000, 0x00000000, 0xFF7FFFFF, 0xFF7FFFFF,
-0xFFFFFFFF, 0x7FF3FFFF, 0xFFFFFDFE, 0x7FFFFFFF,
-0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFE00F, 0xFC31FFFF,
-0x00FFFFFF, 0x00000000, 0xFFFF0000, 0xFFFFFFFF,
-0xFFFFFFFF, 0xF80001FF, 0x00000003, 0x00000000,
-0x00000000, 0x00000000, 0x00000000, 0x00000000,
-0xFFFFD740, 0xFFFFFFFB, 0x547F7FFF, 0x000FFFFD,
-0xFFFFDFFE, 0xFFFFFFFF, 0xDFFEFFFF, 0xFFFFFFFF,
-0xFFFF0003, 0xFFFFFFFF, 0xFFFF199F, 0x033FCFFF,
-0x00000000, 0xFFFE0000, 0x027FFFFF, 0xFFFFFFFE,
-0x0000007F, 0x00000000, 0xFFFF0000, 0x000707FF,
-0x00000000, 0x07FFFFFE, 0x000007FE, 0xFFFE0000,
-0xFFFFFFFF, 0x7CFFFFFF, 0x002F7FFF, 0x00000060,
-0xFFFFFFE0, 0x23FFFFFF, 0xFF000000, 0x00000003,
-0xFFF99FE0, 0x03C5FDFF, 0xB0000000, 0x00030003,
-0xFFF987E0, 0x036DFDFF, 0x5E000000, 0x001C0000,
-0xFFFBAFE0, 0x23EDFDFF, 0x00000000, 0x00000001,
-0xFFF99FE0, 0x23CDFDFF, 0xB0000000, 0x00000003,
-0xD63DC7E0, 0x03BFC718, 0x00000000, 0x00000000,
-0xFFFDDFE0, 0x03EFFDFF, 0x00000000, 0x00000003,
-0xFFFDDFE0, 0x03EFFDFF, 0x40000000, 0x00000003,
-0xFFFDDFE0, 0x03FFFDFF, 0x00000000, 0x00000003,
-0x00000000, 0x00000000, 0x00000000, 0x00000000,
-0xFFFFFFFE, 0x000D7FFF, 0x0000003F, 0x00000000,
-0xFEF02596, 0x200D6CAE, 0x0000001F, 0x00000000,
-0x00000000, 0x00000000, 0xFFFFFEFF, 0x000003FF,
-0x00000000, 0x00000000, 0x00000000, 0x00000000,
-0x00000000, 0x00000000, 0x00000000, 0x00000000,
-0x00000000, 0xFFFFFFFF, 0xFFFF003F, 0x007FFFFF,
-0x0007DAED, 0x50000000, 0x82315001, 0x002C62AB,
-0x40000000, 0xF580C900, 0x00000007, 0x02010800,
-0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-0x0FFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x03FFFFFF,
-0x3F3FFFFF, 0xFFFFFFFF, 0xAAFF3F3F, 0x3FFFFFFF,
-0xFFFFFFFF, 0x5FDFFFFF, 0x0FCF1FDC, 0x1FDC1FFF,
-0x00000000, 0x00004C40, 0x00000000, 0x00000000,
-0x00000007, 0x00000000, 0x00000000, 0x00000000,
-0x00000080, 0x000003FE, 0xFFFFFFFE, 0xFFFFFFFF,
-0x001FFFFF, 0xFFFFFFFE, 0xFFFFFFFF, 0x07FFFFFF,
-0xFFFFFFE0, 0x00001FFF, 0x00000000, 0x00000000,
-0x00000000, 0x00000000, 0x00000000, 0x00000000,
-0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-0xFFFFFFFF, 0x0000003F, 0x00000000, 0x00000000,
-0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-0xFFFFFFFF, 0x0000000F, 0x00000000, 0x00000000,
-0x00000000, 0x07FF6000, 0x87FFFFFE, 0x07FFFFFE,
-0x00000000, 0x00800000, 0xFF7FFFFF, 0xFF7FFFFF,
-0x00FFFFFF, 0x00000000, 0xFFFF0000, 0xFFFFFFFF,
-0xFFFFFFFF, 0xF80001FF, 0x00030003, 0x00000000,
-0xFFFFFFFF, 0xFFFFFFFF, 0x0000003F, 0x00000003,
-0xFFFFD7C0, 0xFFFFFFFB, 0x547F7FFF, 0x000FFFFD,
-0xFFFFDFFE, 0xFFFFFFFF, 0xDFFEFFFF, 0xFFFFFFFF,
-0xFFFF007B, 0xFFFFFFFF, 0xFFFF199F, 0x033FCFFF,
-0x00000000, 0xFFFE0000, 0x027FFFFF, 0xFFFFFFFE,
-0xFFFE007F, 0xBBFFFFFB, 0xFFFF0016, 0x000707FF,
-0x00000000, 0x07FFFFFE, 0x0007FFFF, 0xFFFF03FF,
-0xFFFFFFFF, 0x7CFFFFFF, 0xFFEF7FFF, 0x03FF3DFF,
-0xFFFFFFEE, 0xF3FFFFFF, 0xFF1E3FFF, 0x0000FFCF,
-0xFFF99FEE, 0xD3C5FDFF, 0xB080399F, 0x0003FFCF,
-0xFFF987E4, 0xD36DFDFF, 0x5E003987, 0x001FFFC0,
-0xFFFBAFEE, 0xF3EDFDFF, 0x00003BBF, 0x0000FFC1,
-0xFFF99FEE, 0xF3CDFDFF, 0xB0C0398F, 0x0000FFC3,
-0xD63DC7EC, 0xC3BFC718, 0x00803DC7, 0x0000FF80,
-0xFFFDDFEE, 0xC3EFFDFF, 0x00603DDF, 0x0000FFC3,
-0xFFFDDFEC, 0xC3EFFDFF, 0x40603DDF, 0x0000FFC3,
-0xFFFDDFEC, 0xC3FFFDFF, 0x00803DCF, 0x0000FFC3,
-0x00000000, 0x00000000, 0x00000000, 0x00000000,
-0xFFFFFFFE, 0x07FF7FFF, 0x03FF7FFF, 0x00000000,
-0xFEF02596, 0x3BFF6CAE, 0x03FF3F5F, 0x00000000,
-0x03000000, 0xC2A003FF, 0xFFFFFEFF, 0xFFFE03FF,
-0xFEBF0FDF, 0x02FE3FFF, 0x00000000, 0x00000000,
-0x00000000, 0x00000000, 0x00000000, 0x00000000,
-0x00000000, 0x00000000, 0x1FFF0000, 0x00000002,
-0x000000A0, 0x003EFFFE, 0xFFFFFFFE, 0xFFFFFFFF,
-0x661FFFFF, 0xFFFFFFFE, 0xFFFFFFFF, 0x77FFFFFF,
-};
-static const unsigned char nmstrtPages[] = {
-0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00,
-0x00, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
-0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x13,
-0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x15, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x17,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x18,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-};
-static const unsigned char namePages[] = {
-0x19, 0x03, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x00,
-0x00, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
-0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x13,
-0x26, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x27, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x17,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
-0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x18,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-};
diff --git a/third_party/expat/files/lib/siphash.h b/third_party/expat/files/lib/siphash.h
deleted file mode 100644
index 581872df7b49..000000000000
--- a/third_party/expat/files/lib/siphash.h
+++ /dev/null
@@ -1,374 +0,0 @@
-/* ==========================================================================
- * siphash.h - SipHash-2-4 in a single header file
- * --------------------------------------------------------------------------
- * Derived by William Ahern from the reference implementation[1] published[2]
- * by Jean-Philippe Aumasson and Daniel J. Berstein.
- * Minimal changes by Sebastian Pipping and Victor Stinner on top, see below.
- * Licensed under the CC0 Public Domain Dedication license.
- *
- * 1. https://www.131002.net/siphash/siphash24.c
- * 2. https://www.131002.net/siphash/
- * --------------------------------------------------------------------------
- * HISTORY:
- *
- * 2017-07-25  (Vadim Zeitlin)
- *   - Fix use of SIPHASH_MAIN macro
- *
- * 2017-07-05  (Sebastian Pipping)
- *   - Use _SIP_ULL macro to not require a C++11 compiler if compiled as C++
- *   - Add const qualifiers at two places
- *   - Ensure <=80 characters line length (assuming tab width 4)
- *
- * 2017-06-23  (Victor Stinner)
- *   - Address Win64 compile warnings
- *
- * 2017-06-18  (Sebastian Pipping)
- *   - Clarify license note in the header
- *   - Address C89 issues:
- *     - Stop using inline keyword (and let compiler decide)
- *     - Replace _Bool by int
- *     - Turn macro siphash24 into a function
- *     - Address invalid conversion (void pointer) by explicit cast
- *   - Address lack of stdint.h for Visual Studio 2003 to 2008
- *   - Always expose sip24_valid (for self-tests)
- *
- * 2012-11-04 - Born.  (William Ahern)
- * --------------------------------------------------------------------------
- * USAGE:
- *
- * SipHash-2-4 takes as input two 64-bit words as the key, some number of
- * message bytes, and outputs a 64-bit word as the message digest. This
- * implementation employs two data structures: a struct sipkey for
- * representing the key, and a struct siphash for representing the hash
- * state.
- *
- * For converting a 16-byte unsigned char array to a key, use either the
- * macro sip_keyof or the routine sip_tokey. The former instantiates a
- * compound literal key, while the latter requires a key object as a
- * parameter.
- *
- * 	unsigned char secret[16];
- * 	arc4random_buf(secret, sizeof secret);
- * 	struct sipkey *key = sip_keyof(secret);
- *
- * For hashing a message, use either the convenience macro siphash24 or the
- * routines sip24_init, sip24_update, and sip24_final.
- *
- * 	struct siphash state;
- * 	void *msg;
- * 	size_t len;
- * 	uint64_t hash;
- *
- * 	sip24_init(&state, key);
- * 	sip24_update(&state, msg, len);
- * 	hash = sip24_final(&state);
- *
- * or
- *
- * 	hash = siphash24(msg, len, key);
- *
- * To convert the 64-bit hash value to a canonical 8-byte little-endian
- * binary representation, use either the macro sip_binof or the routine
- * sip_tobin. The former instantiates and returns a compound literal array,
- * while the latter requires an array object as a parameter.
- * --------------------------------------------------------------------------
- * NOTES:
- *
- * o Neither sip_keyof, sip_binof, nor siphash24 will work with compilers
- *   lacking compound literal support. Instead, you must use the lower-level
- *   interfaces which take as parameters the temporary state objects.
- *
- * o Uppercase macros may evaluate parameters more than once. Lowercase
- *   macros should not exhibit any such side effects.
- * ==========================================================================
- */
-#ifndef SIPHASH_H
-#define SIPHASH_H
-
-#include <stddef.h> /* size_t */
-
-#if defined(_WIN32) && defined(_MSC_VER) && (_MSC_VER < 1600)
-  /* For vs2003/7.1 up to vs2008/9.0; _MSC_VER 1600 is vs2010/10.0 */
-  typedef unsigned __int8   uint8_t;
-  typedef unsigned __int32 uint32_t;
-  typedef unsigned __int64 uint64_t;
-#else
- #include <stdint.h> /* uint64_t uint32_t uint8_t */
-#endif
-
-
-/*
- * Workaround to not require a C++11 compiler for using ULL suffix
- * if this code is included and compiled as C++; related GCC warning is:
- * warning: use of C++11 long long integer constant [-Wlong-long]
- */
-#define _SIP_ULL(high, low)  (((uint64_t)high << 32) | low)
-
-
-#define SIP_ROTL(x, b) (uint64_t)(((x) << (b)) | ( (x) >> (64 - (b))))
-
-#define SIP_U32TO8_LE(p, v) \
-	(p)[0] = (uint8_t)((v) >>  0); (p)[1] = (uint8_t)((v) >>  8); \
-	(p)[2] = (uint8_t)((v) >> 16); (p)[3] = (uint8_t)((v) >> 24);
-
-#define SIP_U64TO8_LE(p, v) \
-	SIP_U32TO8_LE((p) + 0, (uint32_t)((v) >>  0)); \
-	SIP_U32TO8_LE((p) + 4, (uint32_t)((v) >> 32));
-
-#define SIP_U8TO64_LE(p) \
-	(((uint64_t)((p)[0]) <<  0) | \
-	 ((uint64_t)((p)[1]) <<  8) | \
-	 ((uint64_t)((p)[2]) << 16) | \
-	 ((uint64_t)((p)[3]) << 24) | \
-	 ((uint64_t)((p)[4]) << 32) | \
-	 ((uint64_t)((p)[5]) << 40) | \
-	 ((uint64_t)((p)[6]) << 48) | \
-	 ((uint64_t)((p)[7]) << 56))
-
-
-#define SIPHASH_INITIALIZER { 0, 0, 0, 0, { 0 }, 0, 0 }
-
-struct siphash {
-	uint64_t v0, v1, v2, v3;
-
-	unsigned char buf[8], *p;
-	uint64_t c;
-}; /* struct siphash */
-
-
-#define SIP_KEYLEN 16
-
-struct sipkey {
-	uint64_t k[2];
-}; /* struct sipkey */
-
-#define sip_keyof(k) sip_tokey(&(struct sipkey){ { 0 } }, (k))
-
-static struct sipkey *sip_tokey(struct sipkey *key, const void *src) {
-	key->k[0] = SIP_U8TO64_LE((const unsigned char *)src);
-	key->k[1] = SIP_U8TO64_LE((const unsigned char *)src + 8);
-	return key;
-} /* sip_tokey() */
-
-
-#define sip_binof(v) sip_tobin((unsigned char[8]){ 0 }, (v))
-
-static void *sip_tobin(void *dst, uint64_t u64) {
-	SIP_U64TO8_LE((unsigned char *)dst, u64);
-	return dst;
-} /* sip_tobin() */
-
-
-static void sip_round(struct siphash *H, const int rounds) {
-	int i;
-
-	for (i = 0; i < rounds; i++) {
-		H->v0 += H->v1;
-		H->v1 = SIP_ROTL(H->v1, 13);
-		H->v1 ^= H->v0;
-		H->v0 = SIP_ROTL(H->v0, 32);
-
-		H->v2 += H->v3;
-		H->v3 = SIP_ROTL(H->v3, 16);
-		H->v3 ^= H->v2;
-
-		H->v0 += H->v3;
-		H->v3 = SIP_ROTL(H->v3, 21);
-		H->v3 ^= H->v0;
-
-		H->v2 += H->v1;
-		H->v1 = SIP_ROTL(H->v1, 17);
-		H->v1 ^= H->v2;
-		H->v2 = SIP_ROTL(H->v2, 32);
-	}
-} /* sip_round() */
-
-
-static struct siphash *sip24_init(struct siphash *H,
-		const struct sipkey *key) {
-	H->v0 = _SIP_ULL(0x736f6d65U, 0x70736575U) ^ key->k[0];
-	H->v1 = _SIP_ULL(0x646f7261U, 0x6e646f6dU) ^ key->k[1];
-	H->v2 = _SIP_ULL(0x6c796765U, 0x6e657261U) ^ key->k[0];
-	H->v3 = _SIP_ULL(0x74656462U, 0x79746573U) ^ key->k[1];
-
-	H->p = H->buf;
-	H->c = 0;
-
-	return H;
-} /* sip24_init() */
-
-
-#define sip_endof(a) (&(a)[sizeof (a) / sizeof *(a)])
-
-static struct siphash *sip24_update(struct siphash *H, const void *src,
-		size_t len) {
-	const unsigned char *p = (const unsigned char *)src, *pe = p + len;
-	uint64_t m;
-
-	do {
-		while (p < pe && H->p < sip_endof(H->buf))
-			*H->p++ = *p++;
-
-		if (H->p < sip_endof(H->buf))
-			break;
-
-		m = SIP_U8TO64_LE(H->buf);
-		H->v3 ^= m;
-		sip_round(H, 2);
-		H->v0 ^= m;
-
-		H->p = H->buf;
-		H->c += 8;
-	} while (p < pe);
-
-	return H;
-} /* sip24_update() */
-
-
-static uint64_t sip24_final(struct siphash *H) {
-	const char left = (char)(H->p - H->buf);
-	uint64_t b = (H->c + left) << 56;
-
-	switch (left) {
-	case 7: b |= (uint64_t)H->buf[6] << 48;
-	case 6: b |= (uint64_t)H->buf[5] << 40;
-	case 5: b |= (uint64_t)H->buf[4] << 32;
-	case 4: b |= (uint64_t)H->buf[3] << 24;
-	case 3: b |= (uint64_t)H->buf[2] << 16;
-	case 2: b |= (uint64_t)H->buf[1] << 8;
-	case 1: b |= (uint64_t)H->buf[0] << 0;
-	case 0: break;
-	}
-
-	H->v3 ^= b;
-	sip_round(H, 2);
-	H->v0 ^= b;
-	H->v2 ^= 0xff;
-	sip_round(H, 4);
-
-	return H->v0 ^ H->v1 ^ H->v2  ^ H->v3;
-} /* sip24_final() */
-
-
-static uint64_t siphash24(const void *src, size_t len,
-		const struct sipkey *key) {
-	struct siphash state = SIPHASH_INITIALIZER;
-	return sip24_final(sip24_update(sip24_init(&state, key), src, len));
-} /* siphash24() */
-
-
-/*
- * SipHash-2-4 output with
- * k = 00 01 02 ...
- * and
- * in = (empty string)
- * in = 00 (1 byte)
- * in = 00 01 (2 bytes)
- * in = 00 01 02 (3 bytes)
- * ...
- * in = 00 01 02 ... 3e (63 bytes)
- */
-static int sip24_valid(void) {
-	static const unsigned char vectors[64][8] = {
-		{ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, },
-		{ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, },
-		{ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, },
-		{ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, },
-		{ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, },
-		{ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, },
-		{ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, },
-		{ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, },
-		{ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, },
-		{ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, },
-		{ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, },
-		{ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, },
-		{ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, },
-		{ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, },
-		{ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, },
-		{ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, },
-		{ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, },
-		{ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, },
-		{ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, },
-		{ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, },
-		{ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, },
-		{ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, },
-		{ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, },
-		{ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, },
-		{ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, },
-		{ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, },
-		{ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, },
-		{ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, },
-		{ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, },
-		{ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, },
-		{ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, },
-		{ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, },
-		{ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, },
-		{ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, },
-		{ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, },
-		{ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, },
-		{ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, },
-		{ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, },
-		{ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, },
-		{ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, },
-		{ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, },
-		{ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, },
-		{ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, },
-		{ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, },
-		{ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, },
-		{ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, },
-		{ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, },
-		{ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, },
-		{ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, },
-		{ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, },
-		{ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, },
-		{ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, },
-		{ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, },
-		{ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, },
-		{ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, },
-		{ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, },
-		{ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, },
-		{ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, },
-		{ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, },
-		{ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, },
-		{ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, },
-		{ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, },
-		{ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, },
-		{ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, }
-	};
-	unsigned char in[64];
-	struct sipkey k;
-	size_t i;
-
-	sip_tokey(&k, "\000\001\002\003\004\005\006\007\010\011"
-			"\012\013\014\015\016\017");
-
-	for (i = 0; i < sizeof in; ++i) {
-		in[i] = (unsigned char)i;
-
-		if (siphash24(in, i, &k) != SIP_U8TO64_LE(vectors[i]))
-			return 0;
-	}
-
-	return 1;
-} /* sip24_valid() */
-
-
-#ifdef SIPHASH_MAIN
-
-#include <stdio.h>
-
-int main(void) {
-	const int ok = sip24_valid();
-
-	if (ok)
-		puts("OK");
-	else
-		puts("FAIL");
-
-	return !ok;
-} /* main() */
-
-#endif /* SIPHASH_MAIN */
-
-
-#endif /* SIPHASH_H */
diff --git a/third_party/expat/files/lib/utf8tab.h b/third_party/expat/files/lib/utf8tab.h
deleted file mode 100644
index 7bb3e77603fa..000000000000
--- a/third_party/expat/files/lib/utf8tab.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-*/
-
-
-/* 0x80 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0x84 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0x88 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0x8C */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0x90 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0x94 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0x98 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0x9C */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0xA0 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0xA4 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0xA8 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0xAC */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0xB0 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0xB4 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0xB8 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0xBC */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
-/* 0xC0 */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
-/* 0xC4 */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
-/* 0xC8 */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
-/* 0xCC */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
-/* 0xD0 */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
-/* 0xD4 */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
-/* 0xD8 */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
-/* 0xDC */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
-/* 0xE0 */ BT_LEAD3, BT_LEAD3, BT_LEAD3, BT_LEAD3,
-/* 0xE4 */ BT_LEAD3, BT_LEAD3, BT_LEAD3, BT_LEAD3,
-/* 0xE8 */ BT_LEAD3, BT_LEAD3, BT_LEAD3, BT_LEAD3,
-/* 0xEC */ BT_LEAD3, BT_LEAD3, BT_LEAD3, BT_LEAD3,
-/* 0xF0 */ BT_LEAD4, BT_LEAD4, BT_LEAD4, BT_LEAD4,
-/* 0xF4 */ BT_LEAD4, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0xF8 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
-/* 0xFC */ BT_NONXML, BT_NONXML, BT_MALFORM, BT_MALFORM,
diff --git a/third_party/expat/files/lib/winconfig.h b/third_party/expat/files/lib/winconfig.h
deleted file mode 100644
index 125b6b332406..000000000000
--- a/third_party/expat/files/lib/winconfig.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*================================================================
-** Copyright 2000, Clark Cooper
-** All rights reserved.
-**
-** This is free software. You are permitted to copy, distribute, or modify
-** it under the terms of the MIT/X license (contained in the COPYING file
-** with this distribution.)
-*/
-
-#ifndef WINCONFIG_H
-#define WINCONFIG_H
-
-#ifndef WIN32_LEAN_AND_MEAN
-#define WIN32_LEAN_AND_MEAN
-#endif
-#include <windows.h>
-#undef WIN32_LEAN_AND_MEAN
-
-#include <memory.h>
-#include <string.h>
-
-
-#if defined(HAVE_EXPAT_CONFIG_H)  /* e.g. MinGW */
-# include <expat_config.h>
-#else  /* !defined(HAVE_EXPAT_CONFIG_H) */
-
-
-#define XML_NS 1
-#define XML_DTD 1
-#define XML_CONTEXT_BYTES 1024
-
-/* we will assume all Windows platforms are little endian */
-#define BYTEORDER 1234
-
-/* Windows has memmove() available. */
-#define HAVE_MEMMOVE
-
-
-#endif /* !defined(HAVE_EXPAT_CONFIG_H) */
-
-
-#endif /* ndef WINCONFIG_H */
diff --git a/third_party/expat/files/lib/xmlparse.c b/third_party/expat/files/lib/xmlparse.c
deleted file mode 100644
index 6ff81029ce29..000000000000
--- a/third_party/expat/files/lib/xmlparse.c
+++ /dev/null
@@ -1,7215 +0,0 @@
-/* Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-
-   101bfd65d1ff3d1511cf6671e6aae65f82cd97df6f4da137d46d510731830ad9 (2.2.3+)
-*/
-
-#if !defined(_GNU_SOURCE)
-# define _GNU_SOURCE 1                  /* syscall prototype */
-#endif
-
-#include <stddef.h>
-#include <string.h>                     /* memset(), memcpy() */
-#include <assert.h>
-#include <limits.h>                     /* UINT_MAX */
-#include <stdio.h>                      /* fprintf */
-#include <stdlib.h>                     /* getenv */
-
-#ifdef _WIN32
-#define getpid GetCurrentProcessId
-#else
-#include <sys/time.h>                   /* gettimeofday() */
-#include <sys/types.h>                  /* getpid() */
-#include <unistd.h>                     /* getpid() */
-#include <fcntl.h>                      /* O_RDONLY */
-#include <errno.h>
-#endif
-
-#define XML_BUILDING_EXPAT 1
-
-#ifdef _WIN32
-#include "winconfig.h"
-#elif defined(HAVE_EXPAT_CONFIG_H)
-#include <expat_config.h>
-#endif /* ndef _WIN32 */
-
-#include "ascii.h"
-#include "expat.h"
-#include "siphash.h"
-
-#if defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM)
-# if defined(HAVE_GETRANDOM)
-#  include <sys/random.h>    /* getrandom */
-# else
-#  include <unistd.h>        /* syscall */
-#  include <sys/syscall.h>   /* SYS_getrandom */
-# endif
-# if ! defined(GRND_NONBLOCK)
-#  define GRND_NONBLOCK  0x0001
-# endif  /* defined(GRND_NONBLOCK) */
-#endif  /* defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM) */
-
-#if defined(HAVE_LIBBSD) \
-    && (defined(HAVE_ARC4RANDOM_BUF) || defined(HAVE_ARC4RANDOM))
-# include <bsd/stdlib.h>
-#endif
-
-#if defined(_WIN32) && !defined(LOAD_LIBRARY_SEARCH_SYSTEM32)
-# define LOAD_LIBRARY_SEARCH_SYSTEM32  0x00000800
-#endif
-
-#if !defined(HAVE_GETRANDOM) && !defined(HAVE_SYSCALL_GETRANDOM) \
-    && !defined(HAVE_ARC4RANDOM_BUF) && !defined(HAVE_ARC4RANDOM) \
-    && !defined(XML_DEV_URANDOM) \
-    && !defined(_WIN32) \
-    && !defined(XML_POOR_ENTROPY)
-# error  \
-    You do not have support for any sources of high quality entropy \
-    enabled.  For end user security, that is probably not what you want. \
-    \
-    Your options include: \
-      * Linux + glibc >=2.25 (getrandom): HAVE_GETRANDOM, \
-      * Linux + glibc <2.25 (syscall SYS_getrandom): HAVE_SYSCALL_GETRANDOM, \
-      * BSD / macOS >=10.7 (arc4random_buf): HAVE_ARC4RANDOM_BUF, \
-      * BSD / macOS <10.7 (arc4random): HAVE_ARC4RANDOM, \
-      * libbsd (arc4random_buf): HAVE_ARC4RANDOM_BUF + HAVE_LIBBSD, \
-      * libbsd (arc4random): HAVE_ARC4RANDOM + HAVE_LIBBSD, \
-      * Linux / BSD / macOS (/dev/urandom): XML_DEV_URANDOM \
-      * Windows (RtlGenRandom): _WIN32. \
-    \
-    If insist on not using any of these, bypass this error by defining \
-    XML_POOR_ENTROPY; you have been warned. \
-    \
-    For CMake, one way to pass the define is: \
-        cmake -DCMAKE_C_FLAGS="-pipe -O2 -DHAVE_SYSCALL_GETRANDOM" . \
-    \
-    If you have reasons to patch this detection code away or need changes \
-    to the build system, please open a bug.  Thank you!
-#endif
-
-
-#ifdef XML_UNICODE
-#define XML_ENCODE_MAX XML_UTF16_ENCODE_MAX
-#define XmlConvert XmlUtf16Convert
-#define XmlGetInternalEncoding XmlGetUtf16InternalEncoding
-#define XmlGetInternalEncodingNS XmlGetUtf16InternalEncodingNS
-#define XmlEncode XmlUtf16Encode
-/* Using pointer subtraction to convert to integer type. */
-#define MUST_CONVERT(enc, s) (!(enc)->isUtf16 || (((char *)(s) - (char *)NULL) & 1))
-typedef unsigned short ICHAR;
-#else
-#define XML_ENCODE_MAX XML_UTF8_ENCODE_MAX
-#define XmlConvert XmlUtf8Convert
-#define XmlGetInternalEncoding XmlGetUtf8InternalEncoding
-#define XmlGetInternalEncodingNS XmlGetUtf8InternalEncodingNS
-#define XmlEncode XmlUtf8Encode
-#define MUST_CONVERT(enc, s) (!(enc)->isUtf8)
-typedef char ICHAR;
-#endif
-
-
-#ifndef XML_NS
-
-#define XmlInitEncodingNS XmlInitEncoding
-#define XmlInitUnknownEncodingNS XmlInitUnknownEncoding
-#undef XmlGetInternalEncodingNS
-#define XmlGetInternalEncodingNS XmlGetInternalEncoding
-#define XmlParseXmlDeclNS XmlParseXmlDecl
-
-#endif
-
-#ifdef XML_UNICODE
-
-#ifdef XML_UNICODE_WCHAR_T
-#define XML_T(x) (const wchar_t)x
-#define XML_L(x) L ## x
-#else
-#define XML_T(x) (const unsigned short)x
-#define XML_L(x) x
-#endif
-
-#else
-
-#define XML_T(x) x
-#define XML_L(x) x
-
-#endif
-
-/* Round up n to be a multiple of sz, where sz is a power of 2. */
-#define ROUND_UP(n, sz) (((n) + ((sz) - 1)) & ~((sz) - 1))
-
-/* Handle the case where memmove() doesn't exist. */
-#ifndef HAVE_MEMMOVE
-#ifdef HAVE_BCOPY
-#define memmove(d,s,l) bcopy((s),(d),(l))
-#else
-#error memmove does not exist on this platform, nor is a substitute available
-#endif /* HAVE_BCOPY */
-#endif /* HAVE_MEMMOVE */
-
-#include "internal.h"
-#include "xmltok.h"
-#include "xmlrole.h"
-
-typedef const XML_Char *KEY;
-
-typedef struct {
-  KEY name;
-} NAMED;
-
-typedef struct {
-  NAMED **v;
-  unsigned char power;
-  size_t size;
-  size_t used;
-  const XML_Memory_Handling_Suite *mem;
-} HASH_TABLE;
-
-static size_t
-keylen(KEY s);
-
-static void
-copy_salt_to_sipkey(XML_Parser parser, struct sipkey * key);
-
-/* For probing (after a collision) we need a step size relative prime
-   to the hash table size, which is a power of 2. We use double-hashing,
-   since we can calculate a second hash value cheaply by taking those bits
-   of the first hash value that were discarded (masked out) when the table
-   index was calculated: index = hash & mask, where mask = table->size - 1.
-   We limit the maximum step size to table->size / 4 (mask >> 2) and make
-   it odd, since odd numbers are always relative prime to a power of 2.
-*/
-#define SECOND_HASH(hash, mask, power) \
-  ((((hash) & ~(mask)) >> ((power) - 1)) & ((mask) >> 2))
-#define PROBE_STEP(hash, mask, power) \
-  ((unsigned char)((SECOND_HASH(hash, mask, power)) | 1))
-
-typedef struct {
-  NAMED **p;
-  NAMED **end;
-} HASH_TABLE_ITER;
-
-#define INIT_TAG_BUF_SIZE 32  /* must be a multiple of sizeof(XML_Char) */
-#define INIT_DATA_BUF_SIZE 1024
-#define INIT_ATTS_SIZE 16
-#define INIT_ATTS_VERSION 0xFFFFFFFF
-#define INIT_BLOCK_SIZE 1024
-#define INIT_BUFFER_SIZE 1024
-
-#define EXPAND_SPARE 24
-
-typedef struct binding {
-  struct prefix *prefix;
-  struct binding *nextTagBinding;
-  struct binding *prevPrefixBinding;
-  const struct attribute_id *attId;
-  XML_Char *uri;
-  int uriLen;
-  int uriAlloc;
-} BINDING;
-
-typedef struct prefix {
-  const XML_Char *name;
-  BINDING *binding;
-} PREFIX;
-
-typedef struct {
-  const XML_Char *str;
-  const XML_Char *localPart;
-  const XML_Char *prefix;
-  int strLen;
-  int uriLen;
-  int prefixLen;
-} TAG_NAME;
-
-/* TAG represents an open element.
-   The name of the element is stored in both the document and API
-   encodings.  The memory buffer 'buf' is a separately-allocated
-   memory area which stores the name.  During the XML_Parse()/
-   XMLParseBuffer() when the element is open, the memory for the 'raw'
-   version of the name (in the document encoding) is shared with the
-   document buffer.  If the element is open across calls to
-   XML_Parse()/XML_ParseBuffer(), the buffer is re-allocated to
-   contain the 'raw' name as well.
-
-   A parser re-uses these structures, maintaining a list of allocated
-   TAG objects in a free list.
-*/
-typedef struct tag {
-  struct tag *parent;           /* parent of this element */
-  const char *rawName;          /* tagName in the original encoding */
-  int rawNameLength;
-  TAG_NAME name;                /* tagName in the API encoding */
-  char *buf;                    /* buffer for name components */
-  char *bufEnd;                 /* end of the buffer */
-  BINDING *bindings;
-} TAG;
-
-typedef struct {
-  const XML_Char *name;
-  const XML_Char *textPtr;
-  int textLen;                  /* length in XML_Chars */
-  int processed;                /* # of processed bytes - when suspended */
-  const XML_Char *systemId;
-  const XML_Char *base;
-  const XML_Char *publicId;
-  const XML_Char *notation;
-  XML_Bool open;
-  XML_Bool is_param;
-  XML_Bool is_internal; /* true if declared in internal subset outside PE */
-} ENTITY;
-
-typedef struct {
-  enum XML_Content_Type         type;
-  enum XML_Content_Quant        quant;
-  const XML_Char *              name;
-  int                           firstchild;
-  int                           lastchild;
-  int                           childcnt;
-  int                           nextsib;
-} CONTENT_SCAFFOLD;
-
-#define INIT_SCAFFOLD_ELEMENTS 32
-
-typedef struct block {
-  struct block *next;
-  int size;
-  XML_Char s[1];
-} BLOCK;
-
-typedef struct {
-  BLOCK *blocks;
-  BLOCK *freeBlocks;
-  const XML_Char *end;
-  XML_Char *ptr;
-  XML_Char *start;
-  const XML_Memory_Handling_Suite *mem;
-} STRING_POOL;
-
-/* The XML_Char before the name is used to determine whether
-   an attribute has been specified. */
-typedef struct attribute_id {
-  XML_Char *name;
-  PREFIX *prefix;
-  XML_Bool maybeTokenized;
-  XML_Bool xmlns;
-} ATTRIBUTE_ID;
-
-typedef struct {
-  const ATTRIBUTE_ID *id;
-  XML_Bool isCdata;
-  const XML_Char *value;
-} DEFAULT_ATTRIBUTE;
-
-typedef struct {
-  unsigned long version;
-  unsigned long hash;
-  const XML_Char *uriName;
-} NS_ATT;
-
-typedef struct {
-  const XML_Char *name;
-  PREFIX *prefix;
-  const ATTRIBUTE_ID *idAtt;
-  int nDefaultAtts;
-  int allocDefaultAtts;
-  DEFAULT_ATTRIBUTE *defaultAtts;
-} ELEMENT_TYPE;
-
-typedef struct {
-  HASH_TABLE generalEntities;
-  HASH_TABLE elementTypes;
-  HASH_TABLE attributeIds;
-  HASH_TABLE prefixes;
-  STRING_POOL pool;
-  STRING_POOL entityValuePool;
-  /* false once a parameter entity reference has been skipped */
-  XML_Bool keepProcessing;
-  /* true once an internal or external PE reference has been encountered;
-     this includes the reference to an external subset */
-  XML_Bool hasParamEntityRefs;
-  XML_Bool standalone;
-#ifdef XML_DTD
-  /* indicates if external PE has been read */
-  XML_Bool paramEntityRead;
-  HASH_TABLE paramEntities;
-#endif /* XML_DTD */
-  PREFIX defaultPrefix;
-  /* === scaffolding for building content model === */
-  XML_Bool in_eldecl;
-  CONTENT_SCAFFOLD *scaffold;
-  unsigned contentStringLen;
-  unsigned scaffSize;
-  unsigned scaffCount;
-  int scaffLevel;
-  int *scaffIndex;
-} DTD;
-
-typedef struct open_internal_entity {
-  const char *internalEventPtr;
-  const char *internalEventEndPtr;
-  struct open_internal_entity *next;
-  ENTITY *entity;
-  int startTagLevel;
-  XML_Bool betweenDecl; /* WFC: PE Between Declarations */
-} OPEN_INTERNAL_ENTITY;
-
-typedef enum XML_Error PTRCALL Processor(XML_Parser parser,
-                                         const char *start,
-                                         const char *end,
-                                         const char **endPtr);
-
-static Processor prologProcessor;
-static Processor prologInitProcessor;
-static Processor contentProcessor;
-static Processor cdataSectionProcessor;
-#ifdef XML_DTD
-static Processor ignoreSectionProcessor;
-static Processor externalParEntProcessor;
-static Processor externalParEntInitProcessor;
-static Processor entityValueProcessor;
-static Processor entityValueInitProcessor;
-#endif /* XML_DTD */
-static Processor epilogProcessor;
-static Processor errorProcessor;
-static Processor externalEntityInitProcessor;
-static Processor externalEntityInitProcessor2;
-static Processor externalEntityInitProcessor3;
-static Processor externalEntityContentProcessor;
-static Processor internalEntityProcessor;
-
-static enum XML_Error
-handleUnknownEncoding(XML_Parser parser, const XML_Char *encodingName);
-static enum XML_Error
-processXmlDecl(XML_Parser parser, int isGeneralTextEntity,
-               const char *s, const char *next);
-static enum XML_Error
-initializeEncoding(XML_Parser parser);
-static enum XML_Error
-doProlog(XML_Parser parser, const ENCODING *enc, const char *s,
-         const char *end, int tok, const char *next, const char **nextPtr,
-         XML_Bool haveMore);
-static enum XML_Error
-processInternalEntity(XML_Parser parser, ENTITY *entity,
-                      XML_Bool betweenDecl);
-static enum XML_Error
-doContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,
-          const char *start, const char *end, const char **endPtr,
-          XML_Bool haveMore);
-static enum XML_Error
-doCdataSection(XML_Parser parser, const ENCODING *, const char **startPtr,
-               const char *end, const char **nextPtr, XML_Bool haveMore);
-#ifdef XML_DTD
-static enum XML_Error
-doIgnoreSection(XML_Parser parser, const ENCODING *, const char **startPtr,
-                const char *end, const char **nextPtr, XML_Bool haveMore);
-#endif /* XML_DTD */
-
-static void
-freeBindings(XML_Parser parser, BINDING *bindings);
-static enum XML_Error
-storeAtts(XML_Parser parser, const ENCODING *, const char *s,
-          TAG_NAME *tagNamePtr, BINDING **bindingsPtr);
-static enum XML_Error
-addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,
-           const XML_Char *uri, BINDING **bindingsPtr);
-static int
-defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *, XML_Bool isCdata,
-                XML_Bool isId, const XML_Char *dfltValue, XML_Parser parser);
-static enum XML_Error
-storeAttributeValue(XML_Parser parser, const ENCODING *, XML_Bool isCdata,
-                    const char *, const char *, STRING_POOL *);
-static enum XML_Error
-appendAttributeValue(XML_Parser parser, const ENCODING *, XML_Bool isCdata,
-                     const char *, const char *, STRING_POOL *);
-static ATTRIBUTE_ID *
-getAttributeId(XML_Parser parser, const ENCODING *enc, const char *start,
-               const char *end);
-static int
-setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *);
-static enum XML_Error
-storeEntityValue(XML_Parser parser, const ENCODING *enc, const char *start,
-                 const char *end);
-static int
-reportProcessingInstruction(XML_Parser parser, const ENCODING *enc,
-                            const char *start, const char *end);
-static int
-reportComment(XML_Parser parser, const ENCODING *enc, const char *start,
-              const char *end);
-static void
-reportDefault(XML_Parser parser, const ENCODING *enc, const char *start,
-              const char *end);
-
-static const XML_Char * getContext(XML_Parser parser);
-static XML_Bool
-setContext(XML_Parser parser, const XML_Char *context);
-
-static void FASTCALL normalizePublicId(XML_Char *s);
-
-static DTD * dtdCreate(const XML_Memory_Handling_Suite *ms);
-/* do not call if parentParser != NULL */
-static void dtdReset(DTD *p, const XML_Memory_Handling_Suite *ms);
-static void
-dtdDestroy(DTD *p, XML_Bool isDocEntity, const XML_Memory_Handling_Suite *ms);
-static int
-dtdCopy(XML_Parser oldParser,
-        DTD *newDtd, const DTD *oldDtd, const XML_Memory_Handling_Suite *ms);
-static int
-copyEntityTable(XML_Parser oldParser,
-                HASH_TABLE *, STRING_POOL *, const HASH_TABLE *);
-static NAMED *
-lookup(XML_Parser parser, HASH_TABLE *table, KEY name, size_t createSize);
-static void FASTCALL
-hashTableInit(HASH_TABLE *, const XML_Memory_Handling_Suite *ms);
-static void FASTCALL hashTableClear(HASH_TABLE *);
-static void FASTCALL hashTableDestroy(HASH_TABLE *);
-static void FASTCALL
-hashTableIterInit(HASH_TABLE_ITER *, const HASH_TABLE *);
-static NAMED * FASTCALL hashTableIterNext(HASH_TABLE_ITER *);
-
-static void FASTCALL
-poolInit(STRING_POOL *, const XML_Memory_Handling_Suite *ms);
-static void FASTCALL poolClear(STRING_POOL *);
-static void FASTCALL poolDestroy(STRING_POOL *);
-static XML_Char *
-poolAppend(STRING_POOL *pool, const ENCODING *enc,
-           const char *ptr, const char *end);
-static XML_Char *
-poolStoreString(STRING_POOL *pool, const ENCODING *enc,
-                const char *ptr, const char *end);
-static XML_Bool FASTCALL poolGrow(STRING_POOL *pool);
-static const XML_Char * FASTCALL
-poolCopyString(STRING_POOL *pool, const XML_Char *s);
-static const XML_Char *
-poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n);
-static const XML_Char * FASTCALL
-poolAppendString(STRING_POOL *pool, const XML_Char *s);
-
-static int FASTCALL nextScaffoldPart(XML_Parser parser);
-static XML_Content * build_model(XML_Parser parser);
-static ELEMENT_TYPE *
-getElementType(XML_Parser parser, const ENCODING *enc,
-               const char *ptr, const char *end);
-
-static XML_Char *copyString(const XML_Char *s,
-                            const XML_Memory_Handling_Suite *memsuite);
-
-static unsigned long generate_hash_secret_salt(XML_Parser parser);
-static XML_Bool startParsing(XML_Parser parser);
-
-static XML_Parser
-parserCreate(const XML_Char *encodingName,
-             const XML_Memory_Handling_Suite *memsuite,
-             const XML_Char *nameSep,
-             DTD *dtd);
-
-static void
-parserInit(XML_Parser parser, const XML_Char *encodingName);
-
-#define poolStart(pool) ((pool)->start)
-#define poolEnd(pool) ((pool)->ptr)
-#define poolLength(pool) ((pool)->ptr - (pool)->start)
-#define poolChop(pool) ((void)--(pool->ptr))
-#define poolLastChar(pool) (((pool)->ptr)[-1])
-#define poolDiscard(pool) ((pool)->ptr = (pool)->start)
-#define poolFinish(pool) ((pool)->start = (pool)->ptr)
-#define poolAppendChar(pool, c) \
-  (((pool)->ptr == (pool)->end && !poolGrow(pool)) \
-   ? 0 \
-   : ((*((pool)->ptr)++ = c), 1))
-
-struct XML_ParserStruct {
-  /* The first member must be userData so that the XML_GetUserData
-     macro works. */
-  void *m_userData;
-  void *m_handlerArg;
-  char *m_buffer;
-  const XML_Memory_Handling_Suite m_mem;
-  /* first character to be parsed */
-  const char *m_bufferPtr;
-  /* past last character to be parsed */
-  char *m_bufferEnd;
-  /* allocated end of buffer */
-  const char *m_bufferLim;
-  XML_Index m_parseEndByteIndex;
-  const char *m_parseEndPtr;
-  XML_Char *m_dataBuf;
-  XML_Char *m_dataBufEnd;
-  XML_StartElementHandler m_startElementHandler;
-  XML_EndElementHandler m_endElementHandler;
-  XML_CharacterDataHandler m_characterDataHandler;
-  XML_ProcessingInstructionHandler m_processingInstructionHandler;
-  XML_CommentHandler m_commentHandler;
-  XML_StartCdataSectionHandler m_startCdataSectionHandler;
-  XML_EndCdataSectionHandler m_endCdataSectionHandler;
-  XML_DefaultHandler m_defaultHandler;
-  XML_StartDoctypeDeclHandler m_startDoctypeDeclHandler;
-  XML_EndDoctypeDeclHandler m_endDoctypeDeclHandler;
-  XML_UnparsedEntityDeclHandler m_unparsedEntityDeclHandler;
-  XML_NotationDeclHandler m_notationDeclHandler;
-  XML_StartNamespaceDeclHandler m_startNamespaceDeclHandler;
-  XML_EndNamespaceDeclHandler m_endNamespaceDeclHandler;
-  XML_NotStandaloneHandler m_notStandaloneHandler;
-  XML_ExternalEntityRefHandler m_externalEntityRefHandler;
-  XML_Parser m_externalEntityRefHandlerArg;
-  XML_SkippedEntityHandler m_skippedEntityHandler;
-  XML_UnknownEncodingHandler m_unknownEncodingHandler;
-  XML_ElementDeclHandler m_elementDeclHandler;
-  XML_AttlistDeclHandler m_attlistDeclHandler;
-  XML_EntityDeclHandler m_entityDeclHandler;
-  XML_XmlDeclHandler m_xmlDeclHandler;
-  const ENCODING *m_encoding;
-  INIT_ENCODING m_initEncoding;
-  const ENCODING *m_internalEncoding;
-  const XML_Char *m_protocolEncodingName;
-  XML_Bool m_ns;
-  XML_Bool m_ns_triplets;
-  void *m_unknownEncodingMem;
-  void *m_unknownEncodingData;
-  void *m_unknownEncodingHandlerData;
-  void (XMLCALL *m_unknownEncodingRelease)(void *);
-  PROLOG_STATE m_prologState;
-  Processor *m_processor;
-  enum XML_Error m_errorCode;
-  const char *m_eventPtr;
-  const char *m_eventEndPtr;
-  const char *m_positionPtr;
-  OPEN_INTERNAL_ENTITY *m_openInternalEntities;
-  OPEN_INTERNAL_ENTITY *m_freeInternalEntities;
-  XML_Bool m_defaultExpandInternalEntities;
-  int m_tagLevel;
-  ENTITY *m_declEntity;
-  const XML_Char *m_doctypeName;
-  const XML_Char *m_doctypeSysid;
-  const XML_Char *m_doctypePubid;
-  const XML_Char *m_declAttributeType;
-  const XML_Char *m_declNotationName;
-  const XML_Char *m_declNotationPublicId;
-  ELEMENT_TYPE *m_declElementType;
-  ATTRIBUTE_ID *m_declAttributeId;
-  XML_Bool m_declAttributeIsCdata;
-  XML_Bool m_declAttributeIsId;
-  DTD *m_dtd;
-  const XML_Char *m_curBase;
-  TAG *m_tagStack;
-  TAG *m_freeTagList;
-  BINDING *m_inheritedBindings;
-  BINDING *m_freeBindingList;
-  int m_attsSize;
-  int m_nSpecifiedAtts;
-  int m_idAttIndex;
-  ATTRIBUTE *m_atts;
-  NS_ATT *m_nsAtts;
-  unsigned long m_nsAttsVersion;
-  unsigned char m_nsAttsPower;
-#ifdef XML_ATTR_INFO
-  XML_AttrInfo *m_attInfo;
-#endif
-  POSITION m_position;
-  STRING_POOL m_tempPool;
-  STRING_POOL m_temp2Pool;
-  char *m_groupConnector;
-  unsigned int m_groupSize;
-  XML_Char m_namespaceSeparator;
-  XML_Parser m_parentParser;
-  XML_ParsingStatus m_parsingStatus;
-#ifdef XML_DTD
-  XML_Bool m_isParamEntity;
-  XML_Bool m_useForeignDTD;
-  enum XML_ParamEntityParsing m_paramEntityParsing;
-#endif
-  unsigned long m_hash_secret_salt;
-};
-
-#define MALLOC(s) (parser->m_mem.malloc_fcn((s)))
-#define REALLOC(p,s) (parser->m_mem.realloc_fcn((p),(s)))
-#define FREE(p) (parser->m_mem.free_fcn((p)))
-
-#define userData (parser->m_userData)
-#define handlerArg (parser->m_handlerArg)
-#define startElementHandler (parser->m_startElementHandler)
-#define endElementHandler (parser->m_endElementHandler)
-#define characterDataHandler (parser->m_characterDataHandler)
-#define processingInstructionHandler \
-        (parser->m_processingInstructionHandler)
-#define commentHandler (parser->m_commentHandler)
-#define startCdataSectionHandler \
-        (parser->m_startCdataSectionHandler)
-#define endCdataSectionHandler (parser->m_endCdataSectionHandler)
-#define defaultHandler (parser->m_defaultHandler)
-#define startDoctypeDeclHandler (parser->m_startDoctypeDeclHandler)
-#define endDoctypeDeclHandler (parser->m_endDoctypeDeclHandler)
-#define unparsedEntityDeclHandler \
-        (parser->m_unparsedEntityDeclHandler)
-#define notationDeclHandler (parser->m_notationDeclHandler)
-#define startNamespaceDeclHandler \
-        (parser->m_startNamespaceDeclHandler)
-#define endNamespaceDeclHandler (parser->m_endNamespaceDeclHandler)
-#define notStandaloneHandler (parser->m_notStandaloneHandler)
-#define externalEntityRefHandler \
-        (parser->m_externalEntityRefHandler)
-#define externalEntityRefHandlerArg \
-        (parser->m_externalEntityRefHandlerArg)
-#define internalEntityRefHandler \
-        (parser->m_internalEntityRefHandler)
-#define skippedEntityHandler (parser->m_skippedEntityHandler)
-#define unknownEncodingHandler (parser->m_unknownEncodingHandler)
-#define elementDeclHandler (parser->m_elementDeclHandler)
-#define attlistDeclHandler (parser->m_attlistDeclHandler)
-#define entityDeclHandler (parser->m_entityDeclHandler)
-#define xmlDeclHandler (parser->m_xmlDeclHandler)
-#define encoding (parser->m_encoding)
-#define initEncoding (parser->m_initEncoding)
-#define internalEncoding (parser->m_internalEncoding)
-#define unknownEncodingMem (parser->m_unknownEncodingMem)
-#define unknownEncodingData (parser->m_unknownEncodingData)
-#define unknownEncodingHandlerData \
-  (parser->m_unknownEncodingHandlerData)
-#define unknownEncodingRelease (parser->m_unknownEncodingRelease)
-#define protocolEncodingName (parser->m_protocolEncodingName)
-#define ns (parser->m_ns)
-#define ns_triplets (parser->m_ns_triplets)
-#define prologState (parser->m_prologState)
-#define processor (parser->m_processor)
-#define errorCode (parser->m_errorCode)
-#define eventPtr (parser->m_eventPtr)
-#define eventEndPtr (parser->m_eventEndPtr)
-#define positionPtr (parser->m_positionPtr)
-#define position (parser->m_position)
-#define openInternalEntities (parser->m_openInternalEntities)
-#define freeInternalEntities (parser->m_freeInternalEntities)
-#define defaultExpandInternalEntities \
-        (parser->m_defaultExpandInternalEntities)
-#define tagLevel (parser->m_tagLevel)
-#define buffer (parser->m_buffer)
-#define bufferPtr (parser->m_bufferPtr)
-#define bufferEnd (parser->m_bufferEnd)
-#define parseEndByteIndex (parser->m_parseEndByteIndex)
-#define parseEndPtr (parser->m_parseEndPtr)
-#define bufferLim (parser->m_bufferLim)
-#define dataBuf (parser->m_dataBuf)
-#define dataBufEnd (parser->m_dataBufEnd)
-#define _dtd (parser->m_dtd)
-#define curBase (parser->m_curBase)
-#define declEntity (parser->m_declEntity)
-#define doctypeName (parser->m_doctypeName)
-#define doctypeSysid (parser->m_doctypeSysid)
-#define doctypePubid (parser->m_doctypePubid)
-#define declAttributeType (parser->m_declAttributeType)
-#define declNotationName (parser->m_declNotationName)
-#define declNotationPublicId (parser->m_declNotationPublicId)
-#define declElementType (parser->m_declElementType)
-#define declAttributeId (parser->m_declAttributeId)
-#define declAttributeIsCdata (parser->m_declAttributeIsCdata)
-#define declAttributeIsId (parser->m_declAttributeIsId)
-#define freeTagList (parser->m_freeTagList)
-#define freeBindingList (parser->m_freeBindingList)
-#define inheritedBindings (parser->m_inheritedBindings)
-#define tagStack (parser->m_tagStack)
-#define atts (parser->m_atts)
-#define attsSize (parser->m_attsSize)
-#define nSpecifiedAtts (parser->m_nSpecifiedAtts)
-#define idAttIndex (parser->m_idAttIndex)
-#define nsAtts (parser->m_nsAtts)
-#define nsAttsVersion (parser->m_nsAttsVersion)
-#define nsAttsPower (parser->m_nsAttsPower)
-#define attInfo (parser->m_attInfo)
-#define tempPool (parser->m_tempPool)
-#define temp2Pool (parser->m_temp2Pool)
-#define groupConnector (parser->m_groupConnector)
-#define groupSize (parser->m_groupSize)
-#define namespaceSeparator (parser->m_namespaceSeparator)
-#define parentParser (parser->m_parentParser)
-#define ps_parsing (parser->m_parsingStatus.parsing)
-#define ps_finalBuffer (parser->m_parsingStatus.finalBuffer)
-#ifdef XML_DTD
-#define isParamEntity (parser->m_isParamEntity)
-#define useForeignDTD (parser->m_useForeignDTD)
-#define paramEntityParsing (parser->m_paramEntityParsing)
-#endif /* XML_DTD */
-#define hash_secret_salt (parser->m_hash_secret_salt)
-
-XML_Parser XMLCALL
-XML_ParserCreate(const XML_Char *encodingName)
-{
-  return XML_ParserCreate_MM(encodingName, NULL, NULL);
-}
-
-XML_Parser XMLCALL
-XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep)
-{
-  XML_Char tmp[2];
-  *tmp = nsSep;
-  return XML_ParserCreate_MM(encodingName, NULL, tmp);
-}
-
-static const XML_Char implicitContext[] = {
-  ASCII_x, ASCII_m, ASCII_l, ASCII_EQUALS, ASCII_h, ASCII_t, ASCII_t, ASCII_p,
-  ASCII_COLON, ASCII_SLASH, ASCII_SLASH, ASCII_w, ASCII_w, ASCII_w,
-  ASCII_PERIOD, ASCII_w, ASCII_3, ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,
-  ASCII_SLASH, ASCII_X, ASCII_M, ASCII_L, ASCII_SLASH, ASCII_1, ASCII_9,
-  ASCII_9, ASCII_8, ASCII_SLASH, ASCII_n, ASCII_a, ASCII_m, ASCII_e,
-  ASCII_s, ASCII_p, ASCII_a, ASCII_c, ASCII_e, '\0'
-};
-
-
-#if defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM)
-
-/* Obtain entropy on Linux 3.17+ */
-static int
-writeRandomBytes_getrandom_nonblock(void * target, size_t count) {
-  int success = 0;  /* full count bytes written? */
-  size_t bytesWrittenTotal = 0;
-  const unsigned int getrandomFlags = GRND_NONBLOCK;
-
-  do {
-    void * const currentTarget = (void*)((char*)target + bytesWrittenTotal);
-    const size_t bytesToWrite = count - bytesWrittenTotal;
-
-    const int bytesWrittenMore =
-#if defined(HAVE_GETRANDOM)
-        getrandom(currentTarget, bytesToWrite, getrandomFlags);
-#else
-        syscall(SYS_getrandom, currentTarget, bytesToWrite, getrandomFlags);
-#endif
-
-    if (bytesWrittenMore > 0) {
-      bytesWrittenTotal += bytesWrittenMore;
-      if (bytesWrittenTotal >= count)
-        success = 1;
-    }
-  } while (! success && (errno == EINTR));
-
-  return success;
-}
-
-#endif  /* defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM) */
-
-
-#if ! defined(_WIN32) && defined(XML_DEV_URANDOM)
-
-/* Extract entropy from /dev/urandom */
-static int
-writeRandomBytes_dev_urandom(void * target, size_t count) {
-  int success = 0;  /* full count bytes written? */
-  size_t bytesWrittenTotal = 0;
-
-  const int fd = open("/dev/urandom", O_RDONLY);
-  if (fd < 0) {
-    return 0;
-  }
-
-  do {
-    void * const currentTarget = (void*)((char*)target + bytesWrittenTotal);
-    const size_t bytesToWrite = count - bytesWrittenTotal;
-
-    const ssize_t bytesWrittenMore = read(fd, currentTarget, bytesToWrite);
-
-    if (bytesWrittenMore > 0) {
-      bytesWrittenTotal += bytesWrittenMore;
-      if (bytesWrittenTotal >= count)
-        success = 1;
-    }
-  } while (! success && (errno == EINTR));
-
-  close(fd);
-  return success;
-}
-
-#endif  /* ! defined(_WIN32) && defined(XML_DEV_URANDOM) */
-
-
-#if defined(HAVE_ARC4RANDOM)
-
-static void
-writeRandomBytes_arc4random(void * target, size_t count) {
-  size_t bytesWrittenTotal = 0;
-
-  while (bytesWrittenTotal < count) {
-    const uint32_t random32 = arc4random();
-    size_t i = 0;
-
-    for (; (i < sizeof(random32)) && (bytesWrittenTotal < count);
-        i++, bytesWrittenTotal++) {
-      const uint8_t random8 = (uint8_t)(random32 >> (i * 8));
-      ((uint8_t *)target)[bytesWrittenTotal] = random8;
-    }
-  }
-}
-
-#endif  /* defined(HAVE_ARC4RANDOM) */
-
-
-#ifdef _WIN32
-
-typedef BOOLEAN (APIENTRY *RTLGENRANDOM_FUNC)(PVOID, ULONG);
-HMODULE _Expat_LoadLibrary(LPCTSTR filename);  /* see loadlibrary.c */
-
-/* Obtain entropy on Windows XP / Windows Server 2003 and later.
- * Hint on RtlGenRandom and the following article from libsodium.
- *
- * Michael Howard: Cryptographically Secure Random number on Windows without using CryptoAPI
- * https://blogs.msdn.microsoft.com/michael_howard/2005/01/14/cryptographically-secure-random-number-on-windows-without-using-cryptoapi/
- */
-static int
-writeRandomBytes_RtlGenRandom(void * target, size_t count) {
-  int success = 0;  /* full count bytes written? */
-  const HMODULE advapi32 = _Expat_LoadLibrary(TEXT("ADVAPI32.DLL"));
-
-  if (advapi32) {
-    const RTLGENRANDOM_FUNC RtlGenRandom
-        = (RTLGENRANDOM_FUNC)GetProcAddress(advapi32, "SystemFunction036");
-    if (RtlGenRandom) {
-      if (RtlGenRandom((PVOID)target, (ULONG)count) == TRUE) {
-        success = 1;
-      }
-    }
-    FreeLibrary(advapi32);
-  }
-
-  return success;
-}
-
-#endif /* _WIN32 */
-
-
-#if ! defined(HAVE_ARC4RANDOM_BUF) && ! defined(HAVE_ARC4RANDOM)
-
-static unsigned long
-gather_time_entropy(void)
-{
-#ifdef _WIN32
-  FILETIME ft;
-  GetSystemTimeAsFileTime(&ft); /* never fails */
-  return ft.dwHighDateTime ^ ft.dwLowDateTime;
-#else
-  struct timeval tv;
-  int gettimeofday_res;
-
-  gettimeofday_res = gettimeofday(&tv, NULL);
-
-#if defined(NDEBUG)
-  (void)gettimeofday_res;
-#else
-  assert (gettimeofday_res == 0);
-#endif  /* defined(NDEBUG) */
-
-  /* Microseconds time is <20 bits entropy */
-  return tv.tv_usec;
-#endif
-}
-
-#endif  /* ! defined(HAVE_ARC4RANDOM_BUF) && ! defined(HAVE_ARC4RANDOM) */
-
-
-static unsigned long
-ENTROPY_DEBUG(const char * label, unsigned long entropy) {
-  const char * const EXPAT_ENTROPY_DEBUG = getenv("EXPAT_ENTROPY_DEBUG");
-  if (EXPAT_ENTROPY_DEBUG && ! strcmp(EXPAT_ENTROPY_DEBUG, "1")) {
-    fprintf(stderr, "Entropy: %s --> 0x%0*lx (%lu bytes)\n",
-        label,
-        (int)sizeof(entropy) * 2, entropy,
-        (unsigned long)sizeof(entropy));
-  }
-  return entropy;
-}
-
-static unsigned long
-generate_hash_secret_salt(XML_Parser parser)
-{
-  unsigned long entropy;
-  (void)parser;
-#if defined(HAVE_ARC4RANDOM_BUF)
-  arc4random_buf(&entropy, sizeof(entropy));
-  return ENTROPY_DEBUG("arc4random_buf", entropy);
-#elif defined(HAVE_ARC4RANDOM)
-  writeRandomBytes_arc4random((void *)&entropy, sizeof(entropy));
-  return ENTROPY_DEBUG("arc4random", entropy);
-#else
-  /* Try high quality providers first .. */
-#ifdef _WIN32
-  if (writeRandomBytes_RtlGenRandom((void *)&entropy, sizeof(entropy))) {
-    return ENTROPY_DEBUG("RtlGenRandom", entropy);
-  }
-#elif defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM)
-  if (writeRandomBytes_getrandom_nonblock((void *)&entropy, sizeof(entropy))) {
-    return ENTROPY_DEBUG("getrandom", entropy);
-  }
-#endif
-#if ! defined(_WIN32) && defined(XML_DEV_URANDOM)
-  if (writeRandomBytes_dev_urandom((void *)&entropy, sizeof(entropy))) {
-    return ENTROPY_DEBUG("/dev/urandom", entropy);
-  }
-#endif  /* ! defined(_WIN32) && defined(XML_DEV_URANDOM) */
-  /* .. and self-made low quality for backup: */
-
-  /* Process ID is 0 bits entropy if attacker has local access */
-  entropy = gather_time_entropy() ^ getpid();
-
-  /* Factors are 2^31-1 and 2^61-1 (Mersenne primes M31 and M61) */
-  if (sizeof(unsigned long) == 4) {
-    return ENTROPY_DEBUG("fallback(4)", entropy * 2147483647);
-  } else {
-    return ENTROPY_DEBUG("fallback(8)",
-        (unsigned long)(entropy * 2305843009213693951ULL));
-  }
-#endif
-}
-
-static unsigned long
-get_hash_secret_salt(XML_Parser parser) {
-  if (parser->m_parentParser != NULL)
-    return get_hash_secret_salt(parser->m_parentParser);
-  return parser->m_hash_secret_salt;
-}
-
-static XML_Bool  /* only valid for root parser */
-startParsing(XML_Parser parser)
-{
-    /* hash functions must be initialized before setContext() is called */
-    if (hash_secret_salt == 0)
-      hash_secret_salt = generate_hash_secret_salt(parser);
-    if (ns) {
-      /* implicit context only set for root parser, since child
-         parsers (i.e. external entity parsers) will inherit it
-      */
-      return setContext(parser, implicitContext);
-    }
-    return XML_TRUE;
-}
-
-XML_Parser XMLCALL
-XML_ParserCreate_MM(const XML_Char *encodingName,
-                    const XML_Memory_Handling_Suite *memsuite,
-                    const XML_Char *nameSep)
-{
-  return parserCreate(encodingName, memsuite, nameSep, NULL);
-}
-
-static XML_Parser
-parserCreate(const XML_Char *encodingName,
-             const XML_Memory_Handling_Suite *memsuite,
-             const XML_Char *nameSep,
-             DTD *dtd)
-{
-  XML_Parser parser;
-
-  if (memsuite) {
-    XML_Memory_Handling_Suite *mtemp;
-    parser = (XML_Parser)
-      memsuite->malloc_fcn(sizeof(struct XML_ParserStruct));
-    if (parser != NULL) {
-      mtemp = (XML_Memory_Handling_Suite *)&(parser->m_mem);
-      mtemp->malloc_fcn = memsuite->malloc_fcn;
-      mtemp->realloc_fcn = memsuite->realloc_fcn;
-      mtemp->free_fcn = memsuite->free_fcn;
-    }
-  }
-  else {
-    XML_Memory_Handling_Suite *mtemp;
-    parser = (XML_Parser)malloc(sizeof(struct XML_ParserStruct));
-    if (parser != NULL) {
-      mtemp = (XML_Memory_Handling_Suite *)&(parser->m_mem);
-      mtemp->malloc_fcn = malloc;
-      mtemp->realloc_fcn = realloc;
-      mtemp->free_fcn = free;
-    }
-  }
-
-  if (!parser)
-    return parser;
-
-  buffer = NULL;
-  bufferLim = NULL;
-
-  attsSize = INIT_ATTS_SIZE;
-  atts = (ATTRIBUTE *)MALLOC(attsSize * sizeof(ATTRIBUTE));
-  if (atts == NULL) {
-    FREE(parser);
-    return NULL;
-  }
-#ifdef XML_ATTR_INFO
-  attInfo = (XML_AttrInfo*)MALLOC(attsSize * sizeof(XML_AttrInfo));
-  if (attInfo == NULL) {
-    FREE(atts);
-    FREE(parser);
-    return NULL;
-  }
-#endif
-  dataBuf = (XML_Char *)MALLOC(INIT_DATA_BUF_SIZE * sizeof(XML_Char));
-  if (dataBuf == NULL) {
-    FREE(atts);
-#ifdef XML_ATTR_INFO
-    FREE(attInfo);
-#endif
-    FREE(parser);
-    return NULL;
-  }
-  dataBufEnd = dataBuf + INIT_DATA_BUF_SIZE;
-
-  if (dtd)
-    _dtd = dtd;
-  else {
-    _dtd = dtdCreate(&parser->m_mem);
-    if (_dtd == NULL) {
-      FREE(dataBuf);
-      FREE(atts);
-#ifdef XML_ATTR_INFO
-      FREE(attInfo);
-#endif
-      FREE(parser);
-      return NULL;
-    }
-  }
-
-  freeBindingList = NULL;
-  freeTagList = NULL;
-  freeInternalEntities = NULL;
-
-  groupSize = 0;
-  groupConnector = NULL;
-
-  unknownEncodingHandler = NULL;
-  unknownEncodingHandlerData = NULL;
-
-  namespaceSeparator = ASCII_EXCL;
-  ns = XML_FALSE;
-  ns_triplets = XML_FALSE;
-
-  nsAtts = NULL;
-  nsAttsVersion = 0;
-  nsAttsPower = 0;
-
-  protocolEncodingName = NULL;
-
-  poolInit(&tempPool, &(parser->m_mem));
-  poolInit(&temp2Pool, &(parser->m_mem));
-  parserInit(parser, encodingName);
-
-  if (encodingName && !protocolEncodingName) {
-    XML_ParserFree(parser);
-    return NULL;
-  }
-
-  if (nameSep) {
-    ns = XML_TRUE;
-    internalEncoding = XmlGetInternalEncodingNS();
-    namespaceSeparator = *nameSep;
-  }
-  else {
-    internalEncoding = XmlGetInternalEncoding();
-  }
-
-  return parser;
-}
-
-static void
-parserInit(XML_Parser parser, const XML_Char *encodingName)
-{
-  processor = prologInitProcessor;
-  XmlPrologStateInit(&prologState);
-  if (encodingName != NULL) {
-    protocolEncodingName = copyString(encodingName, &(parser->m_mem));
-  }
-  curBase = NULL;
-  XmlInitEncoding(&initEncoding, &encoding, 0);
-  userData = NULL;
-  handlerArg = NULL;
-  startElementHandler = NULL;
-  endElementHandler = NULL;
-  characterDataHandler = NULL;
-  processingInstructionHandler = NULL;
-  commentHandler = NULL;
-  startCdataSectionHandler = NULL;
-  endCdataSectionHandler = NULL;
-  defaultHandler = NULL;
-  startDoctypeDeclHandler = NULL;
-  endDoctypeDeclHandler = NULL;
-  unparsedEntityDeclHandler = NULL;
-  notationDeclHandler = NULL;
-  startNamespaceDeclHandler = NULL;
-  endNamespaceDeclHandler = NULL;
-  notStandaloneHandler = NULL;
-  externalEntityRefHandler = NULL;
-  externalEntityRefHandlerArg = parser;
-  skippedEntityHandler = NULL;
-  elementDeclHandler = NULL;
-  attlistDeclHandler = NULL;
-  entityDeclHandler = NULL;
-  xmlDeclHandler = NULL;
-  bufferPtr = buffer;
-  bufferEnd = buffer;
-  parseEndByteIndex = 0;
-  parseEndPtr = NULL;
-  declElementType = NULL;
-  declAttributeId = NULL;
-  declEntity = NULL;
-  doctypeName = NULL;
-  doctypeSysid = NULL;
-  doctypePubid = NULL;
-  declAttributeType = NULL;
-  declNotationName = NULL;
-  declNotationPublicId = NULL;
-  declAttributeIsCdata = XML_FALSE;
-  declAttributeIsId = XML_FALSE;
-  memset(&position, 0, sizeof(POSITION));
-  errorCode = XML_ERROR_NONE;
-  eventPtr = NULL;
-  eventEndPtr = NULL;
-  positionPtr = NULL;
-  openInternalEntities = NULL;
-  defaultExpandInternalEntities = XML_TRUE;
-  tagLevel = 0;
-  tagStack = NULL;
-  inheritedBindings = NULL;
-  nSpecifiedAtts = 0;
-  unknownEncodingMem = NULL;
-  unknownEncodingRelease = NULL;
-  unknownEncodingData = NULL;
-  parentParser = NULL;
-  ps_parsing = XML_INITIALIZED;
-#ifdef XML_DTD
-  isParamEntity = XML_FALSE;
-  useForeignDTD = XML_FALSE;
-  paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;
-#endif
-  hash_secret_salt = 0;
-}
-
-/* moves list of bindings to freeBindingList */
-static void FASTCALL
-moveToFreeBindingList(XML_Parser parser, BINDING *bindings)
-{
-  while (bindings) {
-    BINDING *b = bindings;
-    bindings = bindings->nextTagBinding;
-    b->nextTagBinding = freeBindingList;
-    freeBindingList = b;
-  }
-}
-
-XML_Bool XMLCALL
-XML_ParserReset(XML_Parser parser, const XML_Char *encodingName)
-{
-  TAG *tStk;
-  OPEN_INTERNAL_ENTITY *openEntityList;
-
-  if (parser == NULL)
-      return XML_FALSE;
-
-  if (parentParser)
-    return XML_FALSE;
-  /* move tagStack to freeTagList */
-  tStk = tagStack;
-  while (tStk) {
-    TAG *tag = tStk;
-    tStk = tStk->parent;
-    tag->parent = freeTagList;
-    moveToFreeBindingList(parser, tag->bindings);
-    tag->bindings = NULL;
-    freeTagList = tag;
-  }
-  /* move openInternalEntities to freeInternalEntities */
-  openEntityList = openInternalEntities;
-  while (openEntityList) {
-    OPEN_INTERNAL_ENTITY *openEntity = openEntityList;
-    openEntityList = openEntity->next;
-    openEntity->next = freeInternalEntities;
-    freeInternalEntities = openEntity;
-  }
-  moveToFreeBindingList(parser, inheritedBindings);
-  FREE(unknownEncodingMem);
-  if (unknownEncodingRelease)
-    unknownEncodingRelease(unknownEncodingData);
-  poolClear(&tempPool);
-  poolClear(&temp2Pool);
-  FREE((void *)protocolEncodingName);
-  protocolEncodingName = NULL;
-  parserInit(parser, encodingName);
-  dtdReset(_dtd, &parser->m_mem);
-  return XML_TRUE;
-}
-
-enum XML_Status XMLCALL
-XML_SetEncoding(XML_Parser parser, const XML_Char *encodingName)
-{
-  if (parser == NULL)
-      return XML_STATUS_ERROR;
-  /* Block after XML_Parse()/XML_ParseBuffer() has been called.
-     XXX There's no way for the caller to determine which of the
-     XXX possible error cases caused the XML_STATUS_ERROR return.
-  */
-  if (ps_parsing == XML_PARSING || ps_parsing == XML_SUSPENDED)
-    return XML_STATUS_ERROR;
-
-  /* Get rid of any previous encoding name */
-  FREE((void *)protocolEncodingName);
-
-  if (encodingName == NULL)
-    /* No new encoding name */
-    protocolEncodingName = NULL;
-  else {
-    /* Copy the new encoding name into allocated memory */
-    protocolEncodingName = copyString(encodingName, &(parser->m_mem));
-    if (!protocolEncodingName)
-      return XML_STATUS_ERROR;
-  }
-  return XML_STATUS_OK;
-}
-
-XML_Parser XMLCALL
-XML_ExternalEntityParserCreate(XML_Parser oldParser,
-                               const XML_Char *context,
-                               const XML_Char *encodingName)
-{
-  XML_Parser parser = oldParser;
-  DTD *newDtd = NULL;
-  DTD *oldDtd;
-  XML_StartElementHandler oldStartElementHandler;
-  XML_EndElementHandler oldEndElementHandler;
-  XML_CharacterDataHandler oldCharacterDataHandler;
-  XML_ProcessingInstructionHandler oldProcessingInstructionHandler;
-  XML_CommentHandler oldCommentHandler;
-  XML_StartCdataSectionHandler oldStartCdataSectionHandler;
-  XML_EndCdataSectionHandler oldEndCdataSectionHandler;
-  XML_DefaultHandler oldDefaultHandler;
-  XML_UnparsedEntityDeclHandler oldUnparsedEntityDeclHandler;
-  XML_NotationDeclHandler oldNotationDeclHandler;
-  XML_StartNamespaceDeclHandler oldStartNamespaceDeclHandler;
-  XML_EndNamespaceDeclHandler oldEndNamespaceDeclHandler;
-  XML_NotStandaloneHandler oldNotStandaloneHandler;
-  XML_ExternalEntityRefHandler oldExternalEntityRefHandler;
-  XML_SkippedEntityHandler oldSkippedEntityHandler;
-  XML_UnknownEncodingHandler oldUnknownEncodingHandler;
-  XML_ElementDeclHandler oldElementDeclHandler;
-  XML_AttlistDeclHandler oldAttlistDeclHandler;
-  XML_EntityDeclHandler oldEntityDeclHandler;
-  XML_XmlDeclHandler oldXmlDeclHandler;
-  ELEMENT_TYPE * oldDeclElementType;
-
-  void *oldUserData;
-  void *oldHandlerArg;
-  XML_Bool oldDefaultExpandInternalEntities;
-  XML_Parser oldExternalEntityRefHandlerArg;
-#ifdef XML_DTD
-  enum XML_ParamEntityParsing oldParamEntityParsing;
-  int oldInEntityValue;
-#endif
-  XML_Bool oldns_triplets;
-  /* Note that the new parser shares the same hash secret as the old
-     parser, so that dtdCopy and copyEntityTable can lookup values
-     from hash tables associated with either parser without us having
-     to worry which hash secrets each table has.
-  */
-  unsigned long oldhash_secret_salt;
-
-  /* Validate the oldParser parameter before we pull everything out of it */
-  if (oldParser == NULL)
-    return NULL;
-
-  /* Stash the original parser contents on the stack */
-  oldDtd = _dtd;
-  oldStartElementHandler = startElementHandler;
-  oldEndElementHandler = endElementHandler;
-  oldCharacterDataHandler = characterDataHandler;
-  oldProcessingInstructionHandler = processingInstructionHandler;
-  oldCommentHandler = commentHandler;
-  oldStartCdataSectionHandler = startCdataSectionHandler;
-  oldEndCdataSectionHandler = endCdataSectionHandler;
-  oldDefaultHandler = defaultHandler;
-  oldUnparsedEntityDeclHandler = unparsedEntityDeclHandler;
-  oldNotationDeclHandler = notationDeclHandler;
-  oldStartNamespaceDeclHandler = startNamespaceDeclHandler;
-  oldEndNamespaceDeclHandler = endNamespaceDeclHandler;
-  oldNotStandaloneHandler = notStandaloneHandler;
-  oldExternalEntityRefHandler = externalEntityRefHandler;
-  oldSkippedEntityHandler = skippedEntityHandler;
-  oldUnknownEncodingHandler = unknownEncodingHandler;
-  oldElementDeclHandler = elementDeclHandler;
-  oldAttlistDeclHandler = attlistDeclHandler;
-  oldEntityDeclHandler = entityDeclHandler;
-  oldXmlDeclHandler = xmlDeclHandler;
-  oldDeclElementType = declElementType;
-
-  oldUserData = userData;
-  oldHandlerArg = handlerArg;
-  oldDefaultExpandInternalEntities = defaultExpandInternalEntities;
-  oldExternalEntityRefHandlerArg = externalEntityRefHandlerArg;
-#ifdef XML_DTD
-  oldParamEntityParsing = paramEntityParsing;
-  oldInEntityValue = prologState.inEntityValue;
-#endif
-  oldns_triplets = ns_triplets;
-  /* Note that the new parser shares the same hash secret as the old
-     parser, so that dtdCopy and copyEntityTable can lookup values
-     from hash tables associated with either parser without us having
-     to worry which hash secrets each table has.
-  */
-  oldhash_secret_salt = hash_secret_salt;
-
-#ifdef XML_DTD
-  if (!context)
-    newDtd = oldDtd;
-#endif /* XML_DTD */
-
-  /* Note that the magical uses of the pre-processor to make field
-     access look more like C++ require that `parser' be overwritten
-     here.  This makes this function more painful to follow than it
-     would be otherwise.
-  */
-  if (ns) {
-    XML_Char tmp[2];
-    *tmp = namespaceSeparator;
-    parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);
-  }
-  else {
-    parser = parserCreate(encodingName, &parser->m_mem, NULL, newDtd);
-  }
-
-  if (!parser)
-    return NULL;
-
-  startElementHandler = oldStartElementHandler;
-  endElementHandler = oldEndElementHandler;
-  characterDataHandler = oldCharacterDataHandler;
-  processingInstructionHandler = oldProcessingInstructionHandler;
-  commentHandler = oldCommentHandler;
-  startCdataSectionHandler = oldStartCdataSectionHandler;
-  endCdataSectionHandler = oldEndCdataSectionHandler;
-  defaultHandler = oldDefaultHandler;
-  unparsedEntityDeclHandler = oldUnparsedEntityDeclHandler;
-  notationDeclHandler = oldNotationDeclHandler;
-  startNamespaceDeclHandler = oldStartNamespaceDeclHandler;
-  endNamespaceDeclHandler = oldEndNamespaceDeclHandler;
-  notStandaloneHandler = oldNotStandaloneHandler;
-  externalEntityRefHandler = oldExternalEntityRefHandler;
-  skippedEntityHandler = oldSkippedEntityHandler;
-  unknownEncodingHandler = oldUnknownEncodingHandler;
-  elementDeclHandler = oldElementDeclHandler;
-  attlistDeclHandler = oldAttlistDeclHandler;
-  entityDeclHandler = oldEntityDeclHandler;
-  xmlDeclHandler = oldXmlDeclHandler;
-  declElementType = oldDeclElementType;
-  userData = oldUserData;
-  if (oldUserData == oldHandlerArg)
-    handlerArg = userData;
-  else
-    handlerArg = parser;
-  if (oldExternalEntityRefHandlerArg != oldParser)
-    externalEntityRefHandlerArg = oldExternalEntityRefHandlerArg;
-  defaultExpandInternalEntities = oldDefaultExpandInternalEntities;
-  ns_triplets = oldns_triplets;
-  hash_secret_salt = oldhash_secret_salt;
-  parentParser = oldParser;
-#ifdef XML_DTD
-  paramEntityParsing = oldParamEntityParsing;
-  prologState.inEntityValue = oldInEntityValue;
-  if (context) {
-#endif /* XML_DTD */
-    if (!dtdCopy(oldParser, _dtd, oldDtd, &parser->m_mem)
-      || !setContext(parser, context)) {
-      XML_ParserFree(parser);
-      return NULL;
-    }
-    processor = externalEntityInitProcessor;
-#ifdef XML_DTD
-  }
-  else {
-    /* The DTD instance referenced by _dtd is shared between the document's
-       root parser and external PE parsers, therefore one does not need to
-       call setContext. In addition, one also *must* not call setContext,
-       because this would overwrite existing prefix->binding pointers in
-       _dtd with ones that get destroyed with the external PE parser.
-       This would leave those prefixes with dangling pointers.
-    */
-    isParamEntity = XML_TRUE;
-    XmlPrologStateInitExternalEntity(&prologState);
-    processor = externalParEntInitProcessor;
-  }
-#endif /* XML_DTD */
-  return parser;
-}
-
-static void FASTCALL
-destroyBindings(BINDING *bindings, XML_Parser parser)
-{
-  for (;;) {
-    BINDING *b = bindings;
-    if (!b)
-      break;
-    bindings = b->nextTagBinding;
-    FREE(b->uri);
-    FREE(b);
-  }
-}
-
-void XMLCALL
-XML_ParserFree(XML_Parser parser)
-{
-  TAG *tagList;
-  OPEN_INTERNAL_ENTITY *entityList;
-  if (parser == NULL)
-    return;
-  /* free tagStack and freeTagList */
-  tagList = tagStack;
-  for (;;) {
-    TAG *p;
-    if (tagList == NULL) {
-      if (freeTagList == NULL)
-        break;
-      tagList = freeTagList;
-      freeTagList = NULL;
-    }
-    p = tagList;
-    tagList = tagList->parent;
-    FREE(p->buf);
-    destroyBindings(p->bindings, parser);
-    FREE(p);
-  }
-  /* free openInternalEntities and freeInternalEntities */
-  entityList = openInternalEntities;
-  for (;;) {
-    OPEN_INTERNAL_ENTITY *openEntity;
-    if (entityList == NULL) {
-      if (freeInternalEntities == NULL)
-        break;
-      entityList = freeInternalEntities;
-      freeInternalEntities = NULL;
-    }
-    openEntity = entityList;
-    entityList = entityList->next;
-    FREE(openEntity);
-  }
-
-  destroyBindings(freeBindingList, parser);
-  destroyBindings(inheritedBindings, parser);
-  poolDestroy(&tempPool);
-  poolDestroy(&temp2Pool);
-  FREE((void *)protocolEncodingName);
-#ifdef XML_DTD
-  /* external parameter entity parsers share the DTD structure
-     parser->m_dtd with the root parser, so we must not destroy it
-  */
-  if (!isParamEntity && _dtd)
-#else
-  if (_dtd)
-#endif /* XML_DTD */
-    dtdDestroy(_dtd, (XML_Bool)!parentParser, &parser->m_mem);
-  FREE((void *)atts);
-#ifdef XML_ATTR_INFO
-  FREE((void *)attInfo);
-#endif
-  FREE(groupConnector);
-  FREE(buffer);
-  FREE(dataBuf);
-  FREE(nsAtts);
-  FREE(unknownEncodingMem);
-  if (unknownEncodingRelease)
-    unknownEncodingRelease(unknownEncodingData);
-  FREE(parser);
-}
-
-void XMLCALL
-XML_UseParserAsHandlerArg(XML_Parser parser)
-{
-  if (parser != NULL)
-    handlerArg = parser;
-}
-
-enum XML_Error XMLCALL
-XML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD)
-{
-  if (parser == NULL)
-    return XML_ERROR_INVALID_ARGUMENT;
-#ifdef XML_DTD
-  /* block after XML_Parse()/XML_ParseBuffer() has been called */
-  if (ps_parsing == XML_PARSING || ps_parsing == XML_SUSPENDED)
-    return XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING;
-  useForeignDTD = useDTD;
-  return XML_ERROR_NONE;
-#else
-  return XML_ERROR_FEATURE_REQUIRES_XML_DTD;
-#endif
-}
-
-void XMLCALL
-XML_SetReturnNSTriplet(XML_Parser parser, int do_nst)
-{
-  if (parser == NULL)
-    return;
-  /* block after XML_Parse()/XML_ParseBuffer() has been called */
-  if (ps_parsing == XML_PARSING || ps_parsing == XML_SUSPENDED)
-    return;
-  ns_triplets = do_nst ? XML_TRUE : XML_FALSE;
-}
-
-void XMLCALL
-XML_SetUserData(XML_Parser parser, void *p)
-{
-  if (parser == NULL)
-    return;
-  if (handlerArg == userData)
-    handlerArg = userData = p;
-  else
-    userData = p;
-}
-
-enum XML_Status XMLCALL
-XML_SetBase(XML_Parser parser, const XML_Char *p)
-{
-  if (parser == NULL)
-    return XML_STATUS_ERROR;
-  if (p) {
-    p = poolCopyString(&_dtd->pool, p);
-    if (!p)
-      return XML_STATUS_ERROR;
-    curBase = p;
-  }
-  else
-    curBase = NULL;
-  return XML_STATUS_OK;
-}
-
-const XML_Char * XMLCALL
-XML_GetBase(XML_Parser parser)
-{
-  if (parser == NULL)
-    return NULL;
-  return curBase;
-}
-
-int XMLCALL
-XML_GetSpecifiedAttributeCount(XML_Parser parser)
-{
-  if (parser == NULL)
-    return -1;
-  return nSpecifiedAtts;
-}
-
-int XMLCALL
-XML_GetIdAttributeIndex(XML_Parser parser)
-{
-  if (parser == NULL)
-    return -1;
-  return idAttIndex;
-}
-
-#ifdef XML_ATTR_INFO
-const XML_AttrInfo * XMLCALL
-XML_GetAttributeInfo(XML_Parser parser)
-{
-  if (parser == NULL)
-    return NULL;
-  return attInfo;
-}
-#endif
-
-void XMLCALL
-XML_SetElementHandler(XML_Parser parser,
-                      XML_StartElementHandler start,
-                      XML_EndElementHandler end)
-{
-  if (parser == NULL)
-    return;
-  startElementHandler = start;
-  endElementHandler = end;
-}
-
-void XMLCALL
-XML_SetStartElementHandler(XML_Parser parser,
-                           XML_StartElementHandler start) {
-  if (parser != NULL)
-    startElementHandler = start;
-}
-
-void XMLCALL
-XML_SetEndElementHandler(XML_Parser parser,
-                         XML_EndElementHandler end) {
-  if (parser != NULL)
-    endElementHandler = end;
-}
-
-void XMLCALL
-XML_SetCharacterDataHandler(XML_Parser parser,
-                            XML_CharacterDataHandler handler)
-{
-  if (parser != NULL)
-    characterDataHandler = handler;
-}
-
-void XMLCALL
-XML_SetProcessingInstructionHandler(XML_Parser parser,
-                                    XML_ProcessingInstructionHandler handler)
-{
-  if (parser != NULL)
-    processingInstructionHandler = handler;
-}
-
-void XMLCALL
-XML_SetCommentHandler(XML_Parser parser,
-                      XML_CommentHandler handler)
-{
-  if (parser != NULL)
-    commentHandler = handler;
-}
-
-void XMLCALL
-XML_SetCdataSectionHandler(XML_Parser parser,
-                           XML_StartCdataSectionHandler start,
-                           XML_EndCdataSectionHandler end)
-{
-  if (parser == NULL)
-    return;
-  startCdataSectionHandler = start;
-  endCdataSectionHandler = end;
-}
-
-void XMLCALL
-XML_SetStartCdataSectionHandler(XML_Parser parser,
-                                XML_StartCdataSectionHandler start) {
-  if (parser != NULL)
-    startCdataSectionHandler = start;
-}
-
-void XMLCALL
-XML_SetEndCdataSectionHandler(XML_Parser parser,
-                              XML_EndCdataSectionHandler end) {
-  if (parser != NULL)
-    endCdataSectionHandler = end;
-}
-
-void XMLCALL
-XML_SetDefaultHandler(XML_Parser parser,
-                      XML_DefaultHandler handler)
-{
-  if (parser == NULL)
-    return;
-  defaultHandler = handler;
-  defaultExpandInternalEntities = XML_FALSE;
-}
-
-void XMLCALL
-XML_SetDefaultHandlerExpand(XML_Parser parser,
-                            XML_DefaultHandler handler)
-{
-  if (parser == NULL)
-    return;
-  defaultHandler = handler;
-  defaultExpandInternalEntities = XML_TRUE;
-}
-
-void XMLCALL
-XML_SetDoctypeDeclHandler(XML_Parser parser,
-                          XML_StartDoctypeDeclHandler start,
-                          XML_EndDoctypeDeclHandler end)
-{
-  if (parser == NULL)
-    return;
-  startDoctypeDeclHandler = start;
-  endDoctypeDeclHandler = end;
-}
-
-void XMLCALL
-XML_SetStartDoctypeDeclHandler(XML_Parser parser,
-                               XML_StartDoctypeDeclHandler start) {
-  if (parser != NULL)
-    startDoctypeDeclHandler = start;
-}
-
-void XMLCALL
-XML_SetEndDoctypeDeclHandler(XML_Parser parser,
-                             XML_EndDoctypeDeclHandler end) {
-  if (parser != NULL)
-    endDoctypeDeclHandler = end;
-}
-
-void XMLCALL
-XML_SetUnparsedEntityDeclHandler(XML_Parser parser,
-                                 XML_UnparsedEntityDeclHandler handler)
-{
-  if (parser != NULL)
-    unparsedEntityDeclHandler = handler;
-}
-
-void XMLCALL
-XML_SetNotationDeclHandler(XML_Parser parser,
-                           XML_NotationDeclHandler handler)
-{
-  if (parser != NULL)
-    notationDeclHandler = handler;
-}
-
-void XMLCALL
-XML_SetNamespaceDeclHandler(XML_Parser parser,
-                            XML_StartNamespaceDeclHandler start,
-                            XML_EndNamespaceDeclHandler end)
-{
-  if (parser == NULL)
-    return;
-  startNamespaceDeclHandler = start;
-  endNamespaceDeclHandler = end;
-}
-
-void XMLCALL
-XML_SetStartNamespaceDeclHandler(XML_Parser parser,
-                                 XML_StartNamespaceDeclHandler start) {
-  if (parser != NULL)
-    startNamespaceDeclHandler = start;
-}
-
-void XMLCALL
-XML_SetEndNamespaceDeclHandler(XML_Parser parser,
-                               XML_EndNamespaceDeclHandler end) {
-  if (parser != NULL)
-    endNamespaceDeclHandler = end;
-}
-
-void XMLCALL
-XML_SetNotStandaloneHandler(XML_Parser parser,
-                            XML_NotStandaloneHandler handler)
-{
-  if (parser != NULL)
-    notStandaloneHandler = handler;
-}
-
-void XMLCALL
-XML_SetExternalEntityRefHandler(XML_Parser parser,
-                                XML_ExternalEntityRefHandler handler)
-{
-  if (parser != NULL)
-    externalEntityRefHandler = handler;
-}
-
-void XMLCALL
-XML_SetExternalEntityRefHandlerArg(XML_Parser parser, void *arg)
-{
-  if (parser == NULL)
-    return;
-  if (arg)
-    externalEntityRefHandlerArg = (XML_Parser)arg;
-  else
-    externalEntityRefHandlerArg = parser;
-}
-
-void XMLCALL
-XML_SetSkippedEntityHandler(XML_Parser parser,
-                            XML_SkippedEntityHandler handler)
-{
-  if (parser != NULL)
-    skippedEntityHandler = handler;
-}
-
-void XMLCALL
-XML_SetUnknownEncodingHandler(XML_Parser parser,
-                              XML_UnknownEncodingHandler handler,
-                              void *data)
-{
-  if (parser == NULL)
-    return;
-  unknownEncodingHandler = handler;
-  unknownEncodingHandlerData = data;
-}
-
-void XMLCALL
-XML_SetElementDeclHandler(XML_Parser parser,
-                          XML_ElementDeclHandler eldecl)
-{
-  if (parser != NULL)
-    elementDeclHandler = eldecl;
-}
-
-void XMLCALL
-XML_SetAttlistDeclHandler(XML_Parser parser,
-                          XML_AttlistDeclHandler attdecl)
-{
-  if (parser != NULL)
-    attlistDeclHandler = attdecl;
-}
-
-void XMLCALL
-XML_SetEntityDeclHandler(XML_Parser parser,
-                         XML_EntityDeclHandler handler)
-{
-  if (parser != NULL)
-    entityDeclHandler = handler;
-}
-
-void XMLCALL
-XML_SetXmlDeclHandler(XML_Parser parser,
-                      XML_XmlDeclHandler handler) {
-  if (parser != NULL)
-    xmlDeclHandler = handler;
-}
-
-int XMLCALL
-XML_SetParamEntityParsing(XML_Parser parser,
-                          enum XML_ParamEntityParsing peParsing)
-{
-  if (parser == NULL)
-    return 0;
-  /* block after XML_Parse()/XML_ParseBuffer() has been called */
-  if (ps_parsing == XML_PARSING || ps_parsing == XML_SUSPENDED)
-    return 0;
-#ifdef XML_DTD
-  paramEntityParsing = peParsing;
-  return 1;
-#else
-  return peParsing == XML_PARAM_ENTITY_PARSING_NEVER;
-#endif
-}
-
-int XMLCALL
-XML_SetHashSalt(XML_Parser parser,
-                unsigned long hash_salt)
-{
-  if (parser == NULL)
-    return 0;
-  if (parser->m_parentParser)
-    return XML_SetHashSalt(parser->m_parentParser, hash_salt);
-  /* block after XML_Parse()/XML_ParseBuffer() has been called */
-  if (ps_parsing == XML_PARSING || ps_parsing == XML_SUSPENDED)
-    return 0;
-  hash_secret_salt = hash_salt;
-  return 1;
-}
-
-enum XML_Status XMLCALL
-XML_Parse(XML_Parser parser, const char *s, int len, int isFinal)
-{
-  if ((parser == NULL) || (len < 0) || ((s == NULL) && (len != 0))) {
-    if (parser != NULL)
-      parser->m_errorCode = XML_ERROR_INVALID_ARGUMENT;
-    return XML_STATUS_ERROR;
-  }
-  switch (ps_parsing) {
-  case XML_SUSPENDED:
-    errorCode = XML_ERROR_SUSPENDED;
-    return XML_STATUS_ERROR;
-  case XML_FINISHED:
-    errorCode = XML_ERROR_FINISHED;
-    return XML_STATUS_ERROR;
-  case XML_INITIALIZED:
-    if (parentParser == NULL && !startParsing(parser)) {
-      errorCode = XML_ERROR_NO_MEMORY;
-      return XML_STATUS_ERROR;
-    }
-  default:
-    ps_parsing = XML_PARSING;
-  }
-
-  if (len == 0) {
-    ps_finalBuffer = (XML_Bool)isFinal;
-    if (!isFinal)
-      return XML_STATUS_OK;
-    positionPtr = bufferPtr;
-    parseEndPtr = bufferEnd;
-
-    /* If data are left over from last buffer, and we now know that these
-       data are the final chunk of input, then we have to check them again
-       to detect errors based on that fact.
-    */
-    errorCode = processor(parser, bufferPtr, parseEndPtr, &bufferPtr);
-
-    if (errorCode == XML_ERROR_NONE) {
-      switch (ps_parsing) {
-      case XML_SUSPENDED:
-        /* It is hard to be certain, but it seems that this case
-         * cannot occur.  This code is cleaning up a previous parse
-         * with no new data (since len == 0).  Changing the parsing
-         * state requires getting to execute a handler function, and
-         * there doesn't seem to be an opportunity for that while in
-         * this circumstance.
-         *
-         * Given the uncertainty, we retain the code but exclude it
-         * from coverage tests.
-         *
-         * LCOV_EXCL_START
-         */
-        XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
-        positionPtr = bufferPtr;
-        return XML_STATUS_SUSPENDED;
-        /* LCOV_EXCL_STOP */
-      case XML_INITIALIZED:
-      case XML_PARSING:
-        ps_parsing = XML_FINISHED;
-        /* fall through */
-      default:
-        return XML_STATUS_OK;
-      }
-    }
-    eventEndPtr = eventPtr;
-    processor = errorProcessor;
-    return XML_STATUS_ERROR;
-  }
-#ifndef XML_CONTEXT_BYTES
-  else if (bufferPtr == bufferEnd) {
-    const char *end;
-    int nLeftOver;
-    enum XML_Status result;
-    /* Detect overflow (a+b > MAX <==> b > MAX-a) */
-    if (len > ((XML_Size)-1) / 2 - parseEndByteIndex) {
-       errorCode = XML_ERROR_NO_MEMORY;
-       eventPtr = eventEndPtr = NULL;
-       processor = errorProcessor;
-       return XML_STATUS_ERROR;
-    }
-    parseEndByteIndex += len;
-    positionPtr = s;
-    ps_finalBuffer = (XML_Bool)isFinal;
-
-    errorCode = processor(parser, s, parseEndPtr = s + len, &end);
-
-    if (errorCode != XML_ERROR_NONE) {
-      eventEndPtr = eventPtr;
-      processor = errorProcessor;
-      return XML_STATUS_ERROR;
-    }
-    else {
-      switch (ps_parsing) {
-      case XML_SUSPENDED:
-        result = XML_STATUS_SUSPENDED;
-        break;
-      case XML_INITIALIZED:
-      case XML_PARSING:
-        if (isFinal) {
-          ps_parsing = XML_FINISHED;
-          return XML_STATUS_OK;
-        }
-      /* fall through */
-      default:
-        result = XML_STATUS_OK;
-      }
-    }
-
-    XmlUpdatePosition(encoding, positionPtr, end, &position);
-    nLeftOver = s + len - end;
-    if (nLeftOver) {
-      if (buffer == NULL || nLeftOver > bufferLim - buffer) {
-        /* avoid _signed_ integer overflow */
-        char *temp = NULL;
-        const int bytesToAllocate = (int)((unsigned)len * 2U);
-        if (bytesToAllocate > 0) {
-          temp = (buffer == NULL
-                ? (char *)MALLOC(bytesToAllocate)
-                : (char *)REALLOC(buffer, bytesToAllocate));
-        }
-        if (temp == NULL) {
-          errorCode = XML_ERROR_NO_MEMORY;
-          eventPtr = eventEndPtr = NULL;
-          processor = errorProcessor;
-          return XML_STATUS_ERROR;
-        }
-        buffer = temp;
-        bufferLim = buffer + bytesToAllocate;
-      }
-      memcpy(buffer, end, nLeftOver);
-    }
-    bufferPtr = buffer;
-    bufferEnd = buffer + nLeftOver;
-    positionPtr = bufferPtr;
-    parseEndPtr = bufferEnd;
-    eventPtr = bufferPtr;
-    eventEndPtr = bufferPtr;
-    return result;
-  }
-#endif  /* not defined XML_CONTEXT_BYTES */
-  else {
-    void *buff = XML_GetBuffer(parser, len);
-    if (buff == NULL)
-      return XML_STATUS_ERROR;
-    else {
-      memcpy(buff, s, len);
-      return XML_ParseBuffer(parser, len, isFinal);
-    }
-  }
-}
-
-enum XML_Status XMLCALL
-XML_ParseBuffer(XML_Parser parser, int len, int isFinal)
-{
-  const char *start;
-  enum XML_Status result = XML_STATUS_OK;
-
-  if (parser == NULL)
-    return XML_STATUS_ERROR;
-  switch (ps_parsing) {
-  case XML_SUSPENDED:
-    errorCode = XML_ERROR_SUSPENDED;
-    return XML_STATUS_ERROR;
-  case XML_FINISHED:
-    errorCode = XML_ERROR_FINISHED;
-    return XML_STATUS_ERROR;
-  case XML_INITIALIZED:
-    if (parentParser == NULL && !startParsing(parser)) {
-      errorCode = XML_ERROR_NO_MEMORY;
-      return XML_STATUS_ERROR;
-    }
-  default:
-    ps_parsing = XML_PARSING;
-  }
-
-  start = bufferPtr;
-  positionPtr = start;
-  bufferEnd += len;
-  parseEndPtr = bufferEnd;
-  parseEndByteIndex += len;
-  ps_finalBuffer = (XML_Bool)isFinal;
-
-  errorCode = processor(parser, start, parseEndPtr, &bufferPtr);
-
-  if (errorCode != XML_ERROR_NONE) {
-    eventEndPtr = eventPtr;
-    processor = errorProcessor;
-    return XML_STATUS_ERROR;
-  }
-  else {
-    switch (ps_parsing) {
-    case XML_SUSPENDED:
-      result = XML_STATUS_SUSPENDED;
-      break;
-    case XML_INITIALIZED:
-    case XML_PARSING:
-      if (isFinal) {
-        ps_parsing = XML_FINISHED;
-        return result;
-      }
-    default: ;  /* should not happen */
-    }
-  }
-
-  XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
-  positionPtr = bufferPtr;
-  return result;
-}
-
-void * XMLCALL
-XML_GetBuffer(XML_Parser parser, int len)
-{
-  if (parser == NULL)
-    return NULL;
-  if (len < 0) {
-    errorCode = XML_ERROR_NO_MEMORY;
-    return NULL;
-  }
-  switch (ps_parsing) {
-  case XML_SUSPENDED:
-    errorCode = XML_ERROR_SUSPENDED;
-    return NULL;
-  case XML_FINISHED:
-    errorCode = XML_ERROR_FINISHED;
-    return NULL;
-  default: ;
-  }
-
-  if (len > bufferLim - bufferEnd) {
-#ifdef XML_CONTEXT_BYTES
-    int keep;
-#endif  /* defined XML_CONTEXT_BYTES */
-    /* Do not invoke signed arithmetic overflow: */
-    int neededSize = (int) ((unsigned)len + (unsigned)(bufferEnd - bufferPtr));
-    if (neededSize < 0) {
-      errorCode = XML_ERROR_NO_MEMORY;
-      return NULL;
-    }
-#ifdef XML_CONTEXT_BYTES
-    keep = (int)(bufferPtr - buffer);
-    if (keep > XML_CONTEXT_BYTES)
-      keep = XML_CONTEXT_BYTES;
-    neededSize += keep;
-#endif  /* defined XML_CONTEXT_BYTES */
-    if (neededSize  <= bufferLim - buffer) {
-#ifdef XML_CONTEXT_BYTES
-      if (keep < bufferPtr - buffer) {
-        int offset = (int)(bufferPtr - buffer) - keep;
-        memmove(buffer, &buffer[offset], bufferEnd - bufferPtr + keep);
-        bufferEnd -= offset;
-        bufferPtr -= offset;
-      }
-#else
-      memmove(buffer, bufferPtr, bufferEnd - bufferPtr);
-      bufferEnd = buffer + (bufferEnd - bufferPtr);
-      bufferPtr = buffer;
-#endif  /* not defined XML_CONTEXT_BYTES */
-    }
-    else {
-      char *newBuf;
-      int bufferSize = (int)(bufferLim - bufferPtr);
-      if (bufferSize == 0)
-        bufferSize = INIT_BUFFER_SIZE;
-      do {
-        /* Do not invoke signed arithmetic overflow: */
-        bufferSize = (int) (2U * (unsigned) bufferSize);
-      } while (bufferSize < neededSize && bufferSize > 0);
-      if (bufferSize <= 0) {
-        errorCode = XML_ERROR_NO_MEMORY;
-        return NULL;
-      }
-      newBuf = (char *)MALLOC(bufferSize);
-      if (newBuf == 0) {
-        errorCode = XML_ERROR_NO_MEMORY;
-        return NULL;
-      }
-      bufferLim = newBuf + bufferSize;
-#ifdef XML_CONTEXT_BYTES
-      if (bufferPtr) {
-        int keep = (int)(bufferPtr - buffer);
-        if (keep > XML_CONTEXT_BYTES)
-          keep = XML_CONTEXT_BYTES;
-        memcpy(newBuf, &bufferPtr[-keep], bufferEnd - bufferPtr + keep);
-        FREE(buffer);
-        buffer = newBuf;
-        bufferEnd = buffer + (bufferEnd - bufferPtr) + keep;
-        bufferPtr = buffer + keep;
-      }
-      else {
-        bufferEnd = newBuf + (bufferEnd - bufferPtr);
-        bufferPtr = buffer = newBuf;
-      }
-#else
-      if (bufferPtr) {
-        memcpy(newBuf, bufferPtr, bufferEnd - bufferPtr);
-        FREE(buffer);
-      }
-      bufferEnd = newBuf + (bufferEnd - bufferPtr);
-      bufferPtr = buffer = newBuf;
-#endif  /* not defined XML_CONTEXT_BYTES */
-    }
-    eventPtr = eventEndPtr = NULL;
-    positionPtr = NULL;
-  }
-  return bufferEnd;
-}
-
-enum XML_Status XMLCALL
-XML_StopParser(XML_Parser parser, XML_Bool resumable)
-{
-  if (parser == NULL)
-    return XML_STATUS_ERROR;
-  switch (ps_parsing) {
-  case XML_SUSPENDED:
-    if (resumable) {
-      errorCode = XML_ERROR_SUSPENDED;
-      return XML_STATUS_ERROR;
-    }
-    ps_parsing = XML_FINISHED;
-    break;
-  case XML_FINISHED:
-    errorCode = XML_ERROR_FINISHED;
-    return XML_STATUS_ERROR;
-  default:
-    if (resumable) {
-#ifdef XML_DTD
-      if (isParamEntity) {
-        errorCode = XML_ERROR_SUSPEND_PE;
-        return XML_STATUS_ERROR;
-      }
-#endif
-      ps_parsing = XML_SUSPENDED;
-    }
-    else
-      ps_parsing = XML_FINISHED;
-  }
-  return XML_STATUS_OK;
-}
-
-enum XML_Status XMLCALL
-XML_ResumeParser(XML_Parser parser)
-{
-  enum XML_Status result = XML_STATUS_OK;
-
-  if (parser == NULL)
-    return XML_STATUS_ERROR;
-  if (ps_parsing != XML_SUSPENDED) {
-    errorCode = XML_ERROR_NOT_SUSPENDED;
-    return XML_STATUS_ERROR;
-  }
-  ps_parsing = XML_PARSING;
-
-  errorCode = processor(parser, bufferPtr, parseEndPtr, &bufferPtr);
-
-  if (errorCode != XML_ERROR_NONE) {
-    eventEndPtr = eventPtr;
-    processor = errorProcessor;
-    return XML_STATUS_ERROR;
-  }
-  else {
-    switch (ps_parsing) {
-    case XML_SUSPENDED:
-      result = XML_STATUS_SUSPENDED;
-      break;
-    case XML_INITIALIZED:
-    case XML_PARSING:
-      if (ps_finalBuffer) {
-        ps_parsing = XML_FINISHED;
-        return result;
-      }
-    default: ;
-    }
-  }
-
-  XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
-  positionPtr = bufferPtr;
-  return result;
-}
-
-void XMLCALL
-XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status)
-{
-  if (parser == NULL)
-    return;
-  assert(status != NULL);
-  *status = parser->m_parsingStatus;
-}
-
-enum XML_Error XMLCALL
-XML_GetErrorCode(XML_Parser parser)
-{
-  if (parser == NULL)
-    return XML_ERROR_INVALID_ARGUMENT;
-  return errorCode;
-}
-
-XML_Index XMLCALL
-XML_GetCurrentByteIndex(XML_Parser parser)
-{
-  if (parser == NULL)
-    return -1;
-  if (eventPtr)
-    return (XML_Index)(parseEndByteIndex - (parseEndPtr - eventPtr));
-  return -1;
-}
-
-int XMLCALL
-XML_GetCurrentByteCount(XML_Parser parser)
-{
-  if (parser == NULL)
-    return 0;
-  if (eventEndPtr && eventPtr)
-    return (int)(eventEndPtr - eventPtr);
-  return 0;
-}
-
-const char * XMLCALL
-XML_GetInputContext(XML_Parser parser, int *offset, int *size)
-{
-#ifdef XML_CONTEXT_BYTES
-  if (parser == NULL)
-    return NULL;
-  if (eventPtr && buffer) {
-    if (offset != NULL)
-      *offset = (int)(eventPtr - buffer);
-    if (size != NULL)
-      *size   = (int)(bufferEnd - buffer);
-    return buffer;
-  }
-#else
-  (void)parser;
-  (void)offset;
-  (void)size;
-#endif /* defined XML_CONTEXT_BYTES */
-  return (char *) 0;
-}
-
-XML_Size XMLCALL
-XML_GetCurrentLineNumber(XML_Parser parser)
-{
-  if (parser == NULL)
-    return 0;
-  if (eventPtr && eventPtr >= positionPtr) {
-    XmlUpdatePosition(encoding, positionPtr, eventPtr, &position);
-    positionPtr = eventPtr;
-  }
-  return position.lineNumber + 1;
-}
-
-XML_Size XMLCALL
-XML_GetCurrentColumnNumber(XML_Parser parser)
-{
-  if (parser == NULL)
-    return 0;
-  if (eventPtr && eventPtr >= positionPtr) {
-    XmlUpdatePosition(encoding, positionPtr, eventPtr, &position);
-    positionPtr = eventPtr;
-  }
-  return position.columnNumber;
-}
-
-void XMLCALL
-XML_FreeContentModel(XML_Parser parser, XML_Content *model)
-{
-  if (parser != NULL)
-    FREE(model);
-}
-
-void * XMLCALL
-XML_MemMalloc(XML_Parser parser, size_t size)
-{
-  if (parser == NULL)
-    return NULL;
-  return MALLOC(size);
-}
-
-void * XMLCALL
-XML_MemRealloc(XML_Parser parser, void *ptr, size_t size)
-{
-  if (parser == NULL)
-    return NULL;
-  return REALLOC(ptr, size);
-}
-
-void XMLCALL
-XML_MemFree(XML_Parser parser, void *ptr)
-{
-  if (parser != NULL)
-    FREE(ptr);
-}
-
-void XMLCALL
-XML_DefaultCurrent(XML_Parser parser)
-{
-  if (parser == NULL)
-    return;
-  if (defaultHandler) {
-    if (openInternalEntities)
-      reportDefault(parser,
-                    internalEncoding,
-                    openInternalEntities->internalEventPtr,
-                    openInternalEntities->internalEventEndPtr);
-    else
-      reportDefault(parser, encoding, eventPtr, eventEndPtr);
-  }
-}
-
-const XML_LChar * XMLCALL
-XML_ErrorString(enum XML_Error code)
-{
-  static const XML_LChar* const message[] = {
-    0,
-    XML_L("out of memory"),
-    XML_L("syntax error"),
-    XML_L("no element found"),
-    XML_L("not well-formed (invalid token)"),
-    XML_L("unclosed token"),
-    XML_L("partial character"),
-    XML_L("mismatched tag"),
-    XML_L("duplicate attribute"),
-    XML_L("junk after document element"),
-    XML_L("illegal parameter entity reference"),
-    XML_L("undefined entity"),
-    XML_L("recursive entity reference"),
-    XML_L("asynchronous entity"),
-    XML_L("reference to invalid character number"),
-    XML_L("reference to binary entity"),
-    XML_L("reference to external entity in attribute"),
-    XML_L("XML or text declaration not at start of entity"),
-    XML_L("unknown encoding"),
-    XML_L("encoding specified in XML declaration is incorrect"),
-    XML_L("unclosed CDATA section"),
-    XML_L("error in processing external entity reference"),
-    XML_L("document is not standalone"),
-    XML_L("unexpected parser state - please send a bug report"),
-    XML_L("entity declared in parameter entity"),
-    XML_L("requested feature requires XML_DTD support in Expat"),
-    XML_L("cannot change setting once parsing has begun"),
-    XML_L("unbound prefix"),
-    XML_L("must not undeclare prefix"),
-    XML_L("incomplete markup in parameter entity"),
-    XML_L("XML declaration not well-formed"),
-    XML_L("text declaration not well-formed"),
-    XML_L("illegal character(s) in public id"),
-    XML_L("parser suspended"),
-    XML_L("parser not suspended"),
-    XML_L("parsing aborted"),
-    XML_L("parsing finished"),
-    XML_L("cannot suspend in external parameter entity"),
-    XML_L("reserved prefix (xml) must not be undeclared or bound to another namespace name"),
-    XML_L("reserved prefix (xmlns) must not be declared or undeclared"),
-    XML_L("prefix must not be bound to one of the reserved namespace names")
-  };
-  if (code > 0 && (size_t)code < sizeof(message)/sizeof(message[0]))
-    return message[code];
-  return NULL;
-}
-
-const XML_LChar * XMLCALL
-XML_ExpatVersion(void) {
-
-  /* V1 is used to string-ize the version number. However, it would
-     string-ize the actual version macro *names* unless we get them
-     substituted before being passed to V1. CPP is defined to expand
-     a macro, then rescan for more expansions. Thus, we use V2 to expand
-     the version macros, then CPP will expand the resulting V1() macro
-     with the correct numerals. */
-  /* ### I'm assuming cpp is portable in this respect... */
-
-#define V1(a,b,c) XML_L(#a)XML_L(".")XML_L(#b)XML_L(".")XML_L(#c)
-#define V2(a,b,c) XML_L("expat_")V1(a,b,c)
-
-  return V2(XML_MAJOR_VERSION, XML_MINOR_VERSION, XML_MICRO_VERSION);
-
-#undef V1
-#undef V2
-}
-
-XML_Expat_Version XMLCALL
-XML_ExpatVersionInfo(void)
-{
-  XML_Expat_Version version;
-
-  version.major = XML_MAJOR_VERSION;
-  version.minor = XML_MINOR_VERSION;
-  version.micro = XML_MICRO_VERSION;
-
-  return version;
-}
-
-const XML_Feature * XMLCALL
-XML_GetFeatureList(void)
-{
-  static const XML_Feature features[] = {
-    {XML_FEATURE_SIZEOF_XML_CHAR,  XML_L("sizeof(XML_Char)"),
-     sizeof(XML_Char)},
-    {XML_FEATURE_SIZEOF_XML_LCHAR, XML_L("sizeof(XML_LChar)"),
-     sizeof(XML_LChar)},
-#ifdef XML_UNICODE
-    {XML_FEATURE_UNICODE,          XML_L("XML_UNICODE"), 0},
-#endif
-#ifdef XML_UNICODE_WCHAR_T
-    {XML_FEATURE_UNICODE_WCHAR_T,  XML_L("XML_UNICODE_WCHAR_T"), 0},
-#endif
-#ifdef XML_DTD
-    {XML_FEATURE_DTD,              XML_L("XML_DTD"), 0},
-#endif
-#ifdef XML_CONTEXT_BYTES
-    {XML_FEATURE_CONTEXT_BYTES,    XML_L("XML_CONTEXT_BYTES"),
-     XML_CONTEXT_BYTES},
-#endif
-#ifdef XML_MIN_SIZE
-    {XML_FEATURE_MIN_SIZE,         XML_L("XML_MIN_SIZE"), 0},
-#endif
-#ifdef XML_NS
-    {XML_FEATURE_NS,               XML_L("XML_NS"), 0},
-#endif
-#ifdef XML_LARGE_SIZE
-    {XML_FEATURE_LARGE_SIZE,       XML_L("XML_LARGE_SIZE"), 0},
-#endif
-#ifdef XML_ATTR_INFO
-    {XML_FEATURE_ATTR_INFO,        XML_L("XML_ATTR_INFO"), 0},
-#endif
-    {XML_FEATURE_END,              NULL, 0}
-  };
-
-  return features;
-}
-
-/* Initially tag->rawName always points into the parse buffer;
-   for those TAG instances opened while the current parse buffer was
-   processed, and not yet closed, we need to store tag->rawName in a more
-   permanent location, since the parse buffer is about to be discarded.
-*/
-static XML_Bool
-storeRawNames(XML_Parser parser)
-{
-  TAG *tag = tagStack;
-  while (tag) {
-    int bufSize;
-    int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1);
-    char *rawNameBuf = tag->buf + nameLen;
-    /* Stop if already stored.  Since tagStack is a stack, we can stop
-       at the first entry that has already been copied; everything
-       below it in the stack is already been accounted for in a
-       previous call to this function.
-    */
-    if (tag->rawName == rawNameBuf)
-      break;
-    /* For re-use purposes we need to ensure that the
-       size of tag->buf is a multiple of sizeof(XML_Char).
-    */
-    bufSize = nameLen + ROUND_UP(tag->rawNameLength, sizeof(XML_Char));
-    if (bufSize > tag->bufEnd - tag->buf) {
-      char *temp = (char *)REALLOC(tag->buf, bufSize);
-      if (temp == NULL)
-        return XML_FALSE;
-      /* if tag->name.str points to tag->buf (only when namespace
-         processing is off) then we have to update it
-      */
-      if (tag->name.str == (XML_Char *)tag->buf)
-        tag->name.str = (XML_Char *)temp;
-      /* if tag->name.localPart is set (when namespace processing is on)
-         then update it as well, since it will always point into tag->buf
-      */
-      if (tag->name.localPart)
-        tag->name.localPart = (XML_Char *)temp + (tag->name.localPart -
-                                                  (XML_Char *)tag->buf);
-      tag->buf = temp;
-      tag->bufEnd = temp + bufSize;
-      rawNameBuf = temp + nameLen;
-    }
-    memcpy(rawNameBuf, tag->rawName, tag->rawNameLength);
-    tag->rawName = rawNameBuf;
-    tag = tag->parent;
-  }
-  return XML_TRUE;
-}
-
-static enum XML_Error PTRCALL
-contentProcessor(XML_Parser parser,
-                 const char *start,
-                 const char *end,
-                 const char **endPtr)
-{
-  enum XML_Error result = doContent(parser, 0, encoding, start, end,
-                                    endPtr, (XML_Bool)!ps_finalBuffer);
-  if (result == XML_ERROR_NONE) {
-    if (!storeRawNames(parser))
-      return XML_ERROR_NO_MEMORY;
-  }
-  return result;
-}
-
-static enum XML_Error PTRCALL
-externalEntityInitProcessor(XML_Parser parser,
-                            const char *start,
-                            const char *end,
-                            const char **endPtr)
-{
-  enum XML_Error result = initializeEncoding(parser);
-  if (result != XML_ERROR_NONE)
-    return result;
-  processor = externalEntityInitProcessor2;
-  return externalEntityInitProcessor2(parser, start, end, endPtr);
-}
-
-static enum XML_Error PTRCALL
-externalEntityInitProcessor2(XML_Parser parser,
-                             const char *start,
-                             const char *end,
-                             const char **endPtr)
-{
-  const char *next = start; /* XmlContentTok doesn't always set the last arg */
-  int tok = XmlContentTok(encoding, start, end, &next);
-  switch (tok) {
-  case XML_TOK_BOM:
-    /* If we are at the end of the buffer, this would cause the next stage,
-       i.e. externalEntityInitProcessor3, to pass control directly to
-       doContent (by detecting XML_TOK_NONE) without processing any xml text
-       declaration - causing the error XML_ERROR_MISPLACED_XML_PI in doContent.
-    */
-    if (next == end && !ps_finalBuffer) {
-      *endPtr = next;
-      return XML_ERROR_NONE;
-    }
-    start = next;
-    break;
-  case XML_TOK_PARTIAL:
-    if (!ps_finalBuffer) {
-      *endPtr = start;
-      return XML_ERROR_NONE;
-    }
-    eventPtr = start;
-    return XML_ERROR_UNCLOSED_TOKEN;
-  case XML_TOK_PARTIAL_CHAR:
-    if (!ps_finalBuffer) {
-      *endPtr = start;
-      return XML_ERROR_NONE;
-    }
-    eventPtr = start;
-    return XML_ERROR_PARTIAL_CHAR;
-  }
-  processor = externalEntityInitProcessor3;
-  return externalEntityInitProcessor3(parser, start, end, endPtr);
-}
-
-static enum XML_Error PTRCALL
-externalEntityInitProcessor3(XML_Parser parser,
-                             const char *start,
-                             const char *end,
-                             const char **endPtr)
-{
-  int tok;
-  const char *next = start; /* XmlContentTok doesn't always set the last arg */
-  eventPtr = start;
-  tok = XmlContentTok(encoding, start, end, &next);
-  eventEndPtr = next;
-
-  switch (tok) {
-  case XML_TOK_XML_DECL:
-    {
-      enum XML_Error result;
-      result = processXmlDecl(parser, 1, start, next);
-      if (result != XML_ERROR_NONE)
-        return result;
-      switch (ps_parsing) {
-      case XML_SUSPENDED:
-        *endPtr = next;
-        return XML_ERROR_NONE;
-      case XML_FINISHED:
-        return XML_ERROR_ABORTED;
-      default:
-        start = next;
-      }
-    }
-    break;
-  case XML_TOK_PARTIAL:
-    if (!ps_finalBuffer) {
-      *endPtr = start;
-      return XML_ERROR_NONE;
-    }
-    return XML_ERROR_UNCLOSED_TOKEN;
-  case XML_TOK_PARTIAL_CHAR:
-    if (!ps_finalBuffer) {
-      *endPtr = start;
-      return XML_ERROR_NONE;
-    }
-    return XML_ERROR_PARTIAL_CHAR;
-  }
-  processor = externalEntityContentProcessor;
-  tagLevel = 1;
-  return externalEntityContentProcessor(parser, start, end, endPtr);
-}
-
-static enum XML_Error PTRCALL
-externalEntityContentProcessor(XML_Parser parser,
-                               const char *start,
-                               const char *end,
-                               const char **endPtr)
-{
-  enum XML_Error result = doContent(parser, 1, encoding, start, end,
-                                    endPtr, (XML_Bool)!ps_finalBuffer);
-  if (result == XML_ERROR_NONE) {
-    if (!storeRawNames(parser))
-      return XML_ERROR_NO_MEMORY;
-  }
-  return result;
-}
-
-static enum XML_Error
-doContent(XML_Parser parser,
-          int startTagLevel,
-          const ENCODING *enc,
-          const char *s,
-          const char *end,
-          const char **nextPtr,
-          XML_Bool haveMore)
-{
-  /* save one level of indirection */
-  DTD * const dtd = _dtd;
-
-  const char **eventPP;
-  const char **eventEndPP;
-  if (enc == encoding) {
-    eventPP = &eventPtr;
-    eventEndPP = &eventEndPtr;
-  }
-  else {
-    eventPP = &(openInternalEntities->internalEventPtr);
-    eventEndPP = &(openInternalEntities->internalEventEndPtr);
-  }
-  *eventPP = s;
-
-  for (;;) {
-    const char *next = s; /* XmlContentTok doesn't always set the last arg */
-    int tok = XmlContentTok(enc, s, end, &next);
-    *eventEndPP = next;
-    switch (tok) {
-    case XML_TOK_TRAILING_CR:
-      if (haveMore) {
-        *nextPtr = s;
-        return XML_ERROR_NONE;
-      }
-      *eventEndPP = end;
-      if (characterDataHandler) {
-        XML_Char c = 0xA;
-        characterDataHandler(handlerArg, &c, 1);
-      }
-      else if (defaultHandler)
-        reportDefault(parser, enc, s, end);
-      /* We are at the end of the final buffer, should we check for
-         XML_SUSPENDED, XML_FINISHED?
-      */
-      if (startTagLevel == 0)
-        return XML_ERROR_NO_ELEMENTS;
-      if (tagLevel != startTagLevel)
-        return XML_ERROR_ASYNC_ENTITY;
-      *nextPtr = end;
-      return XML_ERROR_NONE;
-    case XML_TOK_NONE:
-      if (haveMore) {
-        *nextPtr = s;
-        return XML_ERROR_NONE;
-      }
-      if (startTagLevel > 0) {
-        if (tagLevel != startTagLevel)
-          return XML_ERROR_ASYNC_ENTITY;
-        *nextPtr = s;
-        return XML_ERROR_NONE;
-      }
-      return XML_ERROR_NO_ELEMENTS;
-    case XML_TOK_INVALID:
-      *eventPP = next;
-      return XML_ERROR_INVALID_TOKEN;
-    case XML_TOK_PARTIAL:
-      if (haveMore) {
-        *nextPtr = s;
-        return XML_ERROR_NONE;
-      }
-      return XML_ERROR_UNCLOSED_TOKEN;
-    case XML_TOK_PARTIAL_CHAR:
-      if (haveMore) {
-        *nextPtr = s;
-        return XML_ERROR_NONE;
-      }
-      return XML_ERROR_PARTIAL_CHAR;
-    case XML_TOK_ENTITY_REF:
-      {
-        const XML_Char *name;
-        ENTITY *entity;
-        XML_Char ch = (XML_Char) XmlPredefinedEntityName(enc,
-                                              s + enc->minBytesPerChar,
-                                              next - enc->minBytesPerChar);
-        if (ch) {
-          if (characterDataHandler)
-            characterDataHandler(handlerArg, &ch, 1);
-          else if (defaultHandler)
-            reportDefault(parser, enc, s, next);
-          break;
-        }
-        name = poolStoreString(&dtd->pool, enc,
-                                s + enc->minBytesPerChar,
-                                next - enc->minBytesPerChar);
-        if (!name)
-          return XML_ERROR_NO_MEMORY;
-        entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);
-        poolDiscard(&dtd->pool);
-        /* First, determine if a check for an existing declaration is needed;
-           if yes, check that the entity exists, and that it is internal,
-           otherwise call the skipped entity or default handler.
-        */
-        if (!dtd->hasParamEntityRefs || dtd->standalone) {
-          if (!entity)
-            return XML_ERROR_UNDEFINED_ENTITY;
-          else if (!entity->is_internal)
-            return XML_ERROR_ENTITY_DECLARED_IN_PE;
-        }
-        else if (!entity) {
-          if (skippedEntityHandler)
-            skippedEntityHandler(handlerArg, name, 0);
-          else if (defaultHandler)
-            reportDefault(parser, enc, s, next);
-          break;
-        }
-        if (entity->open)
-          return XML_ERROR_RECURSIVE_ENTITY_REF;
-        if (entity->notation)
-          return XML_ERROR_BINARY_ENTITY_REF;
-        if (entity->textPtr) {
-          enum XML_Error result;
-          if (!defaultExpandInternalEntities) {
-            if (skippedEntityHandler)
-              skippedEntityHandler(handlerArg, entity->name, 0);
-            else if (defaultHandler)
-              reportDefault(parser, enc, s, next);
-            break;
-          }
-          result = processInternalEntity(parser, entity, XML_FALSE);
-          if (result != XML_ERROR_NONE)
-            return result;
-        }
-        else if (externalEntityRefHandler) {
-          const XML_Char *context;
-          entity->open = XML_TRUE;
-          context = getContext(parser);
-          entity->open = XML_FALSE;
-          if (!context)
-            return XML_ERROR_NO_MEMORY;
-          if (!externalEntityRefHandler(externalEntityRefHandlerArg,
-                                        context,
-                                        entity->base,
-                                        entity->systemId,
-                                        entity->publicId))
-            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
-          poolDiscard(&tempPool);
-        }
-        else if (defaultHandler)
-          reportDefault(parser, enc, s, next);
-        break;
-      }
-    case XML_TOK_START_TAG_NO_ATTS:
-      /* fall through */
-    case XML_TOK_START_TAG_WITH_ATTS:
-      {
-        TAG *tag;
-        enum XML_Error result;
-        XML_Char *toPtr;
-        if (freeTagList) {
-          tag = freeTagList;
-          freeTagList = freeTagList->parent;
-        }
-        else {
-          tag = (TAG *)MALLOC(sizeof(TAG));
-          if (!tag)
-            return XML_ERROR_NO_MEMORY;
-          tag->buf = (char *)MALLOC(INIT_TAG_BUF_SIZE);
-          if (!tag->buf) {
-            FREE(tag);
-            return XML_ERROR_NO_MEMORY;
-          }
-          tag->bufEnd = tag->buf + INIT_TAG_BUF_SIZE;
-        }
-        tag->bindings = NULL;
-        tag->parent = tagStack;
-        tagStack = tag;
-        tag->name.localPart = NULL;
-        tag->name.prefix = NULL;
-        tag->rawName = s + enc->minBytesPerChar;
-        tag->rawNameLength = XmlNameLength(enc, tag->rawName);
-        ++tagLevel;
-        {
-          const char *rawNameEnd = tag->rawName + tag->rawNameLength;
-          const char *fromPtr = tag->rawName;
-          toPtr = (XML_Char *)tag->buf;
-          for (;;) {
-            int bufSize;
-            int convLen;
-            const enum XML_Convert_Result convert_res = XmlConvert(enc,
-                       &fromPtr, rawNameEnd,
-                       (ICHAR **)&toPtr, (ICHAR *)tag->bufEnd - 1);
-            convLen = (int)(toPtr - (XML_Char *)tag->buf);
-            if ((fromPtr >= rawNameEnd) || (convert_res == XML_CONVERT_INPUT_INCOMPLETE)) {
-              tag->name.strLen = convLen;
-              break;
-            }
-            bufSize = (int)(tag->bufEnd - tag->buf) << 1;
-            {
-              char *temp = (char *)REALLOC(tag->buf, bufSize);
-              if (temp == NULL)
-                return XML_ERROR_NO_MEMORY;
-              tag->buf = temp;
-              tag->bufEnd = temp + bufSize;
-              toPtr = (XML_Char *)temp + convLen;
-            }
-          }
-        }
-        tag->name.str = (XML_Char *)tag->buf;
-        *toPtr = XML_T('\0');
-        result = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings));
-        if (result)
-          return result;
-        if (startElementHandler)
-          startElementHandler(handlerArg, tag->name.str,
-                              (const XML_Char **)atts);
-        else if (defaultHandler)
-          reportDefault(parser, enc, s, next);
-        poolClear(&tempPool);
-        break;
-      }
-    case XML_TOK_EMPTY_ELEMENT_NO_ATTS:
-      /* fall through */
-    case XML_TOK_EMPTY_ELEMENT_WITH_ATTS:
-      {
-        const char *rawName = s + enc->minBytesPerChar;
-        enum XML_Error result;
-        BINDING *bindings = NULL;
-        XML_Bool noElmHandlers = XML_TRUE;
-        TAG_NAME name;
-        name.str = poolStoreString(&tempPool, enc, rawName,
-                                   rawName + XmlNameLength(enc, rawName));
-        if (!name.str)
-          return XML_ERROR_NO_MEMORY;
-        poolFinish(&tempPool);
-        result = storeAtts(parser, enc, s, &name, &bindings);
-        if (result != XML_ERROR_NONE) {
-          freeBindings(parser, bindings);
-          return result;
-        }
-        poolFinish(&tempPool);
-        if (startElementHandler) {
-          startElementHandler(handlerArg, name.str, (const XML_Char **)atts);
-          noElmHandlers = XML_FALSE;
-        }
-        if (endElementHandler) {
-          if (startElementHandler)
-            *eventPP = *eventEndPP;
-          endElementHandler(handlerArg, name.str);
-          noElmHandlers = XML_FALSE;
-        }
-        if (noElmHandlers && defaultHandler)
-          reportDefault(parser, enc, s, next);
-        poolClear(&tempPool);
-        freeBindings(parser, bindings);
-      }
-      if (tagLevel == 0)
-        return epilogProcessor(parser, next, end, nextPtr);
-      break;
-    case XML_TOK_END_TAG:
-      if (tagLevel == startTagLevel)
-        return XML_ERROR_ASYNC_ENTITY;
-      else {
-        int len;
-        const char *rawName;
-        TAG *tag = tagStack;
-        tagStack = tag->parent;
-        tag->parent = freeTagList;
-        freeTagList = tag;
-        rawName = s + enc->minBytesPerChar*2;
-        len = XmlNameLength(enc, rawName);
-        if (len != tag->rawNameLength
-            || memcmp(tag->rawName, rawName, len) != 0) {
-          *eventPP = rawName;
-          return XML_ERROR_TAG_MISMATCH;
-        }
-        --tagLevel;
-        if (endElementHandler) {
-          const XML_Char *localPart;
-          const XML_Char *prefix;
-          XML_Char *uri;
-          localPart = tag->name.localPart;
-          if (ns && localPart) {
-            /* localPart and prefix may have been overwritten in
-               tag->name.str, since this points to the binding->uri
-               buffer which gets re-used; so we have to add them again
-            */
-            uri = (XML_Char *)tag->name.str + tag->name.uriLen;
-            /* don't need to check for space - already done in storeAtts() */
-            while (*localPart) *uri++ = *localPart++;
-            prefix = (XML_Char *)tag->name.prefix;
-            if (ns_triplets && prefix) {
-              *uri++ = namespaceSeparator;
-              while (*prefix) *uri++ = *prefix++;
-             }
-            *uri = XML_T('\0');
-          }
-          endElementHandler(handlerArg, tag->name.str);
-        }
-        else if (defaultHandler)
-          reportDefault(parser, enc, s, next);
-        while (tag->bindings) {
-          BINDING *b = tag->bindings;
-          if (endNamespaceDeclHandler)
-            endNamespaceDeclHandler(handlerArg, b->prefix->name);
-          tag->bindings = tag->bindings->nextTagBinding;
-          b->nextTagBinding = freeBindingList;
-          freeBindingList = b;
-          b->prefix->binding = b->prevPrefixBinding;
-        }
-        if (tagLevel == 0)
-          return epilogProcessor(parser, next, end, nextPtr);
-      }
-      break;
-    case XML_TOK_CHAR_REF:
-      {
-        int n = XmlCharRefNumber(enc, s);
-        if (n < 0)
-          return XML_ERROR_BAD_CHAR_REF;
-        if (characterDataHandler) {
-          XML_Char buf[XML_ENCODE_MAX];
-          characterDataHandler(handlerArg, buf, XmlEncode(n, (ICHAR *)buf));
-        }
-        else if (defaultHandler)
-          reportDefault(parser, enc, s, next);
-      }
-      break;
-    case XML_TOK_XML_DECL:
-      return XML_ERROR_MISPLACED_XML_PI;
-    case XML_TOK_DATA_NEWLINE:
-      if (characterDataHandler) {
-        XML_Char c = 0xA;
-        characterDataHandler(handlerArg, &c, 1);
-      }
-      else if (defaultHandler)
-        reportDefault(parser, enc, s, next);
-      break;
-    case XML_TOK_CDATA_SECT_OPEN:
-      {
-        enum XML_Error result;
-        if (startCdataSectionHandler)
-          startCdataSectionHandler(handlerArg);
-#if 0
-        /* Suppose you doing a transformation on a document that involves
-           changing only the character data.  You set up a defaultHandler
-           and a characterDataHandler.  The defaultHandler simply copies
-           characters through.  The characterDataHandler does the
-           transformation and writes the characters out escaping them as
-           necessary.  This case will fail to work if we leave out the
-           following two lines (because & and < inside CDATA sections will
-           be incorrectly escaped).
-
-           However, now we have a start/endCdataSectionHandler, so it seems
-           easier to let the user deal with this.
-        */
-        else if (characterDataHandler)
-          characterDataHandler(handlerArg, dataBuf, 0);
-#endif
-        else if (defaultHandler)
-          reportDefault(parser, enc, s, next);
-        result = doCdataSection(parser, enc, &next, end, nextPtr, haveMore);
-        if (result != XML_ERROR_NONE)
-          return result;
-        else if (!next) {
-          processor = cdataSectionProcessor;
-          return result;
-        }
-      }
-      break;
-    case XML_TOK_TRAILING_RSQB:
-      if (haveMore) {
-        *nextPtr = s;
-        return XML_ERROR_NONE;
-      }
-      if (characterDataHandler) {
-        if (MUST_CONVERT(enc, s)) {
-          ICHAR *dataPtr = (ICHAR *)dataBuf;
-          XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)dataBufEnd);
-          characterDataHandler(handlerArg, dataBuf,
-                               (int)(dataPtr - (ICHAR *)dataBuf));
-        }
-        else
-          characterDataHandler(handlerArg,
-                               (XML_Char *)s,
-                               (int)((XML_Char *)end - (XML_Char *)s));
-      }
-      else if (defaultHandler)
-        reportDefault(parser, enc, s, end);
-      /* We are at the end of the final buffer, should we check for
-         XML_SUSPENDED, XML_FINISHED?
-      */
-      if (startTagLevel == 0) {
-        *eventPP = end;
-        return XML_ERROR_NO_ELEMENTS;
-      }
-      if (tagLevel != startTagLevel) {
-        *eventPP = end;
-        return XML_ERROR_ASYNC_ENTITY;
-      }
-      *nextPtr = end;
-      return XML_ERROR_NONE;
-    case XML_TOK_DATA_CHARS:
-      {
-        XML_CharacterDataHandler charDataHandler = characterDataHandler;
-        if (charDataHandler) {
-          if (MUST_CONVERT(enc, s)) {
-            for (;;) {
-              ICHAR *dataPtr = (ICHAR *)dataBuf;
-              const enum XML_Convert_Result convert_res = XmlConvert(enc, &s, next, &dataPtr, (ICHAR *)dataBufEnd);
-              *eventEndPP = s;
-              charDataHandler(handlerArg, dataBuf,
-                              (int)(dataPtr - (ICHAR *)dataBuf));
-              if ((convert_res == XML_CONVERT_COMPLETED) || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))
-                break;
-              *eventPP = s;
-            }
-          }
-          else
-            charDataHandler(handlerArg,
-                            (XML_Char *)s,
-                            (int)((XML_Char *)next - (XML_Char *)s));
-        }
-        else if (defaultHandler)
-          reportDefault(parser, enc, s, next);
-      }
-      break;
-    case XML_TOK_PI:
-      if (!reportProcessingInstruction(parser, enc, s, next))
-        return XML_ERROR_NO_MEMORY;
-      break;
-    case XML_TOK_COMMENT:
-      if (!reportComment(parser, enc, s, next))
-        return XML_ERROR_NO_MEMORY;
-      break;
-    default:
-      /* All of the tokens produced by XmlContentTok() have their own
-       * explicit cases, so this default is not strictly necessary.
-       * However it is a useful safety net, so we retain the code and
-       * simply exclude it from the coverage tests.
-       *
-       * LCOV_EXCL_START
-       */
-      if (defaultHandler)
-        reportDefault(parser, enc, s, next);
-      break;
-      /* LCOV_EXCL_STOP */
-    }
-    *eventPP = s = next;
-    switch (ps_parsing) {
-    case XML_SUSPENDED:
-      *nextPtr = next;
-      return XML_ERROR_NONE;
-    case XML_FINISHED:
-      return XML_ERROR_ABORTED;
-    default: ;
-    }
-  }
-  /* not reached */
-}
-
-/* This function does not call free() on the allocated memory, merely
- * moving it to the parser's freeBindingList where it can be freed or
- * reused as appropriate.
- */
-static void
-freeBindings(XML_Parser parser, BINDING *bindings)
-{
-  while (bindings) {
-    BINDING *b = bindings;
-
-    /* startNamespaceDeclHandler will have been called for this
-     * binding in addBindings(), so call the end handler now.
-     */
-    if (endNamespaceDeclHandler)
-        endNamespaceDeclHandler(handlerArg, b->prefix->name);
-
-    bindings = bindings->nextTagBinding;
-    b->nextTagBinding = freeBindingList;
-    freeBindingList = b;
-    b->prefix->binding = b->prevPrefixBinding;
-  }
-}
-
-/* Precondition: all arguments must be non-NULL;
-   Purpose:
-   - normalize attributes
-   - check attributes for well-formedness
-   - generate namespace aware attribute names (URI, prefix)
-   - build list of attributes for startElementHandler
-   - default attributes
-   - process namespace declarations (check and report them)
-   - generate namespace aware element name (URI, prefix)
-*/
-static enum XML_Error
-storeAtts(XML_Parser parser, const ENCODING *enc,
-          const char *attStr, TAG_NAME *tagNamePtr,
-          BINDING **bindingsPtr)
-{
-  DTD * const dtd = _dtd;  /* save one level of indirection */
-  ELEMENT_TYPE *elementType;
-  int nDefaultAtts;
-  const XML_Char **appAtts;   /* the attribute list for the application */
-  int attIndex = 0;
-  int prefixLen;
-  int i;
-  int n;
-  XML_Char *uri;
-  int nPrefixes = 0;
-  BINDING *binding;
-  const XML_Char *localPart;
-
-  /* lookup the element type name */
-  elementType = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, tagNamePtr->str,0);
-  if (!elementType) {
-    const XML_Char *name = poolCopyString(&dtd->pool, tagNamePtr->str);
-    if (!name)
-      return XML_ERROR_NO_MEMORY;
-    elementType = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, name,
-                                         sizeof(ELEMENT_TYPE));
-    if (!elementType)
-      return XML_ERROR_NO_MEMORY;
-    if (ns && !setElementTypePrefix(parser, elementType))
-      return XML_ERROR_NO_MEMORY;
-  }
-  nDefaultAtts = elementType->nDefaultAtts;
-
-  /* get the attributes from the tokenizer */
-  n = XmlGetAttributes(enc, attStr, attsSize, atts);
-  if (n + nDefaultAtts > attsSize) {
-    int oldAttsSize = attsSize;
-    ATTRIBUTE *temp;
-#ifdef XML_ATTR_INFO
-    XML_AttrInfo *temp2;
-#endif
-    attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;
-    temp = (ATTRIBUTE *)REALLOC((void *)atts, attsSize * sizeof(ATTRIBUTE));
-    if (temp == NULL) {
-      attsSize = oldAttsSize;
-      return XML_ERROR_NO_MEMORY;
-    }
-    atts = temp;
-#ifdef XML_ATTR_INFO
-    temp2 = (XML_AttrInfo *)REALLOC((void *)attInfo, attsSize * sizeof(XML_AttrInfo));
-    if (temp2 == NULL) {
-      attsSize = oldAttsSize;
-      return XML_ERROR_NO_MEMORY;
-    }
-    attInfo = temp2;
-#endif
-    if (n > oldAttsSize)
-      XmlGetAttributes(enc, attStr, n, atts);
-  }
-
-  appAtts = (const XML_Char **)atts;
-  for (i = 0; i < n; i++) {
-    ATTRIBUTE *currAtt = &atts[i];
-#ifdef XML_ATTR_INFO
-    XML_AttrInfo *currAttInfo = &attInfo[i];
-#endif
-    /* add the name and value to the attribute list */
-    ATTRIBUTE_ID *attId = getAttributeId(parser, enc, currAtt->name,
-                                         currAtt->name
-                                         + XmlNameLength(enc, currAtt->name));
-    if (!attId)
-      return XML_ERROR_NO_MEMORY;
-#ifdef XML_ATTR_INFO
-    currAttInfo->nameStart = parseEndByteIndex - (parseEndPtr - currAtt->name);
-    currAttInfo->nameEnd = currAttInfo->nameStart +
-                           XmlNameLength(enc, currAtt->name);
-    currAttInfo->valueStart = parseEndByteIndex -
-                            (parseEndPtr - currAtt->valuePtr);
-    currAttInfo->valueEnd = parseEndByteIndex - (parseEndPtr - currAtt->valueEnd);
-#endif
-    /* Detect duplicate attributes by their QNames. This does not work when
-       namespace processing is turned on and different prefixes for the same
-       namespace are used. For this case we have a check further down.
-    */
-    if ((attId->name)[-1]) {
-      if (enc == encoding)
-        eventPtr = atts[i].name;
-      return XML_ERROR_DUPLICATE_ATTRIBUTE;
-    }
-    (attId->name)[-1] = 1;
-    appAtts[attIndex++] = attId->name;
-    if (!atts[i].normalized) {
-      enum XML_Error result;
-      XML_Bool isCdata = XML_TRUE;
-
-      /* figure out whether declared as other than CDATA */
-      if (attId->maybeTokenized) {
-        int j;
-        for (j = 0; j < nDefaultAtts; j++) {
-          if (attId == elementType->defaultAtts[j].id) {
-            isCdata = elementType->defaultAtts[j].isCdata;
-            break;
-          }
-        }
-      }
-
-      /* normalize the attribute value */
-      result = storeAttributeValue(parser, enc, isCdata,
-                                   atts[i].valuePtr, atts[i].valueEnd,
-                                   &tempPool);
-      if (result)
-        return result;
-      appAtts[attIndex] = poolStart(&tempPool);
-      poolFinish(&tempPool);
-    }
-    else {
-      /* the value did not need normalizing */
-      appAtts[attIndex] = poolStoreString(&tempPool, enc, atts[i].valuePtr,
-                                          atts[i].valueEnd);
-      if (appAtts[attIndex] == 0)
-        return XML_ERROR_NO_MEMORY;
-      poolFinish(&tempPool);
-    }
-    /* handle prefixed attribute names */
-    if (attId->prefix) {
-      if (attId->xmlns) {
-        /* deal with namespace declarations here */
-        enum XML_Error result = addBinding(parser, attId->prefix, attId,
-                                           appAtts[attIndex], bindingsPtr);
-        if (result)
-          return result;
-        --attIndex;
-      }
-      else {
-        /* deal with other prefixed names later */
-        attIndex++;
-        nPrefixes++;
-        (attId->name)[-1] = 2;
-      }
-    }
-    else
-      attIndex++;
-  }
-
-  /* set-up for XML_GetSpecifiedAttributeCount and XML_GetIdAttributeIndex */
-  nSpecifiedAtts = attIndex;
-  if (elementType->idAtt && (elementType->idAtt->name)[-1]) {
-    for (i = 0; i < attIndex; i += 2)
-      if (appAtts[i] == elementType->idAtt->name) {
-        idAttIndex = i;
-        break;
-      }
-  }
-  else
-    idAttIndex = -1;
-
-  /* do attribute defaulting */
-  for (i = 0; i < nDefaultAtts; i++) {
-    const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + i;
-    if (!(da->id->name)[-1] && da->value) {
-      if (da->id->prefix) {
-        if (da->id->xmlns) {
-          enum XML_Error result = addBinding(parser, da->id->prefix, da->id,
-                                             da->value, bindingsPtr);
-          if (result)
-            return result;
-        }
-        else {
-          (da->id->name)[-1] = 2;
-          nPrefixes++;
-          appAtts[attIndex++] = da->id->name;
-          appAtts[attIndex++] = da->value;
-        }
-      }
-      else {
-        (da->id->name)[-1] = 1;
-        appAtts[attIndex++] = da->id->name;
-        appAtts[attIndex++] = da->value;
-      }
-    }
-  }
-  appAtts[attIndex] = 0;
-
-  /* expand prefixed attribute names, check for duplicates,
-     and clear flags that say whether attributes were specified */
-  i = 0;
-  if (nPrefixes) {
-    int j;  /* hash table index */
-    unsigned long version = nsAttsVersion;
-    int nsAttsSize = (int)1 << nsAttsPower;
-    unsigned char oldNsAttsPower = nsAttsPower;
-    /* size of hash table must be at least 2 * (# of prefixed attributes) */
-    if ((nPrefixes << 1) >> nsAttsPower) {  /* true for nsAttsPower = 0 */
-      NS_ATT *temp;
-      /* hash table size must also be a power of 2 and >= 8 */
-      while (nPrefixes >> nsAttsPower++);
-      if (nsAttsPower < 3)
-        nsAttsPower = 3;
-      nsAttsSize = (int)1 << nsAttsPower;
-      temp = (NS_ATT *)REALLOC(nsAtts, nsAttsSize * sizeof(NS_ATT));
-      if (!temp) {
-        /* Restore actual size of memory in nsAtts */
-        nsAttsPower = oldNsAttsPower;
-        return XML_ERROR_NO_MEMORY;
-      }
-      nsAtts = temp;
-      version = 0;  /* force re-initialization of nsAtts hash table */
-    }
-    /* using a version flag saves us from initializing nsAtts every time */
-    if (!version) {  /* initialize version flags when version wraps around */
-      version = INIT_ATTS_VERSION;
-      for (j = nsAttsSize; j != 0; )
-        nsAtts[--j].version = version;
-    }
-    nsAttsVersion = --version;
-
-    /* expand prefixed names and check for duplicates */
-    for (; i < attIndex; i += 2) {
-      const XML_Char *s = appAtts[i];
-      if (s[-1] == 2) {  /* prefixed */
-        ATTRIBUTE_ID *id;
-        const BINDING *b;
-        unsigned long uriHash;
-        struct siphash sip_state;
-        struct sipkey sip_key;
-
-        copy_salt_to_sipkey(parser, &sip_key);
-        sip24_init(&sip_state, &sip_key);
-
-        ((XML_Char *)s)[-1] = 0;  /* clear flag */
-        id = (ATTRIBUTE_ID *)lookup(parser, &dtd->attributeIds, s, 0);
-        if (!id || !id->prefix) {
-          /* This code is walking through the appAtts array, dealing
-           * with (in this case) a prefixed attribute name.  To be in
-           * the array, the attribute must have already been bound, so
-           * has to have passed through the hash table lookup once
-           * already.  That implies that an entry for it already
-           * exists, so the lookup above will return a pointer to
-           * already allocated memory.  There is no opportunaity for
-           * the allocator to fail, so the condition above cannot be
-           * fulfilled.
-           *
-           * Since it is difficult to be certain that the above
-           * analysis is complete, we retain the test and merely
-           * remove the code from coverage tests.
-           */
-          return XML_ERROR_NO_MEMORY; /* LCOV_EXCL_LINE */
-        }
-        b = id->prefix->binding;
-        if (!b)
-          return XML_ERROR_UNBOUND_PREFIX;
-
-        for (j = 0; j < b->uriLen; j++) {
-          const XML_Char c = b->uri[j];
-          if (!poolAppendChar(&tempPool, c))
-            return XML_ERROR_NO_MEMORY;
-        }
-
-        sip24_update(&sip_state, b->uri, b->uriLen * sizeof(XML_Char));
-
-        while (*s++ != XML_T(ASCII_COLON))
-          ;
-
-        sip24_update(&sip_state, s, keylen(s) * sizeof(XML_Char));
-
-        do {  /* copies null terminator */
-          if (!poolAppendChar(&tempPool, *s))
-            return XML_ERROR_NO_MEMORY;
-        } while (*s++);
-
-        uriHash = (unsigned long)sip24_final(&sip_state);
-
-        { /* Check hash table for duplicate of expanded name (uriName).
-             Derived from code in lookup(parser, HASH_TABLE *table, ...).
-          */
-          unsigned char step = 0;
-          unsigned long mask = nsAttsSize - 1;
-          j = uriHash & mask;  /* index into hash table */
-          while (nsAtts[j].version == version) {
-            /* for speed we compare stored hash values first */
-            if (uriHash == nsAtts[j].hash) {
-              const XML_Char *s1 = poolStart(&tempPool);
-              const XML_Char *s2 = nsAtts[j].uriName;
-              /* s1 is null terminated, but not s2 */
-              for (; *s1 == *s2 && *s1 != 0; s1++, s2++);
-              if (*s1 == 0)
-                return XML_ERROR_DUPLICATE_ATTRIBUTE;
-            }
-            if (!step)
-              step = PROBE_STEP(uriHash, mask, nsAttsPower);
-            j < step ? (j += nsAttsSize - step) : (j -= step);
-          }
-        }
-
-        if (ns_triplets) {  /* append namespace separator and prefix */
-          tempPool.ptr[-1] = namespaceSeparator;
-          s = b->prefix->name;
-          do {
-            if (!poolAppendChar(&tempPool, *s))
-              return XML_ERROR_NO_MEMORY;
-          } while (*s++);
-        }
-
-        /* store expanded name in attribute list */
-        s = poolStart(&tempPool);
-        poolFinish(&tempPool);
-        appAtts[i] = s;
-
-        /* fill empty slot with new version, uriName and hash value */
-        nsAtts[j].version = version;
-        nsAtts[j].hash = uriHash;
-        nsAtts[j].uriName = s;
-
-        if (!--nPrefixes) {
-          i += 2;
-          break;
-        }
-      }
-      else  /* not prefixed */
-        ((XML_Char *)s)[-1] = 0;  /* clear flag */
-    }
-  }
-  /* clear flags for the remaining attributes */
-  for (; i < attIndex; i += 2)
-    ((XML_Char *)(appAtts[i]))[-1] = 0;
-  for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding)
-    binding->attId->name[-1] = 0;
-
-  if (!ns)
-    return XML_ERROR_NONE;
-
-  /* expand the element type name */
-  if (elementType->prefix) {
-    binding = elementType->prefix->binding;
-    if (!binding)
-      return XML_ERROR_UNBOUND_PREFIX;
-    localPart = tagNamePtr->str;
-    while (*localPart++ != XML_T(ASCII_COLON))
-      ;
-  }
-  else if (dtd->defaultPrefix.binding) {
-    binding = dtd->defaultPrefix.binding;
-    localPart = tagNamePtr->str;
-  }
-  else
-    return XML_ERROR_NONE;
-  prefixLen = 0;
-  if (ns_triplets && binding->prefix->name) {
-    for (; binding->prefix->name[prefixLen++];)
-      ;  /* prefixLen includes null terminator */
-  }
-  tagNamePtr->localPart = localPart;
-  tagNamePtr->uriLen = binding->uriLen;
-  tagNamePtr->prefix = binding->prefix->name;
-  tagNamePtr->prefixLen = prefixLen;
-  for (i = 0; localPart[i++];)
-    ;  /* i includes null terminator */
-  n = i + binding->uriLen + prefixLen;
-  if (n > binding->uriAlloc) {
-    TAG *p;
-    uri = (XML_Char *)MALLOC((n + EXPAND_SPARE) * sizeof(XML_Char));
-    if (!uri)
-      return XML_ERROR_NO_MEMORY;
-    binding->uriAlloc = n + EXPAND_SPARE;
-    memcpy(uri, binding->uri, binding->uriLen * sizeof(XML_Char));
-    for (p = tagStack; p; p = p->parent)
-      if (p->name.str == binding->uri)
-        p->name.str = uri;
-    FREE(binding->uri);
-    binding->uri = uri;
-  }
-  /* if namespaceSeparator != '\0' then uri includes it already */
-  uri = binding->uri + binding->uriLen;
-  memcpy(uri, localPart, i * sizeof(XML_Char));
-  /* we always have a namespace separator between localPart and prefix */
-  if (prefixLen) {
-    uri += i - 1;
-    *uri = namespaceSeparator;  /* replace null terminator */
-    memcpy(uri + 1, binding->prefix->name, prefixLen * sizeof(XML_Char));
-  }
-  tagNamePtr->str = binding->uri;
-  return XML_ERROR_NONE;
-}
-
-/* addBinding() overwrites the value of prefix->binding without checking.
-   Therefore one must keep track of the old value outside of addBinding().
-*/
-static enum XML_Error
-addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,
-           const XML_Char *uri, BINDING **bindingsPtr)
-{
-  static const XML_Char xmlNamespace[] = {
-    ASCII_h, ASCII_t, ASCII_t, ASCII_p, ASCII_COLON, ASCII_SLASH, ASCII_SLASH,
-    ASCII_w, ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w, ASCII_3, ASCII_PERIOD,
-    ASCII_o, ASCII_r, ASCII_g, ASCII_SLASH, ASCII_X, ASCII_M, ASCII_L,
-    ASCII_SLASH, ASCII_1, ASCII_9, ASCII_9, ASCII_8, ASCII_SLASH,
-    ASCII_n, ASCII_a, ASCII_m, ASCII_e, ASCII_s, ASCII_p, ASCII_a, ASCII_c,
-    ASCII_e, '\0'
-  };
-  static const int xmlLen =
-    (int)sizeof(xmlNamespace)/sizeof(XML_Char) - 1;
-  static const XML_Char xmlnsNamespace[] = {
-    ASCII_h, ASCII_t, ASCII_t, ASCII_p, ASCII_COLON, ASCII_SLASH, ASCII_SLASH,
-    ASCII_w, ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w, ASCII_3, ASCII_PERIOD,
-    ASCII_o, ASCII_r, ASCII_g, ASCII_SLASH, ASCII_2, ASCII_0, ASCII_0,
-    ASCII_0, ASCII_SLASH, ASCII_x, ASCII_m, ASCII_l, ASCII_n, ASCII_s,
-    ASCII_SLASH, '\0'
-  };
-  static const int xmlnsLen =
-    (int)sizeof(xmlnsNamespace)/sizeof(XML_Char) - 1;
-
-  XML_Bool mustBeXML = XML_FALSE;
-  XML_Bool isXML = XML_TRUE;
-  XML_Bool isXMLNS = XML_TRUE;
-
-  BINDING *b;
-  int len;
-
-  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */
-  if (*uri == XML_T('\0') && prefix->name)
-    return XML_ERROR_UNDECLARING_PREFIX;
-
-  if (prefix->name
-      && prefix->name[0] == XML_T(ASCII_x)
-      && prefix->name[1] == XML_T(ASCII_m)
-      && prefix->name[2] == XML_T(ASCII_l)) {
-
-    /* Not allowed to bind xmlns */
-    if (prefix->name[3] == XML_T(ASCII_n)
-        && prefix->name[4] == XML_T(ASCII_s)
-        && prefix->name[5] == XML_T('\0'))
-      return XML_ERROR_RESERVED_PREFIX_XMLNS;
-
-    if (prefix->name[3] == XML_T('\0'))
-      mustBeXML = XML_TRUE;
-  }
-
-  for (len = 0; uri[len]; len++) {
-    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))
-      isXML = XML_FALSE;
-
-    if (!mustBeXML && isXMLNS
-        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))
-      isXMLNS = XML_FALSE;
-  }
-  isXML = isXML && len == xmlLen;
-  isXMLNS = isXMLNS && len == xmlnsLen;
-
-  if (mustBeXML != isXML)
-    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML
-                     : XML_ERROR_RESERVED_NAMESPACE_URI;
-
-  if (isXMLNS)
-    return XML_ERROR_RESERVED_NAMESPACE_URI;
-
-  if (namespaceSeparator)
-    len++;
-  if (freeBindingList) {
-    b = freeBindingList;
-    if (len > b->uriAlloc) {
-      XML_Char *temp = (XML_Char *)REALLOC(b->uri,
-                          sizeof(XML_Char) * (len + EXPAND_SPARE));
-      if (temp == NULL)
-        return XML_ERROR_NO_MEMORY;
-      b->uri = temp;
-      b->uriAlloc = len + EXPAND_SPARE;
-    }
-    freeBindingList = b->nextTagBinding;
-  }
-  else {
-    b = (BINDING *)MALLOC(sizeof(BINDING));
-    if (!b)
-      return XML_ERROR_NO_MEMORY;
-    b->uri = (XML_Char *)MALLOC(sizeof(XML_Char) * (len + EXPAND_SPARE));
-    if (!b->uri) {
-      FREE(b);
-      return XML_ERROR_NO_MEMORY;
-    }
-    b->uriAlloc = len + EXPAND_SPARE;
-  }
-  b->uriLen = len;
-  memcpy(b->uri, uri, len * sizeof(XML_Char));
-  if (namespaceSeparator)
-    b->uri[len - 1] = namespaceSeparator;
-  b->prefix = prefix;
-  b->attId = attId;
-  b->prevPrefixBinding = prefix->binding;
-  /* NULL binding when default namespace undeclared */
-  if (*uri == XML_T('\0') && prefix == &_dtd->defaultPrefix)
-    prefix->binding = NULL;
-  else
-    prefix->binding = b;
-  b->nextTagBinding = *bindingsPtr;
-  *bindingsPtr = b;
-  /* if attId == NULL then we are not starting a namespace scope */
-  if (attId && startNamespaceDeclHandler)
-    startNamespaceDeclHandler(handlerArg, prefix->name,
-                              prefix->binding ? uri : 0);
-  return XML_ERROR_NONE;
-}
-
-/* The idea here is to avoid using stack for each CDATA section when
-   the whole file is parsed with one call.
-*/
-static enum XML_Error PTRCALL
-cdataSectionProcessor(XML_Parser parser,
-                      const char *start,
-                      const char *end,
-                      const char **endPtr)
-{
-  enum XML_Error result = doCdataSection(parser, encoding, &start, end,
-                                         endPtr, (XML_Bool)!ps_finalBuffer);
-  if (result != XML_ERROR_NONE)
-    return result;
-  if (start) {
-    if (parentParser) {  /* we are parsing an external entity */
-      processor = externalEntityContentProcessor;
-      return externalEntityContentProcessor(parser, start, end, endPtr);
-    }
-    else {
-      processor = contentProcessor;
-      return contentProcessor(parser, start, end, endPtr);
-    }
-  }
-  return result;
-}
-
-/* startPtr gets set to non-null if the section is closed, and to null if
-   the section is not yet closed.
-*/
-static enum XML_Error
-doCdataSection(XML_Parser parser,
-               const ENCODING *enc,
-               const char **startPtr,
-               const char *end,
-               const char **nextPtr,
-               XML_Bool haveMore)
-{
-  const char *s = *startPtr;
-  const char **eventPP;
-  const char **eventEndPP;
-  if (enc == encoding) {
-    eventPP = &eventPtr;
-    *eventPP = s;
-    eventEndPP = &eventEndPtr;
-  }
-  else {
-    eventPP = &(openInternalEntities->internalEventPtr);
-    eventEndPP = &(openInternalEntities->internalEventEndPtr);
-  }
-  *eventPP = s;
-  *startPtr = NULL;
-
-  for (;;) {
-    const char *next;
-    int tok = XmlCdataSectionTok(enc, s, end, &next);
-    *eventEndPP = next;
-    switch (tok) {
-    case XML_TOK_CDATA_SECT_CLOSE:
-      if (endCdataSectionHandler)
-        endCdataSectionHandler(handlerArg);
-#if 0
-      /* see comment under XML_TOK_CDATA_SECT_OPEN */
-      else if (characterDataHandler)
-        characterDataHandler(handlerArg, dataBuf, 0);
-#endif
-      else if (defaultHandler)
-        reportDefault(parser, enc, s, next);
-      *startPtr = next;
-      *nextPtr = next;
-      if (ps_parsing == XML_FINISHED)
-        return XML_ERROR_ABORTED;
-      else
-        return XML_ERROR_NONE;
-    case XML_TOK_DATA_NEWLINE:
-      if (characterDataHandler) {
-        XML_Char c = 0xA;
-        characterDataHandler(handlerArg, &c, 1);
-      }
-      else if (defaultHandler)
-        reportDefault(parser, enc, s, next);
-      break;
-    case XML_TOK_DATA_CHARS:
-      {
-        XML_CharacterDataHandler charDataHandler = characterDataHandler;
-        if (charDataHandler) {
-          if (MUST_CONVERT(enc, s)) {
-            for (;;) {
-              ICHAR *dataPtr = (ICHAR *)dataBuf;
-              const enum XML_Convert_Result convert_res = XmlConvert(enc, &s, next, &dataPtr, (ICHAR *)dataBufEnd);
-              *eventEndPP = next;
-              charDataHandler(handlerArg, dataBuf,
-                              (int)(dataPtr - (ICHAR *)dataBuf));
-              if ((convert_res == XML_CONVERT_COMPLETED) || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))
-                break;
-              *eventPP = s;
-            }
-          }
-          else
-            charDataHandler(handlerArg,
-                            (XML_Char *)s,
-                            (int)((XML_Char *)next - (XML_Char *)s));
-        }
-        else if (defaultHandler)
-          reportDefault(parser, enc, s, next);
-      }
-      break;
-    case XML_TOK_INVALID:
-      *eventPP = next;
-      return XML_ERROR_INVALID_TOKEN;
-    case XML_TOK_PARTIAL_CHAR:
-      if (haveMore) {
-        *nextPtr = s;
-        return XML_ERROR_NONE;
-      }
-      return XML_ERROR_PARTIAL_CHAR;
-    case XML_TOK_PARTIAL:
-    case XML_TOK_NONE:
-      if (haveMore) {
-        *nextPtr = s;
-        return XML_ERROR_NONE;
-      }
-      return XML_ERROR_UNCLOSED_CDATA_SECTION;
-    default:
-      /* Every token returned by XmlCdataSectionTok() has its own
-       * explicit case, so this default case will never be executed.
-       * We retain it as a safety net and exclude it from the coverage
-       * statistics.
-       *
-       * LCOV_EXCL_START
-      */
-      *eventPP = next;
-      return XML_ERROR_UNEXPECTED_STATE;
-      /* LCOV_EXCL_STOP */
-    }
-
-    *eventPP = s = next;
-    switch (ps_parsing) {
-    case XML_SUSPENDED:
-      *nextPtr = next;
-      return XML_ERROR_NONE;
-    case XML_FINISHED:
-      return XML_ERROR_ABORTED;
-    default: ;
-    }
-  }
-  /* not reached */
-}
-
-#ifdef XML_DTD
-
-/* The idea here is to avoid using stack for each IGNORE section when
-   the whole file is parsed with one call.
-*/
-static enum XML_Error PTRCALL
-ignoreSectionProcessor(XML_Parser parser,
-                       const char *start,
-                       const char *end,
-                       const char **endPtr)
-{
-  enum XML_Error result = doIgnoreSection(parser, encoding, &start, end,
-                                          endPtr, (XML_Bool)!ps_finalBuffer);
-  if (result != XML_ERROR_NONE)
-    return result;
-  if (start) {
-    processor = prologProcessor;
-    return prologProcessor(parser, start, end, endPtr);
-  }
-  return result;
-}
-
-/* startPtr gets set to non-null is the section is closed, and to null
-   if the section is not yet closed.
-*/
-static enum XML_Error
-doIgnoreSection(XML_Parser parser,
-                const ENCODING *enc,
-                const char **startPtr,
-                const char *end,
-                const char **nextPtr,
-                XML_Bool haveMore)
-{
-  const char *next;
-  int tok;
-  const char *s = *startPtr;
-  const char **eventPP;
-  const char **eventEndPP;
-  if (enc == encoding) {
-    eventPP = &eventPtr;
-    *eventPP = s;
-    eventEndPP = &eventEndPtr;
-  }
-  else {
-    /* It's not entirely clear, but it seems the following two lines
-     * of code cannot be executed.  The only occasions on which 'enc'
-     * is not 'parser->m_encoding' are when this function is called
-     * from the internal entity processing, and IGNORE sections are an
-     * error in internal entities.
-     *
-     * Since it really isn't clear that this is true, we keep the code
-     * and just remove it from our coverage tests.
-     *
-     * LCOV_EXCL_START
-     */
-    eventPP = &(openInternalEntities->internalEventPtr);
-    eventEndPP = &(openInternalEntities->internalEventEndPtr);
-    /* LCOV_EXCL_STOP */
-  }
-  *eventPP = s;
-  *startPtr = NULL;
-  tok = XmlIgnoreSectionTok(enc, s, end, &next);
-  *eventEndPP = next;
-  switch (tok) {
-  case XML_TOK_IGNORE_SECT:
-    if (defaultHandler)
-      reportDefault(parser, enc, s, next);
-    *startPtr = next;
-    *nextPtr = next;
-    if (ps_parsing == XML_FINISHED)
-      return XML_ERROR_ABORTED;
-    else
-      return XML_ERROR_NONE;
-  case XML_TOK_INVALID:
-    *eventPP = next;
-    return XML_ERROR_INVALID_TOKEN;
-  case XML_TOK_PARTIAL_CHAR:
-    if (haveMore) {
-      *nextPtr = s;
-      return XML_ERROR_NONE;
-    }
-    return XML_ERROR_PARTIAL_CHAR;
-  case XML_TOK_PARTIAL:
-  case XML_TOK_NONE:
-    if (haveMore) {
-      *nextPtr = s;
-      return XML_ERROR_NONE;
-    }
-    return XML_ERROR_SYNTAX; /* XML_ERROR_UNCLOSED_IGNORE_SECTION */
-  default:
-    /* All of the tokens that XmlIgnoreSectionTok() returns have
-     * explicit cases to handle them, so this default case is never
-     * executed.  We keep it as a safety net anyway, and remove it
-     * from our test coverage statistics.
-     *
-     * LCOV_EXCL_START
-     */
-    *eventPP = next;
-    return XML_ERROR_UNEXPECTED_STATE;
-    /* LCOV_EXCL_STOP */
-  }
-  /* not reached */
-}
-
-#endif /* XML_DTD */
-
-static enum XML_Error
-initializeEncoding(XML_Parser parser)
-{
-  const char *s;
-#ifdef XML_UNICODE
-  char encodingBuf[128];
-  /* See comments abount `protoclEncodingName` in parserInit() */
-  if (!protocolEncodingName)
-    s = NULL;
-  else {
-    int i;
-    for (i = 0; protocolEncodingName[i]; i++) {
-      if (i == sizeof(encodingBuf) - 1
-          || (protocolEncodingName[i] & ~0x7f) != 0) {
-        encodingBuf[0] = '\0';
-        break;
-      }
-      encodingBuf[i] = (char)protocolEncodingName[i];
-    }
-    encodingBuf[i] = '\0';
-    s = encodingBuf;
-  }
-#else
-  s = protocolEncodingName;
-#endif
-  if ((ns ? XmlInitEncodingNS : XmlInitEncoding)(&initEncoding, &encoding, s))
-    return XML_ERROR_NONE;
-  return handleUnknownEncoding(parser, protocolEncodingName);
-}
-
-static enum XML_Error
-processXmlDecl(XML_Parser parser, int isGeneralTextEntity,
-               const char *s, const char *next)
-{
-  const char *encodingName = NULL;
-  const XML_Char *storedEncName = NULL;
-  const ENCODING *newEncoding = NULL;
-  const char *version = NULL;
-  const char *versionend;
-  const XML_Char *storedversion = NULL;
-  int standalone = -1;
-  if (!(ns
-        ? XmlParseXmlDeclNS
-        : XmlParseXmlDecl)(isGeneralTextEntity,
-                           encoding,
-                           s,
-                           next,
-                           &eventPtr,
-                           &version,
-                           &versionend,
-                           &encodingName,
-                           &newEncoding,
-                           &standalone)) {
-    if (isGeneralTextEntity)
-      return XML_ERROR_TEXT_DECL;
-    else
-      return XML_ERROR_XML_DECL;
-  }
-  if (!isGeneralTextEntity && standalone == 1) {
-    _dtd->standalone = XML_TRUE;
-#ifdef XML_DTD
-    if (paramEntityParsing == XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE)
-      paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;
-#endif /* XML_DTD */
-  }
-  if (xmlDeclHandler) {
-    if (encodingName != NULL) {
-      storedEncName = poolStoreString(&temp2Pool,
-                                      encoding,
-                                      encodingName,
-                                      encodingName
-                                      + XmlNameLength(encoding, encodingName));
-      if (!storedEncName)
-              return XML_ERROR_NO_MEMORY;
-      poolFinish(&temp2Pool);
-    }
-    if (version) {
-      storedversion = poolStoreString(&temp2Pool,
-                                      encoding,
-                                      version,
-                                      versionend - encoding->minBytesPerChar);
-      if (!storedversion)
-        return XML_ERROR_NO_MEMORY;
-    }
-    xmlDeclHandler(handlerArg, storedversion, storedEncName, standalone);
-  }
-  else if (defaultHandler)
-    reportDefault(parser, encoding, s, next);
-  if (protocolEncodingName == NULL) {
-    if (newEncoding) {
-      /* Check that the specified encoding does not conflict with what
-       * the parser has already deduced.  Do we have the same number
-       * of bytes in the smallest representation of a character?  If
-       * this is UTF-16, is it the same endianness?
-       */
-      if (newEncoding->minBytesPerChar != encoding->minBytesPerChar
-          || (newEncoding->minBytesPerChar == 2 &&
-              newEncoding != encoding)) {
-        eventPtr = encodingName;
-        return XML_ERROR_INCORRECT_ENCODING;
-      }
-      encoding = newEncoding;
-    }
-    else if (encodingName) {
-      enum XML_Error result;
-      if (!storedEncName) {
-        storedEncName = poolStoreString(
-          &temp2Pool, encoding, encodingName,
-          encodingName + XmlNameLength(encoding, encodingName));
-        if (!storedEncName)
-          return XML_ERROR_NO_MEMORY;
-      }
-      result = handleUnknownEncoding(parser, storedEncName);
-      poolClear(&temp2Pool);
-      if (result == XML_ERROR_UNKNOWN_ENCODING)
-        eventPtr = encodingName;
-      return result;
-    }
-  }
-
-  if (storedEncName || storedversion)
-    poolClear(&temp2Pool);
-
-  return XML_ERROR_NONE;
-}
-
-static enum XML_Error
-handleUnknownEncoding(XML_Parser parser, const XML_Char *encodingName)
-{
-  if (unknownEncodingHandler) {
-    XML_Encoding info;
-    int i;
-    for (i = 0; i < 256; i++)
-      info.map[i] = -1;
-    info.convert = NULL;
-    info.data = NULL;
-    info.release = NULL;
-    if (unknownEncodingHandler(unknownEncodingHandlerData, encodingName,
-                               &info)) {
-      ENCODING *enc;
-      unknownEncodingMem = MALLOC(XmlSizeOfUnknownEncoding());
-      if (!unknownEncodingMem) {
-        if (info.release)
-          info.release(info.data);
-        return XML_ERROR_NO_MEMORY;
-      }
-      enc = (ns
-             ? XmlInitUnknownEncodingNS
-             : XmlInitUnknownEncoding)(unknownEncodingMem,
-                                       info.map,
-                                       info.convert,
-                                       info.data);
-      if (enc) {
-        unknownEncodingData = info.data;
-        unknownEncodingRelease = info.release;
-        encoding = enc;
-        return XML_ERROR_NONE;
-      }
-    }
-    if (info.release != NULL)
-      info.release(info.data);
-  }
-  return XML_ERROR_UNKNOWN_ENCODING;
-}
-
-static enum XML_Error PTRCALL
-prologInitProcessor(XML_Parser parser,
-                    const char *s,
-                    const char *end,
-                    const char **nextPtr)
-{
-  enum XML_Error result = initializeEncoding(parser);
-  if (result != XML_ERROR_NONE)
-    return result;
-  processor = prologProcessor;
-  return prologProcessor(parser, s, end, nextPtr);
-}
-
-#ifdef XML_DTD
-
-static enum XML_Error PTRCALL
-externalParEntInitProcessor(XML_Parser parser,
-                            const char *s,
-                            const char *end,
-                            const char **nextPtr)
-{
-  enum XML_Error result = initializeEncoding(parser);
-  if (result != XML_ERROR_NONE)
-    return result;
-
-  /* we know now that XML_Parse(Buffer) has been called,
-     so we consider the external parameter entity read */
-  _dtd->paramEntityRead = XML_TRUE;
-
-  if (prologState.inEntityValue) {
-    processor = entityValueInitProcessor;
-    return entityValueInitProcessor(parser, s, end, nextPtr);
-  }
-  else {
-    processor = externalParEntProcessor;
-    return externalParEntProcessor(parser, s, end, nextPtr);
-  }
-}
-
-static enum XML_Error PTRCALL
-entityValueInitProcessor(XML_Parser parser,
-                         const char *s,
-                         const char *end,
-                         const char **nextPtr)
-{
-  int tok;
-  const char *start = s;
-  const char *next = start;
-  eventPtr = start;
-
-  for (;;) {
-    tok = XmlPrologTok(encoding, start, end, &next);
-    eventEndPtr = next;
-    if (tok <= 0) {
-      if (!ps_finalBuffer && tok != XML_TOK_INVALID) {
-        *nextPtr = s;
-        return XML_ERROR_NONE;
-      }
-      switch (tok) {
-      case XML_TOK_INVALID:
-        return XML_ERROR_INVALID_TOKEN;
-      case XML_TOK_PARTIAL:
-        return XML_ERROR_UNCLOSED_TOKEN;
-      case XML_TOK_PARTIAL_CHAR:
-        return XML_ERROR_PARTIAL_CHAR;
-      case XML_TOK_NONE:   /* start == end */
-      default:
-        break;
-      }
-      /* found end of entity value - can store it now */
-      return storeEntityValue(parser, encoding, s, end);
-    }
-    else if (tok == XML_TOK_XML_DECL) {
-      enum XML_Error result;
-      result = processXmlDecl(parser, 0, start, next);
-      if (result != XML_ERROR_NONE)
-        return result;
-      /* At this point, ps_parsing cannot be XML_SUSPENDED.  For that
-       * to happen, a parameter entity parsing handler must have
-       * attempted to suspend the parser, which fails and raises an
-       * error.  The parser can be aborted, but can't be suspended.
-       */
-      if (ps_parsing == XML_FINISHED)
-        return XML_ERROR_ABORTED;
-      *nextPtr = next;
-      /* stop scanning for text declaration - we found one */
-      processor = entityValueProcessor;
-      return entityValueProcessor(parser, next, end, nextPtr);
-    }
-    /* If we are at the end of the buffer, this would cause XmlPrologTok to
-       return XML_TOK_NONE on the next call, which would then cause the
-       function to exit with *nextPtr set to s - that is what we want for other
-       tokens, but not for the BOM - we would rather like to skip it;
-       then, when this routine is entered the next time, XmlPrologTok will
-       return XML_TOK_INVALID, since the BOM is still in the buffer
-    */
-    else if (tok == XML_TOK_BOM && next == end && !ps_finalBuffer) {
-      *nextPtr = next;
-      return XML_ERROR_NONE;
-    }
-    /* If we get this token, we have the start of what might be a
-       normal tag, but not a declaration (i.e. it doesn't begin with
-       "<!").  In a DTD context, that isn't legal.
-    */
-    else if (tok == XML_TOK_INSTANCE_START) {
-      *nextPtr = next;
-      return XML_ERROR_SYNTAX;
-    }
-    start = next;
-    eventPtr = start;
-  }
-}
-
-static enum XML_Error PTRCALL
-externalParEntProcessor(XML_Parser parser,
-                        const char *s,
-                        const char *end,
-                        const char **nextPtr)
-{
-  const char *next = s;
-  int tok;
-
-  tok = XmlPrologTok(encoding, s, end, &next);
-  if (tok <= 0) {
-    if (!ps_finalBuffer && tok != XML_TOK_INVALID) {
-      *nextPtr = s;
-      return XML_ERROR_NONE;
-    }
-    switch (tok) {
-    case XML_TOK_INVALID:
-      return XML_ERROR_INVALID_TOKEN;
-    case XML_TOK_PARTIAL:
-      return XML_ERROR_UNCLOSED_TOKEN;
-    case XML_TOK_PARTIAL_CHAR:
-      return XML_ERROR_PARTIAL_CHAR;
-    case XML_TOK_NONE:   /* start == end */
-    default:
-      break;
-    }
-  }
-  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.
-     However, when parsing an external subset, doProlog will not accept a BOM
-     as valid, and report a syntax error, so we have to skip the BOM
-  */
-  else if (tok == XML_TOK_BOM) {
-    s = next;
-    tok = XmlPrologTok(encoding, s, end, &next);
-  }
-
-  processor = prologProcessor;
-  return doProlog(parser, encoding, s, end, tok, next,
-                  nextPtr, (XML_Bool)!ps_finalBuffer);
-}
-
-static enum XML_Error PTRCALL
-entityValueProcessor(XML_Parser parser,
-                     const char *s,
-                     const char *end,
-                     const char **nextPtr)
-{
-  const char *start = s;
-  const char *next = s;
-  const ENCODING *enc = encoding;
-  int tok;
-
-  for (;;) {
-    tok = XmlPrologTok(enc, start, end, &next);
-    if (tok <= 0) {
-      if (!ps_finalBuffer && tok != XML_TOK_INVALID) {
-        *nextPtr = s;
-        return XML_ERROR_NONE;
-      }
-      switch (tok) {
-      case XML_TOK_INVALID:
-        return XML_ERROR_INVALID_TOKEN;
-      case XML_TOK_PARTIAL:
-        return XML_ERROR_UNCLOSED_TOKEN;
-      case XML_TOK_PARTIAL_CHAR:
-        return XML_ERROR_PARTIAL_CHAR;
-      case XML_TOK_NONE:   /* start == end */
-      default:
-        break;
-      }
-      /* found end of entity value - can store it now */
-      return storeEntityValue(parser, enc, s, end);
-    }
-    start = next;
-  }
-}
-
-#endif /* XML_DTD */
-
-static enum XML_Error PTRCALL
-prologProcessor(XML_Parser parser,
-                const char *s,
-                const char *end,
-                const char **nextPtr)
-{
-  const char *next = s;
-  int tok = XmlPrologTok(encoding, s, end, &next);
-  return doProlog(parser, encoding, s, end, tok, next,
-                  nextPtr, (XML_Bool)!ps_finalBuffer);
-}
-
-static enum XML_Error
-doProlog(XML_Parser parser,
-         const ENCODING *enc,
-         const char *s,
-         const char *end,
-         int tok,
-         const char *next,
-         const char **nextPtr,
-         XML_Bool haveMore)
-{
-#ifdef XML_DTD
-  static const XML_Char externalSubsetName[] = { ASCII_HASH , '\0' };
-#endif /* XML_DTD */
-  static const XML_Char atypeCDATA[] =
-      { ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0' };
-  static const XML_Char atypeID[] = { ASCII_I, ASCII_D, '\0' };
-  static const XML_Char atypeIDREF[] =
-      { ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, '\0' };
-  static const XML_Char atypeIDREFS[] =
-      { ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, ASCII_S, '\0' };
-  static const XML_Char atypeENTITY[] =
-      { ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_Y, '\0' };
-  static const XML_Char atypeENTITIES[] = { ASCII_E, ASCII_N,
-      ASCII_T, ASCII_I, ASCII_T, ASCII_I, ASCII_E, ASCII_S, '\0' };
-  static const XML_Char atypeNMTOKEN[] = {
-      ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, '\0' };
-  static const XML_Char atypeNMTOKENS[] = { ASCII_N, ASCII_M, ASCII_T,
-      ASCII_O, ASCII_K, ASCII_E, ASCII_N, ASCII_S, '\0' };
-  static const XML_Char notationPrefix[] = { ASCII_N, ASCII_O, ASCII_T,
-      ASCII_A, ASCII_T, ASCII_I, ASCII_O, ASCII_N, ASCII_LPAREN, '\0' };
-  static const XML_Char enumValueSep[] = { ASCII_PIPE, '\0' };
-  static const XML_Char enumValueStart[] = { ASCII_LPAREN, '\0' };
-
-  /* save one level of indirection */
-  DTD * const dtd = _dtd;
-
-  const char **eventPP;
-  const char **eventEndPP;
-  enum XML_Content_Quant quant;
-
-  if (enc == encoding) {
-    eventPP = &eventPtr;
-    eventEndPP = &eventEndPtr;
-  }
-  else {
-    eventPP = &(openInternalEntities->internalEventPtr);
-    eventEndPP = &(openInternalEntities->internalEventEndPtr);
-  }
-
-  for (;;) {
-    int role;
-    XML_Bool handleDefault = XML_TRUE;
-    *eventPP = s;
-    *eventEndPP = next;
-    if (tok <= 0) {
-      if (haveMore && tok != XML_TOK_INVALID) {
-        *nextPtr = s;
-        return XML_ERROR_NONE;
-      }
-      switch (tok) {
-      case XML_TOK_INVALID:
-        *eventPP = next;
-        return XML_ERROR_INVALID_TOKEN;
-      case XML_TOK_PARTIAL:
-        return XML_ERROR_UNCLOSED_TOKEN;
-      case XML_TOK_PARTIAL_CHAR:
-        return XML_ERROR_PARTIAL_CHAR;
-      case -XML_TOK_PROLOG_S:
-        tok = -tok;
-        break;
-      case XML_TOK_NONE:
-#ifdef XML_DTD
-        /* for internal PE NOT referenced between declarations */
-        if (enc != encoding && !openInternalEntities->betweenDecl) {
-          *nextPtr = s;
-          return XML_ERROR_NONE;
-        }
-        /* WFC: PE Between Declarations - must check that PE contains
-           complete markup, not only for external PEs, but also for
-           internal PEs if the reference occurs between declarations.
-        */
-        if (isParamEntity || enc != encoding) {
-          if (XmlTokenRole(&prologState, XML_TOK_NONE, end, end, enc)
-              == XML_ROLE_ERROR)
-            return XML_ERROR_INCOMPLETE_PE;
-          *nextPtr = s;
-          return XML_ERROR_NONE;
-        }
-#endif /* XML_DTD */
-        return XML_ERROR_NO_ELEMENTS;
-      default:
-        tok = -tok;
-        next = end;
-        break;
-      }
-    }
-    role = XmlTokenRole(&prologState, tok, s, next, enc);
-    switch (role) {
-    case XML_ROLE_XML_DECL:
-      {
-        enum XML_Error result = processXmlDecl(parser, 0, s, next);
-        if (result != XML_ERROR_NONE)
-          return result;
-        enc = encoding;
-        handleDefault = XML_FALSE;
-      }
-      break;
-    case XML_ROLE_DOCTYPE_NAME:
-      if (startDoctypeDeclHandler) {
-        doctypeName = poolStoreString(&tempPool, enc, s, next);
-        if (!doctypeName)
-          return XML_ERROR_NO_MEMORY;
-        poolFinish(&tempPool);
-        doctypePubid = NULL;
-        handleDefault = XML_FALSE;
-      }
-      doctypeSysid = NULL; /* always initialize to NULL */
-      break;
-    case XML_ROLE_DOCTYPE_INTERNAL_SUBSET:
-      if (startDoctypeDeclHandler) {
-        startDoctypeDeclHandler(handlerArg, doctypeName, doctypeSysid,
-                                doctypePubid, 1);
-        doctypeName = NULL;
-        poolClear(&tempPool);
-        handleDefault = XML_FALSE;
-      }
-      break;
-#ifdef XML_DTD
-    case XML_ROLE_TEXT_DECL:
-      {
-        enum XML_Error result = processXmlDecl(parser, 1, s, next);
-        if (result != XML_ERROR_NONE)
-          return result;
-        enc = encoding;
-        handleDefault = XML_FALSE;
-      }
-      break;
-#endif /* XML_DTD */
-    case XML_ROLE_DOCTYPE_PUBLIC_ID:
-#ifdef XML_DTD
-      useForeignDTD = XML_FALSE;
-      declEntity = (ENTITY *)lookup(parser,
-                                    &dtd->paramEntities,
-                                    externalSubsetName,
-                                    sizeof(ENTITY));
-      if (!declEntity)
-        return XML_ERROR_NO_MEMORY;
-#endif /* XML_DTD */
-      dtd->hasParamEntityRefs = XML_TRUE;
-      if (startDoctypeDeclHandler) {
-        XML_Char *pubId;
-        if (!XmlIsPublicId(enc, s, next, eventPP))
-          return XML_ERROR_PUBLICID;
-        pubId = poolStoreString(&tempPool, enc,
-                                s + enc->minBytesPerChar,
-                                next - enc->minBytesPerChar);
-        if (!pubId)
-          return XML_ERROR_NO_MEMORY;
-        normalizePublicId(pubId);
-        poolFinish(&tempPool);
-        doctypePubid = pubId;
-        handleDefault = XML_FALSE;
-        goto alreadyChecked;
-      }
-      /* fall through */
-    case XML_ROLE_ENTITY_PUBLIC_ID:
-      if (!XmlIsPublicId(enc, s, next, eventPP))
-        return XML_ERROR_PUBLICID;
-    alreadyChecked:
-      if (dtd->keepProcessing && declEntity) {
-        XML_Char *tem = poolStoreString(&dtd->pool,
-                                        enc,
-                                        s + enc->minBytesPerChar,
-                                        next - enc->minBytesPerChar);
-        if (!tem)
-          return XML_ERROR_NO_MEMORY;
-        normalizePublicId(tem);
-        declEntity->publicId = tem;
-        poolFinish(&dtd->pool);
-        if (entityDeclHandler)
-          handleDefault = XML_FALSE;
-      }
-      break;
-    case XML_ROLE_DOCTYPE_CLOSE:
-      if (doctypeName) {
-        startDoctypeDeclHandler(handlerArg, doctypeName,
-                                doctypeSysid, doctypePubid, 0);
-        poolClear(&tempPool);
-        handleDefault = XML_FALSE;
-      }
-      /* doctypeSysid will be non-NULL in the case of a previous
-         XML_ROLE_DOCTYPE_SYSTEM_ID, even if startDoctypeDeclHandler
-         was not set, indicating an external subset
-      */
-#ifdef XML_DTD
-      if (doctypeSysid || useForeignDTD) {
-        XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;
-        dtd->hasParamEntityRefs = XML_TRUE;
-        if (paramEntityParsing && externalEntityRefHandler) {
-          ENTITY *entity = (ENTITY *)lookup(parser,
-                                            &dtd->paramEntities,
-                                            externalSubsetName,
-                                            sizeof(ENTITY));
-          if (!entity) {
-            /* The external subset name "#" will have already been
-             * inserted into the hash table at the start of the
-             * external entity parsing, so no allocation will happen
-             * and lookup() cannot fail.
-             */
-            return XML_ERROR_NO_MEMORY; /* LCOV_EXCL_LINE */
-          }
-          if (useForeignDTD)
-            entity->base = curBase;
-          dtd->paramEntityRead = XML_FALSE;
-          if (!externalEntityRefHandler(externalEntityRefHandlerArg,
-                                        0,
-                                        entity->base,
-                                        entity->systemId,
-                                        entity->publicId))
-            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
-          if (dtd->paramEntityRead) {
-            if (!dtd->standalone &&
-                notStandaloneHandler &&
-                !notStandaloneHandler(handlerArg))
-              return XML_ERROR_NOT_STANDALONE;
-          }
-          /* if we didn't read the foreign DTD then this means that there
-             is no external subset and we must reset dtd->hasParamEntityRefs
-          */
-          else if (!doctypeSysid)
-            dtd->hasParamEntityRefs = hadParamEntityRefs;
-          /* end of DTD - no need to update dtd->keepProcessing */
-        }
-        useForeignDTD = XML_FALSE;
-      }
-#endif /* XML_DTD */
-      if (endDoctypeDeclHandler) {
-        endDoctypeDeclHandler(handlerArg);
-        handleDefault = XML_FALSE;
-      }
-      break;
-    case XML_ROLE_INSTANCE_START:
-#ifdef XML_DTD
-      /* if there is no DOCTYPE declaration then now is the
-         last chance to read the foreign DTD
-      */
-      if (useForeignDTD) {
-        XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;
-        dtd->hasParamEntityRefs = XML_TRUE;
-        if (paramEntityParsing && externalEntityRefHandler) {
-          ENTITY *entity = (ENTITY *)lookup(parser, &dtd->paramEntities,
-                                            externalSubsetName,
-                                            sizeof(ENTITY));
-          if (!entity)
-            return XML_ERROR_NO_MEMORY;
-          entity->base = curBase;
-          dtd->paramEntityRead = XML_FALSE;
-          if (!externalEntityRefHandler(externalEntityRefHandlerArg,
-                                        0,
-                                        entity->base,
-                                        entity->systemId,
-                                        entity->publicId))
-            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
-          if (dtd->paramEntityRead) {
-            if (!dtd->standalone &&
-                notStandaloneHandler &&
-                !notStandaloneHandler(handlerArg))
-              return XML_ERROR_NOT_STANDALONE;
-          }
-          /* if we didn't read the foreign DTD then this means that there
-             is no external subset and we must reset dtd->hasParamEntityRefs
-          */
-          else
-            dtd->hasParamEntityRefs = hadParamEntityRefs;
-          /* end of DTD - no need to update dtd->keepProcessing */
-        }
-      }
-#endif /* XML_DTD */
-      processor = contentProcessor;
-      return contentProcessor(parser, s, end, nextPtr);
-    case XML_ROLE_ATTLIST_ELEMENT_NAME:
-      declElementType = getElementType(parser, enc, s, next);
-      if (!declElementType)
-        return XML_ERROR_NO_MEMORY;
-      goto checkAttListDeclHandler;
-    case XML_ROLE_ATTRIBUTE_NAME:
-      declAttributeId = getAttributeId(parser, enc, s, next);
-      if (!declAttributeId)
-        return XML_ERROR_NO_MEMORY;
-      declAttributeIsCdata = XML_FALSE;
-      declAttributeType = NULL;
-      declAttributeIsId = XML_FALSE;
-      goto checkAttListDeclHandler;
-    case XML_ROLE_ATTRIBUTE_TYPE_CDATA:
-      declAttributeIsCdata = XML_TRUE;
-      declAttributeType = atypeCDATA;
-      goto checkAttListDeclHandler;
-    case XML_ROLE_ATTRIBUTE_TYPE_ID:
-      declAttributeIsId = XML_TRUE;
-      declAttributeType = atypeID;
-      goto checkAttListDeclHandler;
-    case XML_ROLE_ATTRIBUTE_TYPE_IDREF:
-      declAttributeType = atypeIDREF;
-      goto checkAttListDeclHandler;
-    case XML_ROLE_ATTRIBUTE_TYPE_IDREFS:
-      declAttributeType = atypeIDREFS;
-      goto checkAttListDeclHandler;
-    case XML_ROLE_ATTRIBUTE_TYPE_ENTITY:
-      declAttributeType = atypeENTITY;
-      goto checkAttListDeclHandler;
-    case XML_ROLE_ATTRIBUTE_TYPE_ENTITIES:
-      declAttributeType = atypeENTITIES;
-      goto checkAttListDeclHandler;
-    case XML_ROLE_ATTRIBUTE_TYPE_NMTOKEN:
-      declAttributeType = atypeNMTOKEN;
-      goto checkAttListDeclHandler;
-    case XML_ROLE_ATTRIBUTE_TYPE_NMTOKENS:
-      declAttributeType = atypeNMTOKENS;
-    checkAttListDeclHandler:
-      if (dtd->keepProcessing && attlistDeclHandler)
-        handleDefault = XML_FALSE;
-      break;
-    case XML_ROLE_ATTRIBUTE_ENUM_VALUE:
-    case XML_ROLE_ATTRIBUTE_NOTATION_VALUE:
-      if (dtd->keepProcessing && attlistDeclHandler) {
-        const XML_Char *prefix;
-        if (declAttributeType) {
-          prefix = enumValueSep;
-        }
-        else {
-          prefix = (role == XML_ROLE_ATTRIBUTE_NOTATION_VALUE
-                    ? notationPrefix
-                    : enumValueStart);
-        }
-        if (!poolAppendString(&tempPool, prefix))
-          return XML_ERROR_NO_MEMORY;
-        if (!poolAppend(&tempPool, enc, s, next))
-          return XML_ERROR_NO_MEMORY;
-        declAttributeType = tempPool.start;
-        handleDefault = XML_FALSE;
-      }
-      break;
-    case XML_ROLE_IMPLIED_ATTRIBUTE_VALUE:
-    case XML_ROLE_REQUIRED_ATTRIBUTE_VALUE:
-      if (dtd->keepProcessing) {
-        if (!defineAttribute(declElementType, declAttributeId,
-                             declAttributeIsCdata, declAttributeIsId,
-                             0, parser))
-          return XML_ERROR_NO_MEMORY;
-        if (attlistDeclHandler && declAttributeType) {
-          if (*declAttributeType == XML_T(ASCII_LPAREN)
-              || (*declAttributeType == XML_T(ASCII_N)
-                  && declAttributeType[1] == XML_T(ASCII_O))) {
-            /* Enumerated or Notation type */
-            if (!poolAppendChar(&tempPool, XML_T(ASCII_RPAREN))
-                || !poolAppendChar(&tempPool, XML_T('\0')))
-              return XML_ERROR_NO_MEMORY;
-            declAttributeType = tempPool.start;
-            poolFinish(&tempPool);
-          }
-          *eventEndPP = s;
-          attlistDeclHandler(handlerArg, declElementType->name,
-                             declAttributeId->name, declAttributeType,
-                             0, role == XML_ROLE_REQUIRED_ATTRIBUTE_VALUE);
-          poolClear(&tempPool);
-          handleDefault = XML_FALSE;
-        }
-      }
-      break;
-    case XML_ROLE_DEFAULT_ATTRIBUTE_VALUE:
-    case XML_ROLE_FIXED_ATTRIBUTE_VALUE:
-      if (dtd->keepProcessing) {
-        const XML_Char *attVal;
-        enum XML_Error result =
-          storeAttributeValue(parser, enc, declAttributeIsCdata,
-                              s + enc->minBytesPerChar,
-                              next - enc->minBytesPerChar,
-                              &dtd->pool);
-        if (result)
-          return result;
-        attVal = poolStart(&dtd->pool);
-        poolFinish(&dtd->pool);
-        /* ID attributes aren't allowed to have a default */
-        if (!defineAttribute(declElementType, declAttributeId,
-                             declAttributeIsCdata, XML_FALSE, attVal, parser))
-          return XML_ERROR_NO_MEMORY;
-        if (attlistDeclHandler && declAttributeType) {
-          if (*declAttributeType == XML_T(ASCII_LPAREN)
-              || (*declAttributeType == XML_T(ASCII_N)
-                  && declAttributeType[1] == XML_T(ASCII_O))) {
-            /* Enumerated or Notation type */
-            if (!poolAppendChar(&tempPool, XML_T(ASCII_RPAREN))
-                || !poolAppendChar(&tempPool, XML_T('\0')))
-              return XML_ERROR_NO_MEMORY;
-            declAttributeType = tempPool.start;
-            poolFinish(&tempPool);
-          }
-          *eventEndPP = s;
-          attlistDeclHandler(handlerArg, declElementType->name,
-                             declAttributeId->name, declAttributeType,
-                             attVal,
-                             role == XML_ROLE_FIXED_ATTRIBUTE_VALUE);
-          poolClear(&tempPool);
-          handleDefault = XML_FALSE;
-        }
-      }
-      break;
-    case XML_ROLE_ENTITY_VALUE:
-      if (dtd->keepProcessing) {
-        enum XML_Error result = storeEntityValue(parser, enc,
-                                            s + enc->minBytesPerChar,
-                                            next - enc->minBytesPerChar);
-        if (declEntity) {
-          declEntity->textPtr = poolStart(&dtd->entityValuePool);
-          declEntity->textLen = (int)(poolLength(&dtd->entityValuePool));
-          poolFinish(&dtd->entityValuePool);
-          if (entityDeclHandler) {
-            *eventEndPP = s;
-            entityDeclHandler(handlerArg,
-                              declEntity->name,
-                              declEntity->is_param,
-                              declEntity->textPtr,
-                              declEntity->textLen,
-                              curBase, 0, 0, 0);
-            handleDefault = XML_FALSE;
-          }
-        }
-        else
-          poolDiscard(&dtd->entityValuePool);
-        if (result != XML_ERROR_NONE)
-          return result;
-      }
-      break;
-    case XML_ROLE_DOCTYPE_SYSTEM_ID:
-#ifdef XML_DTD
-      useForeignDTD = XML_FALSE;
-#endif /* XML_DTD */
-      dtd->hasParamEntityRefs = XML_TRUE;
-      if (startDoctypeDeclHandler) {
-        doctypeSysid = poolStoreString(&tempPool, enc,
-                                       s + enc->minBytesPerChar,
-                                       next - enc->minBytesPerChar);
-        if (doctypeSysid == NULL)
-          return XML_ERROR_NO_MEMORY;
-        poolFinish(&tempPool);
-        handleDefault = XML_FALSE;
-      }
-#ifdef XML_DTD
-      else
-        /* use externalSubsetName to make doctypeSysid non-NULL
-           for the case where no startDoctypeDeclHandler is set */
-        doctypeSysid = externalSubsetName;
-#endif /* XML_DTD */
-      if (!dtd->standalone
-#ifdef XML_DTD
-          && !paramEntityParsing
-#endif /* XML_DTD */
-          && notStandaloneHandler
-          && !notStandaloneHandler(handlerArg))
-        return XML_ERROR_NOT_STANDALONE;
-#ifndef XML_DTD
-      break;
-#else /* XML_DTD */
-      if (!declEntity) {
-        declEntity = (ENTITY *)lookup(parser,
-                                      &dtd->paramEntities,
-                                      externalSubsetName,
-                                      sizeof(ENTITY));
-        if (!declEntity)
-          return XML_ERROR_NO_MEMORY;
-        declEntity->publicId = NULL;
-      }
-      /* fall through */
-#endif /* XML_DTD */
-    case XML_ROLE_ENTITY_SYSTEM_ID:
-      if (dtd->keepProcessing && declEntity) {
-        declEntity->systemId = poolStoreString(&dtd->pool, enc,
-                                               s + enc->minBytesPerChar,
-                                               next - enc->minBytesPerChar);
-        if (!declEntity->systemId)
-          return XML_ERROR_NO_MEMORY;
-        declEntity->base = curBase;
-        poolFinish(&dtd->pool);
-        if (entityDeclHandler)
-          handleDefault = XML_FALSE;
-      }
-      break;
-    case XML_ROLE_ENTITY_COMPLETE:
-      if (dtd->keepProcessing && declEntity && entityDeclHandler) {
-        *eventEndPP = s;
-        entityDeclHandler(handlerArg,
-                          declEntity->name,
-                          declEntity->is_param,
-                          0,0,
-                          declEntity->base,
-                          declEntity->systemId,
-                          declEntity->publicId,
-                          0);
-        handleDefault = XML_FALSE;
-      }
-      break;
-    case XML_ROLE_ENTITY_NOTATION_NAME:
-      if (dtd->keepProcessing && declEntity) {
-        declEntity->notation = poolStoreString(&dtd->pool, enc, s, next);
-        if (!declEntity->notation)
-          return XML_ERROR_NO_MEMORY;
-        poolFinish(&dtd->pool);
-        if (unparsedEntityDeclHandler) {
-          *eventEndPP = s;
-          unparsedEntityDeclHandler(handlerArg,
-                                    declEntity->name,
-                                    declEntity->base,
-                                    declEntity->systemId,
-                                    declEntity->publicId,
-                                    declEntity->notation);
-          handleDefault = XML_FALSE;
-        }
-        else if (entityDeclHandler) {
-          *eventEndPP = s;
-          entityDeclHandler(handlerArg,
-                            declEntity->name,
-                            0,0,0,
-                            declEntity->base,
-                            declEntity->systemId,
-                            declEntity->publicId,
-                            declEntity->notation);
-          handleDefault = XML_FALSE;
-        }
-      }
-      break;
-    case XML_ROLE_GENERAL_ENTITY_NAME:
-      {
-        if (XmlPredefinedEntityName(enc, s, next)) {
-          declEntity = NULL;
-          break;
-        }
-        if (dtd->keepProcessing) {
-          const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);
-          if (!name)
-            return XML_ERROR_NO_MEMORY;
-          declEntity = (ENTITY *)lookup(parser, &dtd->generalEntities, name,
-                                        sizeof(ENTITY));
-          if (!declEntity)
-            return XML_ERROR_NO_MEMORY;
-          if (declEntity->name != name) {
-            poolDiscard(&dtd->pool);
-            declEntity = NULL;
-          }
-          else {
-            poolFinish(&dtd->pool);
-            declEntity->publicId = NULL;
-            declEntity->is_param = XML_FALSE;
-            /* if we have a parent parser or are reading an internal parameter
-               entity, then the entity declaration is not considered "internal"
-            */
-            declEntity->is_internal = !(parentParser || openInternalEntities);
-            if (entityDeclHandler)
-              handleDefault = XML_FALSE;
-          }
-        }
-        else {
-          poolDiscard(&dtd->pool);
-          declEntity = NULL;
-        }
-      }
-      break;
-    case XML_ROLE_PARAM_ENTITY_NAME:
-#ifdef XML_DTD
-      if (dtd->keepProcessing) {
-        const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);
-        if (!name)
-          return XML_ERROR_NO_MEMORY;
-        declEntity = (ENTITY *)lookup(parser, &dtd->paramEntities,
-                                           name, sizeof(ENTITY));
-        if (!declEntity)
-          return XML_ERROR_NO_MEMORY;
-        if (declEntity->name != name) {
-          poolDiscard(&dtd->pool);
-          declEntity = NULL;
-        }
-        else {
-          poolFinish(&dtd->pool);
-          declEntity->publicId = NULL;
-          declEntity->is_param = XML_TRUE;
-          /* if we have a parent parser or are reading an internal parameter
-             entity, then the entity declaration is not considered "internal"
-          */
-          declEntity->is_internal = !(parentParser || openInternalEntities);
-          if (entityDeclHandler)
-            handleDefault = XML_FALSE;
-        }
-      }
-      else {
-        poolDiscard(&dtd->pool);
-        declEntity = NULL;
-      }
-#else /* not XML_DTD */
-      declEntity = NULL;
-#endif /* XML_DTD */
-      break;
-    case XML_ROLE_NOTATION_NAME:
-      declNotationPublicId = NULL;
-      declNotationName = NULL;
-      if (notationDeclHandler) {
-        declNotationName = poolStoreString(&tempPool, enc, s, next);
-        if (!declNotationName)
-          return XML_ERROR_NO_MEMORY;
-        poolFinish(&tempPool);
-        handleDefault = XML_FALSE;
-      }
-      break;
-    case XML_ROLE_NOTATION_PUBLIC_ID:
-      if (!XmlIsPublicId(enc, s, next, eventPP))
-        return XML_ERROR_PUBLICID;
-      if (declNotationName) {  /* means notationDeclHandler != NULL */
-        XML_Char *tem = poolStoreString(&tempPool,
-                                        enc,
-                                        s + enc->minBytesPerChar,
-                                        next - enc->minBytesPerChar);
-        if (!tem)
-          return XML_ERROR_NO_MEMORY;
-        normalizePublicId(tem);
-        declNotationPublicId = tem;
-        poolFinish(&tempPool);
-        handleDefault = XML_FALSE;
-      }
-      break;
-    case XML_ROLE_NOTATION_SYSTEM_ID:
-      if (declNotationName && notationDeclHandler) {
-        const XML_Char *systemId
-          = poolStoreString(&tempPool, enc,
-                            s + enc->minBytesPerChar,
-                            next - enc->minBytesPerChar);
-        if (!systemId)
-          return XML_ERROR_NO_MEMORY;
-        *eventEndPP = s;
-        notationDeclHandler(handlerArg,
-                            declNotationName,
-                            curBase,
-                            systemId,
-                            declNotationPublicId);
-        handleDefault = XML_FALSE;
-      }
-      poolClear(&tempPool);
-      break;
-    case XML_ROLE_NOTATION_NO_SYSTEM_ID:
-      if (declNotationPublicId && notationDeclHandler) {
-        *eventEndPP = s;
-        notationDeclHandler(handlerArg,
-                            declNotationName,
-                            curBase,
-                            0,
-                            declNotationPublicId);
-        handleDefault = XML_FALSE;
-      }
-      poolClear(&tempPool);
-      break;
-    case XML_ROLE_ERROR:
-      switch (tok) {
-      case XML_TOK_PARAM_ENTITY_REF:
-        /* PE references in internal subset are
-           not allowed within declarations. */
-        return XML_ERROR_PARAM_ENTITY_REF;
-      case XML_TOK_XML_DECL:
-        return XML_ERROR_MISPLACED_XML_PI;
-      default:
-        return XML_ERROR_SYNTAX;
-      }
-#ifdef XML_DTD
-    case XML_ROLE_IGNORE_SECT:
-      {
-        enum XML_Error result;
-        if (defaultHandler)
-          reportDefault(parser, enc, s, next);
-        handleDefault = XML_FALSE;
-        result = doIgnoreSection(parser, enc, &next, end, nextPtr, haveMore);
-        if (result != XML_ERROR_NONE)
-          return result;
-        else if (!next) {
-          processor = ignoreSectionProcessor;
-          return result;
-        }
-      }
-      break;
-#endif /* XML_DTD */
-    case XML_ROLE_GROUP_OPEN:
-      if (prologState.level >= groupSize) {
-        if (groupSize) {
-          char *temp = (char *)REALLOC(groupConnector, groupSize *= 2);
-          if (temp == NULL) {
-            groupSize /= 2;
-            return XML_ERROR_NO_MEMORY;
-          }
-          groupConnector = temp;
-          if (dtd->scaffIndex) {
-            int *temp = (int *)REALLOC(dtd->scaffIndex,
-                          groupSize * sizeof(int));
-            if (temp == NULL)
-              return XML_ERROR_NO_MEMORY;
-            dtd->scaffIndex = temp;
-          }
-        }
-        else {
-          groupConnector = (char *)MALLOC(groupSize = 32);
-          if (!groupConnector) {
-            groupSize = 0;
-            return XML_ERROR_NO_MEMORY;
-          }
-        }
-      }
-      groupConnector[prologState.level] = 0;
-      if (dtd->in_eldecl) {
-        int myindex = nextScaffoldPart(parser);
-        if (myindex < 0)
-          return XML_ERROR_NO_MEMORY;
-        dtd->scaffIndex[dtd->scaffLevel] = myindex;
-        dtd->scaffLevel++;
-        dtd->scaffold[myindex].type = XML_CTYPE_SEQ;
-        if (elementDeclHandler)
-          handleDefault = XML_FALSE;
-      }
-      break;
-    case XML_ROLE_GROUP_SEQUENCE:
-      if (groupConnector[prologState.level] == ASCII_PIPE)
-        return XML_ERROR_SYNTAX;
-      groupConnector[prologState.level] = ASCII_COMMA;
-      if (dtd->in_eldecl && elementDeclHandler)
-        handleDefault = XML_FALSE;
-      break;
-    case XML_ROLE_GROUP_CHOICE:
-      if (groupConnector[prologState.level] == ASCII_COMMA)
-        return XML_ERROR_SYNTAX;
-      if (dtd->in_eldecl
-          && !groupConnector[prologState.level]
-          && (dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
-              != XML_CTYPE_MIXED)
-          ) {
-        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
-            = XML_CTYPE_CHOICE;
-        if (elementDeclHandler)
-          handleDefault = XML_FALSE;
-      }
-      groupConnector[prologState.level] = ASCII_PIPE;
-      break;
-    case XML_ROLE_PARAM_ENTITY_REF:
-#ifdef XML_DTD
-    case XML_ROLE_INNER_PARAM_ENTITY_REF:
-      dtd->hasParamEntityRefs = XML_TRUE;
-      if (!paramEntityParsing)
-        dtd->keepProcessing = dtd->standalone;
-      else {
-        const XML_Char *name;
-        ENTITY *entity;
-        name = poolStoreString(&dtd->pool, enc,
-                                s + enc->minBytesPerChar,
-                                next - enc->minBytesPerChar);
-        if (!name)
-          return XML_ERROR_NO_MEMORY;
-        entity = (ENTITY *)lookup(parser, &dtd->paramEntities, name, 0);
-        poolDiscard(&dtd->pool);
-        /* first, determine if a check for an existing declaration is needed;
-           if yes, check that the entity exists, and that it is internal,
-           otherwise call the skipped entity handler
-        */
-        if (prologState.documentEntity &&
-            (dtd->standalone
-             ? !openInternalEntities
-             : !dtd->hasParamEntityRefs)) {
-          if (!entity)
-            return XML_ERROR_UNDEFINED_ENTITY;
-          else if (!entity->is_internal) {
-            /* It's hard to exhaustively search the code to be sure,
-             * but there doesn't seem to be a way of executing the
-             * following line.  There are two cases:
-             *
-             * If 'standalone' is false, the DTD must have no
-             * parameter entities or we wouldn't have passed the outer
-             * 'if' statement.  That measn the only entity in the hash
-             * table is the external subset name "#" which cannot be
-             * given as a parameter entity name in XML syntax, so the
-             * lookup must have returned NULL and we don't even reach
-             * the test for an internal entity.
-             *
-             * If 'standalone' is true, it does not seem to be
-             * possible to create entities taking this code path that
-             * are not internal entities, so fail the test above.
-             *
-             * Because this analysis is very uncertain, the code is
-             * being left in place and merely removed from the
-             * coverage test statistics.
-             */
-            return XML_ERROR_ENTITY_DECLARED_IN_PE; /* LCOV_EXCL_LINE */
-          }
-        }
-        else if (!entity) {
-          dtd->keepProcessing = dtd->standalone;
-          /* cannot report skipped entities in declarations */
-          if ((role == XML_ROLE_PARAM_ENTITY_REF) && skippedEntityHandler) {
-            skippedEntityHandler(handlerArg, name, 1);
-            handleDefault = XML_FALSE;
-          }
-          break;
-        }
-        if (entity->open)
-          return XML_ERROR_RECURSIVE_ENTITY_REF;
-        if (entity->textPtr) {
-          enum XML_Error result;
-          XML_Bool betweenDecl =
-            (role == XML_ROLE_PARAM_ENTITY_REF ? XML_TRUE : XML_FALSE);
-          result = processInternalEntity(parser, entity, betweenDecl);
-          if (result != XML_ERROR_NONE)
-            return result;
-          handleDefault = XML_FALSE;
-          break;
-        }
-        if (externalEntityRefHandler) {
-          dtd->paramEntityRead = XML_FALSE;
-          entity->open = XML_TRUE;
-          if (!externalEntityRefHandler(externalEntityRefHandlerArg,
-                                        0,
-                                        entity->base,
-                                        entity->systemId,
-                                        entity->publicId)) {
-            entity->open = XML_FALSE;
-            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
-          }
-          entity->open = XML_FALSE;
-          handleDefault = XML_FALSE;
-          if (!dtd->paramEntityRead) {
-            dtd->keepProcessing = dtd->standalone;
-            break;
-          }
-        }
-        else {
-          dtd->keepProcessing = dtd->standalone;
-          break;
-        }
-      }
-#endif /* XML_DTD */
-      if (!dtd->standalone &&
-          notStandaloneHandler &&
-          !notStandaloneHandler(handlerArg))
-        return XML_ERROR_NOT_STANDALONE;
-      break;
-
-    /* Element declaration stuff */
-
-    case XML_ROLE_ELEMENT_NAME:
-      if (elementDeclHandler) {
-        declElementType = getElementType(parser, enc, s, next);
-        if (!declElementType)
-          return XML_ERROR_NO_MEMORY;
-        dtd->scaffLevel = 0;
-        dtd->scaffCount = 0;
-        dtd->in_eldecl = XML_TRUE;
-        handleDefault = XML_FALSE;
-      }
-      break;
-
-    case XML_ROLE_CONTENT_ANY:
-    case XML_ROLE_CONTENT_EMPTY:
-      if (dtd->in_eldecl) {
-        if (elementDeclHandler) {
-          XML_Content * content = (XML_Content *) MALLOC(sizeof(XML_Content));
-          if (!content)
-            return XML_ERROR_NO_MEMORY;
-          content->quant = XML_CQUANT_NONE;
-          content->name = NULL;
-          content->numchildren = 0;
-          content->children = NULL;
-          content->type = ((role == XML_ROLE_CONTENT_ANY) ?
-                           XML_CTYPE_ANY :
-                           XML_CTYPE_EMPTY);
-          *eventEndPP = s;
-          elementDeclHandler(handlerArg, declElementType->name, content);
-          handleDefault = XML_FALSE;
-        }
-        dtd->in_eldecl = XML_FALSE;
-      }
-      break;
-
-    case XML_ROLE_CONTENT_PCDATA:
-      if (dtd->in_eldecl) {
-        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
-            = XML_CTYPE_MIXED;
-        if (elementDeclHandler)
-          handleDefault = XML_FALSE;
-      }
-      break;
-
-    case XML_ROLE_CONTENT_ELEMENT:
-      quant = XML_CQUANT_NONE;
-      goto elementContent;
-    case XML_ROLE_CONTENT_ELEMENT_OPT:
-      quant = XML_CQUANT_OPT;
-      goto elementContent;
-    case XML_ROLE_CONTENT_ELEMENT_REP:
-      quant = XML_CQUANT_REP;
-      goto elementContent;
-    case XML_ROLE_CONTENT_ELEMENT_PLUS:
-      quant = XML_CQUANT_PLUS;
-    elementContent:
-      if (dtd->in_eldecl) {
-        ELEMENT_TYPE *el;
-        const XML_Char *name;
-        int nameLen;
-        const char *nxt = (quant == XML_CQUANT_NONE
-                           ? next
-                           : next - enc->minBytesPerChar);
-        int myindex = nextScaffoldPart(parser);
-        if (myindex < 0)
-          return XML_ERROR_NO_MEMORY;
-        dtd->scaffold[myindex].type = XML_CTYPE_NAME;
-        dtd->scaffold[myindex].quant = quant;
-        el = getElementType(parser, enc, s, nxt);
-        if (!el)
-          return XML_ERROR_NO_MEMORY;
-        name = el->name;
-        dtd->scaffold[myindex].name = name;
-        nameLen = 0;
-        for (; name[nameLen++]; );
-        dtd->contentStringLen +=  nameLen;
-        if (elementDeclHandler)
-          handleDefault = XML_FALSE;
-      }
-      break;
-
-    case XML_ROLE_GROUP_CLOSE:
-      quant = XML_CQUANT_NONE;
-      goto closeGroup;
-    case XML_ROLE_GROUP_CLOSE_OPT:
-      quant = XML_CQUANT_OPT;
-      goto closeGroup;
-    case XML_ROLE_GROUP_CLOSE_REP:
-      quant = XML_CQUANT_REP;
-      goto closeGroup;
-    case XML_ROLE_GROUP_CLOSE_PLUS:
-      quant = XML_CQUANT_PLUS;
-    closeGroup:
-      if (dtd->in_eldecl) {
-        if (elementDeclHandler)
-          handleDefault = XML_FALSE;
-        dtd->scaffLevel--;
-        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel]].quant = quant;
-        if (dtd->scaffLevel == 0) {
-          if (!handleDefault) {
-            XML_Content *model = build_model(parser);
-            if (!model)
-              return XML_ERROR_NO_MEMORY;
-            *eventEndPP = s;
-            elementDeclHandler(handlerArg, declElementType->name, model);
-          }
-          dtd->in_eldecl = XML_FALSE;
-          dtd->contentStringLen = 0;
-        }
-      }
-      break;
-      /* End element declaration stuff */
-
-    case XML_ROLE_PI:
-      if (!reportProcessingInstruction(parser, enc, s, next))
-        return XML_ERROR_NO_MEMORY;
-      handleDefault = XML_FALSE;
-      break;
-    case XML_ROLE_COMMENT:
-      if (!reportComment(parser, enc, s, next))
-        return XML_ERROR_NO_MEMORY;
-      handleDefault = XML_FALSE;
-      break;
-    case XML_ROLE_NONE:
-      switch (tok) {
-      case XML_TOK_BOM:
-        handleDefault = XML_FALSE;
-        break;
-      }
-      break;
-    case XML_ROLE_DOCTYPE_NONE:
-      if (startDoctypeDeclHandler)
-        handleDefault = XML_FALSE;
-      break;
-    case XML_ROLE_ENTITY_NONE:
-      if (dtd->keepProcessing && entityDeclHandler)
-        handleDefault = XML_FALSE;
-      break;
-    case XML_ROLE_NOTATION_NONE:
-      if (notationDeclHandler)
-        handleDefault = XML_FALSE;
-      break;
-    case XML_ROLE_ATTLIST_NONE:
-      if (dtd->keepProcessing && attlistDeclHandler)
-        handleDefault = XML_FALSE;
-      break;
-    case XML_ROLE_ELEMENT_NONE:
-      if (elementDeclHandler)
-        handleDefault = XML_FALSE;
-      break;
-    } /* end of big switch */
-
-    if (handleDefault && defaultHandler)
-      reportDefault(parser, enc, s, next);
-
-    switch (ps_parsing) {
-    case XML_SUSPENDED:
-      *nextPtr = next;
-      return XML_ERROR_NONE;
-    case XML_FINISHED:
-      return XML_ERROR_ABORTED;
-    default:
-      s = next;
-      tok = XmlPrologTok(enc, s, end, &next);
-    }
-  }
-  /* not reached */
-}
-
-static enum XML_Error PTRCALL
-epilogProcessor(XML_Parser parser,
-                const char *s,
-                const char *end,
-                const char **nextPtr)
-{
-  processor = epilogProcessor;
-  eventPtr = s;
-  for (;;) {
-    const char *next = NULL;
-    int tok = XmlPrologTok(encoding, s, end, &next);
-    eventEndPtr = next;
-    switch (tok) {
-    /* report partial linebreak - it might be the last token */
-    case -XML_TOK_PROLOG_S:
-      if (defaultHandler) {
-        reportDefault(parser, encoding, s, next);
-        if (ps_parsing == XML_FINISHED)
-          return XML_ERROR_ABORTED;
-      }
-      *nextPtr = next;
-      return XML_ERROR_NONE;
-    case XML_TOK_NONE:
-      *nextPtr = s;
-      return XML_ERROR_NONE;
-    case XML_TOK_PROLOG_S:
-      if (defaultHandler)
-        reportDefault(parser, encoding, s, next);
-      break;
-    case XML_TOK_PI:
-      if (!reportProcessingInstruction(parser, encoding, s, next))
-        return XML_ERROR_NO_MEMORY;
-      break;
-    case XML_TOK_COMMENT:
-      if (!reportComment(parser, encoding, s, next))
-        return XML_ERROR_NO_MEMORY;
-      break;
-    case XML_TOK_INVALID:
-      eventPtr = next;
-      return XML_ERROR_INVALID_TOKEN;
-    case XML_TOK_PARTIAL:
-      if (!ps_finalBuffer) {
-        *nextPtr = s;
-        return XML_ERROR_NONE;
-      }
-      return XML_ERROR_UNCLOSED_TOKEN;
-    case XML_TOK_PARTIAL_CHAR:
-      if (!ps_finalBuffer) {
-        *nextPtr = s;
-        return XML_ERROR_NONE;
-      }
-      return XML_ERROR_PARTIAL_CHAR;
-    default:
-      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;
-    }
-    eventPtr = s = next;
-    switch (ps_parsing) {
-    case XML_SUSPENDED:
-      *nextPtr = next;
-      return XML_ERROR_NONE;
-    case XML_FINISHED:
-      return XML_ERROR_ABORTED;
-    default: ;
-    }
-  }
-}
-
-static enum XML_Error
-processInternalEntity(XML_Parser parser, ENTITY *entity,
-                      XML_Bool betweenDecl)
-{
-  const char *textStart, *textEnd;
-  const char *next;
-  enum XML_Error result;
-  OPEN_INTERNAL_ENTITY *openEntity;
-
-  if (freeInternalEntities) {
-    openEntity = freeInternalEntities;
-    freeInternalEntities = openEntity->next;
-  }
-  else {
-    openEntity = (OPEN_INTERNAL_ENTITY *)MALLOC(sizeof(OPEN_INTERNAL_ENTITY));
-    if (!openEntity)
-      return XML_ERROR_NO_MEMORY;
-  }
-  entity->open = XML_TRUE;
-  entity->processed = 0;
-  openEntity->next = openInternalEntities;
-  openInternalEntities = openEntity;
-  openEntity->entity = entity;
-  openEntity->startTagLevel = tagLevel;
-  openEntity->betweenDecl = betweenDecl;
-  openEntity->internalEventPtr = NULL;
-  openEntity->internalEventEndPtr = NULL;
-  textStart = (char *)entity->textPtr;
-  textEnd = (char *)(entity->textPtr + entity->textLen);
-  /* Set a safe default value in case 'next' does not get set */
-  next = textStart;
-
-#ifdef XML_DTD
-  if (entity->is_param) {
-    int tok = XmlPrologTok(internalEncoding, textStart, textEnd, &next);
-    result = doProlog(parser, internalEncoding, textStart, textEnd, tok,
-                      next, &next, XML_FALSE);
-  }
-  else
-#endif /* XML_DTD */
-    result = doContent(parser, tagLevel, internalEncoding, textStart,
-                       textEnd, &next, XML_FALSE);
-
-  if (result == XML_ERROR_NONE) {
-    if (textEnd != next && ps_parsing == XML_SUSPENDED) {
-      entity->processed = (int)(next - textStart);
-      processor = internalEntityProcessor;
-    }
-    else {
-      entity->open = XML_FALSE;
-      openInternalEntities = openEntity->next;
-      /* put openEntity back in list of free instances */
-      openEntity->next = freeInternalEntities;
-      freeInternalEntities = openEntity;
-    }
-  }
-  return result;
-}
-
-static enum XML_Error PTRCALL
-internalEntityProcessor(XML_Parser parser,
-                        const char *s,
-                        const char *end,
-                        const char **nextPtr)
-{
-  ENTITY *entity;
-  const char *textStart, *textEnd;
-  const char *next;
-  enum XML_Error result;
-  OPEN_INTERNAL_ENTITY *openEntity = openInternalEntities;
-  if (!openEntity)
-    return XML_ERROR_UNEXPECTED_STATE;
-
-  entity = openEntity->entity;
-  textStart = ((char *)entity->textPtr) + entity->processed;
-  textEnd = (char *)(entity->textPtr + entity->textLen);
-  /* Set a safe default value in case 'next' does not get set */
-  next = textStart;
-
-#ifdef XML_DTD
-  if (entity->is_param) {
-    int tok = XmlPrologTok(internalEncoding, textStart, textEnd, &next);
-    result = doProlog(parser, internalEncoding, textStart, textEnd, tok,
-                      next, &next, XML_FALSE);
-  }
-  else
-#endif /* XML_DTD */
-    result = doContent(parser, openEntity->startTagLevel, internalEncoding,
-                       textStart, textEnd, &next, XML_FALSE);
-
-  if (result != XML_ERROR_NONE)
-    return result;
-  else if (textEnd != next && ps_parsing == XML_SUSPENDED) {
-    entity->processed = (int)(next - (char *)entity->textPtr);
-    return result;
-  }
-  else {
-    entity->open = XML_FALSE;
-    openInternalEntities = openEntity->next;
-    /* put openEntity back in list of free instances */
-    openEntity->next = freeInternalEntities;
-    freeInternalEntities = openEntity;
-  }
-
-#ifdef XML_DTD
-  if (entity->is_param) {
-    int tok;
-    processor = prologProcessor;
-    tok = XmlPrologTok(encoding, s, end, &next);
-    return doProlog(parser, encoding, s, end, tok, next, nextPtr,
-                    (XML_Bool)!ps_finalBuffer);
-  }
-  else
-#endif /* XML_DTD */
-  {
-    processor = contentProcessor;
-    /* see externalEntityContentProcessor vs contentProcessor */
-    return doContent(parser, parentParser ? 1 : 0, encoding, s, end,
-                     nextPtr, (XML_Bool)!ps_finalBuffer);
-  }
-}
-
-static enum XML_Error PTRCALL
-errorProcessor(XML_Parser parser,
-               const char *UNUSED_P(s),
-               const char *UNUSED_P(end),
-               const char **UNUSED_P(nextPtr))
-{
-  return errorCode;
-}
-
-static enum XML_Error
-storeAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,
-                    const char *ptr, const char *end,
-                    STRING_POOL *pool)
-{
-  enum XML_Error result = appendAttributeValue(parser, enc, isCdata, ptr,
-                                               end, pool);
-  if (result)
-    return result;
-  if (!isCdata && poolLength(pool) && poolLastChar(pool) == 0x20)
-    poolChop(pool);
-  if (!poolAppendChar(pool, XML_T('\0')))
-    return XML_ERROR_NO_MEMORY;
-  return XML_ERROR_NONE;
-}
-
-static enum XML_Error
-appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,
-                     const char *ptr, const char *end,
-                     STRING_POOL *pool)
-{
-  DTD * const dtd = _dtd;  /* save one level of indirection */
-  for (;;) {
-    const char *next;
-    int tok = XmlAttributeValueTok(enc, ptr, end, &next);
-    switch (tok) {
-    case XML_TOK_NONE:
-      return XML_ERROR_NONE;
-    case XML_TOK_INVALID:
-      if (enc == encoding)
-        eventPtr = next;
-      return XML_ERROR_INVALID_TOKEN;
-    case XML_TOK_PARTIAL:
-      if (enc == encoding)
-        eventPtr = ptr;
-      return XML_ERROR_INVALID_TOKEN;
-    case XML_TOK_CHAR_REF:
-      {
-        XML_Char buf[XML_ENCODE_MAX];
-        int i;
-        int n = XmlCharRefNumber(enc, ptr);
-        if (n < 0) {
-          if (enc == encoding)
-            eventPtr = ptr;
-          return XML_ERROR_BAD_CHAR_REF;
-        }
-        if (!isCdata
-            && n == 0x20 /* space */
-            && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))
-          break;
-        n = XmlEncode(n, (ICHAR *)buf);
-        /* The XmlEncode() functions can never return 0 here.  That
-         * error return happens if the code point passed in is either
-         * negative or greater than or equal to 0x110000.  The
-         * XmlCharRefNumber() functions will all return a number
-         * strictly less than 0x110000 or a negative value if an error
-         * occurred.  The negative value is intercepted above, so
-         * XmlEncode() is never passed a value it might return an
-         * error for.
-         */
-        for (i = 0; i < n; i++) {
-          if (!poolAppendChar(pool, buf[i]))
-            return XML_ERROR_NO_MEMORY;
-        }
-      }
-      break;
-    case XML_TOK_DATA_CHARS:
-      if (!poolAppend(pool, enc, ptr, next))
-        return XML_ERROR_NO_MEMORY;
-      break;
-    case XML_TOK_TRAILING_CR:
-      next = ptr + enc->minBytesPerChar;
-      /* fall through */
-    case XML_TOK_ATTRIBUTE_VALUE_S:
-    case XML_TOK_DATA_NEWLINE:
-      if (!isCdata && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))
-        break;
-      if (!poolAppendChar(pool, 0x20))
-        return XML_ERROR_NO_MEMORY;
-      break;
-    case XML_TOK_ENTITY_REF:
-      {
-        const XML_Char *name;
-        ENTITY *entity;
-        char checkEntityDecl;
-        XML_Char ch = (XML_Char) XmlPredefinedEntityName(enc,
-                                              ptr + enc->minBytesPerChar,
-                                              next - enc->minBytesPerChar);
-        if (ch) {
-          if (!poolAppendChar(pool, ch))
-                return XML_ERROR_NO_MEMORY;
-          break;
-        }
-        name = poolStoreString(&temp2Pool, enc,
-                               ptr + enc->minBytesPerChar,
-                               next - enc->minBytesPerChar);
-        if (!name)
-          return XML_ERROR_NO_MEMORY;
-        entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);
-        poolDiscard(&temp2Pool);
-        /* First, determine if a check for an existing declaration is needed;
-           if yes, check that the entity exists, and that it is internal.
-        */
-        if (pool == &dtd->pool)  /* are we called from prolog? */
-          checkEntityDecl =
-#ifdef XML_DTD
-              prologState.documentEntity &&
-#endif /* XML_DTD */
-              (dtd->standalone
-               ? !openInternalEntities
-               : !dtd->hasParamEntityRefs);
-        else /* if (pool == &tempPool): we are called from content */
-          checkEntityDecl = !dtd->hasParamEntityRefs || dtd->standalone;
-        if (checkEntityDecl) {
-          if (!entity)
-            return XML_ERROR_UNDEFINED_ENTITY;
-          else if (!entity->is_internal)
-            return XML_ERROR_ENTITY_DECLARED_IN_PE;
-        }
-        else if (!entity) {
-          /* Cannot report skipped entity here - see comments on
-             skippedEntityHandler.
-          if (skippedEntityHandler)
-            skippedEntityHandler(handlerArg, name, 0);
-          */
-          /* Cannot call the default handler because this would be
-             out of sync with the call to the startElementHandler.
-          if ((pool == &tempPool) && defaultHandler)
-            reportDefault(parser, enc, ptr, next);
-          */
-          break;
-        }
-        if (entity->open) {
-          if (enc == encoding) {
-            /* It does not appear that this line can be executed.
-             *
-             * The "if (entity->open)" check catches recursive entity
-             * definitions.  In order to be called with an open
-             * entity, it must have gone through this code before and
-             * been through the recursive call to
-             * appendAttributeValue() some lines below.  That call
-             * sets the local encoding ("enc") to the parser's
-             * internal encoding (internal_utf8 or internal_utf16),
-             * which can never be the same as the principle encoding.
-             * It doesn't appear there is another code path that gets
-             * here with entity->open being TRUE.
-             *
-             * Since it is not certain that this logic is watertight,
-             * we keep the line and merely exclude it from coverage
-             * tests.
-             */
-            eventPtr = ptr; /* LCOV_EXCL_LINE */
-          }
-          return XML_ERROR_RECURSIVE_ENTITY_REF;
-        }
-        if (entity->notation) {
-          if (enc == encoding)
-            eventPtr = ptr;
-          return XML_ERROR_BINARY_ENTITY_REF;
-        }
-        if (!entity->textPtr) {
-          if (enc == encoding)
-            eventPtr = ptr;
-          return XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF;
-        }
-        else {
-          enum XML_Error result;
-          const XML_Char *textEnd = entity->textPtr + entity->textLen;
-          entity->open = XML_TRUE;
-          result = appendAttributeValue(parser, internalEncoding, isCdata,
-                                        (char *)entity->textPtr,
-                                        (char *)textEnd, pool);
-          entity->open = XML_FALSE;
-          if (result)
-            return result;
-        }
-      }
-      break;
-    default:
-      /* The only token returned by XmlAttributeValueTok() that does
-       * not have an explicit case here is XML_TOK_PARTIAL_CHAR.
-       * Getting that would require an entity name to contain an
-       * incomplete XML character (e.g. \xE2\x82); however previous
-       * tokenisers will have already recognised and rejected such
-       * names before XmlAttributeValueTok() gets a look-in.  This
-       * default case should be retained as a safety net, but the code
-       * excluded from coverage tests.
-       *
-       * LCOV_EXCL_START
-       */
-      if (enc == encoding)
-        eventPtr = ptr;
-      return XML_ERROR_UNEXPECTED_STATE;
-      /* LCOV_EXCL_STOP */
-    }
-    ptr = next;
-  }
-  /* not reached */
-}
-
-static enum XML_Error
-storeEntityValue(XML_Parser parser,
-                 const ENCODING *enc,
-                 const char *entityTextPtr,
-                 const char *entityTextEnd)
-{
-  DTD * const dtd = _dtd;  /* save one level of indirection */
-  STRING_POOL *pool = &(dtd->entityValuePool);
-  enum XML_Error result = XML_ERROR_NONE;
-#ifdef XML_DTD
-  int oldInEntityValue = prologState.inEntityValue;
-  prologState.inEntityValue = 1;
-#endif /* XML_DTD */
-  /* never return Null for the value argument in EntityDeclHandler,
-     since this would indicate an external entity; therefore we
-     have to make sure that entityValuePool.start is not null */
-  if (!pool->blocks) {
-    if (!poolGrow(pool))
-      return XML_ERROR_NO_MEMORY;
-  }
-
-  for (;;) {
-    const char *next;
-    int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);
-    switch (tok) {
-    case XML_TOK_PARAM_ENTITY_REF:
-#ifdef XML_DTD
-      if (isParamEntity || enc != encoding) {
-        const XML_Char *name;
-        ENTITY *entity;
-        name = poolStoreString(&tempPool, enc,
-                               entityTextPtr + enc->minBytesPerChar,
-                               next - enc->minBytesPerChar);
-        if (!name) {
-          result = XML_ERROR_NO_MEMORY;
-          goto endEntityValue;
-        }
-        entity = (ENTITY *)lookup(parser, &dtd->paramEntities, name, 0);
-        poolDiscard(&tempPool);
-        if (!entity) {
-          /* not a well-formedness error - see XML 1.0: WFC Entity Declared */
-          /* cannot report skipped entity here - see comments on
-             skippedEntityHandler
-          if (skippedEntityHandler)
-            skippedEntityHandler(handlerArg, name, 0);
-          */
-          dtd->keepProcessing = dtd->standalone;
-          goto endEntityValue;
-        }
-        if (entity->open) {
-          if (enc == encoding)
-            eventPtr = entityTextPtr;
-          result = XML_ERROR_RECURSIVE_ENTITY_REF;
-          goto endEntityValue;
-        }
-        if (entity->systemId) {
-          if (externalEntityRefHandler) {
-            dtd->paramEntityRead = XML_FALSE;
-            entity->open = XML_TRUE;
-            if (!externalEntityRefHandler(externalEntityRefHandlerArg,
-                                          0,
-                                          entity->base,
-                                          entity->systemId,
-                                          entity->publicId)) {
-              entity->open = XML_FALSE;
-              result = XML_ERROR_EXTERNAL_ENTITY_HANDLING;
-              goto endEntityValue;
-            }
-            entity->open = XML_FALSE;
-            if (!dtd->paramEntityRead)
-              dtd->keepProcessing = dtd->standalone;
-          }
-          else
-            dtd->keepProcessing = dtd->standalone;
-        }
-        else {
-          entity->open = XML_TRUE;
-          result = storeEntityValue(parser,
-                                    internalEncoding,
-                                    (char *)entity->textPtr,
-                                    (char *)(entity->textPtr
-                                             + entity->textLen));
-          entity->open = XML_FALSE;
-          if (result)
-            goto endEntityValue;
-        }
-        break;
-      }
-#endif /* XML_DTD */
-      /* In the internal subset, PE references are not legal
-         within markup declarations, e.g entity values in this case. */
-      eventPtr = entityTextPtr;
-      result = XML_ERROR_PARAM_ENTITY_REF;
-      goto endEntityValue;
-    case XML_TOK_NONE:
-      result = XML_ERROR_NONE;
-      goto endEntityValue;
-    case XML_TOK_ENTITY_REF:
-    case XML_TOK_DATA_CHARS:
-      if (!poolAppend(pool, enc, entityTextPtr, next)) {
-        result = XML_ERROR_NO_MEMORY;
-        goto endEntityValue;
-      }
-      break;
-    case XML_TOK_TRAILING_CR:
-      next = entityTextPtr + enc->minBytesPerChar;
-      /* fall through */
-    case XML_TOK_DATA_NEWLINE:
-      if (pool->end == pool->ptr && !poolGrow(pool)) {
-              result = XML_ERROR_NO_MEMORY;
-        goto endEntityValue;
-      }
-      *(pool->ptr)++ = 0xA;
-      break;
-    case XML_TOK_CHAR_REF:
-      {
-        XML_Char buf[XML_ENCODE_MAX];
-        int i;
-        int n = XmlCharRefNumber(enc, entityTextPtr);
-        if (n < 0) {
-          if (enc == encoding)
-            eventPtr = entityTextPtr;
-          result = XML_ERROR_BAD_CHAR_REF;
-          goto endEntityValue;
-        }
-        n = XmlEncode(n, (ICHAR *)buf);
-        /* The XmlEncode() functions can never return 0 here.  That
-         * error return happens if the code point passed in is either
-         * negative or greater than or equal to 0x110000.  The
-         * XmlCharRefNumber() functions will all return a number
-         * strictly less than 0x110000 or a negative value if an error
-         * occurred.  The negative value is intercepted above, so
-         * XmlEncode() is never passed a value it might return an
-         * error for.
-         */
-        for (i = 0; i < n; i++) {
-          if (pool->end == pool->ptr && !poolGrow(pool)) {
-            result = XML_ERROR_NO_MEMORY;
-            goto endEntityValue;
-          }
-          *(pool->ptr)++ = buf[i];
-        }
-      }
-      break;
-    case XML_TOK_PARTIAL:
-      if (enc == encoding)
-        eventPtr = entityTextPtr;
-      result = XML_ERROR_INVALID_TOKEN;
-      goto endEntityValue;
-    case XML_TOK_INVALID:
-      if (enc == encoding)
-        eventPtr = next;
-      result = XML_ERROR_INVALID_TOKEN;
-      goto endEntityValue;
-    default:
-      /* This default case should be unnecessary -- all the tokens
-       * that XmlEntityValueTok() can return have their own explicit
-       * cases -- but should be retained for safety.  We do however
-       * exclude it from the coverage statistics.
-       *
-       * LCOV_EXCL_START
-       */
-      if (enc == encoding)
-        eventPtr = entityTextPtr;
-      result = XML_ERROR_UNEXPECTED_STATE;
-      goto endEntityValue;
-      /* LCOV_EXCL_STOP */
-    }
-    entityTextPtr = next;
-  }
-endEntityValue:
-#ifdef XML_DTD
-  prologState.inEntityValue = oldInEntityValue;
-#endif /* XML_DTD */
-  return result;
-}
-
-static void FASTCALL
-normalizeLines(XML_Char *s)
-{
-  XML_Char *p;
-  for (;; s++) {
-    if (*s == XML_T('\0'))
-      return;
-    if (*s == 0xD)
-      break;
-  }
-  p = s;
-  do {
-    if (*s == 0xD) {
-      *p++ = 0xA;
-      if (*++s == 0xA)
-        s++;
-    }
-    else
-      *p++ = *s++;
-  } while (*s);
-  *p = XML_T('\0');
-}
-
-static int
-reportProcessingInstruction(XML_Parser parser, const ENCODING *enc,
-                            const char *start, const char *end)
-{
-  const XML_Char *target;
-  XML_Char *data;
-  const char *tem;
-  if (!processingInstructionHandler) {
-    if (defaultHandler)
-      reportDefault(parser, enc, start, end);
-    return 1;
-  }
-  start += enc->minBytesPerChar * 2;
-  tem = start + XmlNameLength(enc, start);
-  target = poolStoreString(&tempPool, enc, start, tem);
-  if (!target)
-    return 0;
-  poolFinish(&tempPool);
-  data = poolStoreString(&tempPool, enc,
-                        XmlSkipS(enc, tem),
-                        end - enc->minBytesPerChar*2);
-  if (!data)
-    return 0;
-  normalizeLines(data);
-  processingInstructionHandler(handlerArg, target, data);
-  poolClear(&tempPool);
-  return 1;
-}
-
-static int
-reportComment(XML_Parser parser, const ENCODING *enc,
-              const char *start, const char *end)
-{
-  XML_Char *data;
-  if (!commentHandler) {
-    if (defaultHandler)
-      reportDefault(parser, enc, start, end);
-    return 1;
-  }
-  data = poolStoreString(&tempPool,
-                         enc,
-                         start + enc->minBytesPerChar * 4,
-                         end - enc->minBytesPerChar * 3);
-  if (!data)
-    return 0;
-  normalizeLines(data);
-  commentHandler(handlerArg, data);
-  poolClear(&tempPool);
-  return 1;
-}
-
-static void
-reportDefault(XML_Parser parser, const ENCODING *enc,
-              const char *s, const char *end)
-{
-  if (MUST_CONVERT(enc, s)) {
-    enum XML_Convert_Result convert_res;
-    const char **eventPP;
-    const char **eventEndPP;
-    if (enc == encoding) {
-      eventPP = &eventPtr;
-      eventEndPP = &eventEndPtr;
-    }
-    else {
-      /* To get here, two things must be true; the parser must be
-       * using a character encoding that is not the same as the
-       * encoding passed in, and the encoding passed in must need
-       * conversion to the internal format (UTF-8 unless XML_UNICODE
-       * is defined).  The only occasions on which the encoding passed
-       * in is not the same as the parser's encoding are when it is
-       * the internal encoding (e.g. a previously defined parameter
-       * entity, already converted to internal format).  This by
-       * definition doesn't need conversion, so the whole branch never
-       * gets executed.
-       *
-       * For safety's sake we don't delete these lines and merely
-       * exclude them from coverage statistics.
-       *
-       * LCOV_EXCL_START
-       */
-      eventPP = &(openInternalEntities->internalEventPtr);
-      eventEndPP = &(openInternalEntities->internalEventEndPtr);
-      /* LCOV_EXCL_STOP */
-    }
-    do {
-      ICHAR *dataPtr = (ICHAR *)dataBuf;
-      convert_res = XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)dataBufEnd);
-      *eventEndPP = s;
-      defaultHandler(handlerArg, dataBuf, (int)(dataPtr - (ICHAR *)dataBuf));
-      *eventPP = s;
-    } while ((convert_res != XML_CONVERT_COMPLETED) && (convert_res != XML_CONVERT_INPUT_INCOMPLETE));
-  }
-  else
-    defaultHandler(handlerArg, (XML_Char *)s, (int)((XML_Char *)end - (XML_Char *)s));
-}
-
-
-static int
-defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *attId, XML_Bool isCdata,
-                XML_Bool isId, const XML_Char *value, XML_Parser parser)
-{
-  DEFAULT_ATTRIBUTE *att;
-  if (value || isId) {
-    /* The handling of default attributes gets messed up if we have
-       a default which duplicates a non-default. */
-    int i;
-    for (i = 0; i < type->nDefaultAtts; i++)
-      if (attId == type->defaultAtts[i].id)
-        return 1;
-    if (isId && !type->idAtt && !attId->xmlns)
-      type->idAtt = attId;
-  }
-  if (type->nDefaultAtts == type->allocDefaultAtts) {
-    if (type->allocDefaultAtts == 0) {
-      type->allocDefaultAtts = 8;
-      type->defaultAtts = (DEFAULT_ATTRIBUTE *)MALLOC(type->allocDefaultAtts
-                            * sizeof(DEFAULT_ATTRIBUTE));
-      if (!type->defaultAtts)
-        return 0;
-    }
-    else {
-      DEFAULT_ATTRIBUTE *temp;
-      int count = type->allocDefaultAtts * 2;
-      temp = (DEFAULT_ATTRIBUTE *)
-        REALLOC(type->defaultAtts, (count * sizeof(DEFAULT_ATTRIBUTE)));
-      if (temp == NULL)
-        return 0;
-      type->allocDefaultAtts = count;
-      type->defaultAtts = temp;
-    }
-  }
-  att = type->defaultAtts + type->nDefaultAtts;
-  att->id = attId;
-  att->value = value;
-  att->isCdata = isCdata;
-  if (!isCdata)
-    attId->maybeTokenized = XML_TRUE;
-  type->nDefaultAtts += 1;
-  return 1;
-}
-
-static int
-setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)
-{
-  DTD * const dtd = _dtd;  /* save one level of indirection */
-  const XML_Char *name;
-  for (name = elementType->name; *name; name++) {
-    if (*name == XML_T(ASCII_COLON)) {
-      PREFIX *prefix;
-      const XML_Char *s;
-      for (s = elementType->name; s != name; s++) {
-        if (!poolAppendChar(&dtd->pool, *s))
-          return 0;
-      }
-      if (!poolAppendChar(&dtd->pool, XML_T('\0')))
-        return 0;
-      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),
-                                sizeof(PREFIX));
-      if (!prefix)
-        return 0;
-      if (prefix->name == poolStart(&dtd->pool))
-        poolFinish(&dtd->pool);
-      else
-        poolDiscard(&dtd->pool);
-      elementType->prefix = prefix;
-
-    }
-  }
-  return 1;
-}
-
-static ATTRIBUTE_ID *
-getAttributeId(XML_Parser parser, const ENCODING *enc,
-               const char *start, const char *end)
-{
-  DTD * const dtd = _dtd;  /* save one level of indirection */
-  ATTRIBUTE_ID *id;
-  const XML_Char *name;
-  if (!poolAppendChar(&dtd->pool, XML_T('\0')))
-    return NULL;
-  name = poolStoreString(&dtd->pool, enc, start, end);
-  if (!name)
-    return NULL;
-  /* skip quotation mark - its storage will be re-used (like in name[-1]) */
-  ++name;
-  id = (ATTRIBUTE_ID *)lookup(parser, &dtd->attributeIds, name, sizeof(ATTRIBUTE_ID));
-  if (!id)
-    return NULL;
-  if (id->name != name)
-    poolDiscard(&dtd->pool);
-  else {
-    poolFinish(&dtd->pool);
-    if (!ns)
-      ;
-    else if (name[0] == XML_T(ASCII_x)
-        && name[1] == XML_T(ASCII_m)
-        && name[2] == XML_T(ASCII_l)
-        && name[3] == XML_T(ASCII_n)
-        && name[4] == XML_T(ASCII_s)
-        && (name[5] == XML_T('\0') || name[5] == XML_T(ASCII_COLON))) {
-      if (name[5] == XML_T('\0'))
-        id->prefix = &dtd->defaultPrefix;
-      else
-        id->prefix = (PREFIX *)lookup(parser, &dtd->prefixes, name + 6, sizeof(PREFIX));
-      id->xmlns = XML_TRUE;
-    }
-    else {
-      int i;
-      for (i = 0; name[i]; i++) {
-        /* attributes without prefix are *not* in the default namespace */
-        if (name[i] == XML_T(ASCII_COLON)) {
-          int j;
-          for (j = 0; j < i; j++) {
-            if (!poolAppendChar(&dtd->pool, name[j]))
-              return NULL;
-          }
-          if (!poolAppendChar(&dtd->pool, XML_T('\0')))
-            return NULL;
-          id->prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),
-                                        sizeof(PREFIX));
-          if (!id->prefix)
-            return NULL;
-          if (id->prefix->name == poolStart(&dtd->pool))
-            poolFinish(&dtd->pool);
-          else
-            poolDiscard(&dtd->pool);
-          break;
-        }
-      }
-    }
-  }
-  return id;
-}
-
-#define CONTEXT_SEP XML_T(ASCII_FF)
-
-static const XML_Char *
-getContext(XML_Parser parser)
-{
-  DTD * const dtd = _dtd;  /* save one level of indirection */
-  HASH_TABLE_ITER iter;
-  XML_Bool needSep = XML_FALSE;
-
-  if (dtd->defaultPrefix.binding) {
-    int i;
-    int len;
-    if (!poolAppendChar(&tempPool, XML_T(ASCII_EQUALS)))
-      return NULL;
-    len = dtd->defaultPrefix.binding->uriLen;
-    if (namespaceSeparator)
-      len--;
-    for (i = 0; i < len; i++) {
-      if (!poolAppendChar(&tempPool, dtd->defaultPrefix.binding->uri[i])) {
-        /* Because of memory caching, I don't believe this line can be
-         * executed.
-         *
-         * This is part of a loop copying the default prefix binding
-         * URI into the parser's temporary string pool.  Previously,
-         * that URI was copied into the same string pool, with a
-         * terminating NUL character, as part of setContext().  When
-         * the pool was cleared, that leaves a block definitely big
-         * enough to hold the URI on the free block list of the pool.
-         * The URI copy in getContext() therefore cannot run out of
-         * memory.
-         *
-         * If the pool is used between the setContext() and
-         * getContext() calls, the worst it can do is leave a bigger
-         * block on the front of the free list.  Given that this is
-         * all somewhat inobvious and program logic can be changed, we
-         * don't delete the line but we do exclude it from the test
-         * coverage statistics.
-         */
-        return NULL; /* LCOV_EXCL_LINE */
-      }
-    }
-    needSep = XML_TRUE;
-  }
-
-  hashTableIterInit(&iter, &(dtd->prefixes));
-  for (;;) {
-    int i;
-    int len;
-    const XML_Char *s;
-    PREFIX *prefix = (PREFIX *)hashTableIterNext(&iter);
-    if (!prefix)
-      break;
-    if (!prefix->binding) {
-      /* This test appears to be (justifiable) paranoia.  There does
-       * not seem to be a way of injecting a prefix without a binding
-       * that doesn't get errored long before this function is called.
-       * The test should remain for safety's sake, so we instead
-       * exclude the following line from the coverage statistics.
-       */
-      continue; /* LCOV_EXCL_LINE */
-    }
-    if (needSep && !poolAppendChar(&tempPool, CONTEXT_SEP))
-      return NULL;
-    for (s = prefix->name; *s; s++)
-      if (!poolAppendChar(&tempPool, *s))
-        return NULL;
-    if (!poolAppendChar(&tempPool, XML_T(ASCII_EQUALS)))
-      return NULL;
-    len = prefix->binding->uriLen;
-    if (namespaceSeparator)
-      len--;
-    for (i = 0; i < len; i++)
-      if (!poolAppendChar(&tempPool, prefix->binding->uri[i]))
-        return NULL;
-    needSep = XML_TRUE;
-  }
-
-
-  hashTableIterInit(&iter, &(dtd->generalEntities));
-  for (;;) {
-    const XML_Char *s;
-    ENTITY *e = (ENTITY *)hashTableIterNext(&iter);
-    if (!e)
-      break;
-    if (!e->open)
-      continue;
-    if (needSep && !poolAppendChar(&tempPool, CONTEXT_SEP))
-      return NULL;
-    for (s = e->name; *s; s++)
-      if (!poolAppendChar(&tempPool, *s))
-        return 0;
-    needSep = XML_TRUE;
-  }
-
-  if (!poolAppendChar(&tempPool, XML_T('\0')))
-    return NULL;
-  return tempPool.start;
-}
-
-static XML_Bool
-setContext(XML_Parser parser, const XML_Char *context)
-{
-  DTD * const dtd = _dtd;  /* save one level of indirection */
-  const XML_Char *s = context;
-
-  while (*context != XML_T('\0')) {
-    if (*s == CONTEXT_SEP || *s == XML_T('\0')) {
-      ENTITY *e;
-      if (!poolAppendChar(&tempPool, XML_T('\0')))
-        return XML_FALSE;
-      e = (ENTITY *)lookup(parser, &dtd->generalEntities, poolStart(&tempPool), 0);
-      if (e)
-        e->open = XML_TRUE;
-      if (*s != XML_T('\0'))
-        s++;
-      context = s;
-      poolDiscard(&tempPool);
-    }
-    else if (*s == XML_T(ASCII_EQUALS)) {
-      PREFIX *prefix;
-      if (poolLength(&tempPool) == 0)
-        prefix = &dtd->defaultPrefix;
-      else {
-        if (!poolAppendChar(&tempPool, XML_T('\0')))
-          return XML_FALSE;
-        prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&tempPool),
-                                  sizeof(PREFIX));
-        if (!prefix)
-          return XML_FALSE;
-        if (prefix->name == poolStart(&tempPool)) {
-          prefix->name = poolCopyString(&dtd->pool, prefix->name);
-          if (!prefix->name)
-            return XML_FALSE;
-        }
-        poolDiscard(&tempPool);
-      }
-      for (context = s + 1;
-           *context != CONTEXT_SEP && *context != XML_T('\0');
-           context++)
-        if (!poolAppendChar(&tempPool, *context))
-          return XML_FALSE;
-      if (!poolAppendChar(&tempPool, XML_T('\0')))
-        return XML_FALSE;
-      if (addBinding(parser, prefix, NULL, poolStart(&tempPool),
-                     &inheritedBindings) != XML_ERROR_NONE)
-        return XML_FALSE;
-      poolDiscard(&tempPool);
-      if (*context != XML_T('\0'))
-        ++context;
-      s = context;
-    }
-    else {
-      if (!poolAppendChar(&tempPool, *s))
-        return XML_FALSE;
-      s++;
-    }
-  }
-  return XML_TRUE;
-}
-
-static void FASTCALL
-normalizePublicId(XML_Char *publicId)
-{
-  XML_Char *p = publicId;
-  XML_Char *s;
-  for (s = publicId; *s; s++) {
-    switch (*s) {
-    case 0x20:
-    case 0xD:
-    case 0xA:
-      if (p != publicId && p[-1] != 0x20)
-        *p++ = 0x20;
-      break;
-    default:
-      *p++ = *s;
-    }
-  }
-  if (p != publicId && p[-1] == 0x20)
-    --p;
-  *p = XML_T('\0');
-}
-
-static DTD *
-dtdCreate(const XML_Memory_Handling_Suite *ms)
-{
-  DTD *p = (DTD *)ms->malloc_fcn(sizeof(DTD));
-  if (p == NULL)
-    return p;
-  poolInit(&(p->pool), ms);
-  poolInit(&(p->entityValuePool), ms);
-  hashTableInit(&(p->generalEntities), ms);
-  hashTableInit(&(p->elementTypes), ms);
-  hashTableInit(&(p->attributeIds), ms);
-  hashTableInit(&(p->prefixes), ms);
-#ifdef XML_DTD
-  p->paramEntityRead = XML_FALSE;
-  hashTableInit(&(p->paramEntities), ms);
-#endif /* XML_DTD */
-  p->defaultPrefix.name = NULL;
-  p->defaultPrefix.binding = NULL;
-
-  p->in_eldecl = XML_FALSE;
-  p->scaffIndex = NULL;
-  p->scaffold = NULL;
-  p->scaffLevel = 0;
-  p->scaffSize = 0;
-  p->scaffCount = 0;
-  p->contentStringLen = 0;
-
-  p->keepProcessing = XML_TRUE;
-  p->hasParamEntityRefs = XML_FALSE;
-  p->standalone = XML_FALSE;
-  return p;
-}
-
-static void
-dtdReset(DTD *p, const XML_Memory_Handling_Suite *ms)
-{
-  HASH_TABLE_ITER iter;
-  hashTableIterInit(&iter, &(p->elementTypes));
-  for (;;) {
-    ELEMENT_TYPE *e = (ELEMENT_TYPE *)hashTableIterNext(&iter);
-    if (!e)
-      break;
-    if (e->allocDefaultAtts != 0)
-      ms->free_fcn(e->defaultAtts);
-  }
-  hashTableClear(&(p->generalEntities));
-#ifdef XML_DTD
-  p->paramEntityRead = XML_FALSE;
-  hashTableClear(&(p->paramEntities));
-#endif /* XML_DTD */
-  hashTableClear(&(p->elementTypes));
-  hashTableClear(&(p->attributeIds));
-  hashTableClear(&(p->prefixes));
-  poolClear(&(p->pool));
-  poolClear(&(p->entityValuePool));
-  p->defaultPrefix.name = NULL;
-  p->defaultPrefix.binding = NULL;
-
-  p->in_eldecl = XML_FALSE;
-
-  ms->free_fcn(p->scaffIndex);
-  p->scaffIndex = NULL;
-  ms->free_fcn(p->scaffold);
-  p->scaffold = NULL;
-
-  p->scaffLevel = 0;
-  p->scaffSize = 0;
-  p->scaffCount = 0;
-  p->contentStringLen = 0;
-
-  p->keepProcessing = XML_TRUE;
-  p->hasParamEntityRefs = XML_FALSE;
-  p->standalone = XML_FALSE;
-}
-
-static void
-dtdDestroy(DTD *p, XML_Bool isDocEntity, const XML_Memory_Handling_Suite *ms)
-{
-  HASH_TABLE_ITER iter;
-  hashTableIterInit(&iter, &(p->elementTypes));
-  for (;;) {
-    ELEMENT_TYPE *e = (ELEMENT_TYPE *)hashTableIterNext(&iter);
-    if (!e)
-      break;
-    if (e->allocDefaultAtts != 0)
-      ms->free_fcn(e->defaultAtts);
-  }
-  hashTableDestroy(&(p->generalEntities));
-#ifdef XML_DTD
-  hashTableDestroy(&(p->paramEntities));
-#endif /* XML_DTD */
-  hashTableDestroy(&(p->elementTypes));
-  hashTableDestroy(&(p->attributeIds));
-  hashTableDestroy(&(p->prefixes));
-  poolDestroy(&(p->pool));
-  poolDestroy(&(p->entityValuePool));
-  if (isDocEntity) {
-    ms->free_fcn(p->scaffIndex);
-    ms->free_fcn(p->scaffold);
-  }
-  ms->free_fcn(p);
-}
-
-/* Do a deep copy of the DTD. Return 0 for out of memory, non-zero otherwise.
-   The new DTD has already been initialized.
-*/
-static int
-dtdCopy(XML_Parser oldParser, DTD *newDtd, const DTD *oldDtd, const XML_Memory_Handling_Suite *ms)
-{
-  HASH_TABLE_ITER iter;
-
-  /* Copy the prefix table. */
-
-  hashTableIterInit(&iter, &(oldDtd->prefixes));
-  for (;;) {
-    const XML_Char *name;
-    const PREFIX *oldP = (PREFIX *)hashTableIterNext(&iter);
-    if (!oldP)
-      break;
-    name = poolCopyString(&(newDtd->pool), oldP->name);
-    if (!name)
-      return 0;
-    if (!lookup(oldParser, &(newDtd->prefixes), name, sizeof(PREFIX)))
-      return 0;
-  }
-
-  hashTableIterInit(&iter, &(oldDtd->attributeIds));
-
-  /* Copy the attribute id table. */
-
-  for (;;) {
-    ATTRIBUTE_ID *newA;
-    const XML_Char *name;
-    const ATTRIBUTE_ID *oldA = (ATTRIBUTE_ID *)hashTableIterNext(&iter);
-
-    if (!oldA)
-      break;
-    /* Remember to allocate the scratch byte before the name. */
-    if (!poolAppendChar(&(newDtd->pool), XML_T('\0')))
-      return 0;
-    name = poolCopyString(&(newDtd->pool), oldA->name);
-    if (!name)
-      return 0;
-    ++name;
-    newA = (ATTRIBUTE_ID *)lookup(oldParser, &(newDtd->attributeIds), name,
-                                  sizeof(ATTRIBUTE_ID));
-    if (!newA)
-      return 0;
-    newA->maybeTokenized = oldA->maybeTokenized;
-    if (oldA->prefix) {
-      newA->xmlns = oldA->xmlns;
-      if (oldA->prefix == &oldDtd->defaultPrefix)
-        newA->prefix = &newDtd->defaultPrefix;
-      else
-        newA->prefix = (PREFIX *)lookup(oldParser, &(newDtd->prefixes),
-                                        oldA->prefix->name, 0);
-    }
-  }
-
-  /* Copy the element type table. */
-
-  hashTableIterInit(&iter, &(oldDtd->elementTypes));
-
-  for (;;) {
-    int i;
-    ELEMENT_TYPE *newE;
-    const XML_Char *name;
-    const ELEMENT_TYPE *oldE = (ELEMENT_TYPE *)hashTableIterNext(&iter);
-    if (!oldE)
-      break;
-    name = poolCopyString(&(newDtd->pool), oldE->name);
-    if (!name)
-      return 0;
-    newE = (ELEMENT_TYPE *)lookup(oldParser, &(newDtd->elementTypes), name,
-                                  sizeof(ELEMENT_TYPE));
-    if (!newE)
-      return 0;
-    if (oldE->nDefaultAtts) {
-      newE->defaultAtts = (DEFAULT_ATTRIBUTE *)
-          ms->malloc_fcn(oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));
-      if (!newE->defaultAtts) {
-        return 0;
-      }
-    }
-    if (oldE->idAtt)
-      newE->idAtt = (ATTRIBUTE_ID *)
-          lookup(oldParser, &(newDtd->attributeIds), oldE->idAtt->name, 0);
-    newE->allocDefaultAtts = newE->nDefaultAtts = oldE->nDefaultAtts;
-    if (oldE->prefix)
-      newE->prefix = (PREFIX *)lookup(oldParser, &(newDtd->prefixes),
-                                      oldE->prefix->name, 0);
-    for (i = 0; i < newE->nDefaultAtts; i++) {
-      newE->defaultAtts[i].id = (ATTRIBUTE_ID *)
-          lookup(oldParser, &(newDtd->attributeIds), oldE->defaultAtts[i].id->name, 0);
-      newE->defaultAtts[i].isCdata = oldE->defaultAtts[i].isCdata;
-      if (oldE->defaultAtts[i].value) {
-        newE->defaultAtts[i].value
-            = poolCopyString(&(newDtd->pool), oldE->defaultAtts[i].value);
-        if (!newE->defaultAtts[i].value)
-          return 0;
-      }
-      else
-        newE->defaultAtts[i].value = NULL;
-    }
-  }
-
-  /* Copy the entity tables. */
-  if (!copyEntityTable(oldParser,
-                       &(newDtd->generalEntities),
-                       &(newDtd->pool),
-                       &(oldDtd->generalEntities)))
-      return 0;
-
-#ifdef XML_DTD
-  if (!copyEntityTable(oldParser,
-                       &(newDtd->paramEntities),
-                       &(newDtd->pool),
-                       &(oldDtd->paramEntities)))
-      return 0;
-  newDtd->paramEntityRead = oldDtd->paramEntityRead;
-#endif /* XML_DTD */
-
-  newDtd->keepProcessing = oldDtd->keepProcessing;
-  newDtd->hasParamEntityRefs = oldDtd->hasParamEntityRefs;
-  newDtd->standalone = oldDtd->standalone;
-
-  /* Don't want deep copying for scaffolding */
-  newDtd->in_eldecl = oldDtd->in_eldecl;
-  newDtd->scaffold = oldDtd->scaffold;
-  newDtd->contentStringLen = oldDtd->contentStringLen;
-  newDtd->scaffSize = oldDtd->scaffSize;
-  newDtd->scaffLevel = oldDtd->scaffLevel;
-  newDtd->scaffIndex = oldDtd->scaffIndex;
-
-  return 1;
-}  /* End dtdCopy */
-
-static int
-copyEntityTable(XML_Parser oldParser,
-                HASH_TABLE *newTable,
-                STRING_POOL *newPool,
-                const HASH_TABLE *oldTable)
-{
-  HASH_TABLE_ITER iter;
-  const XML_Char *cachedOldBase = NULL;
-  const XML_Char *cachedNewBase = NULL;
-
-  hashTableIterInit(&iter, oldTable);
-
-  for (;;) {
-    ENTITY *newE;
-    const XML_Char *name;
-    const ENTITY *oldE = (ENTITY *)hashTableIterNext(&iter);
-    if (!oldE)
-      break;
-    name = poolCopyString(newPool, oldE->name);
-    if (!name)
-      return 0;
-    newE = (ENTITY *)lookup(oldParser, newTable, name, sizeof(ENTITY));
-    if (!newE)
-      return 0;
-    if (oldE->systemId) {
-      const XML_Char *tem = poolCopyString(newPool, oldE->systemId);
-      if (!tem)
-        return 0;
-      newE->systemId = tem;
-      if (oldE->base) {
-        if (oldE->base == cachedOldBase)
-          newE->base = cachedNewBase;
-        else {
-          cachedOldBase = oldE->base;
-          tem = poolCopyString(newPool, cachedOldBase);
-          if (!tem)
-            return 0;
-          cachedNewBase = newE->base = tem;
-        }
-      }
-      if (oldE->publicId) {
-        tem = poolCopyString(newPool, oldE->publicId);
-        if (!tem)
-          return 0;
-        newE->publicId = tem;
-      }
-    }
-    else {
-      const XML_Char *tem = poolCopyStringN(newPool, oldE->textPtr,
-                                            oldE->textLen);
-      if (!tem)
-        return 0;
-      newE->textPtr = tem;
-      newE->textLen = oldE->textLen;
-    }
-    if (oldE->notation) {
-      const XML_Char *tem = poolCopyString(newPool, oldE->notation);
-      if (!tem)
-        return 0;
-      newE->notation = tem;
-    }
-    newE->is_param = oldE->is_param;
-    newE->is_internal = oldE->is_internal;
-  }
-  return 1;
-}
-
-#define INIT_POWER 6
-
-static XML_Bool FASTCALL
-keyeq(KEY s1, KEY s2)
-{
-  for (; *s1 == *s2; s1++, s2++)
-    if (*s1 == 0)
-      return XML_TRUE;
-  return XML_FALSE;
-}
-
-static size_t
-keylen(KEY s)
-{
-  size_t len = 0;
-  for (; *s; s++, len++);
-  return len;
-}
-
-static void
-copy_salt_to_sipkey(XML_Parser parser, struct sipkey * key)
-{
-  key->k[0] = 0;
-  key->k[1] = get_hash_secret_salt(parser);
-}
-
-static unsigned long FASTCALL
-hash(XML_Parser parser, KEY s)
-{
-  struct siphash state;
-  struct sipkey key;
-  (void)sip_tobin;
-  (void)sip24_valid;
-  copy_salt_to_sipkey(parser, &key);
-  sip24_init(&state, &key);
-  sip24_update(&state, s, keylen(s) * sizeof(XML_Char));
-  return (unsigned long)sip24_final(&state);
-}
-
-static NAMED *
-lookup(XML_Parser parser, HASH_TABLE *table, KEY name, size_t createSize)
-{
-  size_t i;
-  if (table->size == 0) {
-    size_t tsize;
-    if (!createSize)
-      return NULL;
-    table->power = INIT_POWER;
-    /* table->size is a power of 2 */
-    table->size = (size_t)1 << INIT_POWER;
-    tsize = table->size * sizeof(NAMED *);
-    table->v = (NAMED **)table->mem->malloc_fcn(tsize);
-    if (!table->v) {
-      table->size = 0;
-      return NULL;
-    }
-    memset(table->v, 0, tsize);
-    i = hash(parser, name) & ((unsigned long)table->size - 1);
-  }
-  else {
-    unsigned long h = hash(parser, name);
-    unsigned long mask = (unsigned long)table->size - 1;
-    unsigned char step = 0;
-    i = h & mask;
-    while (table->v[i]) {
-      if (keyeq(name, table->v[i]->name))
-        return table->v[i];
-      if (!step)
-        step = PROBE_STEP(h, mask, table->power);
-      i < step ? (i += table->size - step) : (i -= step);
-    }
-    if (!createSize)
-      return NULL;
-
-    /* check for overflow (table is half full) */
-    if (table->used >> (table->power - 1)) {
-      unsigned char newPower = table->power + 1;
-      size_t newSize = (size_t)1 << newPower;
-      unsigned long newMask = (unsigned long)newSize - 1;
-      size_t tsize = newSize * sizeof(NAMED *);
-      NAMED **newV = (NAMED **)table->mem->malloc_fcn(tsize);
-      if (!newV)
-        return NULL;
-      memset(newV, 0, tsize);
-      for (i = 0; i < table->size; i++)
-        if (table->v[i]) {
-          unsigned long newHash = hash(parser, table->v[i]->name);
-          size_t j = newHash & newMask;
-          step = 0;
-          while (newV[j]) {
-            if (!step)
-              step = PROBE_STEP(newHash, newMask, newPower);
-            j < step ? (j += newSize - step) : (j -= step);
-          }
-          newV[j] = table->v[i];
-        }
-      table->mem->free_fcn(table->v);
-      table->v = newV;
-      table->power = newPower;
-      table->size = newSize;
-      i = h & newMask;
-      step = 0;
-      while (table->v[i]) {
-        if (!step)
-          step = PROBE_STEP(h, newMask, newPower);
-        i < step ? (i += newSize - step) : (i -= step);
-      }
-    }
-  }
-  table->v[i] = (NAMED *)table->mem->malloc_fcn(createSize);
-  if (!table->v[i])
-    return NULL;
-  memset(table->v[i], 0, createSize);
-  table->v[i]->name = name;
-  (table->used)++;
-  return table->v[i];
-}
-
-static void FASTCALL
-hashTableClear(HASH_TABLE *table)
-{
-  size_t i;
-  for (i = 0; i < table->size; i++) {
-    table->mem->free_fcn(table->v[i]);
-    table->v[i] = NULL;
-  }
-  table->used = 0;
-}
-
-static void FASTCALL
-hashTableDestroy(HASH_TABLE *table)
-{
-  size_t i;
-  for (i = 0; i < table->size; i++)
-    table->mem->free_fcn(table->v[i]);
-  table->mem->free_fcn(table->v);
-}
-
-static void FASTCALL
-hashTableInit(HASH_TABLE *p, const XML_Memory_Handling_Suite *ms)
-{
-  p->power = 0;
-  p->size = 0;
-  p->used = 0;
-  p->v = NULL;
-  p->mem = ms;
-}
-
-static void FASTCALL
-hashTableIterInit(HASH_TABLE_ITER *iter, const HASH_TABLE *table)
-{
-  iter->p = table->v;
-  iter->end = iter->p + table->size;
-}
-
-static NAMED * FASTCALL
-hashTableIterNext(HASH_TABLE_ITER *iter)
-{
-  while (iter->p != iter->end) {
-    NAMED *tem = *(iter->p)++;
-    if (tem)
-      return tem;
-  }
-  return NULL;
-}
-
-static void FASTCALL
-poolInit(STRING_POOL *pool, const XML_Memory_Handling_Suite *ms)
-{
-  pool->blocks = NULL;
-  pool->freeBlocks = NULL;
-  pool->start = NULL;
-  pool->ptr = NULL;
-  pool->end = NULL;
-  pool->mem = ms;
-}
-
-static void FASTCALL
-poolClear(STRING_POOL *pool)
-{
-  if (!pool->freeBlocks)
-    pool->freeBlocks = pool->blocks;
-  else {
-    BLOCK *p = pool->blocks;
-    while (p) {
-      BLOCK *tem = p->next;
-      p->next = pool->freeBlocks;
-      pool->freeBlocks = p;
-      p = tem;
-    }
-  }
-  pool->blocks = NULL;
-  pool->start = NULL;
-  pool->ptr = NULL;
-  pool->end = NULL;
-}
-
-static void FASTCALL
-poolDestroy(STRING_POOL *pool)
-{
-  BLOCK *p = pool->blocks;
-  while (p) {
-    BLOCK *tem = p->next;
-    pool->mem->free_fcn(p);
-    p = tem;
-  }
-  p = pool->freeBlocks;
-  while (p) {
-    BLOCK *tem = p->next;
-    pool->mem->free_fcn(p);
-    p = tem;
-  }
-}
-
-static XML_Char *
-poolAppend(STRING_POOL *pool, const ENCODING *enc,
-           const char *ptr, const char *end)
-{
-  if (!pool->ptr && !poolGrow(pool))
-    return NULL;
-  for (;;) {
-    const enum XML_Convert_Result convert_res = XmlConvert(enc, &ptr, end, (ICHAR **)&(pool->ptr), (ICHAR *)pool->end);
-    if ((convert_res == XML_CONVERT_COMPLETED) || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))
-      break;
-    if (!poolGrow(pool))
-      return NULL;
-  }
-  return pool->start;
-}
-
-static const XML_Char * FASTCALL
-poolCopyString(STRING_POOL *pool, const XML_Char *s)
-{
-  do {
-    if (!poolAppendChar(pool, *s))
-      return NULL;
-  } while (*s++);
-  s = pool->start;
-  poolFinish(pool);
-  return s;
-}
-
-static const XML_Char *
-poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n)
-{
-  if (!pool->ptr && !poolGrow(pool)) {
-    /* The following line is unreachable given the current usage of
-     * poolCopyStringN().  Currently it is called from exactly one
-     * place to copy the text of a simple general entity.  By that
-     * point, the name of the entity is already stored in the pool, so
-     * pool->ptr cannot be NULL.
-     *
-     * If poolCopyStringN() is used elsewhere as it well might be,
-     * this line may well become executable again.  Regardless, this
-     * sort of check shouldn't be removed lightly, so we just exclude
-     * it from the coverage statistics.
-     */
-    return NULL; /* LCOV_EXCL_LINE */
-  }
-  for (; n > 0; --n, s++) {
-    if (!poolAppendChar(pool, *s))
-      return NULL;
-  }
-  s = pool->start;
-  poolFinish(pool);
-  return s;
-}
-
-static const XML_Char * FASTCALL
-poolAppendString(STRING_POOL *pool, const XML_Char *s)
-{
-  while (*s) {
-    if (!poolAppendChar(pool, *s))
-      return NULL;
-    s++;
-  }
-  return pool->start;
-}
-
-static XML_Char *
-poolStoreString(STRING_POOL *pool, const ENCODING *enc,
-                const char *ptr, const char *end)
-{
-  if (!poolAppend(pool, enc, ptr, end))
-    return NULL;
-  if (pool->ptr == pool->end && !poolGrow(pool))
-    return NULL;
-  *(pool->ptr)++ = 0;
-  return pool->start;
-}
-
-static size_t
-poolBytesToAllocateFor(int blockSize)
-{
-  /* Unprotected math would be:
-  ** return offsetof(BLOCK, s) + blockSize * sizeof(XML_Char);
-  **
-  ** Detect overflow, avoiding _signed_ overflow undefined behavior
-  ** For a + b * c we check b * c in isolation first, so that addition of a
-  ** on top has no chance of making us accept a small non-negative number
-  */
-  const size_t stretch = sizeof(XML_Char);  /* can be 4 bytes */
-
-  if (blockSize <= 0)
-    return 0;
-
-  if (blockSize > (int)(INT_MAX / stretch))
-    return 0;
-
-  {
-    const int stretchedBlockSize = blockSize * (int)stretch;
-    const int bytesToAllocate = (int)(
-        offsetof(BLOCK, s) + (unsigned)stretchedBlockSize);
-    if (bytesToAllocate < 0)
-      return 0;
-
-    return (size_t)bytesToAllocate;
-  }
-}
-
-static XML_Bool FASTCALL
-poolGrow(STRING_POOL *pool)
-{
-  if (pool->freeBlocks) {
-    if (pool->start == 0) {
-      pool->blocks = pool->freeBlocks;
-      pool->freeBlocks = pool->freeBlocks->next;
-      pool->blocks->next = NULL;
-      pool->start = pool->blocks->s;
-      pool->end = pool->start + pool->blocks->size;
-      pool->ptr = pool->start;
-      return XML_TRUE;
-    }
-    if (pool->end - pool->start < pool->freeBlocks->size) {
-      BLOCK *tem = pool->freeBlocks->next;
-      pool->freeBlocks->next = pool->blocks;
-      pool->blocks = pool->freeBlocks;
-      pool->freeBlocks = tem;
-      memcpy(pool->blocks->s, pool->start,
-             (pool->end - pool->start) * sizeof(XML_Char));
-      pool->ptr = pool->blocks->s + (pool->ptr - pool->start);
-      pool->start = pool->blocks->s;
-      pool->end = pool->start + pool->blocks->size;
-      return XML_TRUE;
-    }
-  }
-  if (pool->blocks && pool->start == pool->blocks->s) {
-    BLOCK *temp;
-    int blockSize = (int)((unsigned)(pool->end - pool->start)*2U);
-    size_t bytesToAllocate;
-
-    // NOTE: Needs to be calculated prior to calling `realloc`
-    //       to avoid dangling pointers:
-    const ptrdiff_t offsetInsideBlock = pool->ptr - pool->start;
-
-    if (blockSize < 0) {
-      /* This condition traps a situation where either more than
-       * INT_MAX/2 bytes have already been allocated.  This isn't
-       * readily testable, since it is unlikely that an average
-       * machine will have that much memory, so we exclude it from the
-       * coverage statistics.
-       */
-      return XML_FALSE; /* LCOV_EXCL_LINE */
-    }
-
-    bytesToAllocate = poolBytesToAllocateFor(blockSize);
-    if (bytesToAllocate == 0)
-      return XML_FALSE;
-
-    temp = (BLOCK *)
-      pool->mem->realloc_fcn(pool->blocks, (unsigned)bytesToAllocate);
-    if (temp == NULL)
-      return XML_FALSE;
-    pool->blocks = temp;
-    pool->blocks->size = blockSize;
-    pool->ptr = pool->blocks->s + offsetInsideBlock;
-    pool->start = pool->blocks->s;
-    pool->end = pool->start + blockSize;
-  }
-  else {
-    BLOCK *tem;
-    int blockSize = (int)(pool->end - pool->start);
-    size_t bytesToAllocate;
-
-    if (blockSize < 0) {
-      /* This condition traps a situation where either more than
-       * INT_MAX bytes have already been allocated (which is prevented
-       * by various pieces of program logic, not least this one, never
-       * mind the unlikelihood of actually having that much memory) or
-       * the pool control fields have been corrupted (which could
-       * conceivably happen in an extremely buggy user handler
-       * function).  Either way it isn't readily testable, so we
-       * exclude it from the coverage statistics.
-       */
-      return XML_FALSE;  /* LCOV_EXCL_LINE */
-    }
-
-    if (blockSize < INIT_BLOCK_SIZE)
-      blockSize = INIT_BLOCK_SIZE;
-    else {
-      /* Detect overflow, avoiding _signed_ overflow undefined behavior */
-      if ((int)((unsigned)blockSize * 2U) < 0) {
-        return XML_FALSE;
-      }
-      blockSize *= 2;
-    }
-
-    bytesToAllocate = poolBytesToAllocateFor(blockSize);
-    if (bytesToAllocate == 0)
-      return XML_FALSE;
-
-    tem = (BLOCK *)pool->mem->malloc_fcn(bytesToAllocate);
-    if (!tem)
-      return XML_FALSE;
-    tem->size = blockSize;
-    tem->next = pool->blocks;
-    pool->blocks = tem;
-    if (pool->ptr != pool->start)
-      memcpy(tem->s, pool->start,
-             (pool->ptr - pool->start) * sizeof(XML_Char));
-    pool->ptr = tem->s + (pool->ptr - pool->start);
-    pool->start = tem->s;
-    pool->end = tem->s + blockSize;
-  }
-  return XML_TRUE;
-}
-
-static int FASTCALL
-nextScaffoldPart(XML_Parser parser)
-{
-  DTD * const dtd = _dtd;  /* save one level of indirection */
-  CONTENT_SCAFFOLD * me;
-  int next;
-
-  if (!dtd->scaffIndex) {
-    dtd->scaffIndex = (int *)MALLOC(groupSize * sizeof(int));
-    if (!dtd->scaffIndex)
-      return -1;
-    dtd->scaffIndex[0] = 0;
-  }
-
-  if (dtd->scaffCount >= dtd->scaffSize) {
-    CONTENT_SCAFFOLD *temp;
-    if (dtd->scaffold) {
-      temp = (CONTENT_SCAFFOLD *)
-        REALLOC(dtd->scaffold, dtd->scaffSize * 2 * sizeof(CONTENT_SCAFFOLD));
-      if (temp == NULL)
-        return -1;
-      dtd->scaffSize *= 2;
-    }
-    else {
-      temp = (CONTENT_SCAFFOLD *)MALLOC(INIT_SCAFFOLD_ELEMENTS
-                                        * sizeof(CONTENT_SCAFFOLD));
-      if (temp == NULL)
-        return -1;
-      dtd->scaffSize = INIT_SCAFFOLD_ELEMENTS;
-    }
-    dtd->scaffold = temp;
-  }
-  next = dtd->scaffCount++;
-  me = &dtd->scaffold[next];
-  if (dtd->scaffLevel) {
-    CONTENT_SCAFFOLD *parent = &dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel-1]];
-    if (parent->lastchild) {
-      dtd->scaffold[parent->lastchild].nextsib = next;
-    }
-    if (!parent->childcnt)
-      parent->firstchild = next;
-    parent->lastchild = next;
-    parent->childcnt++;
-  }
-  me->firstchild = me->lastchild = me->childcnt = me->nextsib = 0;
-  return next;
-}
-
-static void
-build_node(XML_Parser parser,
-           int src_node,
-           XML_Content *dest,
-           XML_Content **contpos,
-           XML_Char **strpos)
-{
-  DTD * const dtd = _dtd;  /* save one level of indirection */
-  dest->type = dtd->scaffold[src_node].type;
-  dest->quant = dtd->scaffold[src_node].quant;
-  if (dest->type == XML_CTYPE_NAME) {
-    const XML_Char *src;
-    dest->name = *strpos;
-    src = dtd->scaffold[src_node].name;
-    for (;;) {
-      *(*strpos)++ = *src;
-      if (!*src)
-        break;
-      src++;
-    }
-    dest->numchildren = 0;
-    dest->children = NULL;
-  }
-  else {
-    unsigned int i;
-    int cn;
-    dest->numchildren = dtd->scaffold[src_node].childcnt;
-    dest->children = *contpos;
-    *contpos += dest->numchildren;
-    for (i = 0, cn = dtd->scaffold[src_node].firstchild;
-         i < dest->numchildren;
-         i++, cn = dtd->scaffold[cn].nextsib) {
-      build_node(parser, cn, &(dest->children[i]), contpos, strpos);
-    }
-    dest->name = NULL;
-  }
-}
-
-static XML_Content *
-build_model (XML_Parser parser)
-{
-  DTD * const dtd = _dtd;  /* save one level of indirection */
-  XML_Content *ret;
-  XML_Content *cpos;
-  XML_Char * str;
-  int allocsize = (dtd->scaffCount * sizeof(XML_Content)
-                   + (dtd->contentStringLen * sizeof(XML_Char)));
-
-  ret = (XML_Content *)MALLOC(allocsize);
-  if (!ret)
-    return NULL;
-
-  str =  (XML_Char *) (&ret[dtd->scaffCount]);
-  cpos = &ret[1];
-
-  build_node(parser, 0, ret, &cpos, &str);
-  return ret;
-}
-
-static ELEMENT_TYPE *
-getElementType(XML_Parser parser,
-               const ENCODING *enc,
-               const char *ptr,
-               const char *end)
-{
-  DTD * const dtd = _dtd;  /* save one level of indirection */
-  const XML_Char *name = poolStoreString(&dtd->pool, enc, ptr, end);
-  ELEMENT_TYPE *ret;
-
-  if (!name)
-    return NULL;
-  ret = (ELEMENT_TYPE *) lookup(parser, &dtd->elementTypes, name, sizeof(ELEMENT_TYPE));
-  if (!ret)
-    return NULL;
-  if (ret->name != name)
-    poolDiscard(&dtd->pool);
-  else {
-    poolFinish(&dtd->pool);
-    if (!setElementTypePrefix(parser, ret))
-      return NULL;
-  }
-  return ret;
-}
-
-static XML_Char *
-copyString(const XML_Char *s,
-           const XML_Memory_Handling_Suite *memsuite)
-{
-    int charsRequired = 0;
-    XML_Char *result;
-
-    /* First determine how long the string is */
-    while (s[charsRequired] != 0) {
-      charsRequired++;
-    }
-    /* Include the terminator */
-    charsRequired++;
-
-    /* Now allocate space for the copy */
-    result = memsuite->malloc_fcn(charsRequired * sizeof(XML_Char));
-    if (result == NULL)
-        return NULL;
-    /* Copy the original into place */
-    memcpy(result, s, charsRequired * sizeof(XML_Char));
-    return result;
-}
diff --git a/third_party/expat/files/lib/xmlrole.c b/third_party/expat/files/lib/xmlrole.c
deleted file mode 100644
index c809ee51482b..000000000000
--- a/third_party/expat/files/lib/xmlrole.c
+++ /dev/null
@@ -1,1358 +0,0 @@
-/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-*/
-
-#include <stddef.h>
-
-#ifdef _WIN32
-#include "winconfig.h"
-#else
-#ifdef HAVE_EXPAT_CONFIG_H
-#include <expat_config.h>
-#endif
-#endif /* ndef _WIN32 */
-
-#include "expat_external.h"
-#include "internal.h"
-#include "xmlrole.h"
-#include "ascii.h"
-
-/* Doesn't check:
-
- that ,| are not mixed in a model group
- content of literals
-
-*/
-
-static const char KW_ANY[] = {
-    ASCII_A, ASCII_N, ASCII_Y, '\0' };
-static const char KW_ATTLIST[] = {
-    ASCII_A, ASCII_T, ASCII_T, ASCII_L, ASCII_I, ASCII_S, ASCII_T, '\0' };
-static const char KW_CDATA[] = {
-    ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0' };
-static const char KW_DOCTYPE[] = {
-    ASCII_D, ASCII_O, ASCII_C, ASCII_T, ASCII_Y, ASCII_P, ASCII_E, '\0' };
-static const char KW_ELEMENT[] = {
-    ASCII_E, ASCII_L, ASCII_E, ASCII_M, ASCII_E, ASCII_N, ASCII_T, '\0' };
-static const char KW_EMPTY[] = {
-    ASCII_E, ASCII_M, ASCII_P, ASCII_T, ASCII_Y, '\0' };
-static const char KW_ENTITIES[] = {
-    ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_I, ASCII_E, ASCII_S,
-    '\0' };
-static const char KW_ENTITY[] = {
-    ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_Y, '\0' };
-static const char KW_FIXED[] = {
-    ASCII_F, ASCII_I, ASCII_X, ASCII_E, ASCII_D, '\0' };
-static const char KW_ID[] = {
-    ASCII_I, ASCII_D, '\0' };
-static const char KW_IDREF[] = {
-    ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, '\0' };
-static const char KW_IDREFS[] = {
-    ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, ASCII_S, '\0' };
-#ifdef XML_DTD
-static const char KW_IGNORE[] = {
-    ASCII_I, ASCII_G, ASCII_N, ASCII_O, ASCII_R, ASCII_E, '\0' };
-#endif
-static const char KW_IMPLIED[] = {
-    ASCII_I, ASCII_M, ASCII_P, ASCII_L, ASCII_I, ASCII_E, ASCII_D, '\0' };
-#ifdef XML_DTD
-static const char KW_INCLUDE[] = {
-    ASCII_I, ASCII_N, ASCII_C, ASCII_L, ASCII_U, ASCII_D, ASCII_E, '\0' };
-#endif
-static const char KW_NDATA[] = {
-    ASCII_N, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0' };
-static const char KW_NMTOKEN[] = {
-    ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, '\0' };
-static const char KW_NMTOKENS[] = {
-    ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, ASCII_S,
-    '\0' };
-static const char KW_NOTATION[] =
-    { ASCII_N, ASCII_O, ASCII_T, ASCII_A, ASCII_T, ASCII_I, ASCII_O, ASCII_N,
-      '\0' };
-static const char KW_PCDATA[] = {
-    ASCII_P, ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0' };
-static const char KW_PUBLIC[] = {
-    ASCII_P, ASCII_U, ASCII_B, ASCII_L, ASCII_I, ASCII_C, '\0' };
-static const char KW_REQUIRED[] = {
-    ASCII_R, ASCII_E, ASCII_Q, ASCII_U, ASCII_I, ASCII_R, ASCII_E, ASCII_D,
-    '\0' };
-static const char KW_SYSTEM[] = {
-    ASCII_S, ASCII_Y, ASCII_S, ASCII_T, ASCII_E, ASCII_M, '\0' };
-
-#ifndef MIN_BYTES_PER_CHAR
-#define MIN_BYTES_PER_CHAR(enc) ((enc)->minBytesPerChar)
-#endif
-
-#ifdef XML_DTD
-#define setTopLevel(state) \
-  ((state)->handler = ((state)->documentEntity \
-                       ? internalSubset \
-                       : externalSubset1))
-#else /* not XML_DTD */
-#define setTopLevel(state) ((state)->handler = internalSubset)
-#endif /* not XML_DTD */
-
-typedef int PTRCALL PROLOG_HANDLER(PROLOG_STATE *state,
-                                   int tok,
-                                   const char *ptr,
-                                   const char *end,
-                                   const ENCODING *enc);
-
-static PROLOG_HANDLER
-  prolog0, prolog1, prolog2,
-  doctype0, doctype1, doctype2, doctype3, doctype4, doctype5,
-  internalSubset,
-  entity0, entity1, entity2, entity3, entity4, entity5, entity6,
-  entity7, entity8, entity9, entity10,
-  notation0, notation1, notation2, notation3, notation4,
-  attlist0, attlist1, attlist2, attlist3, attlist4, attlist5, attlist6,
-  attlist7, attlist8, attlist9,
-  element0, element1, element2, element3, element4, element5, element6,
-  element7,
-#ifdef XML_DTD
-  externalSubset0, externalSubset1,
-  condSect0, condSect1, condSect2,
-#endif /* XML_DTD */
-  declClose,
-  error;
-
-static int FASTCALL common(PROLOG_STATE *state, int tok);
-
-static int PTRCALL
-prolog0(PROLOG_STATE *state,
-        int tok,
-        const char *ptr,
-        const char *end,
-        const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    state->handler = prolog1;
-    return XML_ROLE_NONE;
-  case XML_TOK_XML_DECL:
-    state->handler = prolog1;
-    return XML_ROLE_XML_DECL;
-  case XML_TOK_PI:
-    state->handler = prolog1;
-    return XML_ROLE_PI;
-  case XML_TOK_COMMENT:
-    state->handler = prolog1;
-    return XML_ROLE_COMMENT;
-  case XML_TOK_BOM:
-    return XML_ROLE_NONE;
-  case XML_TOK_DECL_OPEN:
-    if (!XmlNameMatchesAscii(enc,
-                             ptr + 2 * MIN_BYTES_PER_CHAR(enc),
-                             end,
-                             KW_DOCTYPE))
-      break;
-    state->handler = doctype0;
-    return XML_ROLE_DOCTYPE_NONE;
-  case XML_TOK_INSTANCE_START:
-    state->handler = error;
-    return XML_ROLE_INSTANCE_START;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-prolog1(PROLOG_STATE *state,
-        int tok,
-        const char *ptr,
-        const char *end,
-        const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_NONE;
-  case XML_TOK_PI:
-    return XML_ROLE_PI;
-  case XML_TOK_COMMENT:
-    return XML_ROLE_COMMENT;
-  case XML_TOK_BOM:
-    /* This case can never arise.  To reach this role function, the
-     * parse must have passed through prolog0 and therefore have had
-     * some form of input, even if only a space.  At that point, a
-     * byte order mark is no longer a valid character (though
-     * technically it should be interpreted as a non-breaking space),
-     * so will be rejected by the tokenizing stages.
-     */
-    return XML_ROLE_NONE; /* LCOV_EXCL_LINE */
-  case XML_TOK_DECL_OPEN:
-    if (!XmlNameMatchesAscii(enc,
-                             ptr + 2 * MIN_BYTES_PER_CHAR(enc),
-                             end,
-                             KW_DOCTYPE))
-      break;
-    state->handler = doctype0;
-    return XML_ROLE_DOCTYPE_NONE;
-  case XML_TOK_INSTANCE_START:
-    state->handler = error;
-    return XML_ROLE_INSTANCE_START;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-prolog2(PROLOG_STATE *state,
-        int tok,
-        const char *UNUSED_P(ptr),
-        const char *UNUSED_P(end),
-        const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_NONE;
-  case XML_TOK_PI:
-    return XML_ROLE_PI;
-  case XML_TOK_COMMENT:
-    return XML_ROLE_COMMENT;
-  case XML_TOK_INSTANCE_START:
-    state->handler = error;
-    return XML_ROLE_INSTANCE_START;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-doctype0(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_DOCTYPE_NONE;
-  case XML_TOK_NAME:
-  case XML_TOK_PREFIXED_NAME:
-    state->handler = doctype1;
-    return XML_ROLE_DOCTYPE_NAME;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-doctype1(PROLOG_STATE *state,
-         int tok,
-         const char *ptr,
-         const char *end,
-         const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_DOCTYPE_NONE;
-  case XML_TOK_OPEN_BRACKET:
-    state->handler = internalSubset;
-    return XML_ROLE_DOCTYPE_INTERNAL_SUBSET;
-  case XML_TOK_DECL_CLOSE:
-    state->handler = prolog2;
-    return XML_ROLE_DOCTYPE_CLOSE;
-  case XML_TOK_NAME:
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_SYSTEM)) {
-      state->handler = doctype3;
-      return XML_ROLE_DOCTYPE_NONE;
-    }
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_PUBLIC)) {
-      state->handler = doctype2;
-      return XML_ROLE_DOCTYPE_NONE;
-    }
-    break;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-doctype2(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_DOCTYPE_NONE;
-  case XML_TOK_LITERAL:
-    state->handler = doctype3;
-    return XML_ROLE_DOCTYPE_PUBLIC_ID;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-doctype3(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_DOCTYPE_NONE;
-  case XML_TOK_LITERAL:
-    state->handler = doctype4;
-    return XML_ROLE_DOCTYPE_SYSTEM_ID;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-doctype4(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_DOCTYPE_NONE;
-  case XML_TOK_OPEN_BRACKET:
-    state->handler = internalSubset;
-    return XML_ROLE_DOCTYPE_INTERNAL_SUBSET;
-  case XML_TOK_DECL_CLOSE:
-    state->handler = prolog2;
-    return XML_ROLE_DOCTYPE_CLOSE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-doctype5(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_DOCTYPE_NONE;
-  case XML_TOK_DECL_CLOSE:
-    state->handler = prolog2;
-    return XML_ROLE_DOCTYPE_CLOSE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-internalSubset(PROLOG_STATE *state,
-               int tok,
-               const char *ptr,
-               const char *end,
-               const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_NONE;
-  case XML_TOK_DECL_OPEN:
-    if (XmlNameMatchesAscii(enc,
-                            ptr + 2 * MIN_BYTES_PER_CHAR(enc),
-                            end,
-                            KW_ENTITY)) {
-      state->handler = entity0;
-      return XML_ROLE_ENTITY_NONE;
-    }
-    if (XmlNameMatchesAscii(enc,
-                            ptr + 2 * MIN_BYTES_PER_CHAR(enc),
-                            end,
-                            KW_ATTLIST)) {
-      state->handler = attlist0;
-      return XML_ROLE_ATTLIST_NONE;
-    }
-    if (XmlNameMatchesAscii(enc,
-                            ptr + 2 * MIN_BYTES_PER_CHAR(enc),
-                            end,
-                            KW_ELEMENT)) {
-      state->handler = element0;
-      return XML_ROLE_ELEMENT_NONE;
-    }
-    if (XmlNameMatchesAscii(enc,
-                            ptr + 2 * MIN_BYTES_PER_CHAR(enc),
-                            end,
-                            KW_NOTATION)) {
-      state->handler = notation0;
-      return XML_ROLE_NOTATION_NONE;
-    }
-    break;
-  case XML_TOK_PI:
-    return XML_ROLE_PI;
-  case XML_TOK_COMMENT:
-    return XML_ROLE_COMMENT;
-  case XML_TOK_PARAM_ENTITY_REF:
-    return XML_ROLE_PARAM_ENTITY_REF;
-  case XML_TOK_CLOSE_BRACKET:
-    state->handler = doctype5;
-    return XML_ROLE_DOCTYPE_NONE;
-  case XML_TOK_NONE:
-    return XML_ROLE_NONE;
-  }
-  return common(state, tok);
-}
-
-#ifdef XML_DTD
-
-static int PTRCALL
-externalSubset0(PROLOG_STATE *state,
-                int tok,
-                const char *ptr,
-                const char *end,
-                const ENCODING *enc)
-{
-  state->handler = externalSubset1;
-  if (tok == XML_TOK_XML_DECL)
-    return XML_ROLE_TEXT_DECL;
-  return externalSubset1(state, tok, ptr, end, enc);
-}
-
-static int PTRCALL
-externalSubset1(PROLOG_STATE *state,
-                int tok,
-                const char *ptr,
-                const char *end,
-                const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_COND_SECT_OPEN:
-    state->handler = condSect0;
-    return XML_ROLE_NONE;
-  case XML_TOK_COND_SECT_CLOSE:
-    if (state->includeLevel == 0)
-      break;
-    state->includeLevel -= 1;
-    return XML_ROLE_NONE;
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_NONE;
-  case XML_TOK_CLOSE_BRACKET:
-    break;
-  case XML_TOK_NONE:
-    if (state->includeLevel)
-      break;
-    return XML_ROLE_NONE;
-  default:
-    return internalSubset(state, tok, ptr, end, enc);
-  }
-  return common(state, tok);
-}
-
-#endif /* XML_DTD */
-
-static int PTRCALL
-entity0(PROLOG_STATE *state,
-        int tok,
-        const char *UNUSED_P(ptr),
-        const char *UNUSED_P(end),
-        const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ENTITY_NONE;
-  case XML_TOK_PERCENT:
-    state->handler = entity1;
-    return XML_ROLE_ENTITY_NONE;
-  case XML_TOK_NAME:
-    state->handler = entity2;
-    return XML_ROLE_GENERAL_ENTITY_NAME;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-entity1(PROLOG_STATE *state,
-        int tok,
-        const char *UNUSED_P(ptr),
-        const char *UNUSED_P(end),
-        const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ENTITY_NONE;
-  case XML_TOK_NAME:
-    state->handler = entity7;
-    return XML_ROLE_PARAM_ENTITY_NAME;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-entity2(PROLOG_STATE *state,
-        int tok,
-        const char *ptr,
-        const char *end,
-        const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ENTITY_NONE;
-  case XML_TOK_NAME:
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_SYSTEM)) {
-      state->handler = entity4;
-      return XML_ROLE_ENTITY_NONE;
-    }
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_PUBLIC)) {
-      state->handler = entity3;
-      return XML_ROLE_ENTITY_NONE;
-    }
-    break;
-  case XML_TOK_LITERAL:
-    state->handler = declClose;
-    state->role_none = XML_ROLE_ENTITY_NONE;
-    return XML_ROLE_ENTITY_VALUE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-entity3(PROLOG_STATE *state,
-        int tok,
-        const char *UNUSED_P(ptr),
-        const char *UNUSED_P(end),
-        const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ENTITY_NONE;
-  case XML_TOK_LITERAL:
-    state->handler = entity4;
-    return XML_ROLE_ENTITY_PUBLIC_ID;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-entity4(PROLOG_STATE *state,
-        int tok,
-        const char *UNUSED_P(ptr),
-        const char *UNUSED_P(end),
-        const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ENTITY_NONE;
-  case XML_TOK_LITERAL:
-    state->handler = entity5;
-    return XML_ROLE_ENTITY_SYSTEM_ID;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-entity5(PROLOG_STATE *state,
-        int tok,
-        const char *ptr,
-        const char *end,
-        const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ENTITY_NONE;
-  case XML_TOK_DECL_CLOSE:
-    setTopLevel(state);
-    return XML_ROLE_ENTITY_COMPLETE;
-  case XML_TOK_NAME:
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_NDATA)) {
-      state->handler = entity6;
-      return XML_ROLE_ENTITY_NONE;
-    }
-    break;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-entity6(PROLOG_STATE *state,
-        int tok,
-        const char *UNUSED_P(ptr),
-        const char *UNUSED_P(end),
-        const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ENTITY_NONE;
-  case XML_TOK_NAME:
-    state->handler = declClose;
-    state->role_none = XML_ROLE_ENTITY_NONE;
-    return XML_ROLE_ENTITY_NOTATION_NAME;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-entity7(PROLOG_STATE *state,
-        int tok,
-        const char *ptr,
-        const char *end,
-        const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ENTITY_NONE;
-  case XML_TOK_NAME:
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_SYSTEM)) {
-      state->handler = entity9;
-      return XML_ROLE_ENTITY_NONE;
-    }
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_PUBLIC)) {
-      state->handler = entity8;
-      return XML_ROLE_ENTITY_NONE;
-    }
-    break;
-  case XML_TOK_LITERAL:
-    state->handler = declClose;
-    state->role_none = XML_ROLE_ENTITY_NONE;
-    return XML_ROLE_ENTITY_VALUE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-entity8(PROLOG_STATE *state,
-        int tok,
-        const char *UNUSED_P(ptr),
-        const char *UNUSED_P(end),
-        const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ENTITY_NONE;
-  case XML_TOK_LITERAL:
-    state->handler = entity9;
-    return XML_ROLE_ENTITY_PUBLIC_ID;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-entity9(PROLOG_STATE *state,
-        int tok,
-        const char *UNUSED_P(ptr),
-        const char *UNUSED_P(end),
-        const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ENTITY_NONE;
-  case XML_TOK_LITERAL:
-    state->handler = entity10;
-    return XML_ROLE_ENTITY_SYSTEM_ID;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-entity10(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ENTITY_NONE;
-  case XML_TOK_DECL_CLOSE:
-    setTopLevel(state);
-    return XML_ROLE_ENTITY_COMPLETE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-notation0(PROLOG_STATE *state,
-          int tok,
-          const char *UNUSED_P(ptr),
-          const char *UNUSED_P(end),
-          const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_NOTATION_NONE;
-  case XML_TOK_NAME:
-    state->handler = notation1;
-    return XML_ROLE_NOTATION_NAME;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-notation1(PROLOG_STATE *state,
-          int tok,
-          const char *ptr,
-          const char *end,
-          const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_NOTATION_NONE;
-  case XML_TOK_NAME:
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_SYSTEM)) {
-      state->handler = notation3;
-      return XML_ROLE_NOTATION_NONE;
-    }
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_PUBLIC)) {
-      state->handler = notation2;
-      return XML_ROLE_NOTATION_NONE;
-    }
-    break;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-notation2(PROLOG_STATE *state,
-          int tok,
-          const char *UNUSED_P(ptr),
-          const char *UNUSED_P(end),
-          const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_NOTATION_NONE;
-  case XML_TOK_LITERAL:
-    state->handler = notation4;
-    return XML_ROLE_NOTATION_PUBLIC_ID;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-notation3(PROLOG_STATE *state,
-          int tok,
-          const char *UNUSED_P(ptr),
-          const char *UNUSED_P(end),
-          const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_NOTATION_NONE;
-  case XML_TOK_LITERAL:
-    state->handler = declClose;
-    state->role_none = XML_ROLE_NOTATION_NONE;
-    return XML_ROLE_NOTATION_SYSTEM_ID;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-notation4(PROLOG_STATE *state,
-          int tok,
-          const char *UNUSED_P(ptr),
-          const char *UNUSED_P(end),
-          const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_NOTATION_NONE;
-  case XML_TOK_LITERAL:
-    state->handler = declClose;
-    state->role_none = XML_ROLE_NOTATION_NONE;
-    return XML_ROLE_NOTATION_SYSTEM_ID;
-  case XML_TOK_DECL_CLOSE:
-    setTopLevel(state);
-    return XML_ROLE_NOTATION_NO_SYSTEM_ID;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-attlist0(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ATTLIST_NONE;
-  case XML_TOK_NAME:
-  case XML_TOK_PREFIXED_NAME:
-    state->handler = attlist1;
-    return XML_ROLE_ATTLIST_ELEMENT_NAME;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-attlist1(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ATTLIST_NONE;
-  case XML_TOK_DECL_CLOSE:
-    setTopLevel(state);
-    return XML_ROLE_ATTLIST_NONE;
-  case XML_TOK_NAME:
-  case XML_TOK_PREFIXED_NAME:
-    state->handler = attlist2;
-    return XML_ROLE_ATTRIBUTE_NAME;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-attlist2(PROLOG_STATE *state,
-         int tok,
-         const char *ptr,
-         const char *end,
-         const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ATTLIST_NONE;
-  case XML_TOK_NAME:
-    {
-      static const char * const types[] = {
-        KW_CDATA,
-        KW_ID,
-        KW_IDREF,
-        KW_IDREFS,
-        KW_ENTITY,
-        KW_ENTITIES,
-        KW_NMTOKEN,
-        KW_NMTOKENS,
-      };
-      int i;
-      for (i = 0; i < (int)(sizeof(types)/sizeof(types[0])); i++)
-        if (XmlNameMatchesAscii(enc, ptr, end, types[i])) {
-          state->handler = attlist8;
-          return XML_ROLE_ATTRIBUTE_TYPE_CDATA + i;
-        }
-    }
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_NOTATION)) {
-      state->handler = attlist5;
-      return XML_ROLE_ATTLIST_NONE;
-    }
-    break;
-  case XML_TOK_OPEN_PAREN:
-    state->handler = attlist3;
-    return XML_ROLE_ATTLIST_NONE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-attlist3(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ATTLIST_NONE;
-  case XML_TOK_NMTOKEN:
-  case XML_TOK_NAME:
-  case XML_TOK_PREFIXED_NAME:
-    state->handler = attlist4;
-    return XML_ROLE_ATTRIBUTE_ENUM_VALUE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-attlist4(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ATTLIST_NONE;
-  case XML_TOK_CLOSE_PAREN:
-    state->handler = attlist8;
-    return XML_ROLE_ATTLIST_NONE;
-  case XML_TOK_OR:
-    state->handler = attlist3;
-    return XML_ROLE_ATTLIST_NONE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-attlist5(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ATTLIST_NONE;
-  case XML_TOK_OPEN_PAREN:
-    state->handler = attlist6;
-    return XML_ROLE_ATTLIST_NONE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-attlist6(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ATTLIST_NONE;
-  case XML_TOK_NAME:
-    state->handler = attlist7;
-    return XML_ROLE_ATTRIBUTE_NOTATION_VALUE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-attlist7(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ATTLIST_NONE;
-  case XML_TOK_CLOSE_PAREN:
-    state->handler = attlist8;
-    return XML_ROLE_ATTLIST_NONE;
-  case XML_TOK_OR:
-    state->handler = attlist6;
-    return XML_ROLE_ATTLIST_NONE;
-  }
-  return common(state, tok);
-}
-
-/* default value */
-static int PTRCALL
-attlist8(PROLOG_STATE *state,
-         int tok,
-         const char *ptr,
-         const char *end,
-         const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ATTLIST_NONE;
-  case XML_TOK_POUND_NAME:
-    if (XmlNameMatchesAscii(enc,
-                            ptr + MIN_BYTES_PER_CHAR(enc),
-                            end,
-                            KW_IMPLIED)) {
-      state->handler = attlist1;
-      return XML_ROLE_IMPLIED_ATTRIBUTE_VALUE;
-    }
-    if (XmlNameMatchesAscii(enc,
-                            ptr + MIN_BYTES_PER_CHAR(enc),
-                            end,
-                            KW_REQUIRED)) {
-      state->handler = attlist1;
-      return XML_ROLE_REQUIRED_ATTRIBUTE_VALUE;
-    }
-    if (XmlNameMatchesAscii(enc,
-                            ptr + MIN_BYTES_PER_CHAR(enc),
-                            end,
-                            KW_FIXED)) {
-      state->handler = attlist9;
-      return XML_ROLE_ATTLIST_NONE;
-    }
-    break;
-  case XML_TOK_LITERAL:
-    state->handler = attlist1;
-    return XML_ROLE_DEFAULT_ATTRIBUTE_VALUE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-attlist9(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ATTLIST_NONE;
-  case XML_TOK_LITERAL:
-    state->handler = attlist1;
-    return XML_ROLE_FIXED_ATTRIBUTE_VALUE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-element0(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ELEMENT_NONE;
-  case XML_TOK_NAME:
-  case XML_TOK_PREFIXED_NAME:
-    state->handler = element1;
-    return XML_ROLE_ELEMENT_NAME;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-element1(PROLOG_STATE *state,
-         int tok,
-         const char *ptr,
-         const char *end,
-         const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ELEMENT_NONE;
-  case XML_TOK_NAME:
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_EMPTY)) {
-      state->handler = declClose;
-      state->role_none = XML_ROLE_ELEMENT_NONE;
-      return XML_ROLE_CONTENT_EMPTY;
-    }
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_ANY)) {
-      state->handler = declClose;
-      state->role_none = XML_ROLE_ELEMENT_NONE;
-      return XML_ROLE_CONTENT_ANY;
-    }
-    break;
-  case XML_TOK_OPEN_PAREN:
-    state->handler = element2;
-    state->level = 1;
-    return XML_ROLE_GROUP_OPEN;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-element2(PROLOG_STATE *state,
-         int tok,
-         const char *ptr,
-         const char *end,
-         const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ELEMENT_NONE;
-  case XML_TOK_POUND_NAME:
-    if (XmlNameMatchesAscii(enc,
-                            ptr + MIN_BYTES_PER_CHAR(enc),
-                            end,
-                            KW_PCDATA)) {
-      state->handler = element3;
-      return XML_ROLE_CONTENT_PCDATA;
-    }
-    break;
-  case XML_TOK_OPEN_PAREN:
-    state->level = 2;
-    state->handler = element6;
-    return XML_ROLE_GROUP_OPEN;
-  case XML_TOK_NAME:
-  case XML_TOK_PREFIXED_NAME:
-    state->handler = element7;
-    return XML_ROLE_CONTENT_ELEMENT;
-  case XML_TOK_NAME_QUESTION:
-    state->handler = element7;
-    return XML_ROLE_CONTENT_ELEMENT_OPT;
-  case XML_TOK_NAME_ASTERISK:
-    state->handler = element7;
-    return XML_ROLE_CONTENT_ELEMENT_REP;
-  case XML_TOK_NAME_PLUS:
-    state->handler = element7;
-    return XML_ROLE_CONTENT_ELEMENT_PLUS;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-element3(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ELEMENT_NONE;
-  case XML_TOK_CLOSE_PAREN:
-    state->handler = declClose;
-    state->role_none = XML_ROLE_ELEMENT_NONE;
-    return XML_ROLE_GROUP_CLOSE;
-  case XML_TOK_CLOSE_PAREN_ASTERISK:
-    state->handler = declClose;
-    state->role_none = XML_ROLE_ELEMENT_NONE;
-    return XML_ROLE_GROUP_CLOSE_REP;
-  case XML_TOK_OR:
-    state->handler = element4;
-    return XML_ROLE_ELEMENT_NONE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-element4(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ELEMENT_NONE;
-  case XML_TOK_NAME:
-  case XML_TOK_PREFIXED_NAME:
-    state->handler = element5;
-    return XML_ROLE_CONTENT_ELEMENT;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-element5(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ELEMENT_NONE;
-  case XML_TOK_CLOSE_PAREN_ASTERISK:
-    state->handler = declClose;
-    state->role_none = XML_ROLE_ELEMENT_NONE;
-    return XML_ROLE_GROUP_CLOSE_REP;
-  case XML_TOK_OR:
-    state->handler = element4;
-    return XML_ROLE_ELEMENT_NONE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-element6(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ELEMENT_NONE;
-  case XML_TOK_OPEN_PAREN:
-    state->level += 1;
-    return XML_ROLE_GROUP_OPEN;
-  case XML_TOK_NAME:
-  case XML_TOK_PREFIXED_NAME:
-    state->handler = element7;
-    return XML_ROLE_CONTENT_ELEMENT;
-  case XML_TOK_NAME_QUESTION:
-    state->handler = element7;
-    return XML_ROLE_CONTENT_ELEMENT_OPT;
-  case XML_TOK_NAME_ASTERISK:
-    state->handler = element7;
-    return XML_ROLE_CONTENT_ELEMENT_REP;
-  case XML_TOK_NAME_PLUS:
-    state->handler = element7;
-    return XML_ROLE_CONTENT_ELEMENT_PLUS;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-element7(PROLOG_STATE *state,
-         int tok,
-         const char *UNUSED_P(ptr),
-         const char *UNUSED_P(end),
-         const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_ELEMENT_NONE;
-  case XML_TOK_CLOSE_PAREN:
-    state->level -= 1;
-    if (state->level == 0) {
-      state->handler = declClose;
-      state->role_none = XML_ROLE_ELEMENT_NONE;
-    }
-    return XML_ROLE_GROUP_CLOSE;
-  case XML_TOK_CLOSE_PAREN_ASTERISK:
-    state->level -= 1;
-    if (state->level == 0) {
-      state->handler = declClose;
-      state->role_none = XML_ROLE_ELEMENT_NONE;
-    }
-    return XML_ROLE_GROUP_CLOSE_REP;
-  case XML_TOK_CLOSE_PAREN_QUESTION:
-    state->level -= 1;
-    if (state->level == 0) {
-      state->handler = declClose;
-      state->role_none = XML_ROLE_ELEMENT_NONE;
-    }
-    return XML_ROLE_GROUP_CLOSE_OPT;
-  case XML_TOK_CLOSE_PAREN_PLUS:
-    state->level -= 1;
-    if (state->level == 0) {
-      state->handler = declClose;
-      state->role_none = XML_ROLE_ELEMENT_NONE;
-    }
-    return XML_ROLE_GROUP_CLOSE_PLUS;
-  case XML_TOK_COMMA:
-    state->handler = element6;
-    return XML_ROLE_GROUP_SEQUENCE;
-  case XML_TOK_OR:
-    state->handler = element6;
-    return XML_ROLE_GROUP_CHOICE;
-  }
-  return common(state, tok);
-}
-
-#ifdef XML_DTD
-
-static int PTRCALL
-condSect0(PROLOG_STATE *state,
-          int tok,
-          const char *ptr,
-          const char *end,
-          const ENCODING *enc)
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_NONE;
-  case XML_TOK_NAME:
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_INCLUDE)) {
-      state->handler = condSect1;
-      return XML_ROLE_NONE;
-    }
-    if (XmlNameMatchesAscii(enc, ptr, end, KW_IGNORE)) {
-      state->handler = condSect2;
-      return XML_ROLE_NONE;
-    }
-    break;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-condSect1(PROLOG_STATE *state,
-          int tok,
-          const char *UNUSED_P(ptr),
-          const char *UNUSED_P(end),
-          const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_NONE;
-  case XML_TOK_OPEN_BRACKET:
-    state->handler = externalSubset1;
-    state->includeLevel += 1;
-    return XML_ROLE_NONE;
-  }
-  return common(state, tok);
-}
-
-static int PTRCALL
-condSect2(PROLOG_STATE *state,
-          int tok,
-          const char *UNUSED_P(ptr),
-          const char *UNUSED_P(end),
-          const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return XML_ROLE_NONE;
-  case XML_TOK_OPEN_BRACKET:
-    state->handler = externalSubset1;
-    return XML_ROLE_IGNORE_SECT;
-  }
-  return common(state, tok);
-}
-
-#endif /* XML_DTD */
-
-static int PTRCALL
-declClose(PROLOG_STATE *state,
-          int tok,
-          const char *UNUSED_P(ptr),
-          const char *UNUSED_P(end),
-          const ENCODING *UNUSED_P(enc))
-{
-  switch (tok) {
-  case XML_TOK_PROLOG_S:
-    return state->role_none;
-  case XML_TOK_DECL_CLOSE:
-    setTopLevel(state);
-    return state->role_none;
-  }
-  return common(state, tok);
-}
-
-/* This function will only be invoked if the internal logic of the
- * parser has broken down.  It is used in two cases:
- *
- * 1: When the XML prolog has been finished.  At this point the
- * processor (the parser level above these role handlers) should
- * switch from prologProcessor to contentProcessor and reinitialise
- * the handler function.
- *
- * 2: When an error has been detected (via common() below).  At this
- * point again the processor should be switched to errorProcessor,
- * which will never call a handler.
- *
- * The result of this is that error() can only be called if the
- * processor switch failed to happen, which is an internal error and
- * therefore we shouldn't be able to provoke it simply by using the
- * library.  It is a necessary backstop, however, so we merely exclude
- * it from the coverage statistics.
- *
- * LCOV_EXCL_START
- */
-static int PTRCALL
-error(PROLOG_STATE *UNUSED_P(state),
-      int UNUSED_P(tok),
-      const char *UNUSED_P(ptr),
-      const char *UNUSED_P(end),
-      const ENCODING *UNUSED_P(enc))
-{
-  return XML_ROLE_NONE;
-}
-/* LCOV_EXCL_STOP */
-
-static int FASTCALL
-common(PROLOG_STATE *state, int tok)
-{
-#ifdef XML_DTD
-  if (!state->documentEntity && tok == XML_TOK_PARAM_ENTITY_REF)
-    return XML_ROLE_INNER_PARAM_ENTITY_REF;
-#endif
-  state->handler = error;
-  return XML_ROLE_ERROR;
-}
-
-void
-XmlPrologStateInit(PROLOG_STATE *state)
-{
-  state->handler = prolog0;
-#ifdef XML_DTD
-  state->documentEntity = 1;
-  state->includeLevel = 0;
-  state->inEntityValue = 0;
-#endif /* XML_DTD */
-}
-
-#ifdef XML_DTD
-
-void
-XmlPrologStateInitExternalEntity(PROLOG_STATE *state)
-{
-  state->handler = externalSubset0;
-  state->documentEntity = 0;
-  state->includeLevel = 0;
-}
-
-#endif /* XML_DTD */
diff --git a/third_party/expat/files/lib/xmlrole.h b/third_party/expat/files/lib/xmlrole.h
deleted file mode 100644
index 4dd9f06f9767..000000000000
--- a/third_party/expat/files/lib/xmlrole.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-*/
-
-#ifndef XmlRole_INCLUDED
-#define XmlRole_INCLUDED 1
-
-#ifdef __VMS
-/*      0        1         2         3      0        1         2         3
-        1234567890123456789012345678901     1234567890123456789012345678901 */
-#define XmlPrologStateInitExternalEntity    XmlPrologStateInitExternalEnt
-#endif
-
-#include "xmltok.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-enum {
-  XML_ROLE_ERROR = -1,
-  XML_ROLE_NONE = 0,
-  XML_ROLE_XML_DECL,
-  XML_ROLE_INSTANCE_START,
-  XML_ROLE_DOCTYPE_NONE,
-  XML_ROLE_DOCTYPE_NAME,
-  XML_ROLE_DOCTYPE_SYSTEM_ID,
-  XML_ROLE_DOCTYPE_PUBLIC_ID,
-  XML_ROLE_DOCTYPE_INTERNAL_SUBSET,
-  XML_ROLE_DOCTYPE_CLOSE,
-  XML_ROLE_GENERAL_ENTITY_NAME,
-  XML_ROLE_PARAM_ENTITY_NAME,
-  XML_ROLE_ENTITY_NONE,
-  XML_ROLE_ENTITY_VALUE,
-  XML_ROLE_ENTITY_SYSTEM_ID,
-  XML_ROLE_ENTITY_PUBLIC_ID,
-  XML_ROLE_ENTITY_COMPLETE,
-  XML_ROLE_ENTITY_NOTATION_NAME,
-  XML_ROLE_NOTATION_NONE,
-  XML_ROLE_NOTATION_NAME,
-  XML_ROLE_NOTATION_SYSTEM_ID,
-  XML_ROLE_NOTATION_NO_SYSTEM_ID,
-  XML_ROLE_NOTATION_PUBLIC_ID,
-  XML_ROLE_ATTRIBUTE_NAME,
-  XML_ROLE_ATTRIBUTE_TYPE_CDATA,
-  XML_ROLE_ATTRIBUTE_TYPE_ID,
-  XML_ROLE_ATTRIBUTE_TYPE_IDREF,
-  XML_ROLE_ATTRIBUTE_TYPE_IDREFS,
-  XML_ROLE_ATTRIBUTE_TYPE_ENTITY,
-  XML_ROLE_ATTRIBUTE_TYPE_ENTITIES,
-  XML_ROLE_ATTRIBUTE_TYPE_NMTOKEN,
-  XML_ROLE_ATTRIBUTE_TYPE_NMTOKENS,
-  XML_ROLE_ATTRIBUTE_ENUM_VALUE,
-  XML_ROLE_ATTRIBUTE_NOTATION_VALUE,
-  XML_ROLE_ATTLIST_NONE,
-  XML_ROLE_ATTLIST_ELEMENT_NAME,
-  XML_ROLE_IMPLIED_ATTRIBUTE_VALUE,
-  XML_ROLE_REQUIRED_ATTRIBUTE_VALUE,
-  XML_ROLE_DEFAULT_ATTRIBUTE_VALUE,
-  XML_ROLE_FIXED_ATTRIBUTE_VALUE,
-  XML_ROLE_ELEMENT_NONE,
-  XML_ROLE_ELEMENT_NAME,
-  XML_ROLE_CONTENT_ANY,
-  XML_ROLE_CONTENT_EMPTY,
-  XML_ROLE_CONTENT_PCDATA,
-  XML_ROLE_GROUP_OPEN,
-  XML_ROLE_GROUP_CLOSE,
-  XML_ROLE_GROUP_CLOSE_REP,
-  XML_ROLE_GROUP_CLOSE_OPT,
-  XML_ROLE_GROUP_CLOSE_PLUS,
-  XML_ROLE_GROUP_CHOICE,
-  XML_ROLE_GROUP_SEQUENCE,
-  XML_ROLE_CONTENT_ELEMENT,
-  XML_ROLE_CONTENT_ELEMENT_REP,
-  XML_ROLE_CONTENT_ELEMENT_OPT,
-  XML_ROLE_CONTENT_ELEMENT_PLUS,
-  XML_ROLE_PI,
-  XML_ROLE_COMMENT,
-#ifdef XML_DTD
-  XML_ROLE_TEXT_DECL,
-  XML_ROLE_IGNORE_SECT,
-  XML_ROLE_INNER_PARAM_ENTITY_REF,
-#endif /* XML_DTD */
-  XML_ROLE_PARAM_ENTITY_REF
-};
-
-typedef struct prolog_state {
-  int (PTRCALL *handler) (struct prolog_state *state,
-                          int tok,
-                          const char *ptr,
-                          const char *end,
-                          const ENCODING *enc);
-  unsigned level;
-  int role_none;
-#ifdef XML_DTD
-  unsigned includeLevel;
-  int documentEntity;
-  int inEntityValue;
-#endif /* XML_DTD */
-} PROLOG_STATE;
-
-void XmlPrologStateInit(PROLOG_STATE *);
-#ifdef XML_DTD
-void XmlPrologStateInitExternalEntity(PROLOG_STATE *);
-#endif /* XML_DTD */
-
-#define XmlTokenRole(state, tok, ptr, end, enc) \
- (((state)->handler)(state, tok, ptr, end, enc))
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* not XmlRole_INCLUDED */
diff --git a/third_party/expat/files/lib/xmltok.c b/third_party/expat/files/lib/xmltok.c
deleted file mode 100644
index db4a5c8ca3ef..000000000000
--- a/third_party/expat/files/lib/xmltok.c
+++ /dev/null
@@ -1,1754 +0,0 @@
-/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-*/
-
-#include <stddef.h>
-
-#ifdef _WIN32
-#include "winconfig.h"
-#else
-#ifdef HAVE_EXPAT_CONFIG_H
-#include <expat_config.h>
-#endif
-#endif /* ndef _WIN32 */
-
-#include "expat_external.h"
-#include "internal.h"
-#include "xmltok.h"
-#include "nametab.h"
-
-#ifdef XML_DTD
-#define IGNORE_SECTION_TOK_VTABLE , PREFIX(ignoreSectionTok)
-#else
-#define IGNORE_SECTION_TOK_VTABLE /* as nothing */
-#endif
-
-#define VTABLE1 \
-  { PREFIX(prologTok), PREFIX(contentTok), \
-    PREFIX(cdataSectionTok) IGNORE_SECTION_TOK_VTABLE }, \
-  { PREFIX(attributeValueTok), PREFIX(entityValueTok) }, \
-  PREFIX(sameName), \
-  PREFIX(nameMatchesAscii), \
-  PREFIX(nameLength), \
-  PREFIX(skipS), \
-  PREFIX(getAtts), \
-  PREFIX(charRefNumber), \
-  PREFIX(predefinedEntityName), \
-  PREFIX(updatePosition), \
-  PREFIX(isPublicId)
-
-#define VTABLE VTABLE1, PREFIX(toUtf8), PREFIX(toUtf16)
-
-#define UCS2_GET_NAMING(pages, hi, lo) \
-   (namingBitmap[(pages[hi] << 3) + ((lo) >> 5)] & (1u << ((lo) & 0x1F)))
-
-/* A 2 byte UTF-8 representation splits the characters 11 bits between
-   the bottom 5 and 6 bits of the bytes.  We need 8 bits to index into
-   pages, 3 bits to add to that index and 5 bits to generate the mask.
-*/
-#define UTF8_GET_NAMING2(pages, byte) \
-    (namingBitmap[((pages)[(((byte)[0]) >> 2) & 7] << 3) \
-                      + ((((byte)[0]) & 3) << 1) \
-                      + ((((byte)[1]) >> 5) & 1)] \
-         & (1u << (((byte)[1]) & 0x1F)))
-
-/* A 3 byte UTF-8 representation splits the characters 16 bits between
-   the bottom 4, 6 and 6 bits of the bytes.  We need 8 bits to index
-   into pages, 3 bits to add to that index and 5 bits to generate the
-   mask.
-*/
-#define UTF8_GET_NAMING3(pages, byte) \
-  (namingBitmap[((pages)[((((byte)[0]) & 0xF) << 4) \
-                             + ((((byte)[1]) >> 2) & 0xF)] \
-                       << 3) \
-                      + ((((byte)[1]) & 3) << 1) \
-                      + ((((byte)[2]) >> 5) & 1)] \
-         & (1u << (((byte)[2]) & 0x1F)))
-
-#define UTF8_GET_NAMING(pages, p, n) \
-  ((n) == 2 \
-  ? UTF8_GET_NAMING2(pages, (const unsigned char *)(p)) \
-  : ((n) == 3 \
-     ? UTF8_GET_NAMING3(pages, (const unsigned char *)(p)) \
-     : 0))
-
-/* Detection of invalid UTF-8 sequences is based on Table 3.1B
-   of Unicode 3.2: http://www.unicode.org/unicode/reports/tr28/
-   with the additional restriction of not allowing the Unicode
-   code points 0xFFFF and 0xFFFE (sequences EF,BF,BF and EF,BF,BE).
-   Implementation details:
-     (A & 0x80) == 0     means A < 0x80
-   and
-     (A & 0xC0) == 0xC0  means A > 0xBF
-*/
-
-#define UTF8_INVALID2(p) \
-  ((*p) < 0xC2 || ((p)[1] & 0x80) == 0 || ((p)[1] & 0xC0) == 0xC0)
-
-#define UTF8_INVALID3(p) \
-  (((p)[2] & 0x80) == 0 \
-  || \
-  ((*p) == 0xEF && (p)[1] == 0xBF \
-    ? \
-    (p)[2] > 0xBD \
-    : \
-    ((p)[2] & 0xC0) == 0xC0) \
-  || \
-  ((*p) == 0xE0 \
-    ? \
-    (p)[1] < 0xA0 || ((p)[1] & 0xC0) == 0xC0 \
-    : \
-    ((p)[1] & 0x80) == 0 \
-    || \
-    ((*p) == 0xED ? (p)[1] > 0x9F : ((p)[1] & 0xC0) == 0xC0)))
-
-#define UTF8_INVALID4(p) \
-  (((p)[3] & 0x80) == 0 || ((p)[3] & 0xC0) == 0xC0 \
-  || \
-  ((p)[2] & 0x80) == 0 || ((p)[2] & 0xC0) == 0xC0 \
-  || \
-  ((*p) == 0xF0 \
-    ? \
-    (p)[1] < 0x90 || ((p)[1] & 0xC0) == 0xC0 \
-    : \
-    ((p)[1] & 0x80) == 0 \
-    || \
-    ((*p) == 0xF4 ? (p)[1] > 0x8F : ((p)[1] & 0xC0) == 0xC0)))
-
-static int PTRFASTCALL
-isNever(const ENCODING *UNUSED_P(enc), const char *UNUSED_P(p))
-{
-  return 0;
-}
-
-static int PTRFASTCALL
-utf8_isName2(const ENCODING *UNUSED_P(enc), const char *p)
-{
-  return UTF8_GET_NAMING2(namePages, (const unsigned char *)p);
-}
-
-static int PTRFASTCALL
-utf8_isName3(const ENCODING *UNUSED_P(enc), const char *p)
-{
-  return UTF8_GET_NAMING3(namePages, (const unsigned char *)p);
-}
-
-#define utf8_isName4 isNever
-
-static int PTRFASTCALL
-utf8_isNmstrt2(const ENCODING *UNUSED_P(enc), const char *p)
-{
-  return UTF8_GET_NAMING2(nmstrtPages, (const unsigned char *)p);
-}
-
-static int PTRFASTCALL
-utf8_isNmstrt3(const ENCODING *UNUSED_P(enc), const char *p)
-{
-  return UTF8_GET_NAMING3(nmstrtPages, (const unsigned char *)p);
-}
-
-#define utf8_isNmstrt4 isNever
-
-static int PTRFASTCALL
-utf8_isInvalid2(const ENCODING *UNUSED_P(enc), const char *p)
-{
-  return UTF8_INVALID2((const unsigned char *)p);
-}
-
-static int PTRFASTCALL
-utf8_isInvalid3(const ENCODING *UNUSED_P(enc), const char *p)
-{
-  return UTF8_INVALID3((const unsigned char *)p);
-}
-
-static int PTRFASTCALL
-utf8_isInvalid4(const ENCODING *UNUSED_P(enc), const char *p)
-{
-  return UTF8_INVALID4((const unsigned char *)p);
-}
-
-struct normal_encoding {
-  ENCODING enc;
-  unsigned char type[256];
-#ifdef XML_MIN_SIZE
-  int (PTRFASTCALL *byteType)(const ENCODING *, const char *);
-  int (PTRFASTCALL *isNameMin)(const ENCODING *, const char *);
-  int (PTRFASTCALL *isNmstrtMin)(const ENCODING *, const char *);
-  int (PTRFASTCALL *byteToAscii)(const ENCODING *, const char *);
-  int (PTRCALL *charMatches)(const ENCODING *, const char *, int);
-#endif /* XML_MIN_SIZE */
-  int (PTRFASTCALL *isName2)(const ENCODING *, const char *);
-  int (PTRFASTCALL *isName3)(const ENCODING *, const char *);
-  int (PTRFASTCALL *isName4)(const ENCODING *, const char *);
-  int (PTRFASTCALL *isNmstrt2)(const ENCODING *, const char *);
-  int (PTRFASTCALL *isNmstrt3)(const ENCODING *, const char *);
-  int (PTRFASTCALL *isNmstrt4)(const ENCODING *, const char *);
-  int (PTRFASTCALL *isInvalid2)(const ENCODING *, const char *);
-  int (PTRFASTCALL *isInvalid3)(const ENCODING *, const char *);
-  int (PTRFASTCALL *isInvalid4)(const ENCODING *, const char *);
-};
-
-#define AS_NORMAL_ENCODING(enc)   ((const struct normal_encoding *) (enc))
-
-#ifdef XML_MIN_SIZE
-
-#define STANDARD_VTABLE(E) \
- E ## byteType, \
- E ## isNameMin, \
- E ## isNmstrtMin, \
- E ## byteToAscii, \
- E ## charMatches,
-
-#else
-
-#define STANDARD_VTABLE(E) /* as nothing */
-
-#endif
-
-#define NORMAL_VTABLE(E) \
- E ## isName2, \
- E ## isName3, \
- E ## isName4, \
- E ## isNmstrt2, \
- E ## isNmstrt3, \
- E ## isNmstrt4, \
- E ## isInvalid2, \
- E ## isInvalid3, \
- E ## isInvalid4
-
-#define NULL_VTABLE \
- /* isName2 */ NULL, \
- /* isName3 */ NULL, \
- /* isName4 */ NULL, \
- /* isNmstrt2 */ NULL, \
- /* isNmstrt3 */ NULL, \
- /* isNmstrt4 */ NULL, \
- /* isInvalid2 */ NULL, \
- /* isInvalid3 */ NULL, \
- /* isInvalid4 */ NULL
-
-static int FASTCALL checkCharRefNumber(int);
-
-#include "xmltok_impl.h"
-#include "ascii.h"
-
-#ifdef XML_MIN_SIZE
-#define sb_isNameMin isNever
-#define sb_isNmstrtMin isNever
-#endif
-
-#ifdef XML_MIN_SIZE
-#define MINBPC(enc) ((enc)->minBytesPerChar)
-#else
-/* minimum bytes per character */
-#define MINBPC(enc) 1
-#endif
-
-#define SB_BYTE_TYPE(enc, p) \
-  (((struct normal_encoding *)(enc))->type[(unsigned char)*(p)])
-
-#ifdef XML_MIN_SIZE
-static int PTRFASTCALL
-sb_byteType(const ENCODING *enc, const char *p)
-{
-  return SB_BYTE_TYPE(enc, p);
-}
-#define BYTE_TYPE(enc, p) \
- (AS_NORMAL_ENCODING(enc)->byteType(enc, p))
-#else
-#define BYTE_TYPE(enc, p) SB_BYTE_TYPE(enc, p)
-#endif
-
-#ifdef XML_MIN_SIZE
-#define BYTE_TO_ASCII(enc, p) \
- (AS_NORMAL_ENCODING(enc)->byteToAscii(enc, p))
-static int PTRFASTCALL
-sb_byteToAscii(const ENCODING *enc, const char *p)
-{
-  return *p;
-}
-#else
-#define BYTE_TO_ASCII(enc, p) (*(p))
-#endif
-
-#define IS_NAME_CHAR(enc, p, n) \
- (AS_NORMAL_ENCODING(enc)->isName ## n(enc, p))
-#define IS_NMSTRT_CHAR(enc, p, n) \
- (AS_NORMAL_ENCODING(enc)->isNmstrt ## n(enc, p))
-#define IS_INVALID_CHAR(enc, p, n) \
- (AS_NORMAL_ENCODING(enc)->isInvalid ## n(enc, p))
-
-#ifdef XML_MIN_SIZE
-#define IS_NAME_CHAR_MINBPC(enc, p) \
- (AS_NORMAL_ENCODING(enc)->isNameMin(enc, p))
-#define IS_NMSTRT_CHAR_MINBPC(enc, p) \
- (AS_NORMAL_ENCODING(enc)->isNmstrtMin(enc, p))
-#else
-#define IS_NAME_CHAR_MINBPC(enc, p) (0)
-#define IS_NMSTRT_CHAR_MINBPC(enc, p) (0)
-#endif
-
-#ifdef XML_MIN_SIZE
-#define CHAR_MATCHES(enc, p, c) \
- (AS_NORMAL_ENCODING(enc)->charMatches(enc, p, c))
-static int PTRCALL
-sb_charMatches(const ENCODING *enc, const char *p, int c)
-{
-  return *p == c;
-}
-#else
-/* c is an ASCII character */
-#define CHAR_MATCHES(enc, p, c) (*(p) == c)
-#endif
-
-#define PREFIX(ident) normal_ ## ident
-#define XML_TOK_IMPL_C
-#include "xmltok_impl.c"
-#undef XML_TOK_IMPL_C
-
-#undef MINBPC
-#undef BYTE_TYPE
-#undef BYTE_TO_ASCII
-#undef CHAR_MATCHES
-#undef IS_NAME_CHAR
-#undef IS_NAME_CHAR_MINBPC
-#undef IS_NMSTRT_CHAR
-#undef IS_NMSTRT_CHAR_MINBPC
-#undef IS_INVALID_CHAR
-
-enum {  /* UTF8_cvalN is value of masked first byte of N byte sequence */
-  UTF8_cval1 = 0x00,
-  UTF8_cval2 = 0xc0,
-  UTF8_cval3 = 0xe0,
-  UTF8_cval4 = 0xf0
-};
-
-void
-align_limit_to_full_utf8_characters(const char * from, const char ** fromLimRef)
-{
-  const char * fromLim = *fromLimRef;
-  size_t walked = 0;
-  for (; fromLim > from; fromLim--, walked++) {
-    const unsigned char prev = (unsigned char)fromLim[-1];
-    if ((prev & 0xf8u) == 0xf0u) { /* 4-byte character, lead by 0b11110xxx byte */
-      if (walked + 1 >= 4) {
-        fromLim += 4 - 1;
-        break;
-      } else {
-        walked = 0;
-      }
-    } else if ((prev & 0xf0u) == 0xe0u) { /* 3-byte character, lead by 0b1110xxxx byte */
-      if (walked + 1 >= 3) {
-        fromLim += 3 - 1;
-        break;
-      } else {
-        walked = 0;
-      }
-    } else if ((prev & 0xe0u) == 0xc0u) { /* 2-byte character, lead by 0b110xxxxx byte */
-      if (walked + 1 >= 2) {
-        fromLim += 2 - 1;
-        break;
-      } else {
-        walked = 0;
-      }
-    } else if ((prev & 0x80u) == 0x00u) { /* 1-byte character, matching 0b0xxxxxxx */
-      break;
-    }
-  }
-  *fromLimRef = fromLim;
-}
-
-static enum XML_Convert_Result PTRCALL
-utf8_toUtf8(const ENCODING *UNUSED_P(enc),
-            const char **fromP, const char *fromLim,
-            char **toP, const char *toLim)
-{
-  char *to;
-  const char *from;
-  const char *fromLimInitial = fromLim;
-
-  /* Avoid copying partial characters. */
-  align_limit_to_full_utf8_characters(*fromP, &fromLim);
-
-  for (to = *toP, from = *fromP; (from < fromLim) && (to < toLim); from++, to++)
-    *to = *from;
-  *fromP = from;
-  *toP = to;
-
-  if (fromLim < fromLimInitial)
-    return XML_CONVERT_INPUT_INCOMPLETE;
-  else if ((to == toLim) && (from < fromLim))
-    return XML_CONVERT_OUTPUT_EXHAUSTED;
-  else
-    return XML_CONVERT_COMPLETED;
-}
-
-static enum XML_Convert_Result PTRCALL
-utf8_toUtf16(const ENCODING *enc,
-             const char **fromP, const char *fromLim,
-             unsigned short **toP, const unsigned short *toLim)
-{
-  enum XML_Convert_Result res = XML_CONVERT_COMPLETED;
-  unsigned short *to = *toP;
-  const char *from = *fromP;
-  while (from < fromLim && to < toLim) {
-    switch (((struct normal_encoding *)enc)->type[(unsigned char)*from]) {
-    case BT_LEAD2:
-      if (fromLim - from < 2) {
-        res = XML_CONVERT_INPUT_INCOMPLETE;
-        goto after;
-      }
-      *to++ = (unsigned short)(((from[0] & 0x1f) << 6) | (from[1] & 0x3f));
-      from += 2;
-      break;
-    case BT_LEAD3:
-      if (fromLim - from < 3) {
-        res = XML_CONVERT_INPUT_INCOMPLETE;
-        goto after;
-      }
-      *to++ = (unsigned short)(((from[0] & 0xf) << 12)
-                               | ((from[1] & 0x3f) << 6) | (from[2] & 0x3f));
-      from += 3;
-      break;
-    case BT_LEAD4:
-      {
-        unsigned long n;
-        if (toLim - to < 2) {
-          res = XML_CONVERT_OUTPUT_EXHAUSTED;
-          goto after;
-        }
-        if (fromLim - from < 4) {
-          res = XML_CONVERT_INPUT_INCOMPLETE;
-          goto after;
-        }
-        n = ((from[0] & 0x7) << 18) | ((from[1] & 0x3f) << 12)
-            | ((from[2] & 0x3f) << 6) | (from[3] & 0x3f);
-        n -= 0x10000;
-        to[0] = (unsigned short)((n >> 10) | 0xD800);
-        to[1] = (unsigned short)((n & 0x3FF) | 0xDC00);
-        to += 2;
-        from += 4;
-      }
-      break;
-    default:
-      *to++ = *from++;
-      break;
-    }
-  }
-  if (from < fromLim)
-    res = XML_CONVERT_OUTPUT_EXHAUSTED;
-after:
-  *fromP = from;
-  *toP = to;
-  return res;
-}
-
-#ifdef XML_NS
-static const struct normal_encoding utf8_encoding_ns = {
-  { VTABLE1, utf8_toUtf8, utf8_toUtf16, 1, 1, 0 },
-  {
-#include "asciitab.h"
-#include "utf8tab.h"
-  },
-  STANDARD_VTABLE(sb_) NORMAL_VTABLE(utf8_)
-};
-#endif
-
-static const struct normal_encoding utf8_encoding = {
-  { VTABLE1, utf8_toUtf8, utf8_toUtf16, 1, 1, 0 },
-  {
-#define BT_COLON BT_NMSTRT
-#include "asciitab.h"
-#undef BT_COLON
-#include "utf8tab.h"
-  },
-  STANDARD_VTABLE(sb_) NORMAL_VTABLE(utf8_)
-};
-
-#ifdef XML_NS
-
-static const struct normal_encoding internal_utf8_encoding_ns = {
-  { VTABLE1, utf8_toUtf8, utf8_toUtf16, 1, 1, 0 },
-  {
-#include "iasciitab.h"
-#include "utf8tab.h"
-  },
-  STANDARD_VTABLE(sb_) NORMAL_VTABLE(utf8_)
-};
-
-#endif
-
-static const struct normal_encoding internal_utf8_encoding = {
-  { VTABLE1, utf8_toUtf8, utf8_toUtf16, 1, 1, 0 },
-  {
-#define BT_COLON BT_NMSTRT
-#include "iasciitab.h"
-#undef BT_COLON
-#include "utf8tab.h"
-  },
-  STANDARD_VTABLE(sb_) NORMAL_VTABLE(utf8_)
-};
-
-static enum XML_Convert_Result PTRCALL
-latin1_toUtf8(const ENCODING *UNUSED_P(enc),
-              const char **fromP, const char *fromLim,
-              char **toP, const char *toLim)
-{
-  for (;;) {
-    unsigned char c;
-    if (*fromP == fromLim)
-      return XML_CONVERT_COMPLETED;
-    c = (unsigned char)**fromP;
-    if (c & 0x80) {
-      if (toLim - *toP < 2)
-        return XML_CONVERT_OUTPUT_EXHAUSTED;
-      *(*toP)++ = (char)((c >> 6) | UTF8_cval2);
-      *(*toP)++ = (char)((c & 0x3f) | 0x80);
-      (*fromP)++;
-    }
-    else {
-      if (*toP == toLim)
-        return XML_CONVERT_OUTPUT_EXHAUSTED;
-      *(*toP)++ = *(*fromP)++;
-    }
-  }
-}
-
-static enum XML_Convert_Result PTRCALL
-latin1_toUtf16(const ENCODING *UNUSED_P(enc),
-               const char **fromP, const char *fromLim,
-               unsigned short **toP, const unsigned short *toLim)
-{
-  while (*fromP < fromLim && *toP < toLim)
-    *(*toP)++ = (unsigned char)*(*fromP)++;
-
-  if ((*toP == toLim) && (*fromP < fromLim))
-    return XML_CONVERT_OUTPUT_EXHAUSTED;
-  else
-    return XML_CONVERT_COMPLETED;
-}
-
-#ifdef XML_NS
-
-static const struct normal_encoding latin1_encoding_ns = {
-  { VTABLE1, latin1_toUtf8, latin1_toUtf16, 1, 0, 0 },
-  {
-#include "asciitab.h"
-#include "latin1tab.h"
-  },
-  STANDARD_VTABLE(sb_) NULL_VTABLE
-};
-
-#endif
-
-static const struct normal_encoding latin1_encoding = {
-  { VTABLE1, latin1_toUtf8, latin1_toUtf16, 1, 0, 0 },
-  {
-#define BT_COLON BT_NMSTRT
-#include "asciitab.h"
-#undef BT_COLON
-#include "latin1tab.h"
-  },
-  STANDARD_VTABLE(sb_) NULL_VTABLE
-};
-
-static enum XML_Convert_Result PTRCALL
-ascii_toUtf8(const ENCODING *UNUSED_P(enc),
-             const char **fromP, const char *fromLim,
-             char **toP, const char *toLim)
-{
-  while (*fromP < fromLim && *toP < toLim)
-    *(*toP)++ = *(*fromP)++;
-
-  if ((*toP == toLim) && (*fromP < fromLim))
-    return XML_CONVERT_OUTPUT_EXHAUSTED;
-  else
-    return XML_CONVERT_COMPLETED;
-}
-
-#ifdef XML_NS
-
-static const struct normal_encoding ascii_encoding_ns = {
-  { VTABLE1, ascii_toUtf8, latin1_toUtf16, 1, 1, 0 },
-  {
-#include "asciitab.h"
-/* BT_NONXML == 0 */
-  },
-  STANDARD_VTABLE(sb_) NULL_VTABLE
-};
-
-#endif
-
-static const struct normal_encoding ascii_encoding = {
-  { VTABLE1, ascii_toUtf8, latin1_toUtf16, 1, 1, 0 },
-  {
-#define BT_COLON BT_NMSTRT
-#include "asciitab.h"
-#undef BT_COLON
-/* BT_NONXML == 0 */
-  },
-  STANDARD_VTABLE(sb_) NULL_VTABLE
-};
-
-static int PTRFASTCALL
-unicode_byte_type(char hi, char lo)
-{
-  switch ((unsigned char)hi) {
-  case 0xD8: case 0xD9: case 0xDA: case 0xDB:
-    return BT_LEAD4;
-  case 0xDC: case 0xDD: case 0xDE: case 0xDF:
-    return BT_TRAIL;
-  case 0xFF:
-    switch ((unsigned char)lo) {
-    case 0xFF:
-    case 0xFE:
-      return BT_NONXML;
-    }
-    break;
-  }
-  return BT_NONASCII;
-}
-
-#define DEFINE_UTF16_TO_UTF8(E) \
-static enum XML_Convert_Result  PTRCALL \
-E ## toUtf8(const ENCODING *UNUSED_P(enc), \
-            const char **fromP, const char *fromLim, \
-            char **toP, const char *toLim) \
-{ \
-  const char *from = *fromP; \
-  fromLim = from + (((fromLim - from) >> 1) << 1);  /* shrink to even */ \
-  for (; from < fromLim; from += 2) { \
-    int plane; \
-    unsigned char lo2; \
-    unsigned char lo = GET_LO(from); \
-    unsigned char hi = GET_HI(from); \
-    switch (hi) { \
-    case 0: \
-      if (lo < 0x80) { \
-        if (*toP == toLim) { \
-          *fromP = from; \
-          return XML_CONVERT_OUTPUT_EXHAUSTED; \
-        } \
-        *(*toP)++ = lo; \
-        break; \
-      } \
-      /* fall through */ \
-    case 0x1: case 0x2: case 0x3: \
-    case 0x4: case 0x5: case 0x6: case 0x7: \
-      if (toLim -  *toP < 2) { \
-        *fromP = from; \
-        return XML_CONVERT_OUTPUT_EXHAUSTED; \
-      } \
-      *(*toP)++ = ((lo >> 6) | (hi << 2) |  UTF8_cval2); \
-      *(*toP)++ = ((lo & 0x3f) | 0x80); \
-      break; \
-    default: \
-      if (toLim -  *toP < 3)  { \
-        *fromP = from; \
-        return XML_CONVERT_OUTPUT_EXHAUSTED; \
-      } \
-      /* 16 bits divided 4, 6, 6 amongst 3 bytes */ \
-      *(*toP)++ = ((hi >> 4) | UTF8_cval3); \
-      *(*toP)++ = (((hi & 0xf) << 2) | (lo >> 6) | 0x80); \
-      *(*toP)++ = ((lo & 0x3f) | 0x80); \
-      break; \
-    case 0xD8: case 0xD9: case 0xDA: case 0xDB: \
-      if (toLim -  *toP < 4) { \
-        *fromP = from; \
-        return XML_CONVERT_OUTPUT_EXHAUSTED; \
-      } \
-      if (fromLim - from < 4) { \
-        *fromP = from; \
-        return XML_CONVERT_INPUT_INCOMPLETE; \
-      } \
-      plane = (((hi & 0x3) << 2) | ((lo >> 6) & 0x3)) + 1; \
-      *(*toP)++ = ((plane >> 2) | UTF8_cval4); \
-      *(*toP)++ = (((lo >> 2) & 0xF) | ((plane & 0x3) << 4) | 0x80); \
-      from += 2; \
-      lo2 = GET_LO(from); \
-      *(*toP)++ = (((lo & 0x3) << 4) \
-                   | ((GET_HI(from) & 0x3) << 2) \
-                   | (lo2 >> 6) \
-                   | 0x80); \
-      *(*toP)++ = ((lo2 & 0x3f) | 0x80); \
-      break; \
-    } \
-  } \
-  *fromP = from; \
-  if (from < fromLim) \
-    return XML_CONVERT_INPUT_INCOMPLETE; \
-  else \
-    return XML_CONVERT_COMPLETED; \
-}
-
-#define DEFINE_UTF16_TO_UTF16(E) \
-static enum XML_Convert_Result  PTRCALL \
-E ## toUtf16(const ENCODING *UNUSED_P(enc), \
-             const char **fromP, const char *fromLim, \
-             unsigned short **toP, const unsigned short *toLim) \
-{ \
-  enum XML_Convert_Result res = XML_CONVERT_COMPLETED; \
-  fromLim = *fromP + (((fromLim - *fromP) >> 1) << 1);  /* shrink to even */ \
-  /* Avoid copying first half only of surrogate */ \
-  if (fromLim - *fromP > ((toLim - *toP) << 1) \
-      && (GET_HI(fromLim - 2) & 0xF8) == 0xD8) { \
-    fromLim -= 2; \
-    res = XML_CONVERT_INPUT_INCOMPLETE; \
-  } \
-  for (; *fromP < fromLim && *toP < toLim; *fromP += 2) \
-    *(*toP)++ = (GET_HI(*fromP) << 8) | GET_LO(*fromP); \
-  if ((*toP == toLim) && (*fromP < fromLim)) \
-    return XML_CONVERT_OUTPUT_EXHAUSTED; \
-  else \
-    return res; \
-}
-
-#define SET2(ptr, ch) \
-  (((ptr)[0] = ((ch) & 0xff)), ((ptr)[1] = ((ch) >> 8)))
-#define GET_LO(ptr) ((unsigned char)(ptr)[0])
-#define GET_HI(ptr) ((unsigned char)(ptr)[1])
-
-DEFINE_UTF16_TO_UTF8(little2_)
-DEFINE_UTF16_TO_UTF16(little2_)
-
-#undef SET2
-#undef GET_LO
-#undef GET_HI
-
-#define SET2(ptr, ch) \
-  (((ptr)[0] = ((ch) >> 8)), ((ptr)[1] = ((ch) & 0xFF)))
-#define GET_LO(ptr) ((unsigned char)(ptr)[1])
-#define GET_HI(ptr) ((unsigned char)(ptr)[0])
-
-DEFINE_UTF16_TO_UTF8(big2_)
-DEFINE_UTF16_TO_UTF16(big2_)
-
-#undef SET2
-#undef GET_LO
-#undef GET_HI
-
-#define LITTLE2_BYTE_TYPE(enc, p) \
- ((p)[1] == 0 \
-  ? ((struct normal_encoding *)(enc))->type[(unsigned char)*(p)] \
-  : unicode_byte_type((p)[1], (p)[0]))
-#define LITTLE2_BYTE_TO_ASCII(enc, p) ((p)[1] == 0 ? (p)[0] : -1)
-#define LITTLE2_CHAR_MATCHES(enc, p, c) ((p)[1] == 0 && (p)[0] == c)
-#define LITTLE2_IS_NAME_CHAR_MINBPC(enc, p) \
-  UCS2_GET_NAMING(namePages, (unsigned char)p[1], (unsigned char)p[0])
-#define LITTLE2_IS_NMSTRT_CHAR_MINBPC(enc, p) \
-  UCS2_GET_NAMING(nmstrtPages, (unsigned char)p[1], (unsigned char)p[0])
-
-#ifdef XML_MIN_SIZE
-
-static int PTRFASTCALL
-little2_byteType(const ENCODING *enc, const char *p)
-{
-  return LITTLE2_BYTE_TYPE(enc, p);
-}
-
-static int PTRFASTCALL
-little2_byteToAscii(const ENCODING *enc, const char *p)
-{
-  return LITTLE2_BYTE_TO_ASCII(enc, p);
-}
-
-static int PTRCALL
-little2_charMatches(const ENCODING *enc, const char *p, int c)
-{
-  return LITTLE2_CHAR_MATCHES(enc, p, c);
-}
-
-static int PTRFASTCALL
-little2_isNameMin(const ENCODING *enc, const char *p)
-{
-  return LITTLE2_IS_NAME_CHAR_MINBPC(enc, p);
-}
-
-static int PTRFASTCALL
-little2_isNmstrtMin(const ENCODING *enc, const char *p)
-{
-  return LITTLE2_IS_NMSTRT_CHAR_MINBPC(enc, p);
-}
-
-#undef VTABLE
-#define VTABLE VTABLE1, little2_toUtf8, little2_toUtf16
-
-#else /* not XML_MIN_SIZE */
-
-#undef PREFIX
-#define PREFIX(ident) little2_ ## ident
-#define MINBPC(enc) 2
-/* CHAR_MATCHES is guaranteed to have MINBPC bytes available. */
-#define BYTE_TYPE(enc, p) LITTLE2_BYTE_TYPE(enc, p)
-#define BYTE_TO_ASCII(enc, p) LITTLE2_BYTE_TO_ASCII(enc, p)
-#define CHAR_MATCHES(enc, p, c) LITTLE2_CHAR_MATCHES(enc, p, c)
-#define IS_NAME_CHAR(enc, p, n) 0
-#define IS_NAME_CHAR_MINBPC(enc, p) LITTLE2_IS_NAME_CHAR_MINBPC(enc, p)
-#define IS_NMSTRT_CHAR(enc, p, n) (0)
-#define IS_NMSTRT_CHAR_MINBPC(enc, p) LITTLE2_IS_NMSTRT_CHAR_MINBPC(enc, p)
-
-#define XML_TOK_IMPL_C
-#include "xmltok_impl.c"
-#undef XML_TOK_IMPL_C
-
-#undef MINBPC
-#undef BYTE_TYPE
-#undef BYTE_TO_ASCII
-#undef CHAR_MATCHES
-#undef IS_NAME_CHAR
-#undef IS_NAME_CHAR_MINBPC
-#undef IS_NMSTRT_CHAR
-#undef IS_NMSTRT_CHAR_MINBPC
-#undef IS_INVALID_CHAR
-
-#endif /* not XML_MIN_SIZE */
-
-#ifdef XML_NS
-
-static const struct normal_encoding little2_encoding_ns = {
-  { VTABLE, 2, 0,
-#if BYTEORDER == 1234
-    1
-#else
-    0
-#endif
-  },
-  {
-#include "asciitab.h"
-#include "latin1tab.h"
-  },
-  STANDARD_VTABLE(little2_) NULL_VTABLE
-};
-
-#endif
-
-static const struct normal_encoding little2_encoding = {
-  { VTABLE, 2, 0,
-#if BYTEORDER == 1234
-    1
-#else
-    0
-#endif
-  },
-  {
-#define BT_COLON BT_NMSTRT
-#include "asciitab.h"
-#undef BT_COLON
-#include "latin1tab.h"
-  },
-  STANDARD_VTABLE(little2_) NULL_VTABLE
-};
-
-#if BYTEORDER != 4321
-
-#ifdef XML_NS
-
-static const struct normal_encoding internal_little2_encoding_ns = {
-  { VTABLE, 2, 0, 1 },
-  {
-#include "iasciitab.h"
-#include "latin1tab.h"
-  },
-  STANDARD_VTABLE(little2_) NULL_VTABLE
-};
-
-#endif
-
-static const struct normal_encoding internal_little2_encoding = {
-  { VTABLE, 2, 0, 1 },
-  {
-#define BT_COLON BT_NMSTRT
-#include "iasciitab.h"
-#undef BT_COLON
-#include "latin1tab.h"
-  },
-  STANDARD_VTABLE(little2_) NULL_VTABLE
-};
-
-#endif
-
-
-#define BIG2_BYTE_TYPE(enc, p) \
- ((p)[0] == 0 \
-  ? ((struct normal_encoding *)(enc))->type[(unsigned char)(p)[1]] \
-  : unicode_byte_type((p)[0], (p)[1]))
-#define BIG2_BYTE_TO_ASCII(enc, p) ((p)[0] == 0 ? (p)[1] : -1)
-#define BIG2_CHAR_MATCHES(enc, p, c) ((p)[0] == 0 && (p)[1] == c)
-#define BIG2_IS_NAME_CHAR_MINBPC(enc, p) \
-  UCS2_GET_NAMING(namePages, (unsigned char)p[0], (unsigned char)p[1])
-#define BIG2_IS_NMSTRT_CHAR_MINBPC(enc, p) \
-  UCS2_GET_NAMING(nmstrtPages, (unsigned char)p[0], (unsigned char)p[1])
-
-#ifdef XML_MIN_SIZE
-
-static int PTRFASTCALL
-big2_byteType(const ENCODING *enc, const char *p)
-{
-  return BIG2_BYTE_TYPE(enc, p);
-}
-
-static int PTRFASTCALL
-big2_byteToAscii(const ENCODING *enc, const char *p)
-{
-  return BIG2_BYTE_TO_ASCII(enc, p);
-}
-
-static int PTRCALL
-big2_charMatches(const ENCODING *enc, const char *p, int c)
-{
-  return BIG2_CHAR_MATCHES(enc, p, c);
-}
-
-static int PTRFASTCALL
-big2_isNameMin(const ENCODING *enc, const char *p)
-{
-  return BIG2_IS_NAME_CHAR_MINBPC(enc, p);
-}
-
-static int PTRFASTCALL
-big2_isNmstrtMin(const ENCODING *enc, const char *p)
-{
-  return BIG2_IS_NMSTRT_CHAR_MINBPC(enc, p);
-}
-
-#undef VTABLE
-#define VTABLE VTABLE1, big2_toUtf8, big2_toUtf16
-
-#else /* not XML_MIN_SIZE */
-
-#undef PREFIX
-#define PREFIX(ident) big2_ ## ident
-#define MINBPC(enc) 2
-/* CHAR_MATCHES is guaranteed to have MINBPC bytes available. */
-#define BYTE_TYPE(enc, p) BIG2_BYTE_TYPE(enc, p)
-#define BYTE_TO_ASCII(enc, p) BIG2_BYTE_TO_ASCII(enc, p)
-#define CHAR_MATCHES(enc, p, c) BIG2_CHAR_MATCHES(enc, p, c)
-#define IS_NAME_CHAR(enc, p, n) 0
-#define IS_NAME_CHAR_MINBPC(enc, p) BIG2_IS_NAME_CHAR_MINBPC(enc, p)
-#define IS_NMSTRT_CHAR(enc, p, n) (0)
-#define IS_NMSTRT_CHAR_MINBPC(enc, p) BIG2_IS_NMSTRT_CHAR_MINBPC(enc, p)
-
-#define XML_TOK_IMPL_C
-#include "xmltok_impl.c"
-#undef XML_TOK_IMPL_C
-
-#undef MINBPC
-#undef BYTE_TYPE
-#undef BYTE_TO_ASCII
-#undef CHAR_MATCHES
-#undef IS_NAME_CHAR
-#undef IS_NAME_CHAR_MINBPC
-#undef IS_NMSTRT_CHAR
-#undef IS_NMSTRT_CHAR_MINBPC
-#undef IS_INVALID_CHAR
-
-#endif /* not XML_MIN_SIZE */
-
-#ifdef XML_NS
-
-static const struct normal_encoding big2_encoding_ns = {
-  { VTABLE, 2, 0,
-#if BYTEORDER == 4321
-  1
-#else
-  0
-#endif
-  },
-  {
-#include "asciitab.h"
-#include "latin1tab.h"
-  },
-  STANDARD_VTABLE(big2_) NULL_VTABLE
-};
-
-#endif
-
-static const struct normal_encoding big2_encoding = {
-  { VTABLE, 2, 0,
-#if BYTEORDER == 4321
-  1
-#else
-  0
-#endif
-  },
-  {
-#define BT_COLON BT_NMSTRT
-#include "asciitab.h"
-#undef BT_COLON
-#include "latin1tab.h"
-  },
-  STANDARD_VTABLE(big2_) NULL_VTABLE
-};
-
-#if BYTEORDER != 1234
-
-#ifdef XML_NS
-
-static const struct normal_encoding internal_big2_encoding_ns = {
-  { VTABLE, 2, 0, 1 },
-  {
-#include "iasciitab.h"
-#include "latin1tab.h"
-  },
-  STANDARD_VTABLE(big2_) NULL_VTABLE
-};
-
-#endif
-
-static const struct normal_encoding internal_big2_encoding = {
-  { VTABLE, 2, 0, 1 },
-  {
-#define BT_COLON BT_NMSTRT
-#include "iasciitab.h"
-#undef BT_COLON
-#include "latin1tab.h"
-  },
-  STANDARD_VTABLE(big2_) NULL_VTABLE
-};
-
-#endif
-
-#undef PREFIX
-
-static int FASTCALL
-streqci(const char *s1, const char *s2)
-{
-  for (;;) {
-    char c1 = *s1++;
-    char c2 = *s2++;
-    if (ASCII_a <= c1 && c1 <= ASCII_z)
-      c1 += ASCII_A - ASCII_a;
-    if (ASCII_a <= c2 && c2 <= ASCII_z)
-      /* The following line will never get executed.  streqci() is
-       * only called from two places, both of which guarantee to put
-       * upper-case strings into s2.
-       */
-      c2 += ASCII_A - ASCII_a; /* LCOV_EXCL_LINE */
-    if (c1 != c2)
-      return 0;
-    if (!c1)
-      break;
-  }
-  return 1;
-}
-
-static void PTRCALL
-initUpdatePosition(const ENCODING *UNUSED_P(enc), const char *ptr,
-                   const char *end, POSITION *pos)
-{
-  normal_updatePosition(&utf8_encoding.enc, ptr, end, pos);
-}
-
-static int
-toAscii(const ENCODING *enc, const char *ptr, const char *end)
-{
-  char buf[1];
-  char *p = buf;
-  XmlUtf8Convert(enc, &ptr, end, &p, p + 1);
-  if (p == buf)
-    return -1;
-  else
-    return buf[0];
-}
-
-static int FASTCALL
-isSpace(int c)
-{
-  switch (c) {
-  case 0x20:
-  case 0xD:
-  case 0xA:
-  case 0x9:
-    return 1;
-  }
-  return 0;
-}
-
-/* Return 1 if there's just optional white space or there's an S
-   followed by name=val.
-*/
-static int
-parsePseudoAttribute(const ENCODING *enc,
-                     const char *ptr,
-                     const char *end,
-                     const char **namePtr,
-                     const char **nameEndPtr,
-                     const char **valPtr,
-                     const char **nextTokPtr)
-{
-  int c;
-  char open;
-  if (ptr == end) {
-    *namePtr = NULL;
-    return 1;
-  }
-  if (!isSpace(toAscii(enc, ptr, end))) {
-    *nextTokPtr = ptr;
-    return 0;
-  }
-  do {
-    ptr += enc->minBytesPerChar;
-  } while (isSpace(toAscii(enc, ptr, end)));
-  if (ptr == end) {
-    *namePtr = NULL;
-    return 1;
-  }
-  *namePtr = ptr;
-  for (;;) {
-    c = toAscii(enc, ptr, end);
-    if (c == -1) {
-      *nextTokPtr = ptr;
-      return 0;
-    }
-    if (c == ASCII_EQUALS) {
-      *nameEndPtr = ptr;
-      break;
-    }
-    if (isSpace(c)) {
-      *nameEndPtr = ptr;
-      do {
-        ptr += enc->minBytesPerChar;
-      } while (isSpace(c = toAscii(enc, ptr, end)));
-      if (c != ASCII_EQUALS) {
-        *nextTokPtr = ptr;
-        return 0;
-      }
-      break;
-    }
-    ptr += enc->minBytesPerChar;
-  }
-  if (ptr == *namePtr) {
-    *nextTokPtr = ptr;
-    return 0;
-  }
-  ptr += enc->minBytesPerChar;
-  c = toAscii(enc, ptr, end);
-  while (isSpace(c)) {
-    ptr += enc->minBytesPerChar;
-    c = toAscii(enc, ptr, end);
-  }
-  if (c != ASCII_QUOT && c != ASCII_APOS) {
-    *nextTokPtr = ptr;
-    return 0;
-  }
-  open = (char)c;
-  ptr += enc->minBytesPerChar;
-  *valPtr = ptr;
-  for (;; ptr += enc->minBytesPerChar) {
-    c = toAscii(enc, ptr, end);
-    if (c == open)
-      break;
-    if (!(ASCII_a <= c && c <= ASCII_z)
-        && !(ASCII_A <= c && c <= ASCII_Z)
-        && !(ASCII_0 <= c && c <= ASCII_9)
-        && c != ASCII_PERIOD
-        && c != ASCII_MINUS
-        && c != ASCII_UNDERSCORE) {
-      *nextTokPtr = ptr;
-      return 0;
-    }
-  }
-  *nextTokPtr = ptr + enc->minBytesPerChar;
-  return 1;
-}
-
-static const char KW_version[] = {
-  ASCII_v, ASCII_e, ASCII_r, ASCII_s, ASCII_i, ASCII_o, ASCII_n, '\0'
-};
-
-static const char KW_encoding[] = {
-  ASCII_e, ASCII_n, ASCII_c, ASCII_o, ASCII_d, ASCII_i, ASCII_n, ASCII_g, '\0'
-};
-
-static const char KW_standalone[] = {
-  ASCII_s, ASCII_t, ASCII_a, ASCII_n, ASCII_d, ASCII_a, ASCII_l, ASCII_o,
-  ASCII_n, ASCII_e, '\0'
-};
-
-static const char KW_yes[] = {
-  ASCII_y, ASCII_e, ASCII_s,  '\0'
-};
-
-static const char KW_no[] = {
-  ASCII_n, ASCII_o,  '\0'
-};
-
-static int
-doParseXmlDecl(const ENCODING *(*encodingFinder)(const ENCODING *,
-                                                 const char *,
-                                                 const char *),
-               int isGeneralTextEntity,
-               const ENCODING *enc,
-               const char *ptr,
-               const char *end,
-               const char **badPtr,
-               const char **versionPtr,
-               const char **versionEndPtr,
-               const char **encodingName,
-               const ENCODING **encoding,
-               int *standalone)
-{
-  const char *val = NULL;
-  const char *name = NULL;
-  const char *nameEnd = NULL;
-  ptr += 5 * enc->minBytesPerChar;
-  end -= 2 * enc->minBytesPerChar;
-  if (!parsePseudoAttribute(enc, ptr, end, &name, &nameEnd, &val, &ptr)
-      || !name) {
-    *badPtr = ptr;
-    return 0;
-  }
-  if (!XmlNameMatchesAscii(enc, name, nameEnd, KW_version)) {
-    if (!isGeneralTextEntity) {
-      *badPtr = name;
-      return 0;
-    }
-  }
-  else {
-    if (versionPtr)
-      *versionPtr = val;
-    if (versionEndPtr)
-      *versionEndPtr = ptr;
-    if (!parsePseudoAttribute(enc, ptr, end, &name, &nameEnd, &val, &ptr)) {
-      *badPtr = ptr;
-      return 0;
-    }
-    if (!name) {
-      if (isGeneralTextEntity) {
-        /* a TextDecl must have an EncodingDecl */
-        *badPtr = ptr;
-        return 0;
-      }
-      return 1;
-    }
-  }
-  if (XmlNameMatchesAscii(enc, name, nameEnd, KW_encoding)) {
-    int c = toAscii(enc, val, end);
-    if (!(ASCII_a <= c && c <= ASCII_z) && !(ASCII_A <= c && c <= ASCII_Z)) {
-      *badPtr = val;
-      return 0;
-    }
-    if (encodingName)
-      *encodingName = val;
-    if (encoding)
-      *encoding = encodingFinder(enc, val, ptr - enc->minBytesPerChar);
-    if (!parsePseudoAttribute(enc, ptr, end, &name, &nameEnd, &val, &ptr)) {
-      *badPtr = ptr;
-      return 0;
-    }
-    if (!name)
-      return 1;
-  }
-  if (!XmlNameMatchesAscii(enc, name, nameEnd, KW_standalone)
-      || isGeneralTextEntity) {
-    *badPtr = name;
-    return 0;
-  }
-  if (XmlNameMatchesAscii(enc, val, ptr - enc->minBytesPerChar, KW_yes)) {
-    if (standalone)
-      *standalone = 1;
-  }
-  else if (XmlNameMatchesAscii(enc, val, ptr - enc->minBytesPerChar, KW_no)) {
-    if (standalone)
-      *standalone = 0;
-  }
-  else {
-    *badPtr = val;
-    return 0;
-  }
-  while (isSpace(toAscii(enc, ptr, end)))
-    ptr += enc->minBytesPerChar;
-  if (ptr != end) {
-    *badPtr = ptr;
-    return 0;
-  }
-  return 1;
-}
-
-static int FASTCALL
-checkCharRefNumber(int result)
-{
-  switch (result >> 8) {
-  case 0xD8: case 0xD9: case 0xDA: case 0xDB:
-  case 0xDC: case 0xDD: case 0xDE: case 0xDF:
-    return -1;
-  case 0:
-    if (latin1_encoding.type[result] == BT_NONXML)
-      return -1;
-    break;
-  case 0xFF:
-    if (result == 0xFFFE || result == 0xFFFF)
-      return -1;
-    break;
-  }
-  return result;
-}
-
-int FASTCALL
-XmlUtf8Encode(int c, char *buf)
-{
-  enum {
-    /* minN is minimum legal resulting value for N byte sequence */
-    min2 = 0x80,
-    min3 = 0x800,
-    min4 = 0x10000
-  };
-
-  if (c < 0)
-    return 0; /* LCOV_EXCL_LINE: this case is always eliminated beforehand */
-  if (c < min2) {
-    buf[0] = (char)(c | UTF8_cval1);
-    return 1;
-  }
-  if (c < min3) {
-    buf[0] = (char)((c >> 6) | UTF8_cval2);
-    buf[1] = (char)((c & 0x3f) | 0x80);
-    return 2;
-  }
-  if (c < min4) {
-    buf[0] = (char)((c >> 12) | UTF8_cval3);
-    buf[1] = (char)(((c >> 6) & 0x3f) | 0x80);
-    buf[2] = (char)((c & 0x3f) | 0x80);
-    return 3;
-  }
-  if (c < 0x110000) {
-    buf[0] = (char)((c >> 18) | UTF8_cval4);
-    buf[1] = (char)(((c >> 12) & 0x3f) | 0x80);
-    buf[2] = (char)(((c >> 6) & 0x3f) | 0x80);
-    buf[3] = (char)((c & 0x3f) | 0x80);
-    return 4;
-  }
-  return 0; /* LCOV_EXCL_LINE: this case too is eliminated before calling */
-}
-
-int FASTCALL
-XmlUtf16Encode(int charNum, unsigned short *buf)
-{
-  if (charNum < 0)
-    return 0;
-  if (charNum < 0x10000) {
-    buf[0] = (unsigned short)charNum;
-    return 1;
-  }
-  if (charNum < 0x110000) {
-    charNum -= 0x10000;
-    buf[0] = (unsigned short)((charNum >> 10) + 0xD800);
-    buf[1] = (unsigned short)((charNum & 0x3FF) + 0xDC00);
-    return 2;
-  }
-  return 0;
-}
-
-struct unknown_encoding {
-  struct normal_encoding normal;
-  CONVERTER convert;
-  void *userData;
-  unsigned short utf16[256];
-  char utf8[256][4];
-};
-
-#define AS_UNKNOWN_ENCODING(enc)  ((const struct unknown_encoding *) (enc))
-
-int
-XmlSizeOfUnknownEncoding(void)
-{
-  return sizeof(struct unknown_encoding);
-}
-
-static int PTRFASTCALL
-unknown_isName(const ENCODING *enc, const char *p)
-{
-  const struct unknown_encoding *uenc = AS_UNKNOWN_ENCODING(enc);
-  int c = uenc->convert(uenc->userData, p);
-  if (c & ~0xFFFF)
-    return 0;
-  return UCS2_GET_NAMING(namePages, c >> 8, c & 0xFF);
-}
-
-static int PTRFASTCALL
-unknown_isNmstrt(const ENCODING *enc, const char *p)
-{
-  const struct unknown_encoding *uenc = AS_UNKNOWN_ENCODING(enc);
-  int c = uenc->convert(uenc->userData, p);
-  if (c & ~0xFFFF)
-    return 0;
-  return UCS2_GET_NAMING(nmstrtPages, c >> 8, c & 0xFF);
-}
-
-static int PTRFASTCALL
-unknown_isInvalid(const ENCODING *enc, const char *p)
-{
-  const struct unknown_encoding *uenc = AS_UNKNOWN_ENCODING(enc);
-  int c = uenc->convert(uenc->userData, p);
-  return (c & ~0xFFFF) || checkCharRefNumber(c) < 0;
-}
-
-static enum XML_Convert_Result PTRCALL
-unknown_toUtf8(const ENCODING *enc,
-               const char **fromP, const char *fromLim,
-               char **toP, const char *toLim)
-{
-  const struct unknown_encoding *uenc = AS_UNKNOWN_ENCODING(enc);
-  char buf[XML_UTF8_ENCODE_MAX];
-  for (;;) {
-    const char *utf8;
-    int n;
-    if (*fromP == fromLim)
-      return XML_CONVERT_COMPLETED;
-    utf8 = uenc->utf8[(unsigned char)**fromP];
-    n = *utf8++;
-    if (n == 0) {
-      int c = uenc->convert(uenc->userData, *fromP);
-      n = XmlUtf8Encode(c, buf);
-      if (n > toLim - *toP)
-        return XML_CONVERT_OUTPUT_EXHAUSTED;
-      utf8 = buf;
-      *fromP += (AS_NORMAL_ENCODING(enc)->type[(unsigned char)**fromP]
-                 - (BT_LEAD2 - 2));
-    }
-    else {
-      if (n > toLim - *toP)
-        return XML_CONVERT_OUTPUT_EXHAUSTED;
-      (*fromP)++;
-    }
-    do {
-      *(*toP)++ = *utf8++;
-    } while (--n != 0);
-  }
-}
-
-static enum XML_Convert_Result PTRCALL
-unknown_toUtf16(const ENCODING *enc,
-                const char **fromP, const char *fromLim,
-                unsigned short **toP, const unsigned short *toLim)
-{
-  const struct unknown_encoding *uenc = AS_UNKNOWN_ENCODING(enc);
-  while (*fromP < fromLim && *toP < toLim) {
-    unsigned short c = uenc->utf16[(unsigned char)**fromP];
-    if (c == 0) {
-      c = (unsigned short)
-          uenc->convert(uenc->userData, *fromP);
-      *fromP += (AS_NORMAL_ENCODING(enc)->type[(unsigned char)**fromP]
-                 - (BT_LEAD2 - 2));
-    }
-    else
-      (*fromP)++;
-    *(*toP)++ = c;
-  }
-
-  if ((*toP == toLim) && (*fromP < fromLim))
-    return XML_CONVERT_OUTPUT_EXHAUSTED;
-  else
-    return XML_CONVERT_COMPLETED;
-}
-
-ENCODING *
-XmlInitUnknownEncoding(void *mem,
-                       int *table,
-                       CONVERTER convert,
-                       void *userData)
-{
-  int i;
-  struct unknown_encoding *e = (struct unknown_encoding *)mem;
-  for (i = 0; i < (int)sizeof(struct normal_encoding); i++)
-    ((char *)mem)[i] = ((char *)&latin1_encoding)[i];
-  for (i = 0; i < 128; i++)
-    if (latin1_encoding.type[i] != BT_OTHER
-        && latin1_encoding.type[i] != BT_NONXML
-        && table[i] != i)
-      return 0;
-  for (i = 0; i < 256; i++) {
-    int c = table[i];
-    if (c == -1) {
-      e->normal.type[i] = BT_MALFORM;
-      /* This shouldn't really get used. */
-      e->utf16[i] = 0xFFFF;
-      e->utf8[i][0] = 1;
-      e->utf8[i][1] = 0;
-    }
-    else if (c < 0) {
-      if (c < -4)
-        return 0;
-      /* Multi-byte sequences need a converter function */
-      if (!convert)
-        return 0;
-      e->normal.type[i] = (unsigned char)(BT_LEAD2 - (c + 2));
-      e->utf8[i][0] = 0;
-      e->utf16[i] = 0;
-    }
-    else if (c < 0x80) {
-      if (latin1_encoding.type[c] != BT_OTHER
-          && latin1_encoding.type[c] != BT_NONXML
-          && c != i)
-        return 0;
-      e->normal.type[i] = latin1_encoding.type[c];
-      e->utf8[i][0] = 1;
-      e->utf8[i][1] = (char)c;
-      e->utf16[i] = (unsigned short)(c == 0 ? 0xFFFF : c);
-    }
-    else if (checkCharRefNumber(c) < 0) {
-      e->normal.type[i] = BT_NONXML;
-      /* This shouldn't really get used. */
-      e->utf16[i] = 0xFFFF;
-      e->utf8[i][0] = 1;
-      e->utf8[i][1] = 0;
-    }
-    else {
-      if (c > 0xFFFF)
-        return 0;
-      if (UCS2_GET_NAMING(nmstrtPages, c >> 8, c & 0xff))
-        e->normal.type[i] = BT_NMSTRT;
-      else if (UCS2_GET_NAMING(namePages, c >> 8, c & 0xff))
-        e->normal.type[i] = BT_NAME;
-      else
-        e->normal.type[i] = BT_OTHER;
-      e->utf8[i][0] = (char)XmlUtf8Encode(c, e->utf8[i] + 1);
-      e->utf16[i] = (unsigned short)c;
-    }
-  }
-  e->userData = userData;
-  e->convert = convert;
-  if (convert) {
-    e->normal.isName2 = unknown_isName;
-    e->normal.isName3 = unknown_isName;
-    e->normal.isName4 = unknown_isName;
-    e->normal.isNmstrt2 = unknown_isNmstrt;
-    e->normal.isNmstrt3 = unknown_isNmstrt;
-    e->normal.isNmstrt4 = unknown_isNmstrt;
-    e->normal.isInvalid2 = unknown_isInvalid;
-    e->normal.isInvalid3 = unknown_isInvalid;
-    e->normal.isInvalid4 = unknown_isInvalid;
-  }
-  e->normal.enc.utf8Convert = unknown_toUtf8;
-  e->normal.enc.utf16Convert = unknown_toUtf16;
-  return &(e->normal.enc);
-}
-
-/* If this enumeration is changed, getEncodingIndex and encodings
-must also be changed. */
-enum {
-  UNKNOWN_ENC = -1,
-  ISO_8859_1_ENC = 0,
-  US_ASCII_ENC,
-  UTF_8_ENC,
-  UTF_16_ENC,
-  UTF_16BE_ENC,
-  UTF_16LE_ENC,
-  /* must match encodingNames up to here */
-  NO_ENC
-};
-
-static const char KW_ISO_8859_1[] = {
-  ASCII_I, ASCII_S, ASCII_O, ASCII_MINUS, ASCII_8, ASCII_8, ASCII_5, ASCII_9,
-  ASCII_MINUS, ASCII_1, '\0'
-};
-static const char KW_US_ASCII[] = {
-  ASCII_U, ASCII_S, ASCII_MINUS, ASCII_A, ASCII_S, ASCII_C, ASCII_I, ASCII_I,
-  '\0'
-};
-static const char KW_UTF_8[] =  {
-  ASCII_U, ASCII_T, ASCII_F, ASCII_MINUS, ASCII_8, '\0'
-};
-static const char KW_UTF_16[] = {
-  ASCII_U, ASCII_T, ASCII_F, ASCII_MINUS, ASCII_1, ASCII_6, '\0'
-};
-static const char KW_UTF_16BE[] = {
-  ASCII_U, ASCII_T, ASCII_F, ASCII_MINUS, ASCII_1, ASCII_6, ASCII_B, ASCII_E,
-  '\0'
-};
-static const char KW_UTF_16LE[] = {
-  ASCII_U, ASCII_T, ASCII_F, ASCII_MINUS, ASCII_1, ASCII_6, ASCII_L, ASCII_E,
-  '\0'
-};
-
-static int FASTCALL
-getEncodingIndex(const char *name)
-{
-  static const char * const encodingNames[] = {
-    KW_ISO_8859_1,
-    KW_US_ASCII,
-    KW_UTF_8,
-    KW_UTF_16,
-    KW_UTF_16BE,
-    KW_UTF_16LE,
-  };
-  int i;
-  if (name == NULL)
-    return NO_ENC;
-  for (i = 0; i < (int)(sizeof(encodingNames)/sizeof(encodingNames[0])); i++)
-    if (streqci(name, encodingNames[i]))
-      return i;
-  return UNKNOWN_ENC;
-}
-
-/* For binary compatibility, we store the index of the encoding
-   specified at initialization in the isUtf16 member.
-*/
-
-#define INIT_ENC_INDEX(enc) ((int)(enc)->initEnc.isUtf16)
-#define SET_INIT_ENC_INDEX(enc, i) ((enc)->initEnc.isUtf16 = (char)i)
-
-/* This is what detects the encoding.  encodingTable maps from
-   encoding indices to encodings; INIT_ENC_INDEX(enc) is the index of
-   the external (protocol) specified encoding; state is
-   XML_CONTENT_STATE if we're parsing an external text entity, and
-   XML_PROLOG_STATE otherwise.
-*/
-
-
-static int
-initScan(const ENCODING * const *encodingTable,
-         const INIT_ENCODING *enc,
-         int state,
-         const char *ptr,
-         const char *end,
-         const char **nextTokPtr)
-{
-  const ENCODING **encPtr;
-
-  if (ptr >= end)
-    return XML_TOK_NONE;
-  encPtr = enc->encPtr;
-  if (ptr + 1 == end) {
-    /* only a single byte available for auto-detection */
-#ifndef XML_DTD /* FIXME */
-    /* a well-formed document entity must have more than one byte */
-    if (state != XML_CONTENT_STATE)
-      return XML_TOK_PARTIAL;
-#endif
-    /* so we're parsing an external text entity... */
-    /* if UTF-16 was externally specified, then we need at least 2 bytes */
-    switch (INIT_ENC_INDEX(enc)) {
-    case UTF_16_ENC:
-    case UTF_16LE_ENC:
-    case UTF_16BE_ENC:
-      return XML_TOK_PARTIAL;
-    }
-    switch ((unsigned char)*ptr) {
-    case 0xFE:
-    case 0xFF:
-    case 0xEF: /* possibly first byte of UTF-8 BOM */
-      if (INIT_ENC_INDEX(enc) == ISO_8859_1_ENC
-          && state == XML_CONTENT_STATE)
-        break;
-      /* fall through */
-    case 0x00:
-    case 0x3C:
-      return XML_TOK_PARTIAL;
-    }
-  }
-  else {
-    switch (((unsigned char)ptr[0] << 8) | (unsigned char)ptr[1]) {
-    case 0xFEFF:
-      if (INIT_ENC_INDEX(enc) == ISO_8859_1_ENC
-          && state == XML_CONTENT_STATE)
-        break;
-      *nextTokPtr = ptr + 2;
-      *encPtr = encodingTable[UTF_16BE_ENC];
-      return XML_TOK_BOM;
-    /* 00 3C is handled in the default case */
-    case 0x3C00:
-      if ((INIT_ENC_INDEX(enc) == UTF_16BE_ENC
-           || INIT_ENC_INDEX(enc) == UTF_16_ENC)
-          && state == XML_CONTENT_STATE)
-        break;
-      *encPtr = encodingTable[UTF_16LE_ENC];
-      return XmlTok(*encPtr, state, ptr, end, nextTokPtr);
-    case 0xFFFE:
-      if (INIT_ENC_INDEX(enc) == ISO_8859_1_ENC
-          && state == XML_CONTENT_STATE)
-        break;
-      *nextTokPtr = ptr + 2;
-      *encPtr = encodingTable[UTF_16LE_ENC];
-      return XML_TOK_BOM;
-    case 0xEFBB:
-      /* Maybe a UTF-8 BOM (EF BB BF) */
-      /* If there's an explicitly specified (external) encoding
-         of ISO-8859-1 or some flavour of UTF-16
-         and this is an external text entity,
-         don't look for the BOM,
-         because it might be a legal data.
-      */
-      if (state == XML_CONTENT_STATE) {
-        int e = INIT_ENC_INDEX(enc);
-        if (e == ISO_8859_1_ENC || e == UTF_16BE_ENC
-            || e == UTF_16LE_ENC || e == UTF_16_ENC)
-          break;
-      }
-      if (ptr + 2 == end)
-        return XML_TOK_PARTIAL;
-      if ((unsigned char)ptr[2] == 0xBF) {
-        *nextTokPtr = ptr + 3;
-        *encPtr = encodingTable[UTF_8_ENC];
-        return XML_TOK_BOM;
-      }
-      break;
-    default:
-      if (ptr[0] == '\0') {
-        /* 0 isn't a legal data character. Furthermore a document
-           entity can only start with ASCII characters.  So the only
-           way this can fail to be big-endian UTF-16 if it it's an
-           external parsed general entity that's labelled as
-           UTF-16LE.
-        */
-        if (state == XML_CONTENT_STATE && INIT_ENC_INDEX(enc) == UTF_16LE_ENC)
-          break;
-        *encPtr = encodingTable[UTF_16BE_ENC];
-        return XmlTok(*encPtr, state, ptr, end, nextTokPtr);
-      }
-      else if (ptr[1] == '\0') {
-        /* We could recover here in the case:
-            - parsing an external entity
-            - second byte is 0
-            - no externally specified encoding
-            - no encoding declaration
-           by assuming UTF-16LE.  But we don't, because this would mean when
-           presented just with a single byte, we couldn't reliably determine
-           whether we needed further bytes.
-        */
-        if (state == XML_CONTENT_STATE)
-          break;
-        *encPtr = encodingTable[UTF_16LE_ENC];
-        return XmlTok(*encPtr, state, ptr, end, nextTokPtr);
-      }
-      break;
-    }
-  }
-  *encPtr = encodingTable[INIT_ENC_INDEX(enc)];
-  return XmlTok(*encPtr, state, ptr, end, nextTokPtr);
-}
-
-
-#define NS(x) x
-#define ns(x) x
-#define XML_TOK_NS_C
-#include "xmltok_ns.c"
-#undef XML_TOK_NS_C
-#undef NS
-#undef ns
-
-#ifdef XML_NS
-
-#define NS(x) x ## NS
-#define ns(x) x ## _ns
-
-#define XML_TOK_NS_C
-#include "xmltok_ns.c"
-#undef XML_TOK_NS_C
-
-#undef NS
-#undef ns
-
-ENCODING *
-XmlInitUnknownEncodingNS(void *mem,
-                         int *table,
-                         CONVERTER convert,
-                         void *userData)
-{
-  ENCODING *enc = XmlInitUnknownEncoding(mem, table, convert, userData);
-  if (enc)
-    ((struct normal_encoding *)enc)->type[ASCII_COLON] = BT_COLON;
-  return enc;
-}
-
-#endif /* XML_NS */
diff --git a/third_party/expat/files/lib/xmltok.h b/third_party/expat/files/lib/xmltok.h
deleted file mode 100644
index 752007e8b9e2..000000000000
--- a/third_party/expat/files/lib/xmltok.h
+++ /dev/null
@@ -1,322 +0,0 @@
-/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-*/
-
-#ifndef XmlTok_INCLUDED
-#define XmlTok_INCLUDED 1
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* The following token may be returned by XmlContentTok */
-#define XML_TOK_TRAILING_RSQB -5 /* ] or ]] at the end of the scan; might be
-                                    start of illegal ]]> sequence */
-/* The following tokens may be returned by both XmlPrologTok and
-   XmlContentTok.
-*/
-#define XML_TOK_NONE -4          /* The string to be scanned is empty */
-#define XML_TOK_TRAILING_CR -3   /* A CR at the end of the scan;
-                                    might be part of CRLF sequence */
-#define XML_TOK_PARTIAL_CHAR -2  /* only part of a multibyte sequence */
-#define XML_TOK_PARTIAL -1       /* only part of a token */
-#define XML_TOK_INVALID 0
-
-/* The following tokens are returned by XmlContentTok; some are also
-   returned by XmlAttributeValueTok, XmlEntityTok, XmlCdataSectionTok.
-*/
-#define XML_TOK_START_TAG_WITH_ATTS 1
-#define XML_TOK_START_TAG_NO_ATTS 2
-#define XML_TOK_EMPTY_ELEMENT_WITH_ATTS 3 /* empty element tag <e/> */
-#define XML_TOK_EMPTY_ELEMENT_NO_ATTS 4
-#define XML_TOK_END_TAG 5
-#define XML_TOK_DATA_CHARS 6
-#define XML_TOK_DATA_NEWLINE 7
-#define XML_TOK_CDATA_SECT_OPEN 8
-#define XML_TOK_ENTITY_REF 9
-#define XML_TOK_CHAR_REF 10               /* numeric character reference */
-
-/* The following tokens may be returned by both XmlPrologTok and
-   XmlContentTok.
-*/
-#define XML_TOK_PI 11                     /* processing instruction */
-#define XML_TOK_XML_DECL 12               /* XML decl or text decl */
-#define XML_TOK_COMMENT 13
-#define XML_TOK_BOM 14                    /* Byte order mark */
-
-/* The following tokens are returned only by XmlPrologTok */
-#define XML_TOK_PROLOG_S 15
-#define XML_TOK_DECL_OPEN 16              /* <!foo */
-#define XML_TOK_DECL_CLOSE 17             /* > */
-#define XML_TOK_NAME 18
-#define XML_TOK_NMTOKEN 19
-#define XML_TOK_POUND_NAME 20             /* #name */
-#define XML_TOK_OR 21                     /* | */
-#define XML_TOK_PERCENT 22
-#define XML_TOK_OPEN_PAREN 23
-#define XML_TOK_CLOSE_PAREN 24
-#define XML_TOK_OPEN_BRACKET 25
-#define XML_TOK_CLOSE_BRACKET 26
-#define XML_TOK_LITERAL 27
-#define XML_TOK_PARAM_ENTITY_REF 28
-#define XML_TOK_INSTANCE_START 29
-
-/* The following occur only in element type declarations */
-#define XML_TOK_NAME_QUESTION 30          /* name? */
-#define XML_TOK_NAME_ASTERISK 31          /* name* */
-#define XML_TOK_NAME_PLUS 32              /* name+ */
-#define XML_TOK_COND_SECT_OPEN 33         /* <![ */
-#define XML_TOK_COND_SECT_CLOSE 34        /* ]]> */
-#define XML_TOK_CLOSE_PAREN_QUESTION 35   /* )? */
-#define XML_TOK_CLOSE_PAREN_ASTERISK 36   /* )* */
-#define XML_TOK_CLOSE_PAREN_PLUS 37       /* )+ */
-#define XML_TOK_COMMA 38
-
-/* The following token is returned only by XmlAttributeValueTok */
-#define XML_TOK_ATTRIBUTE_VALUE_S 39
-
-/* The following token is returned only by XmlCdataSectionTok */
-#define XML_TOK_CDATA_SECT_CLOSE 40
-
-/* With namespace processing this is returned by XmlPrologTok for a
-   name with a colon.
-*/
-#define XML_TOK_PREFIXED_NAME 41
-
-#ifdef XML_DTD
-#define XML_TOK_IGNORE_SECT 42
-#endif /* XML_DTD */
-
-#ifdef XML_DTD
-#define XML_N_STATES 4
-#else /* not XML_DTD */
-#define XML_N_STATES 3
-#endif /* not XML_DTD */
-
-#define XML_PROLOG_STATE 0
-#define XML_CONTENT_STATE 1
-#define XML_CDATA_SECTION_STATE 2
-#ifdef XML_DTD
-#define XML_IGNORE_SECTION_STATE 3
-#endif /* XML_DTD */
-
-#define XML_N_LITERAL_TYPES 2
-#define XML_ATTRIBUTE_VALUE_LITERAL 0
-#define XML_ENTITY_VALUE_LITERAL 1
-
-/* The size of the buffer passed to XmlUtf8Encode must be at least this. */
-#define XML_UTF8_ENCODE_MAX 4
-/* The size of the buffer passed to XmlUtf16Encode must be at least this. */
-#define XML_UTF16_ENCODE_MAX 2
-
-typedef struct position {
-  /* first line and first column are 0 not 1 */
-  XML_Size lineNumber;
-  XML_Size columnNumber;
-} POSITION;
-
-typedef struct {
-  const char *name;
-  const char *valuePtr;
-  const char *valueEnd;
-  char normalized;
-} ATTRIBUTE;
-
-struct encoding;
-typedef struct encoding ENCODING;
-
-typedef int (PTRCALL *SCANNER)(const ENCODING *,
-                               const char *,
-                               const char *,
-                               const char **);
-
-enum XML_Convert_Result {
-  XML_CONVERT_COMPLETED = 0,
-  XML_CONVERT_INPUT_INCOMPLETE = 1,
-  XML_CONVERT_OUTPUT_EXHAUSTED = 2  /* and therefore potentially input remaining as well */
-};
-
-struct encoding {
-  SCANNER scanners[XML_N_STATES];
-  SCANNER literalScanners[XML_N_LITERAL_TYPES];
-  int (PTRCALL *sameName)(const ENCODING *,
-                          const char *,
-                          const char *);
-  int (PTRCALL *nameMatchesAscii)(const ENCODING *,
-                                  const char *,
-                                  const char *,
-                                  const char *);
-  int (PTRFASTCALL *nameLength)(const ENCODING *, const char *);
-  const char *(PTRFASTCALL *skipS)(const ENCODING *, const char *);
-  int (PTRCALL *getAtts)(const ENCODING *enc,
-                         const char *ptr,
-                         int attsMax,
-                         ATTRIBUTE *atts);
-  int (PTRFASTCALL *charRefNumber)(const ENCODING *enc, const char *ptr);
-  int (PTRCALL *predefinedEntityName)(const ENCODING *,
-                                      const char *,
-                                      const char *);
-  void (PTRCALL *updatePosition)(const ENCODING *,
-                                 const char *ptr,
-                                 const char *end,
-                                 POSITION *);
-  int (PTRCALL *isPublicId)(const ENCODING *enc,
-                            const char *ptr,
-                            const char *end,
-                            const char **badPtr);
-  enum XML_Convert_Result (PTRCALL *utf8Convert)(const ENCODING *enc,
-                              const char **fromP,
-                              const char *fromLim,
-                              char **toP,
-                              const char *toLim);
-  enum XML_Convert_Result (PTRCALL *utf16Convert)(const ENCODING *enc,
-                               const char **fromP,
-                               const char *fromLim,
-                               unsigned short **toP,
-                               const unsigned short *toLim);
-  int minBytesPerChar;
-  char isUtf8;
-  char isUtf16;
-};
-
-/* Scan the string starting at ptr until the end of the next complete
-   token, but do not scan past eptr.  Return an integer giving the
-   type of token.
-
-   Return XML_TOK_NONE when ptr == eptr; nextTokPtr will not be set.
-
-   Return XML_TOK_PARTIAL when the string does not contain a complete
-   token; nextTokPtr will not be set.
-
-   Return XML_TOK_INVALID when the string does not start a valid
-   token; nextTokPtr will be set to point to the character which made
-   the token invalid.
-
-   Otherwise the string starts with a valid token; nextTokPtr will be
-   set to point to the character following the end of that token.
-
-   Each data character counts as a single token, but adjacent data
-   characters may be returned together.  Similarly for characters in
-   the prolog outside literals, comments and processing instructions.
-*/
-
-
-#define XmlTok(enc, state, ptr, end, nextTokPtr) \
-  (((enc)->scanners[state])(enc, ptr, end, nextTokPtr))
-
-#define XmlPrologTok(enc, ptr, end, nextTokPtr) \
-   XmlTok(enc, XML_PROLOG_STATE, ptr, end, nextTokPtr)
-
-#define XmlContentTok(enc, ptr, end, nextTokPtr) \
-   XmlTok(enc, XML_CONTENT_STATE, ptr, end, nextTokPtr)
-
-#define XmlCdataSectionTok(enc, ptr, end, nextTokPtr) \
-   XmlTok(enc, XML_CDATA_SECTION_STATE, ptr, end, nextTokPtr)
-
-#ifdef XML_DTD
-
-#define XmlIgnoreSectionTok(enc, ptr, end, nextTokPtr) \
-   XmlTok(enc, XML_IGNORE_SECTION_STATE, ptr, end, nextTokPtr)
-
-#endif /* XML_DTD */
-
-/* This is used for performing a 2nd-level tokenization on the content
-   of a literal that has already been returned by XmlTok.
-*/
-#define XmlLiteralTok(enc, literalType, ptr, end, nextTokPtr) \
-  (((enc)->literalScanners[literalType])(enc, ptr, end, nextTokPtr))
-
-#define XmlAttributeValueTok(enc, ptr, end, nextTokPtr) \
-   XmlLiteralTok(enc, XML_ATTRIBUTE_VALUE_LITERAL, ptr, end, nextTokPtr)
-
-#define XmlEntityValueTok(enc, ptr, end, nextTokPtr) \
-   XmlLiteralTok(enc, XML_ENTITY_VALUE_LITERAL, ptr, end, nextTokPtr)
-
-#define XmlSameName(enc, ptr1, ptr2) (((enc)->sameName)(enc, ptr1, ptr2))
-
-#define XmlNameMatchesAscii(enc, ptr1, end1, ptr2) \
-  (((enc)->nameMatchesAscii)(enc, ptr1, end1, ptr2))
-
-#define XmlNameLength(enc, ptr) \
-  (((enc)->nameLength)(enc, ptr))
-
-#define XmlSkipS(enc, ptr) \
-  (((enc)->skipS)(enc, ptr))
-
-#define XmlGetAttributes(enc, ptr, attsMax, atts) \
-  (((enc)->getAtts)(enc, ptr, attsMax, atts))
-
-#define XmlCharRefNumber(enc, ptr) \
-  (((enc)->charRefNumber)(enc, ptr))
-
-#define XmlPredefinedEntityName(enc, ptr, end) \
-  (((enc)->predefinedEntityName)(enc, ptr, end))
-
-#define XmlUpdatePosition(enc, ptr, end, pos) \
-  (((enc)->updatePosition)(enc, ptr, end, pos))
-
-#define XmlIsPublicId(enc, ptr, end, badPtr) \
-  (((enc)->isPublicId)(enc, ptr, end, badPtr))
-
-#define XmlUtf8Convert(enc, fromP, fromLim, toP, toLim) \
-  (((enc)->utf8Convert)(enc, fromP, fromLim, toP, toLim))
-
-#define XmlUtf16Convert(enc, fromP, fromLim, toP, toLim) \
-  (((enc)->utf16Convert)(enc, fromP, fromLim, toP, toLim))
-
-typedef struct {
-  ENCODING initEnc;
-  const ENCODING **encPtr;
-} INIT_ENCODING;
-
-int XmlParseXmlDecl(int isGeneralTextEntity,
-                    const ENCODING *enc,
-                    const char *ptr,
-                    const char *end,
-                    const char **badPtr,
-                    const char **versionPtr,
-                    const char **versionEndPtr,
-                    const char **encodingNamePtr,
-                    const ENCODING **namedEncodingPtr,
-                    int *standalonePtr);
-
-int XmlInitEncoding(INIT_ENCODING *, const ENCODING **, const char *name);
-const ENCODING *XmlGetUtf8InternalEncoding(void);
-const ENCODING *XmlGetUtf16InternalEncoding(void);
-int FASTCALL XmlUtf8Encode(int charNumber, char *buf);
-int FASTCALL XmlUtf16Encode(int charNumber, unsigned short *buf);
-int XmlSizeOfUnknownEncoding(void);
-
-
-typedef int (XMLCALL *CONVERTER) (void *userData, const char *p);
-
-ENCODING *
-XmlInitUnknownEncoding(void *mem,
-                       int *table,
-                       CONVERTER convert,
-                       void *userData);
-
-int XmlParseXmlDeclNS(int isGeneralTextEntity,
-                      const ENCODING *enc,
-                      const char *ptr,
-                      const char *end,
-                      const char **badPtr,
-                      const char **versionPtr,
-                      const char **versionEndPtr,
-                      const char **encodingNamePtr,
-                      const ENCODING **namedEncodingPtr,
-                      int *standalonePtr);
-
-int XmlInitEncodingNS(INIT_ENCODING *, const ENCODING **, const char *name);
-const ENCODING *XmlGetUtf8InternalEncodingNS(void);
-const ENCODING *XmlGetUtf16InternalEncodingNS(void);
-ENCODING *
-XmlInitUnknownEncodingNS(void *mem,
-                         int *table,
-                         CONVERTER convert,
-                         void *userData);
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* not XmlTok_INCLUDED */
diff --git a/third_party/expat/files/lib/xmltok_impl.c b/third_party/expat/files/lib/xmltok_impl.c
deleted file mode 100644
index 4fa1ff679ce5..000000000000
--- a/third_party/expat/files/lib/xmltok_impl.c
+++ /dev/null
@@ -1,1806 +0,0 @@
-/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-*/
-
-/* This file is included! */
-#ifdef XML_TOK_IMPL_C
-
-#ifndef IS_INVALID_CHAR
-#define IS_INVALID_CHAR(enc, ptr, n) (0)
-#endif
-
-#define INVALID_LEAD_CASE(n, ptr, nextTokPtr) \
-    case BT_LEAD ## n: \
-      if (end - ptr < n) \
-        return XML_TOK_PARTIAL_CHAR; \
-      if (IS_INVALID_CHAR(enc, ptr, n)) { \
-        *(nextTokPtr) = (ptr); \
-        return XML_TOK_INVALID; \
-      } \
-      ptr += n; \
-      break;
-
-#define INVALID_CASES(ptr, nextTokPtr) \
-  INVALID_LEAD_CASE(2, ptr, nextTokPtr) \
-  INVALID_LEAD_CASE(3, ptr, nextTokPtr) \
-  INVALID_LEAD_CASE(4, ptr, nextTokPtr) \
-  case BT_NONXML: \
-  case BT_MALFORM: \
-  case BT_TRAIL: \
-    *(nextTokPtr) = (ptr); \
-    return XML_TOK_INVALID;
-
-#define CHECK_NAME_CASE(n, enc, ptr, end, nextTokPtr) \
-   case BT_LEAD ## n: \
-     if (end - ptr < n) \
-       return XML_TOK_PARTIAL_CHAR; \
-     if (!IS_NAME_CHAR(enc, ptr, n)) { \
-       *nextTokPtr = ptr; \
-       return XML_TOK_INVALID; \
-     } \
-     ptr += n; \
-     break;
-
-#define CHECK_NAME_CASES(enc, ptr, end, nextTokPtr) \
-  case BT_NONASCII: \
-    if (!IS_NAME_CHAR_MINBPC(enc, ptr)) { \
-      *nextTokPtr = ptr; \
-      return XML_TOK_INVALID; \
-    } \
-  case BT_NMSTRT: \
-  case BT_HEX: \
-  case BT_DIGIT: \
-  case BT_NAME: \
-  case BT_MINUS: \
-    ptr += MINBPC(enc); \
-    break; \
-  CHECK_NAME_CASE(2, enc, ptr, end, nextTokPtr) \
-  CHECK_NAME_CASE(3, enc, ptr, end, nextTokPtr) \
-  CHECK_NAME_CASE(4, enc, ptr, end, nextTokPtr)
-
-#define CHECK_NMSTRT_CASE(n, enc, ptr, end, nextTokPtr) \
-   case BT_LEAD ## n: \
-     if (end - ptr < n) \
-       return XML_TOK_PARTIAL_CHAR; \
-     if (!IS_NMSTRT_CHAR(enc, ptr, n)) { \
-       *nextTokPtr = ptr; \
-       return XML_TOK_INVALID; \
-     } \
-     ptr += n; \
-     break;
-
-#define CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr) \
-  case BT_NONASCII: \
-    if (!IS_NMSTRT_CHAR_MINBPC(enc, ptr)) { \
-      *nextTokPtr = ptr; \
-      return XML_TOK_INVALID; \
-    } \
-  case BT_NMSTRT: \
-  case BT_HEX: \
-    ptr += MINBPC(enc); \
-    break; \
-  CHECK_NMSTRT_CASE(2, enc, ptr, end, nextTokPtr) \
-  CHECK_NMSTRT_CASE(3, enc, ptr, end, nextTokPtr) \
-  CHECK_NMSTRT_CASE(4, enc, ptr, end, nextTokPtr)
-
-#ifndef PREFIX
-#define PREFIX(ident) ident
-#endif
-
-
-#define HAS_CHARS(enc, ptr, end, count) \
-    (end - ptr >= count * MINBPC(enc))
-
-#define HAS_CHAR(enc, ptr, end) \
-    HAS_CHARS(enc, ptr, end, 1)
-
-#define REQUIRE_CHARS(enc, ptr, end, count) \
-    { \
-      if (! HAS_CHARS(enc, ptr, end, count)) { \
-        return XML_TOK_PARTIAL; \
-      } \
-    }
-
-#define REQUIRE_CHAR(enc, ptr, end) \
-    REQUIRE_CHARS(enc, ptr, end, 1)
-
-
-/* ptr points to character following "<!-" */
-
-static int PTRCALL
-PREFIX(scanComment)(const ENCODING *enc, const char *ptr,
-                    const char *end, const char **nextTokPtr)
-{
-  if (HAS_CHAR(enc, ptr, end)) {
-    if (!CHAR_MATCHES(enc, ptr, ASCII_MINUS)) {
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-    ptr += MINBPC(enc);
-    while (HAS_CHAR(enc, ptr, end)) {
-      switch (BYTE_TYPE(enc, ptr)) {
-      INVALID_CASES(ptr, nextTokPtr)
-      case BT_MINUS:
-        ptr += MINBPC(enc);
-        REQUIRE_CHAR(enc, ptr, end);
-        if (CHAR_MATCHES(enc, ptr, ASCII_MINUS)) {
-          ptr += MINBPC(enc);
-          REQUIRE_CHAR(enc, ptr, end);
-          if (!CHAR_MATCHES(enc, ptr, ASCII_GT)) {
-            *nextTokPtr = ptr;
-            return XML_TOK_INVALID;
-          }
-          *nextTokPtr = ptr + MINBPC(enc);
-          return XML_TOK_COMMENT;
-        }
-        break;
-      default:
-        ptr += MINBPC(enc);
-        break;
-      }
-    }
-  }
-  return XML_TOK_PARTIAL;
-}
-
-/* ptr points to character following "<!" */
-
-static int PTRCALL
-PREFIX(scanDecl)(const ENCODING *enc, const char *ptr,
-                 const char *end, const char **nextTokPtr)
-{
-  REQUIRE_CHAR(enc, ptr, end);
-  switch (BYTE_TYPE(enc, ptr)) {
-  case BT_MINUS:
-    return PREFIX(scanComment)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-  case BT_LSQB:
-    *nextTokPtr = ptr + MINBPC(enc);
-    return XML_TOK_COND_SECT_OPEN;
-  case BT_NMSTRT:
-  case BT_HEX:
-    ptr += MINBPC(enc);
-    break;
-  default:
-    *nextTokPtr = ptr;
-    return XML_TOK_INVALID;
-  }
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-    case BT_PERCNT:
-      REQUIRE_CHARS(enc, ptr, end, 2);
-      /* don't allow <!ENTITY% foo "whatever"> */
-      switch (BYTE_TYPE(enc, ptr + MINBPC(enc))) {
-      case BT_S: case BT_CR: case BT_LF: case BT_PERCNT:
-        *nextTokPtr = ptr;
-        return XML_TOK_INVALID;
-      }
-      /* fall through */
-    case BT_S: case BT_CR: case BT_LF:
-      *nextTokPtr = ptr;
-      return XML_TOK_DECL_OPEN;
-    case BT_NMSTRT:
-    case BT_HEX:
-      ptr += MINBPC(enc);
-      break;
-    default:
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-  }
-  return XML_TOK_PARTIAL;
-}
-
-static int PTRCALL
-PREFIX(checkPiTarget)(const ENCODING *UNUSED_P(enc), const char *ptr,
-                      const char *end, int *tokPtr)
-{
-  int upper = 0;
-  *tokPtr = XML_TOK_PI;
-  if (end - ptr != MINBPC(enc)*3)
-    return 1;
-  switch (BYTE_TO_ASCII(enc, ptr)) {
-  case ASCII_x:
-    break;
-  case ASCII_X:
-    upper = 1;
-    break;
-  default:
-    return 1;
-  }
-  ptr += MINBPC(enc);
-  switch (BYTE_TO_ASCII(enc, ptr)) {
-  case ASCII_m:
-    break;
-  case ASCII_M:
-    upper = 1;
-    break;
-  default:
-    return 1;
-  }
-  ptr += MINBPC(enc);
-  switch (BYTE_TO_ASCII(enc, ptr)) {
-  case ASCII_l:
-    break;
-  case ASCII_L:
-    upper = 1;
-    break;
-  default:
-    return 1;
-  }
-  if (upper)
-    return 0;
-  *tokPtr = XML_TOK_XML_DECL;
-  return 1;
-}
-
-/* ptr points to character following "<?" */
-
-static int PTRCALL
-PREFIX(scanPi)(const ENCODING *enc, const char *ptr,
-               const char *end, const char **nextTokPtr)
-{
-  int tok;
-  const char *target = ptr;
-  REQUIRE_CHAR(enc, ptr, end);
-  switch (BYTE_TYPE(enc, ptr)) {
-  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
-  default:
-    *nextTokPtr = ptr;
-    return XML_TOK_INVALID;
-  }
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
-    case BT_S: case BT_CR: case BT_LF:
-      if (!PREFIX(checkPiTarget)(enc, target, ptr, &tok)) {
-        *nextTokPtr = ptr;
-        return XML_TOK_INVALID;
-      }
-      ptr += MINBPC(enc);
-      while (HAS_CHAR(enc, ptr, end)) {
-        switch (BYTE_TYPE(enc, ptr)) {
-        INVALID_CASES(ptr, nextTokPtr)
-        case BT_QUEST:
-          ptr += MINBPC(enc);
-          REQUIRE_CHAR(enc, ptr, end);
-          if (CHAR_MATCHES(enc, ptr, ASCII_GT)) {
-            *nextTokPtr = ptr + MINBPC(enc);
-            return tok;
-          }
-          break;
-        default:
-          ptr += MINBPC(enc);
-          break;
-        }
-      }
-      return XML_TOK_PARTIAL;
-    case BT_QUEST:
-      if (!PREFIX(checkPiTarget)(enc, target, ptr, &tok)) {
-        *nextTokPtr = ptr;
-        return XML_TOK_INVALID;
-      }
-      ptr += MINBPC(enc);
-      REQUIRE_CHAR(enc, ptr, end);
-      if (CHAR_MATCHES(enc, ptr, ASCII_GT)) {
-        *nextTokPtr = ptr + MINBPC(enc);
-        return tok;
-      }
-      /* fall through */
-    default:
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-  }
-  return XML_TOK_PARTIAL;
-}
-
-static int PTRCALL
-PREFIX(scanCdataSection)(const ENCODING *UNUSED_P(enc), const char *ptr,
-                         const char *end, const char **nextTokPtr)
-{
-  static const char CDATA_LSQB[] = { ASCII_C, ASCII_D, ASCII_A,
-                                     ASCII_T, ASCII_A, ASCII_LSQB };
-  int i;
-  /* CDATA[ */
-  REQUIRE_CHARS(enc, ptr, end, 6);
-  for (i = 0; i < 6; i++, ptr += MINBPC(enc)) {
-    if (!CHAR_MATCHES(enc, ptr, CDATA_LSQB[i])) {
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-  }
-  *nextTokPtr = ptr;
-  return XML_TOK_CDATA_SECT_OPEN;
-}
-
-static int PTRCALL
-PREFIX(cdataSectionTok)(const ENCODING *enc, const char *ptr,
-                        const char *end, const char **nextTokPtr)
-{
-  if (ptr >= end)
-    return XML_TOK_NONE;
-  if (MINBPC(enc) > 1) {
-    size_t n = end - ptr;
-    if (n & (MINBPC(enc) - 1)) {
-      n &= ~(MINBPC(enc) - 1);
-      if (n == 0)
-        return XML_TOK_PARTIAL;
-      end = ptr + n;
-    }
-  }
-  switch (BYTE_TYPE(enc, ptr)) {
-  case BT_RSQB:
-    ptr += MINBPC(enc);
-    REQUIRE_CHAR(enc, ptr, end);
-    if (!CHAR_MATCHES(enc, ptr, ASCII_RSQB))
-      break;
-    ptr += MINBPC(enc);
-    REQUIRE_CHAR(enc, ptr, end);
-    if (!CHAR_MATCHES(enc, ptr, ASCII_GT)) {
-      ptr -= MINBPC(enc);
-      break;
-    }
-    *nextTokPtr = ptr + MINBPC(enc);
-    return XML_TOK_CDATA_SECT_CLOSE;
-  case BT_CR:
-    ptr += MINBPC(enc);
-    REQUIRE_CHAR(enc, ptr, end);
-    if (BYTE_TYPE(enc, ptr) == BT_LF)
-      ptr += MINBPC(enc);
-    *nextTokPtr = ptr;
-    return XML_TOK_DATA_NEWLINE;
-  case BT_LF:
-    *nextTokPtr = ptr + MINBPC(enc);
-    return XML_TOK_DATA_NEWLINE;
-  INVALID_CASES(ptr, nextTokPtr)
-  default:
-    ptr += MINBPC(enc);
-    break;
-  }
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-#define LEAD_CASE(n) \
-    case BT_LEAD ## n: \
-      if (end - ptr < n || IS_INVALID_CHAR(enc, ptr, n)) { \
-        *nextTokPtr = ptr; \
-        return XML_TOK_DATA_CHARS; \
-      } \
-      ptr += n; \
-      break;
-    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
-#undef LEAD_CASE
-    case BT_NONXML:
-    case BT_MALFORM:
-    case BT_TRAIL:
-    case BT_CR:
-    case BT_LF:
-    case BT_RSQB:
-      *nextTokPtr = ptr;
-      return XML_TOK_DATA_CHARS;
-    default:
-      ptr += MINBPC(enc);
-      break;
-    }
-  }
-  *nextTokPtr = ptr;
-  return XML_TOK_DATA_CHARS;
-}
-
-/* ptr points to character following "</" */
-
-static int PTRCALL
-PREFIX(scanEndTag)(const ENCODING *enc, const char *ptr,
-                   const char *end, const char **nextTokPtr)
-{
-  REQUIRE_CHAR(enc, ptr, end);
-  switch (BYTE_TYPE(enc, ptr)) {
-  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
-  default:
-    *nextTokPtr = ptr;
-    return XML_TOK_INVALID;
-  }
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
-    case BT_S: case BT_CR: case BT_LF:
-      for (ptr += MINBPC(enc); HAS_CHAR(enc, ptr, end); ptr += MINBPC(enc)) {
-        switch (BYTE_TYPE(enc, ptr)) {
-        case BT_S: case BT_CR: case BT_LF:
-          break;
-        case BT_GT:
-          *nextTokPtr = ptr + MINBPC(enc);
-          return XML_TOK_END_TAG;
-        default:
-          *nextTokPtr = ptr;
-          return XML_TOK_INVALID;
-        }
-      }
-      return XML_TOK_PARTIAL;
-#ifdef XML_NS
-    case BT_COLON:
-      /* no need to check qname syntax here,
-         since end-tag must match exactly */
-      ptr += MINBPC(enc);
-      break;
-#endif
-    case BT_GT:
-      *nextTokPtr = ptr + MINBPC(enc);
-      return XML_TOK_END_TAG;
-    default:
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-  }
-  return XML_TOK_PARTIAL;
-}
-
-/* ptr points to character following "&#X" */
-
-static int PTRCALL
-PREFIX(scanHexCharRef)(const ENCODING *enc, const char *ptr,
-                       const char *end, const char **nextTokPtr)
-{
-  if (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-    case BT_DIGIT:
-    case BT_HEX:
-      break;
-    default:
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-    for (ptr += MINBPC(enc); HAS_CHAR(enc, ptr, end); ptr += MINBPC(enc)) {
-      switch (BYTE_TYPE(enc, ptr)) {
-      case BT_DIGIT:
-      case BT_HEX:
-        break;
-      case BT_SEMI:
-        *nextTokPtr = ptr + MINBPC(enc);
-        return XML_TOK_CHAR_REF;
-      default:
-        *nextTokPtr = ptr;
-        return XML_TOK_INVALID;
-      }
-    }
-  }
-  return XML_TOK_PARTIAL;
-}
-
-/* ptr points to character following "&#" */
-
-static int PTRCALL
-PREFIX(scanCharRef)(const ENCODING *enc, const char *ptr,
-                    const char *end, const char **nextTokPtr)
-{
-  if (HAS_CHAR(enc, ptr, end)) {
-    if (CHAR_MATCHES(enc, ptr, ASCII_x))
-      return PREFIX(scanHexCharRef)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-    switch (BYTE_TYPE(enc, ptr)) {
-    case BT_DIGIT:
-      break;
-    default:
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-    for (ptr += MINBPC(enc); HAS_CHAR(enc, ptr, end); ptr += MINBPC(enc)) {
-      switch (BYTE_TYPE(enc, ptr)) {
-      case BT_DIGIT:
-        break;
-      case BT_SEMI:
-        *nextTokPtr = ptr + MINBPC(enc);
-        return XML_TOK_CHAR_REF;
-      default:
-        *nextTokPtr = ptr;
-        return XML_TOK_INVALID;
-      }
-    }
-  }
-  return XML_TOK_PARTIAL;
-}
-
-/* ptr points to character following "&" */
-
-static int PTRCALL
-PREFIX(scanRef)(const ENCODING *enc, const char *ptr, const char *end,
-                const char **nextTokPtr)
-{
-  REQUIRE_CHAR(enc, ptr, end);
-  switch (BYTE_TYPE(enc, ptr)) {
-  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
-  case BT_NUM:
-    return PREFIX(scanCharRef)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-  default:
-    *nextTokPtr = ptr;
-    return XML_TOK_INVALID;
-  }
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
-    case BT_SEMI:
-      *nextTokPtr = ptr + MINBPC(enc);
-      return XML_TOK_ENTITY_REF;
-    default:
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-  }
-  return XML_TOK_PARTIAL;
-}
-
-/* ptr points to character following first character of attribute name */
-
-static int PTRCALL
-PREFIX(scanAtts)(const ENCODING *enc, const char *ptr, const char *end,
-                 const char **nextTokPtr)
-{
-#ifdef XML_NS
-  int hadColon = 0;
-#endif
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
-#ifdef XML_NS
-    case BT_COLON:
-      if (hadColon) {
-        *nextTokPtr = ptr;
-        return XML_TOK_INVALID;
-      }
-      hadColon = 1;
-      ptr += MINBPC(enc);
-      REQUIRE_CHAR(enc, ptr, end);
-      switch (BYTE_TYPE(enc, ptr)) {
-      CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
-      default:
-        *nextTokPtr = ptr;
-        return XML_TOK_INVALID;
-      }
-      break;
-#endif
-    case BT_S: case BT_CR: case BT_LF:
-      for (;;) {
-        int t;
-
-        ptr += MINBPC(enc);
-        REQUIRE_CHAR(enc, ptr, end);
-        t = BYTE_TYPE(enc, ptr);
-        if (t == BT_EQUALS)
-          break;
-        switch (t) {
-        case BT_S:
-        case BT_LF:
-        case BT_CR:
-          break;
-        default:
-          *nextTokPtr = ptr;
-          return XML_TOK_INVALID;
-        }
-      }
-    /* fall through */
-    case BT_EQUALS:
-      {
-        int open;
-#ifdef XML_NS
-        hadColon = 0;
-#endif
-        for (;;) {
-          ptr += MINBPC(enc);
-          REQUIRE_CHAR(enc, ptr, end);
-          open = BYTE_TYPE(enc, ptr);
-          if (open == BT_QUOT || open == BT_APOS)
-            break;
-          switch (open) {
-          case BT_S:
-          case BT_LF:
-          case BT_CR:
-            break;
-          default:
-            *nextTokPtr = ptr;
-            return XML_TOK_INVALID;
-          }
-        }
-        ptr += MINBPC(enc);
-        /* in attribute value */
-        for (;;) {
-          int t;
-          REQUIRE_CHAR(enc, ptr, end);
-          t = BYTE_TYPE(enc, ptr);
-          if (t == open)
-            break;
-          switch (t) {
-          INVALID_CASES(ptr, nextTokPtr)
-          case BT_AMP:
-            {
-              int tok = PREFIX(scanRef)(enc, ptr + MINBPC(enc), end, &ptr);
-              if (tok <= 0) {
-                if (tok == XML_TOK_INVALID)
-                  *nextTokPtr = ptr;
-                return tok;
-              }
-              break;
-            }
-          case BT_LT:
-            *nextTokPtr = ptr;
-            return XML_TOK_INVALID;
-          default:
-            ptr += MINBPC(enc);
-            break;
-          }
-        }
-        ptr += MINBPC(enc);
-        REQUIRE_CHAR(enc, ptr, end);
-        switch (BYTE_TYPE(enc, ptr)) {
-        case BT_S:
-        case BT_CR:
-        case BT_LF:
-          break;
-        case BT_SOL:
-          goto sol;
-        case BT_GT:
-          goto gt;
-        default:
-          *nextTokPtr = ptr;
-          return XML_TOK_INVALID;
-        }
-        /* ptr points to closing quote */
-        for (;;) {
-          ptr += MINBPC(enc);
-          REQUIRE_CHAR(enc, ptr, end);
-          switch (BYTE_TYPE(enc, ptr)) {
-          CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
-          case BT_S: case BT_CR: case BT_LF:
-            continue;
-          case BT_GT:
-          gt:
-            *nextTokPtr = ptr + MINBPC(enc);
-            return XML_TOK_START_TAG_WITH_ATTS;
-          case BT_SOL:
-          sol:
-            ptr += MINBPC(enc);
-            REQUIRE_CHAR(enc, ptr, end);
-            if (!CHAR_MATCHES(enc, ptr, ASCII_GT)) {
-              *nextTokPtr = ptr;
-              return XML_TOK_INVALID;
-            }
-            *nextTokPtr = ptr + MINBPC(enc);
-            return XML_TOK_EMPTY_ELEMENT_WITH_ATTS;
-          default:
-            *nextTokPtr = ptr;
-            return XML_TOK_INVALID;
-          }
-          break;
-        }
-        break;
-      }
-    default:
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-  }
-  return XML_TOK_PARTIAL;
-}
-
-/* ptr points to character following "<" */
-
-static int PTRCALL
-PREFIX(scanLt)(const ENCODING *enc, const char *ptr, const char *end,
-               const char **nextTokPtr)
-{
-#ifdef XML_NS
-  int hadColon;
-#endif
-  REQUIRE_CHAR(enc, ptr, end);
-  switch (BYTE_TYPE(enc, ptr)) {
-  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
-  case BT_EXCL:
-    ptr += MINBPC(enc);
-    REQUIRE_CHAR(enc, ptr, end);
-    switch (BYTE_TYPE(enc, ptr)) {
-    case BT_MINUS:
-      return PREFIX(scanComment)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-    case BT_LSQB:
-      return PREFIX(scanCdataSection)(enc, ptr + MINBPC(enc),
-                                      end, nextTokPtr);
-    }
-    *nextTokPtr = ptr;
-    return XML_TOK_INVALID;
-  case BT_QUEST:
-    return PREFIX(scanPi)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-  case BT_SOL:
-    return PREFIX(scanEndTag)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-  default:
-    *nextTokPtr = ptr;
-    return XML_TOK_INVALID;
-  }
-#ifdef XML_NS
-  hadColon = 0;
-#endif
-  /* we have a start-tag */
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
-#ifdef XML_NS
-    case BT_COLON:
-      if (hadColon) {
-        *nextTokPtr = ptr;
-        return XML_TOK_INVALID;
-      }
-      hadColon = 1;
-      ptr += MINBPC(enc);
-      REQUIRE_CHAR(enc, ptr, end);
-      switch (BYTE_TYPE(enc, ptr)) {
-      CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
-      default:
-        *nextTokPtr = ptr;
-        return XML_TOK_INVALID;
-      }
-      break;
-#endif
-    case BT_S: case BT_CR: case BT_LF:
-      {
-        ptr += MINBPC(enc);
-        while (HAS_CHAR(enc, ptr, end)) {
-          switch (BYTE_TYPE(enc, ptr)) {
-          CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
-          case BT_GT:
-            goto gt;
-          case BT_SOL:
-            goto sol;
-          case BT_S: case BT_CR: case BT_LF:
-            ptr += MINBPC(enc);
-            continue;
-          default:
-            *nextTokPtr = ptr;
-            return XML_TOK_INVALID;
-          }
-          return PREFIX(scanAtts)(enc, ptr, end, nextTokPtr);
-        }
-        return XML_TOK_PARTIAL;
-      }
-    case BT_GT:
-    gt:
-      *nextTokPtr = ptr + MINBPC(enc);
-      return XML_TOK_START_TAG_NO_ATTS;
-    case BT_SOL:
-    sol:
-      ptr += MINBPC(enc);
-      REQUIRE_CHAR(enc, ptr, end);
-      if (!CHAR_MATCHES(enc, ptr, ASCII_GT)) {
-        *nextTokPtr = ptr;
-        return XML_TOK_INVALID;
-      }
-      *nextTokPtr = ptr + MINBPC(enc);
-      return XML_TOK_EMPTY_ELEMENT_NO_ATTS;
-    default:
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-  }
-  return XML_TOK_PARTIAL;
-}
-
-static int PTRCALL
-PREFIX(contentTok)(const ENCODING *enc, const char *ptr, const char *end,
-                   const char **nextTokPtr)
-{
-  if (ptr >= end)
-    return XML_TOK_NONE;
-  if (MINBPC(enc) > 1) {
-    size_t n = end - ptr;
-    if (n & (MINBPC(enc) - 1)) {
-      n &= ~(MINBPC(enc) - 1);
-      if (n == 0)
-        return XML_TOK_PARTIAL;
-      end = ptr + n;
-    }
-  }
-  switch (BYTE_TYPE(enc, ptr)) {
-  case BT_LT:
-    return PREFIX(scanLt)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-  case BT_AMP:
-    return PREFIX(scanRef)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-  case BT_CR:
-    ptr += MINBPC(enc);
-    if (! HAS_CHAR(enc, ptr, end))
-      return XML_TOK_TRAILING_CR;
-    if (BYTE_TYPE(enc, ptr) == BT_LF)
-      ptr += MINBPC(enc);
-    *nextTokPtr = ptr;
-    return XML_TOK_DATA_NEWLINE;
-  case BT_LF:
-    *nextTokPtr = ptr + MINBPC(enc);
-    return XML_TOK_DATA_NEWLINE;
-  case BT_RSQB:
-    ptr += MINBPC(enc);
-    if (! HAS_CHAR(enc, ptr, end))
-      return XML_TOK_TRAILING_RSQB;
-    if (!CHAR_MATCHES(enc, ptr, ASCII_RSQB))
-      break;
-    ptr += MINBPC(enc);
-    if (! HAS_CHAR(enc, ptr, end))
-      return XML_TOK_TRAILING_RSQB;
-    if (!CHAR_MATCHES(enc, ptr, ASCII_GT)) {
-      ptr -= MINBPC(enc);
-      break;
-    }
-    *nextTokPtr = ptr;
-    return XML_TOK_INVALID;
-  INVALID_CASES(ptr, nextTokPtr)
-  default:
-    ptr += MINBPC(enc);
-    break;
-  }
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-#define LEAD_CASE(n) \
-    case BT_LEAD ## n: \
-      if (end - ptr < n || IS_INVALID_CHAR(enc, ptr, n)) { \
-        *nextTokPtr = ptr; \
-        return XML_TOK_DATA_CHARS; \
-      } \
-      ptr += n; \
-      break;
-    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
-#undef LEAD_CASE
-    case BT_RSQB:
-      if (HAS_CHARS(enc, ptr, end, 2)) {
-         if (!CHAR_MATCHES(enc, ptr + MINBPC(enc), ASCII_RSQB)) {
-           ptr += MINBPC(enc);
-           break;
-         }
-         if (HAS_CHARS(enc, ptr, end, 3)) {
-           if (!CHAR_MATCHES(enc, ptr + 2*MINBPC(enc), ASCII_GT)) {
-             ptr += MINBPC(enc);
-             break;
-           }
-           *nextTokPtr = ptr + 2*MINBPC(enc);
-           return XML_TOK_INVALID;
-         }
-      }
-      /* fall through */
-    case BT_AMP:
-    case BT_LT:
-    case BT_NONXML:
-    case BT_MALFORM:
-    case BT_TRAIL:
-    case BT_CR:
-    case BT_LF:
-      *nextTokPtr = ptr;
-      return XML_TOK_DATA_CHARS;
-    default:
-      ptr += MINBPC(enc);
-      break;
-    }
-  }
-  *nextTokPtr = ptr;
-  return XML_TOK_DATA_CHARS;
-}
-
-/* ptr points to character following "%" */
-
-static int PTRCALL
-PREFIX(scanPercent)(const ENCODING *enc, const char *ptr, const char *end,
-                    const char **nextTokPtr)
-{
-  REQUIRE_CHAR(enc, ptr, end);
-  switch (BYTE_TYPE(enc, ptr)) {
-  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
-  case BT_S: case BT_LF: case BT_CR: case BT_PERCNT:
-    *nextTokPtr = ptr;
-    return XML_TOK_PERCENT;
-  default:
-    *nextTokPtr = ptr;
-    return XML_TOK_INVALID;
-  }
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
-    case BT_SEMI:
-      *nextTokPtr = ptr + MINBPC(enc);
-      return XML_TOK_PARAM_ENTITY_REF;
-    default:
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-  }
-  return XML_TOK_PARTIAL;
-}
-
-static int PTRCALL
-PREFIX(scanPoundName)(const ENCODING *enc, const char *ptr, const char *end,
-                      const char **nextTokPtr)
-{
-  REQUIRE_CHAR(enc, ptr, end);
-  switch (BYTE_TYPE(enc, ptr)) {
-  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
-  default:
-    *nextTokPtr = ptr;
-    return XML_TOK_INVALID;
-  }
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
-    case BT_CR: case BT_LF: case BT_S:
-    case BT_RPAR: case BT_GT: case BT_PERCNT: case BT_VERBAR:
-      *nextTokPtr = ptr;
-      return XML_TOK_POUND_NAME;
-    default:
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-  }
-  return -XML_TOK_POUND_NAME;
-}
-
-static int PTRCALL
-PREFIX(scanLit)(int open, const ENCODING *enc,
-                const char *ptr, const char *end,
-                const char **nextTokPtr)
-{
-  while (HAS_CHAR(enc, ptr, end)) {
-    int t = BYTE_TYPE(enc, ptr);
-    switch (t) {
-    INVALID_CASES(ptr, nextTokPtr)
-    case BT_QUOT:
-    case BT_APOS:
-      ptr += MINBPC(enc);
-      if (t != open)
-        break;
-      if (! HAS_CHAR(enc, ptr, end))
-        return -XML_TOK_LITERAL;
-      *nextTokPtr = ptr;
-      switch (BYTE_TYPE(enc, ptr)) {
-      case BT_S: case BT_CR: case BT_LF:
-      case BT_GT: case BT_PERCNT: case BT_LSQB:
-        return XML_TOK_LITERAL;
-      default:
-        return XML_TOK_INVALID;
-      }
-    default:
-      ptr += MINBPC(enc);
-      break;
-    }
-  }
-  return XML_TOK_PARTIAL;
-}
-
-static int PTRCALL
-PREFIX(prologTok)(const ENCODING *enc, const char *ptr, const char *end,
-                  const char **nextTokPtr)
-{
-  int tok;
-  if (ptr >= end)
-    return XML_TOK_NONE;
-  if (MINBPC(enc) > 1) {
-    size_t n = end - ptr;
-    if (n & (MINBPC(enc) - 1)) {
-      n &= ~(MINBPC(enc) - 1);
-      if (n == 0)
-        return XML_TOK_PARTIAL;
-      end = ptr + n;
-    }
-  }
-  switch (BYTE_TYPE(enc, ptr)) {
-  case BT_QUOT:
-    return PREFIX(scanLit)(BT_QUOT, enc, ptr + MINBPC(enc), end, nextTokPtr);
-  case BT_APOS:
-    return PREFIX(scanLit)(BT_APOS, enc, ptr + MINBPC(enc), end, nextTokPtr);
-  case BT_LT:
-    {
-      ptr += MINBPC(enc);
-      REQUIRE_CHAR(enc, ptr, end);
-      switch (BYTE_TYPE(enc, ptr)) {
-      case BT_EXCL:
-        return PREFIX(scanDecl)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-      case BT_QUEST:
-        return PREFIX(scanPi)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-      case BT_NMSTRT:
-      case BT_HEX:
-      case BT_NONASCII:
-      case BT_LEAD2:
-      case BT_LEAD3:
-      case BT_LEAD4:
-        *nextTokPtr = ptr - MINBPC(enc);
-        return XML_TOK_INSTANCE_START;
-      }
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-  case BT_CR:
-    if (ptr + MINBPC(enc) == end) {
-      *nextTokPtr = end;
-      /* indicate that this might be part of a CR/LF pair */
-      return -XML_TOK_PROLOG_S;
-    }
-    /* fall through */
-  case BT_S: case BT_LF:
-    for (;;) {
-      ptr += MINBPC(enc);
-      if (! HAS_CHAR(enc, ptr, end))
-        break;
-      switch (BYTE_TYPE(enc, ptr)) {
-      case BT_S: case BT_LF:
-        break;
-      case BT_CR:
-        /* don't split CR/LF pair */
-        if (ptr + MINBPC(enc) != end)
-          break;
-        /* fall through */
-      default:
-        *nextTokPtr = ptr;
-        return XML_TOK_PROLOG_S;
-      }
-    }
-    *nextTokPtr = ptr;
-    return XML_TOK_PROLOG_S;
-  case BT_PERCNT:
-    return PREFIX(scanPercent)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-  case BT_COMMA:
-    *nextTokPtr = ptr + MINBPC(enc);
-    return XML_TOK_COMMA;
-  case BT_LSQB:
-    *nextTokPtr = ptr + MINBPC(enc);
-    return XML_TOK_OPEN_BRACKET;
-  case BT_RSQB:
-    ptr += MINBPC(enc);
-    if (! HAS_CHAR(enc, ptr, end))
-      return -XML_TOK_CLOSE_BRACKET;
-    if (CHAR_MATCHES(enc, ptr, ASCII_RSQB)) {
-      REQUIRE_CHARS(enc, ptr, end, 2);
-      if (CHAR_MATCHES(enc, ptr + MINBPC(enc), ASCII_GT)) {
-        *nextTokPtr = ptr + 2*MINBPC(enc);
-        return XML_TOK_COND_SECT_CLOSE;
-      }
-    }
-    *nextTokPtr = ptr;
-    return XML_TOK_CLOSE_BRACKET;
-  case BT_LPAR:
-    *nextTokPtr = ptr + MINBPC(enc);
-    return XML_TOK_OPEN_PAREN;
-  case BT_RPAR:
-    ptr += MINBPC(enc);
-    if (! HAS_CHAR(enc, ptr, end))
-      return -XML_TOK_CLOSE_PAREN;
-    switch (BYTE_TYPE(enc, ptr)) {
-    case BT_AST:
-      *nextTokPtr = ptr + MINBPC(enc);
-      return XML_TOK_CLOSE_PAREN_ASTERISK;
-    case BT_QUEST:
-      *nextTokPtr = ptr + MINBPC(enc);
-      return XML_TOK_CLOSE_PAREN_QUESTION;
-    case BT_PLUS:
-      *nextTokPtr = ptr + MINBPC(enc);
-      return XML_TOK_CLOSE_PAREN_PLUS;
-    case BT_CR: case BT_LF: case BT_S:
-    case BT_GT: case BT_COMMA: case BT_VERBAR:
-    case BT_RPAR:
-      *nextTokPtr = ptr;
-      return XML_TOK_CLOSE_PAREN;
-    }
-    *nextTokPtr = ptr;
-    return XML_TOK_INVALID;
-  case BT_VERBAR:
-    *nextTokPtr = ptr + MINBPC(enc);
-    return XML_TOK_OR;
-  case BT_GT:
-    *nextTokPtr = ptr + MINBPC(enc);
-    return XML_TOK_DECL_CLOSE;
-  case BT_NUM:
-    return PREFIX(scanPoundName)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-#define LEAD_CASE(n) \
-  case BT_LEAD ## n: \
-    if (end - ptr < n) \
-      return XML_TOK_PARTIAL_CHAR; \
-    if (IS_NMSTRT_CHAR(enc, ptr, n)) { \
-      ptr += n; \
-      tok = XML_TOK_NAME; \
-      break; \
-    } \
-    if (IS_NAME_CHAR(enc, ptr, n)) { \
-      ptr += n; \
-      tok = XML_TOK_NMTOKEN; \
-      break; \
-    } \
-    *nextTokPtr = ptr; \
-    return XML_TOK_INVALID;
-    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
-#undef LEAD_CASE
-  case BT_NMSTRT:
-  case BT_HEX:
-    tok = XML_TOK_NAME;
-    ptr += MINBPC(enc);
-    break;
-  case BT_DIGIT:
-  case BT_NAME:
-  case BT_MINUS:
-#ifdef XML_NS
-  case BT_COLON:
-#endif
-    tok = XML_TOK_NMTOKEN;
-    ptr += MINBPC(enc);
-    break;
-  case BT_NONASCII:
-    if (IS_NMSTRT_CHAR_MINBPC(enc, ptr)) {
-      ptr += MINBPC(enc);
-      tok = XML_TOK_NAME;
-      break;
-    }
-    if (IS_NAME_CHAR_MINBPC(enc, ptr)) {
-      ptr += MINBPC(enc);
-      tok = XML_TOK_NMTOKEN;
-      break;
-    }
-    /* fall through */
-  default:
-    *nextTokPtr = ptr;
-    return XML_TOK_INVALID;
-  }
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
-    case BT_GT: case BT_RPAR: case BT_COMMA:
-    case BT_VERBAR: case BT_LSQB: case BT_PERCNT:
-    case BT_S: case BT_CR: case BT_LF:
-      *nextTokPtr = ptr;
-      return tok;
-#ifdef XML_NS
-    case BT_COLON:
-      ptr += MINBPC(enc);
-      switch (tok) {
-      case XML_TOK_NAME:
-        REQUIRE_CHAR(enc, ptr, end);
-        tok = XML_TOK_PREFIXED_NAME;
-        switch (BYTE_TYPE(enc, ptr)) {
-        CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
-        default:
-          tok = XML_TOK_NMTOKEN;
-          break;
-        }
-        break;
-      case XML_TOK_PREFIXED_NAME:
-        tok = XML_TOK_NMTOKEN;
-        break;
-      }
-      break;
-#endif
-    case BT_PLUS:
-      if (tok == XML_TOK_NMTOKEN)  {
-        *nextTokPtr = ptr;
-        return XML_TOK_INVALID;
-      }
-      *nextTokPtr = ptr + MINBPC(enc);
-      return XML_TOK_NAME_PLUS;
-    case BT_AST:
-      if (tok == XML_TOK_NMTOKEN)  {
-        *nextTokPtr = ptr;
-        return XML_TOK_INVALID;
-      }
-      *nextTokPtr = ptr + MINBPC(enc);
-      return XML_TOK_NAME_ASTERISK;
-    case BT_QUEST:
-      if (tok == XML_TOK_NMTOKEN)  {
-        *nextTokPtr = ptr;
-        return XML_TOK_INVALID;
-      }
-      *nextTokPtr = ptr + MINBPC(enc);
-      return XML_TOK_NAME_QUESTION;
-    default:
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    }
-  }
-  return -tok;
-}
-
-static int PTRCALL
-PREFIX(attributeValueTok)(const ENCODING *enc, const char *ptr,
-                          const char *end, const char **nextTokPtr)
-{
-  const char *start;
-  if (ptr >= end)
-    return XML_TOK_NONE;
-  else if (! HAS_CHAR(enc, ptr, end)) {
-    /* This line cannot be executed.  The incoming data has already
-     * been tokenized once, so incomplete characters like this have
-     * already been eliminated from the input.  Retaining the paranoia
-     * check is still valuable, however.
-     */
-    return XML_TOK_PARTIAL; /* LCOV_EXCL_LINE */
-  }
-  start = ptr;
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-#define LEAD_CASE(n) \
-    case BT_LEAD ## n: ptr += n; break;
-    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
-#undef LEAD_CASE
-    case BT_AMP:
-      if (ptr == start)
-        return PREFIX(scanRef)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-      *nextTokPtr = ptr;
-      return XML_TOK_DATA_CHARS;
-    case BT_LT:
-      /* this is for inside entity references */
-      *nextTokPtr = ptr;
-      return XML_TOK_INVALID;
-    case BT_LF:
-      if (ptr == start) {
-        *nextTokPtr = ptr + MINBPC(enc);
-        return XML_TOK_DATA_NEWLINE;
-      }
-      *nextTokPtr = ptr;
-      return XML_TOK_DATA_CHARS;
-    case BT_CR:
-      if (ptr == start) {
-        ptr += MINBPC(enc);
-        if (! HAS_CHAR(enc, ptr, end))
-          return XML_TOK_TRAILING_CR;
-        if (BYTE_TYPE(enc, ptr) == BT_LF)
-          ptr += MINBPC(enc);
-        *nextTokPtr = ptr;
-        return XML_TOK_DATA_NEWLINE;
-      }
-      *nextTokPtr = ptr;
-      return XML_TOK_DATA_CHARS;
-    case BT_S:
-      if (ptr == start) {
-        *nextTokPtr = ptr + MINBPC(enc);
-        return XML_TOK_ATTRIBUTE_VALUE_S;
-      }
-      *nextTokPtr = ptr;
-      return XML_TOK_DATA_CHARS;
-    default:
-      ptr += MINBPC(enc);
-      break;
-    }
-  }
-  *nextTokPtr = ptr;
-  return XML_TOK_DATA_CHARS;
-}
-
-static int PTRCALL
-PREFIX(entityValueTok)(const ENCODING *enc, const char *ptr,
-                       const char *end, const char **nextTokPtr)
-{
-  const char *start;
-  if (ptr >= end)
-    return XML_TOK_NONE;
-  else if (! HAS_CHAR(enc, ptr, end)) {
-    /* This line cannot be executed.  The incoming data has already
-     * been tokenized once, so incomplete characters like this have
-     * already been eliminated from the input.  Retaining the paranoia
-     * check is still valuable, however.
-     */
-    return XML_TOK_PARTIAL; /* LCOV_EXCL_LINE */
-  }
-  start = ptr;
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-#define LEAD_CASE(n) \
-    case BT_LEAD ## n: ptr += n; break;
-    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
-#undef LEAD_CASE
-    case BT_AMP:
-      if (ptr == start)
-        return PREFIX(scanRef)(enc, ptr + MINBPC(enc), end, nextTokPtr);
-      *nextTokPtr = ptr;
-      return XML_TOK_DATA_CHARS;
-    case BT_PERCNT:
-      if (ptr == start) {
-        int tok =  PREFIX(scanPercent)(enc, ptr + MINBPC(enc),
-                                       end, nextTokPtr);
-        return (tok == XML_TOK_PERCENT) ? XML_TOK_INVALID : tok;
-      }
-      *nextTokPtr = ptr;
-      return XML_TOK_DATA_CHARS;
-    case BT_LF:
-      if (ptr == start) {
-        *nextTokPtr = ptr + MINBPC(enc);
-        return XML_TOK_DATA_NEWLINE;
-      }
-      *nextTokPtr = ptr;
-      return XML_TOK_DATA_CHARS;
-    case BT_CR:
-      if (ptr == start) {
-        ptr += MINBPC(enc);
-        if (! HAS_CHAR(enc, ptr, end))
-          return XML_TOK_TRAILING_CR;
-        if (BYTE_TYPE(enc, ptr) == BT_LF)
-          ptr += MINBPC(enc);
-        *nextTokPtr = ptr;
-        return XML_TOK_DATA_NEWLINE;
-      }
-      *nextTokPtr = ptr;
-      return XML_TOK_DATA_CHARS;
-    default:
-      ptr += MINBPC(enc);
-      break;
-    }
-  }
-  *nextTokPtr = ptr;
-  return XML_TOK_DATA_CHARS;
-}
-
-#ifdef XML_DTD
-
-static int PTRCALL
-PREFIX(ignoreSectionTok)(const ENCODING *enc, const char *ptr,
-                         const char *end, const char **nextTokPtr)
-{
-  int level = 0;
-  if (MINBPC(enc) > 1) {
-    size_t n = end - ptr;
-    if (n & (MINBPC(enc) - 1)) {
-      n &= ~(MINBPC(enc) - 1);
-      end = ptr + n;
-    }
-  }
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-    INVALID_CASES(ptr, nextTokPtr)
-    case BT_LT:
-      ptr += MINBPC(enc);
-      REQUIRE_CHAR(enc, ptr, end);
-      if (CHAR_MATCHES(enc, ptr, ASCII_EXCL)) {
-        ptr += MINBPC(enc);
-        REQUIRE_CHAR(enc, ptr, end);
-        if (CHAR_MATCHES(enc, ptr, ASCII_LSQB)) {
-          ++level;
-          ptr += MINBPC(enc);
-        }
-      }
-      break;
-    case BT_RSQB:
-      ptr += MINBPC(enc);
-      REQUIRE_CHAR(enc, ptr, end);
-      if (CHAR_MATCHES(enc, ptr, ASCII_RSQB)) {
-        ptr += MINBPC(enc);
-        REQUIRE_CHAR(enc, ptr, end);
-        if (CHAR_MATCHES(enc, ptr, ASCII_GT)) {
-          ptr += MINBPC(enc);
-          if (level == 0) {
-            *nextTokPtr = ptr;
-            return XML_TOK_IGNORE_SECT;
-          }
-          --level;
-        }
-      }
-      break;
-    default:
-      ptr += MINBPC(enc);
-      break;
-    }
-  }
-  return XML_TOK_PARTIAL;
-}
-
-#endif /* XML_DTD */
-
-static int PTRCALL
-PREFIX(isPublicId)(const ENCODING *enc, const char *ptr, const char *end,
-                   const char **badPtr)
-{
-  ptr += MINBPC(enc);
-  end -= MINBPC(enc);
-  for (; HAS_CHAR(enc, ptr, end); ptr += MINBPC(enc)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-    case BT_DIGIT:
-    case BT_HEX:
-    case BT_MINUS:
-    case BT_APOS:
-    case BT_LPAR:
-    case BT_RPAR:
-    case BT_PLUS:
-    case BT_COMMA:
-    case BT_SOL:
-    case BT_EQUALS:
-    case BT_QUEST:
-    case BT_CR:
-    case BT_LF:
-    case BT_SEMI:
-    case BT_EXCL:
-    case BT_AST:
-    case BT_PERCNT:
-    case BT_NUM:
-#ifdef XML_NS
-    case BT_COLON:
-#endif
-      break;
-    case BT_S:
-      if (CHAR_MATCHES(enc, ptr, ASCII_TAB)) {
-        *badPtr = ptr;
-        return 0;
-      }
-      break;
-    case BT_NAME:
-    case BT_NMSTRT:
-      if (!(BYTE_TO_ASCII(enc, ptr) & ~0x7f))
-        break;
-    default:
-      switch (BYTE_TO_ASCII(enc, ptr)) {
-      case 0x24: /* $ */
-      case 0x40: /* @ */
-        break;
-      default:
-        *badPtr = ptr;
-        return 0;
-      }
-      break;
-    }
-  }
-  return 1;
-}
-
-/* This must only be called for a well-formed start-tag or empty
-   element tag.  Returns the number of attributes.  Pointers to the
-   first attsMax attributes are stored in atts.
-*/
-
-static int PTRCALL
-PREFIX(getAtts)(const ENCODING *enc, const char *ptr,
-                int attsMax, ATTRIBUTE *atts)
-{
-  enum { other, inName, inValue } state = inName;
-  int nAtts = 0;
-  int open = 0; /* defined when state == inValue;
-                   initialization just to shut up compilers */
-
-  for (ptr += MINBPC(enc);; ptr += MINBPC(enc)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-#define START_NAME \
-      if (state == other) { \
-        if (nAtts < attsMax) { \
-          atts[nAtts].name = ptr; \
-          atts[nAtts].normalized = 1; \
-        } \
-        state = inName; \
-      }
-#define LEAD_CASE(n) \
-    case BT_LEAD ## n: START_NAME ptr += (n - MINBPC(enc)); break;
-    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
-#undef LEAD_CASE
-    case BT_NONASCII:
-    case BT_NMSTRT:
-    case BT_HEX:
-      START_NAME
-      break;
-#undef START_NAME
-    case BT_QUOT:
-      if (state != inValue) {
-        if (nAtts < attsMax)
-          atts[nAtts].valuePtr = ptr + MINBPC(enc);
-        state = inValue;
-        open = BT_QUOT;
-      }
-      else if (open == BT_QUOT) {
-        state = other;
-        if (nAtts < attsMax)
-          atts[nAtts].valueEnd = ptr;
-        nAtts++;
-      }
-      break;
-    case BT_APOS:
-      if (state != inValue) {
-        if (nAtts < attsMax)
-          atts[nAtts].valuePtr = ptr + MINBPC(enc);
-        state = inValue;
-        open = BT_APOS;
-      }
-      else if (open == BT_APOS) {
-        state = other;
-        if (nAtts < attsMax)
-          atts[nAtts].valueEnd = ptr;
-        nAtts++;
-      }
-      break;
-    case BT_AMP:
-      if (nAtts < attsMax)
-        atts[nAtts].normalized = 0;
-      break;
-    case BT_S:
-      if (state == inName)
-        state = other;
-      else if (state == inValue
-               && nAtts < attsMax
-               && atts[nAtts].normalized
-               && (ptr == atts[nAtts].valuePtr
-                   || BYTE_TO_ASCII(enc, ptr) != ASCII_SPACE
-                   || BYTE_TO_ASCII(enc, ptr + MINBPC(enc)) == ASCII_SPACE
-                   || BYTE_TYPE(enc, ptr + MINBPC(enc)) == open))
-        atts[nAtts].normalized = 0;
-      break;
-    case BT_CR: case BT_LF:
-      /* This case ensures that the first attribute name is counted
-         Apart from that we could just change state on the quote. */
-      if (state == inName)
-        state = other;
-      else if (state == inValue && nAtts < attsMax)
-        atts[nAtts].normalized = 0;
-      break;
-    case BT_GT:
-    case BT_SOL:
-      if (state != inValue)
-        return nAtts;
-      break;
-    default:
-      break;
-    }
-  }
-  /* not reached */
-}
-
-static int PTRFASTCALL
-PREFIX(charRefNumber)(const ENCODING *UNUSED_P(enc), const char *ptr)
-{
-  int result = 0;
-  /* skip &# */
-  ptr += 2*MINBPC(enc);
-  if (CHAR_MATCHES(enc, ptr, ASCII_x)) {
-    for (ptr += MINBPC(enc);
-         !CHAR_MATCHES(enc, ptr, ASCII_SEMI);
-         ptr += MINBPC(enc)) {
-      int c = BYTE_TO_ASCII(enc, ptr);
-      switch (c) {
-      case ASCII_0: case ASCII_1: case ASCII_2: case ASCII_3: case ASCII_4:
-      case ASCII_5: case ASCII_6: case ASCII_7: case ASCII_8: case ASCII_9:
-        result <<= 4;
-        result |= (c - ASCII_0);
-        break;
-      case ASCII_A: case ASCII_B: case ASCII_C:
-      case ASCII_D: case ASCII_E: case ASCII_F:
-        result <<= 4;
-        result += 10 + (c - ASCII_A);
-        break;
-      case ASCII_a: case ASCII_b: case ASCII_c:
-      case ASCII_d: case ASCII_e: case ASCII_f:
-        result <<= 4;
-        result += 10 + (c - ASCII_a);
-        break;
-      }
-      if (result >= 0x110000)
-        return -1;
-    }
-  }
-  else {
-    for (; !CHAR_MATCHES(enc, ptr, ASCII_SEMI); ptr += MINBPC(enc)) {
-      int c = BYTE_TO_ASCII(enc, ptr);
-      result *= 10;
-      result += (c - ASCII_0);
-      if (result >= 0x110000)
-        return -1;
-    }
-  }
-  return checkCharRefNumber(result);
-}
-
-static int PTRCALL
-PREFIX(predefinedEntityName)(const ENCODING *UNUSED_P(enc), const char *ptr,
-                             const char *end)
-{
-  switch ((end - ptr)/MINBPC(enc)) {
-  case 2:
-    if (CHAR_MATCHES(enc, ptr + MINBPC(enc), ASCII_t)) {
-      switch (BYTE_TO_ASCII(enc, ptr)) {
-      case ASCII_l:
-        return ASCII_LT;
-      case ASCII_g:
-        return ASCII_GT;
-      }
-    }
-    break;
-  case 3:
-    if (CHAR_MATCHES(enc, ptr, ASCII_a)) {
-      ptr += MINBPC(enc);
-      if (CHAR_MATCHES(enc, ptr, ASCII_m)) {
-        ptr += MINBPC(enc);
-        if (CHAR_MATCHES(enc, ptr, ASCII_p))
-          return ASCII_AMP;
-      }
-    }
-    break;
-  case 4:
-    switch (BYTE_TO_ASCII(enc, ptr)) {
-    case ASCII_q:
-      ptr += MINBPC(enc);
-      if (CHAR_MATCHES(enc, ptr, ASCII_u)) {
-        ptr += MINBPC(enc);
-        if (CHAR_MATCHES(enc, ptr, ASCII_o)) {
-          ptr += MINBPC(enc);
-          if (CHAR_MATCHES(enc, ptr, ASCII_t))
-            return ASCII_QUOT;
-        }
-      }
-      break;
-    case ASCII_a:
-      ptr += MINBPC(enc);
-      if (CHAR_MATCHES(enc, ptr, ASCII_p)) {
-        ptr += MINBPC(enc);
-        if (CHAR_MATCHES(enc, ptr, ASCII_o)) {
-          ptr += MINBPC(enc);
-          if (CHAR_MATCHES(enc, ptr, ASCII_s))
-            return ASCII_APOS;
-        }
-      }
-      break;
-    }
-  }
-  return 0;
-}
-
-/* This function does not appear to be called from anywhere within the
- * library code.  It is used via the macro XmlSameName(), which is
- * defined but never used.  Since it appears in the encoding function
- * table, removing it is not a thing to be undertaken lightly.  For
- * the moment, we simply exclude it from coverage tests.
- *
- * LCOV_EXCL_START
- */
-static int PTRCALL
-PREFIX(sameName)(const ENCODING *enc, const char *ptr1, const char *ptr2)
-{
-  for (;;) {
-    switch (BYTE_TYPE(enc, ptr1)) {
-#define LEAD_CASE(n) \
-    case BT_LEAD ## n: \
-      if (*ptr1++ != *ptr2++) \
-        return 0;
-    LEAD_CASE(4) LEAD_CASE(3) LEAD_CASE(2)
-#undef LEAD_CASE
-      /* fall through */
-      if (*ptr1++ != *ptr2++)
-        return 0;
-      break;
-    case BT_NONASCII:
-    case BT_NMSTRT:
-#ifdef XML_NS
-    case BT_COLON:
-#endif
-    case BT_HEX:
-    case BT_DIGIT:
-    case BT_NAME:
-    case BT_MINUS:
-      if (*ptr2++ != *ptr1++)
-        return 0;
-      if (MINBPC(enc) > 1) {
-        if (*ptr2++ != *ptr1++)
-          return 0;
-        if (MINBPC(enc) > 2) {
-          if (*ptr2++ != *ptr1++)
-            return 0;
-          if (MINBPC(enc) > 3) {
-            if (*ptr2++ != *ptr1++)
-              return 0;
-          }
-        }
-      }
-      break;
-    default:
-      if (MINBPC(enc) == 1 && *ptr1 == *ptr2)
-        return 1;
-      switch (BYTE_TYPE(enc, ptr2)) {
-      case BT_LEAD2:
-      case BT_LEAD3:
-      case BT_LEAD4:
-      case BT_NONASCII:
-      case BT_NMSTRT:
-#ifdef XML_NS
-      case BT_COLON:
-#endif
-      case BT_HEX:
-      case BT_DIGIT:
-      case BT_NAME:
-      case BT_MINUS:
-        return 0;
-      default:
-        return 1;
-      }
-    }
-  }
-  /* not reached */
-}
-/* LCOV_EXCL_STOP */
-
-static int PTRCALL
-PREFIX(nameMatchesAscii)(const ENCODING *UNUSED_P(enc), const char *ptr1,
-                         const char *end1, const char *ptr2)
-{
-  for (; *ptr2; ptr1 += MINBPC(enc), ptr2++) {
-    if (end1 - ptr1 < MINBPC(enc)) {
-      /* This line cannot be executed.  THe incoming data has already
-       * been tokenized once, so imcomplete characters like this have
-       * already been eliminated from the input.  Retaining the
-       * paranoia check is still valuable, however.
-       */
-      return 0; /* LCOV_EXCL_LINE */
-    }
-    if (!CHAR_MATCHES(enc, ptr1, *ptr2))
-      return 0;
-  }
-  return ptr1 == end1;
-}
-
-static int PTRFASTCALL
-PREFIX(nameLength)(const ENCODING *enc, const char *ptr)
-{
-  const char *start = ptr;
-  for (;;) {
-    switch (BYTE_TYPE(enc, ptr)) {
-#define LEAD_CASE(n) \
-    case BT_LEAD ## n: ptr += n; break;
-    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
-#undef LEAD_CASE
-    case BT_NONASCII:
-    case BT_NMSTRT:
-#ifdef XML_NS
-    case BT_COLON:
-#endif
-    case BT_HEX:
-    case BT_DIGIT:
-    case BT_NAME:
-    case BT_MINUS:
-      ptr += MINBPC(enc);
-      break;
-    default:
-      return (int)(ptr - start);
-    }
-  }
-}
-
-static const char * PTRFASTCALL
-PREFIX(skipS)(const ENCODING *enc, const char *ptr)
-{
-  for (;;) {
-    switch (BYTE_TYPE(enc, ptr)) {
-    case BT_LF:
-    case BT_CR:
-    case BT_S:
-      ptr += MINBPC(enc);
-      break;
-    default:
-      return ptr;
-    }
-  }
-}
-
-static void PTRCALL
-PREFIX(updatePosition)(const ENCODING *enc,
-                       const char *ptr,
-                       const char *end,
-                       POSITION *pos)
-{
-  while (HAS_CHAR(enc, ptr, end)) {
-    switch (BYTE_TYPE(enc, ptr)) {
-#define LEAD_CASE(n) \
-    case BT_LEAD ## n: \
-      ptr += n; \
-      break;
-    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
-#undef LEAD_CASE
-    case BT_LF:
-      pos->columnNumber = (XML_Size)-1;
-      pos->lineNumber++;
-      ptr += MINBPC(enc);
-      break;
-    case BT_CR:
-      pos->lineNumber++;
-      ptr += MINBPC(enc);
-      if (HAS_CHAR(enc, ptr, end) && BYTE_TYPE(enc, ptr) == BT_LF)
-        ptr += MINBPC(enc);
-      pos->columnNumber = (XML_Size)-1;
-      break;
-    default:
-      ptr += MINBPC(enc);
-      break;
-    }
-    pos->columnNumber++;
-  }
-}
-
-#undef DO_LEAD_CASE
-#undef MULTIBYTE_CASES
-#undef INVALID_CASES
-#undef CHECK_NAME_CASE
-#undef CHECK_NAME_CASES
-#undef CHECK_NMSTRT_CASE
-#undef CHECK_NMSTRT_CASES
-
-#endif /* XML_TOK_IMPL_C */
diff --git a/third_party/expat/files/lib/xmltok_impl.h b/third_party/expat/files/lib/xmltok_impl.h
deleted file mode 100644
index da0ea60a657d..000000000000
--- a/third_party/expat/files/lib/xmltok_impl.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
-Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
-See the file COPYING for copying permission.
-*/
-
-enum {
-  BT_NONXML,
-  BT_MALFORM,
-  BT_LT,
-  BT_AMP,
-  BT_RSQB,
-  BT_LEAD2,
-  BT_LEAD3,
-  BT_LEAD4,
-  BT_TRAIL,
-  BT_CR,
-  BT_LF,
-  BT_GT,
-  BT_QUOT,
-  BT_APOS,
-  BT_EQUALS,
-  BT_QUEST,
-  BT_EXCL,
-  BT_SOL,
-  BT_SEMI,
-  BT_NUM,
-  BT_LSQB,
-  BT_S,
-  BT_NMSTRT,
-  BT_COLON,
-  BT_HEX,
-  BT_DIGIT,
-  BT_NAME,
-  BT_MINUS,
-  BT_OTHER, /* known not to be a name or name start character */
-  BT_NONASCII, /* might be a name or name start character */
-  BT_PERCNT,
-  BT_LPAR,
-  BT_RPAR,
-  BT_AST,
-  BT_PLUS,
-  BT_COMMA,
-  BT_VERBAR
-};
-
-#include <stddef.h>
diff --git a/third_party/expat/files/lib/xmltok_ns.c b/third_party/expat/files/lib/xmltok_ns.c
deleted file mode 100644
index c3b88fdf4e3e..000000000000
--- a/third_party/expat/files/lib/xmltok_ns.c
+++ /dev/null
@@ -1,115 +0,0 @@
-/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
-   See the file COPYING for copying permission.
-*/
-
-/* This file is included! */
-#ifdef XML_TOK_NS_C
-
-const ENCODING *
-NS(XmlGetUtf8InternalEncoding)(void)
-{
-  return &ns(internal_utf8_encoding).enc;
-}
-
-const ENCODING *
-NS(XmlGetUtf16InternalEncoding)(void)
-{
-#if BYTEORDER == 1234
-  return &ns(internal_little2_encoding).enc;
-#elif BYTEORDER == 4321
-  return &ns(internal_big2_encoding).enc;
-#else
-  const short n = 1;
-  return (*(const char *)&n
-          ? &ns(internal_little2_encoding).enc
-          : &ns(internal_big2_encoding).enc);
-#endif
-}
-
-static const ENCODING * const NS(encodings)[] = {
-  &ns(latin1_encoding).enc,
-  &ns(ascii_encoding).enc,
-  &ns(utf8_encoding).enc,
-  &ns(big2_encoding).enc,
-  &ns(big2_encoding).enc,
-  &ns(little2_encoding).enc,
-  &ns(utf8_encoding).enc /* NO_ENC */
-};
-
-static int PTRCALL
-NS(initScanProlog)(const ENCODING *enc, const char *ptr, const char *end,
-                   const char **nextTokPtr)
-{
-  return initScan(NS(encodings), (const INIT_ENCODING *)enc,
-                  XML_PROLOG_STATE, ptr, end, nextTokPtr);
-}
-
-static int PTRCALL
-NS(initScanContent)(const ENCODING *enc, const char *ptr, const char *end,
-                    const char **nextTokPtr)
-{
-  return initScan(NS(encodings), (const INIT_ENCODING *)enc,
-                  XML_CONTENT_STATE, ptr, end, nextTokPtr);
-}
-
-int
-NS(XmlInitEncoding)(INIT_ENCODING *p, const ENCODING **encPtr,
-                    const char *name)
-{
-  int i = getEncodingIndex(name);
-  if (i == UNKNOWN_ENC)
-    return 0;
-  SET_INIT_ENC_INDEX(p, i);
-  p->initEnc.scanners[XML_PROLOG_STATE] = NS(initScanProlog);
-  p->initEnc.scanners[XML_CONTENT_STATE] = NS(initScanContent);
-  p->initEnc.updatePosition = initUpdatePosition;
-  p->encPtr = encPtr;
-  *encPtr = &(p->initEnc);
-  return 1;
-}
-
-static const ENCODING *
-NS(findEncoding)(const ENCODING *enc, const char *ptr, const char *end)
-{
-#define ENCODING_MAX 128
-  char buf[ENCODING_MAX];
-  char *p = buf;
-  int i;
-  XmlUtf8Convert(enc, &ptr, end, &p, p + ENCODING_MAX - 1);
-  if (ptr != end)
-    return 0;
-  *p = 0;
-  if (streqci(buf, KW_UTF_16) && enc->minBytesPerChar == 2)
-    return enc;
-  i = getEncodingIndex(buf);
-  if (i == UNKNOWN_ENC)
-    return 0;
-  return NS(encodings)[i];
-}
-
-int
-NS(XmlParseXmlDecl)(int isGeneralTextEntity,
-                    const ENCODING *enc,
-                    const char *ptr,
-                    const char *end,
-                    const char **badPtr,
-                    const char **versionPtr,
-                    const char **versionEndPtr,
-                    const char **encodingName,
-                    const ENCODING **encoding,
-                    int *standalone)
-{
-  return doParseXmlDecl(NS(findEncoding),
-                        isGeneralTextEntity,
-                        enc,
-                        ptr,
-                        end,
-                        badPtr,
-                        versionPtr,
-                        versionEndPtr,
-                        encodingName,
-                        encoding,
-                        standalone);
-}
-
-#endif /* XML_TOK_NS_C */
diff --git a/third_party/expat/fuzz/OWNERS b/third_party/expat/fuzz/OWNERS
index 7ab46b14cbde..41160616626a 100644
--- a/third_party/expat/fuzz/OWNERS
+++ b/third_party/expat/fuzz/OWNERS
@@ -1,2 +1 @@
-mmoroz@chromium.org
 ochang@chromium.org
diff --git a/third_party/expat/fuzz/expat_xml_parse_fuzzer.cc b/third_party/expat/fuzz/expat_xml_parse_fuzzer.cc
index b41207136339..04778ebf6859 100644
--- a/third_party/expat/fuzz/expat_xml_parse_fuzzer.cc
+++ b/third_party/expat/fuzz/expat_xml_parse_fuzzer.cc
@@ -5,7 +5,7 @@
 #include <stddef.h>
 #include <stdint.h>
 
-#include "third_party/expat/files/lib/expat.h"
+#include "third_party/expat/src/expat/lib/expat.h"
 
 #include <vector>
 
diff --git a/third_party/expat/files/lib/expat_config.h b/third_party/expat/include/expat_config/expat_config.h
similarity index 78%
rename from third_party/expat/files/lib/expat_config.h
rename to third_party/expat/include/expat_config/expat_config.h
index 7d92c976c8b4..b1fe3091d90b 100644
--- a/third_party/expat/files/lib/expat_config.h
+++ b/third_party/expat/include/expat_config/expat_config.h
@@ -1,7 +1,10 @@
 /* expat_config.h.  Generated from expat_config.h.in by configure.  */
 /* expat_config.h.in.  Generated from configure.ac by autoheader.  */
 
-/* 1234 = LIL_ENDIAN, 4321 = BIGENDIAN */
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* 1234 = LILENDIAN, 4321 = BIGENDIAN */
 #define BYTEORDER 1234
 
 /* Define to 1 if you have the `arc4random' function. */
@@ -10,9 +13,6 @@
 /* Define to 1 if you have the `arc4random_buf' function. */
 /* #undef HAVE_ARC4RANDOM_BUF */
 
-/* Define to 1 if you have the `bcopy' function. */
-#define HAVE_BCOPY 1
-
 /* Define to 1 if you have the <dlfcn.h> header file. */
 #define HAVE_DLFCN_H 1
 
@@ -23,7 +23,7 @@
 #define HAVE_GETPAGESIZE 1
 
 /* Define to 1 if you have the `getrandom' function. */
-/* #undef HAVE_GETRANDOM */
+/* #define HAVE_GETRANDOM 1 */
 
 /* Define to 1 if you have the <inttypes.h> header file. */
 #define HAVE_INTTYPES_H 1
@@ -31,9 +31,6 @@
 /* Define to 1 if you have the `bsd' library (-lbsd). */
 /* #undef HAVE_LIBBSD */
 
-/* Define to 1 if you have the `memmove' function. */
-#define HAVE_MEMMOVE 1
-
 /* Define to 1 if you have the <memory.h> header file. */
 #define HAVE_MEMORY_H 1
 
@@ -53,7 +50,7 @@
 #define HAVE_STRING_H 1
 
 /* Define to 1 if you have `syscall' and `SYS_getrandom'. */
-/* #undef HAVE_SYSCALL_GETRANDOM */
+/* #define HAVE_SYSCALL_GETRANDOM 1 */
 
 /* Define to 1 if you have the <sys/param.h> header file. */
 #define HAVE_SYS_PARAM_H 1
@@ -70,6 +67,9 @@
 /* Define to the sub-directory where libtool stores uninstalled libraries. */
 #define LT_OBJDIR ".libs/"
 
+/* Name of package */
+#define PACKAGE "expat"
+
 /* Define to the address where bug reports for this package should be sent. */
 #define PACKAGE_BUGREPORT "expat-bugs@libexpat.org"
 
@@ -77,7 +77,7 @@
 #define PACKAGE_NAME "expat"
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING "expat 2.2.3"
+#define PACKAGE_STRING "expat 2.2.9"
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME "expat"
@@ -86,13 +86,29 @@
 #define PACKAGE_URL ""
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "2.2.3"
+#define PACKAGE_VERSION "2.2.9"
 
 /* Define to 1 if you have the ANSI C header files. */
 #define STDC_HEADERS 1
 
-/* whether byteorder is bigendian */
-/* #undef WORDS_BIGENDIAN */
+/* Version number of package */
+#define VERSION "2.2.9"
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Define to allow retrieving the byte offsets for attribute names and values.
+   */
+/* #undef XML_ATTR_INFO */
 
 /* Define to specify how much context to retain around the current parse
    point. */
diff --git a/third_party/expat/roll-expat.sh b/third_party/expat/roll-expat.sh
new file mode 100755
index 000000000000..18d17372a801
--- /dev/null
+++ b/third_party/expat/roll-expat.sh
@@ -0,0 +1,57 @@
+#!/bin/bash
+
+roll_deps() {
+  STEP="roll-deps" &&
+  REVIEWERS=$(grep -E -v "^$|#" third_party/expat/OWNERS | paste -s -d, -)
+  roll-dep -r "${REVIEWERS}" --roll-to origin/upstream/master "$@" src/third_party/expat/src/
+}
+
+update_readme() {
+  STEP="update README.chromium" &&
+  EXPAT_VERSION=$(git -C third_party/expat/src/ describe --long) &&
+  EXPAT_COMMIT=$(git -C third_party/expat/src/ rev-parse HEAD) &&
+  EXPAT_DATE=$(date "+%Y%m%d")
+  sed -i'' -e "s/^Version: .*\$/Version: ${EXPAT_VERSION}/" third_party/expat/README.chromium &&
+  sed -i'' -e "s/^Revision: .*\$/Revision: ${EXPAT_COMMIT}/" third_party/expat/README.chromium &&
+  sed -i'' -e "s/^Date: .*\$/Date: ${EXPAT_DATE}/" third_party/expat/README.chromium &&
+  git add third_party/expat/README.chromium
+}
+
+previous_rev() {
+  STEP="previous revision" &&
+  PREVIOUS_EXPAT_REV=$(git grep "'libexpat_revision':" HEAD~1 -- DEPS | grep -Eho "[0-9a-fA-F]{32}")
+}
+
+check_added_deleted_files() {
+  previous_rev &&
+  STEP="check for added or deleted files since last libexpat revision" &&
+  ADDED_FILES=$(git -C third_party/expat/src/ diff --diff-filter=A --name-only ${PREVIOUS_EXPAT_REV} -- src/ | paste -s -d, -) &&
+  DELETED_FILES=$(git -C third_party/expat/src/ diff --diff-filter=D --name-only ${PREVIOUS_EXPAT_REV} -- src/ | paste -s -d, -) &&
+  RENAMED_FILES=$(git -C third_party/expat/src/ diff --diff-filter=R --name-only ${PREVIOUS_EXPAT_REV} -- src/ | paste -s -d, -) &&
+  if [ -n "$ADDED_FILES" ]; then echo "Added files detected: " $ADDED_FILES; fi &&
+  if [ -n "$DELETED_FILES" ]; then echo "Deleted files detected" $DELETED_FILES; fi &&
+  if [ -n "$RENAMED_FILES" ]; then echo "Renamed files detected" $RENAMED_FILES; fi &&
+  if [ -n "$ADDED_FILES" ] || [ -n "$DELETED_FILES" ] || [ -n "$RENAMED_FILES" ]; then echo -e "\nPlease update src/third_party/expat/BUILD.gn before continuing."; fi
+}
+
+commit() {
+  STEP="commit" &&
+  git commit --quiet --amend --no-edit
+}
+
+update_expat_config_h() {
+  STEP="update expat config.h" &&
+  ( cd third_party/expat/src/expat &&
+    ./buildconf.sh &&
+    ./configure) &&
+  cp third_party/expat/src/expat/expat_config.h third_party/expat/include/expat_config/ &&
+  patch -d third_party/expat -p3 < third_party/expat/0001-Do-not-claim-getrandom.patch &&
+  git add third_party/expat/include/expat_config/expat_config.h
+}
+
+roll_deps "$@" &&
+update_readme &&
+update_expat_config_h &&
+check_added_deleted_files &&
+commit ||
+{ echo "Failed step ${STEP}"; exit 1; }
diff --git a/third_party/fontconfig/BUILD.gn b/third_party/fontconfig/BUILD.gn
index 317575891c21..1bee7acb6b97 100644
--- a/third_party/fontconfig/BUILD.gn
+++ b/third_party/fontconfig/BUILD.gn
@@ -2,9 +2,10 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/config/sanitizers/sanitizers.gni")
 import("//third_party/fontconfig/fontconfig.gni")
 
-assert(is_linux)
+assert(is_linux || is_chromeos)
 
 if (use_bundled_fontconfig) {
   config("fontconfig_config") {
@@ -58,8 +59,25 @@ if (use_bundled_fontconfig) {
     ]
 
     # Fontconfig symbols should not be exported from chrome, nacl_helper, or
-    # anything else.
-    if (!is_component_build) {
+    # anything else. However, if using the instrumented libraries, we do want to
+    # export fontconfig symbols: in this configuration, there are 3 different
+    # fontconfigs: this one, the one from instrumented_libraries, and the one
+    # from the system. Only the first two get loaded: this one from Chrome, and
+    # the one in instrumented_libraries indirectly through eg. gtk -> cairo ->
+    # fontconfig. The latter is a different version of fontconfig with a
+    # different cache file format. Therefore, the caches would have to get
+    # regenerated every time Chrome runs for this other version. Depending on
+    # how many fonts the user has installed, this could take several minutes,
+    # especially for msan builds. Exporting the newer fontconfig symbols here
+    # will ensure that cairo uses this fontconfig, and so avoids the caching
+    # issue. In non-instrumented builds, it is ok that the real system
+    # fontconfig is used by cairo instead of chromium's because caches for that
+    # are warm. We don't *always* export fontconfig because in a rare case, it's
+    # possible for the system fontconfig to be newer and have some Foo() that's
+    # not in ours. Then eg. cairo would call init functions from our fontconfig
+    # and then Foo() from the system fontconfig and crash.
+    if (!is_component_build && !(use_prebuilt_instrumented_libraries ||
+                                 use_locally_built_instrumented_libraries)) {
       defines += [
         "FC_ATTRIBUTE_VISIBILITY_HIDDEN=__attribute((visibility(\"hidden\")))",
         "FC_ATTRIBUTE_VISIBILITY_EXPORT=__attribute((visibility(\"hidden\")))",
diff --git a/third_party/fontconfig/DIR_METADATA b/third_party/fontconfig/DIR_METADATA
new file mode 100644
index 000000000000..594a7d6501fc
--- /dev/null
+++ b/third_party/fontconfig/DIR_METADATA
@@ -0,0 +1,3 @@
+monorail {
+  component: "Blink>Fonts"
+}
diff --git a/third_party/fontconfig/OWNERS b/third_party/fontconfig/OWNERS
index 17f42ca9c75d..91e296fcfffd 100644
--- a/third_party/fontconfig/OWNERS
+++ b/third_party/fontconfig/OWNERS
@@ -1,3 +1,3 @@
 spang@chromium.org
 dnicoara@chromium.org
-thomasanderson@chromium.org
+thomasanderson@chromium.org
\ No newline at end of file
diff --git a/third_party/fontconfig/README.chromium b/third_party/fontconfig/README.chromium
index 69f7c4008a29..2355a647e991 100644
--- a/third_party/fontconfig/README.chromium
+++ b/third_party/fontconfig/README.chromium
@@ -1,6 +1,7 @@
 Name: fontconfig
 URL: http://www.freedesktop.org/wiki/Software/fontconfig/
-Version: ba206df9b9a7ca300265f650842c1459ff7c634a
+Version: 452be8125f0e2a18a7dfef469e05d19374d36307
+CPEPrefix: cpe:/a:fontconfig_project:fontconfig:2.13.91
 License: MIT
 License File: src/COPYING
 Security Critical: yes
diff --git a/third_party/fontconfig/fontconfig.gni b/third_party/fontconfig/fontconfig.gni
index 0965f9fe2c34..50d9f1fa1d4d 100644
--- a/third_party/fontconfig/fontconfig.gni
+++ b/third_party/fontconfig/fontconfig.gni
@@ -2,10 +2,11 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/config/chromeos/args.gni")
 import("//build/config/features.gni")
 
-assert(is_linux)
+assert(is_linux || is_chromeos)
 
 declare_args() {
-  use_bundled_fontconfig = is_linux
+  use_bundled_fontconfig = (is_linux || is_chromeos) && !is_chromeos_device
 }
diff --git a/third_party/fontconfig/include/config.h b/third_party/fontconfig/include/config.h
index 52938df1aae7..9087ca0c15e6 100644
--- a/third_party/fontconfig/include/config.h
+++ b/third_party/fontconfig/include/config.h
@@ -73,7 +73,7 @@
 #define HAVE_FSTATVFS 1
 
 /* Define to 1 if you have the `FT_Done_MM_Var' function. */
-/* #undef HAVE_FT_DONE_MM_VAR */
+#define HAVE_FT_DONE_MM_VAR 1
 
 /* Define to 1 if you have the `FT_Get_BDF_Property' function. */
 #define HAVE_FT_GET_BDF_PROPERTY 1
@@ -270,7 +270,7 @@
 #define PACKAGE_NAME "fontconfig"
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING "fontconfig 2.13.1"
+#define PACKAGE_STRING "fontconfig 2.13.91"
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME "fontconfig"
@@ -279,7 +279,7 @@
 #define PACKAGE_URL ""
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "2.13.1"
+#define PACKAGE_VERSION "2.13.91"
 
 /* Define to necessary symbol if this constant uses a non-standard name on
    your system. */
@@ -332,7 +332,7 @@
 
 
 /* Version number of package */
-#define VERSION "2.13.1"
+#define VERSION "2.13.91"
 
 /* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
    significant byte first (like Motorola and SPARC, unlike Intel). */
diff --git a/third_party/fontconfig/include/fc-case/fccase.h b/third_party/fontconfig/include/fc-case/fccase.h
index 9cc0b9f2fbac..62d9bbaae8e1 100644
--- a/third_party/fontconfig/include/fc-case/fccase.h
+++ b/third_party/fontconfig/include/fc-case/fccase.h
@@ -22,7 +22,7 @@
  * PERFORMANCE OF THIS SOFTWARE.
  */
 
-#define FC_NUM_CASE_FOLD	291
+#define FC_NUM_CASE_FOLD	295
 #define FC_NUM_CASE_FOLD_CHARS	471
 #define FC_MAX_CASE_FOLD_CHARS	6
 #define FC_MAX_CASE_FOLD_EXPAND	4
@@ -300,7 +300,11 @@ static const FcCaseFold    fcCaseFold[FC_NUM_CASE_FOLD] = {
     { 0x0000a7b1, FC_CASE_FOLD_RANGE,    0x0001,  23254 },
     { 0x0000a7b2, FC_CASE_FOLD_RANGE,    0x0001,  23275 },
     { 0x0000a7b3, FC_CASE_FOLD_RANGE,    0x0001,    928 },
-    { 0x0000a7b4, FC_CASE_FOLD_EVEN_ODD, 0x0005,      1 },
+    { 0x0000a7b4, FC_CASE_FOLD_EVEN_ODD, 0x000b,      1 },
+    { 0x0000a7c2, FC_CASE_FOLD_EVEN_ODD, 0x0001,      1 },
+    { 0x0000a7c4, FC_CASE_FOLD_RANGE,    0x0001,    -48 },
+    { 0x0000a7c5, FC_CASE_FOLD_RANGE,    0x0001,  23229 },
+    { 0x0000a7c6, FC_CASE_FOLD_RANGE,    0x0001,  30152 },
     { 0x0000ab70, FC_CASE_FOLD_RANGE,    0x0050,  26672 },
     { 0x0000fb00, FC_CASE_FOLD_FULL,     0x0002,    435 },
     { 0x0000fb01, FC_CASE_FOLD_FULL,     0x0002,    437 },
diff --git a/third_party/fontconfig/include/src/fcalias.h b/third_party/fontconfig/include/src/fcalias.h
index 940a7b1371b5..f8cc77449d0f 100644
--- a/third_party/fontconfig/include/src/fcalias.h
+++ b/third_party/fontconfig/include/src/fcalias.h
@@ -28,6 +28,8 @@ extern __typeof (FcConfigHome) IA__FcConfigHome FC_ATTRIBUTE_VISIBILITY_HIDDEN;
 #define FcConfigHome IA__FcConfigHome
 extern __typeof (FcConfigEnableHome) IA__FcConfigEnableHome FC_ATTRIBUTE_VISIBILITY_HIDDEN;
 #define FcConfigEnableHome IA__FcConfigEnableHome
+extern __typeof (FcConfigGetFilename) IA__FcConfigGetFilename FC_ATTRIBUTE_VISIBILITY_HIDDEN;
+#define FcConfigGetFilename IA__FcConfigGetFilename
 extern __typeof (FcConfigFilename) IA__FcConfigFilename FC_ATTRIBUTE_VISIBILITY_HIDDEN;
 #define FcConfigFilename IA__FcConfigFilename
 extern __typeof (FcConfigCreate) IA__FcConfigCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;
diff --git a/third_party/fontconfig/include/src/fcaliastail.h b/third_party/fontconfig/include/src/fcaliastail.h
index 44fbc3cfdd35..c779f563f97e 100644
--- a/third_party/fontconfig/include/src/fcaliastail.h
+++ b/third_party/fontconfig/include/src/fcaliastail.h
@@ -34,6 +34,8 @@ extern __typeof (FcDirCacheDeleteUUID) FcDirCacheDeleteUUID __attribute((alias("
 extern __typeof (FcConfigHome) FcConfigHome __attribute((alias("IA__FcConfigHome"))) FC_ATTRIBUTE_VISIBILITY_EXPORT;
 # undef FcConfigEnableHome
 extern __typeof (FcConfigEnableHome) FcConfigEnableHome __attribute((alias("IA__FcConfigEnableHome"))) FC_ATTRIBUTE_VISIBILITY_EXPORT;
+# undef FcConfigGetFilename
+extern __typeof (FcConfigGetFilename) FcConfigGetFilename __attribute((alias("IA__FcConfigGetFilename"))) FC_ATTRIBUTE_VISIBILITY_EXPORT;
 # undef FcConfigFilename
 extern __typeof (FcConfigFilename) FcConfigFilename __attribute((alias("IA__FcConfigFilename"))) FC_ATTRIBUTE_VISIBILITY_EXPORT;
 # undef FcConfigCreate
diff --git a/third_party/fontconfig/include/src/fcobjshash.h b/third_party/fontconfig/include/src/fcobjshash.h
index 867a369a9e6e..7d1aa686764c 100644
--- a/third_party/fontconfig/include/src/fcobjshash.h
+++ b/third_party/fontconfig/include/src/fcobjshash.h
@@ -1,6 +1,6 @@
 /* ANSI-C code produced by gperf version 3.1 */
 /* Command-line: gperf --pic -m 100 fcobjshash.gperf  */
-/* Computed positions: -k'2-3' */
+/* Computed positions: -k'3,5' */
 
 #if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
       && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
@@ -37,7 +37,7 @@ int name;
 int id;
 };
 #include <string.h>
-/* maximum key range = 65, duplicates = 0 */
+/* maximum key range = 56, duplicates = 0 */
 
 #ifdef __GNUC__
 __inline
@@ -51,141 +51,155 @@ FcObjectTypeHash (register const char *str, register size_t len)
 {
   static const unsigned char asso_values[] =
     {
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69,  9, 21, 18,
-      33, 21, 69,  6, 36,  0, 69, 69,  0, 24,
-       9,  0, 21, 69, 33, 15, 18,  0, 69, 69,
-       0, 21,  6, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,
-      69, 69, 69, 69, 69, 69
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61,  2, 30,  4,
+      16, 29, 28, 48, 12,  2, 61, 61,  3, 19,
+      14, 30,  9, 61, 32, 12,  6, 33, 22, 11,
+      32,  5,  2, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61
     };
-  return len + asso_values[(unsigned char)str[2]] + asso_values[(unsigned char)str[1]];
+  register unsigned int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[4]];
+      /*FALLTHROUGH*/
+      case 4:
+      case 3:
+        hval += asso_values[(unsigned char)str[2]];
+        break;
+    }
+  return hval;
 }
 
 struct FcObjectTypeNamePool_t
   {
-    char FcObjectTypeNamePool_str4[sizeof("file")];
-    char FcObjectTypeNamePool_str5[sizeof("color")];
-    char FcObjectTypeNamePool_str7[sizeof("foundry")];
-    char FcObjectTypeNamePool_str8[sizeof("fullname")];
-    char FcObjectTypeNamePool_str9[sizeof("pixelsize")];
-    char FcObjectTypeNamePool_str10[sizeof("size")];
-    char FcObjectTypeNamePool_str12[sizeof("fullnamelang")];
-    char FcObjectTypeNamePool_str13[sizeof("globaladvance")];
-    char FcObjectTypeNamePool_str14[sizeof("slant")];
-    char FcObjectTypeNamePool_str16[sizeof("hinting")];
-    char FcObjectTypeNamePool_str17[sizeof("minspace")];
-    char FcObjectTypeNamePool_str18[sizeof("hintstyle")];
-    char FcObjectTypeNamePool_str19[sizeof("fontformat")];
-    char FcObjectTypeNamePool_str20[sizeof("fontversion")];
-    char FcObjectTypeNamePool_str21[sizeof("fontfeatures")];
-    char FcObjectTypeNamePool_str22[sizeof("lang")];
-    char FcObjectTypeNamePool_str23[sizeof("fontvariations")];
-    char FcObjectTypeNamePool_str24[sizeof("dpi")];
-    char FcObjectTypeNamePool_str25[sizeof("outline")];
+    char FcObjectTypeNamePool_str5[sizeof("dpi")];
+    char FcObjectTypeNamePool_str6[sizeof("size")];
+    char FcObjectTypeNamePool_str7[sizeof("file")];
+    char FcObjectTypeNamePool_str11[sizeof("spacing")];
+    char FcObjectTypeNamePool_str12[sizeof("scalable")];
+    char FcObjectTypeNamePool_str13[sizeof("slant")];
+    char FcObjectTypeNamePool_str14[sizeof("matrix")];
+    char FcObjectTypeNamePool_str15[sizeof("outline")];
+    char FcObjectTypeNamePool_str16[sizeof("hash")];
+    char FcObjectTypeNamePool_str17[sizeof("antialias")];
+    char FcObjectTypeNamePool_str18[sizeof("lang")];
+    char FcObjectTypeNamePool_str19[sizeof("aspect")];
+    char FcObjectTypeNamePool_str20[sizeof("weight")];
+    char FcObjectTypeNamePool_str21[sizeof("charset")];
+    char FcObjectTypeNamePool_str22[sizeof("charwidth")];
+    char FcObjectTypeNamePool_str23[sizeof("hinting")];
+    char FcObjectTypeNamePool_str24[sizeof("charheight")];
+    char FcObjectTypeNamePool_str25[sizeof("fullname")];
     char FcObjectTypeNamePool_str26[sizeof("autohint")];
-    char FcObjectTypeNamePool_str27[sizeof("weight")];
-    char FcObjectTypeNamePool_str28[sizeof("hash")];
-    char FcObjectTypeNamePool_str29[sizeof("postscriptname")];
-    char FcObjectTypeNamePool_str31[sizeof("rgba")];
-    char FcObjectTypeNamePool_str32[sizeof("scale")];
-    char FcObjectTypeNamePool_str33[sizeof("matrix")];
-    char FcObjectTypeNamePool_str34[sizeof("rasterizer")];
-    char FcObjectTypeNamePool_str35[sizeof("scalable")];
-    char FcObjectTypeNamePool_str36[sizeof("antialias")];
-    char FcObjectTypeNamePool_str37[sizeof("spacing")];
-    char FcObjectTypeNamePool_str38[sizeof("width")];
-    char FcObjectTypeNamePool_str39[sizeof("family")];
-    char FcObjectTypeNamePool_str40[sizeof("capability")];
-    char FcObjectTypeNamePool_str41[sizeof("namelang")];
-    char FcObjectTypeNamePool_str42[sizeof("aspect")];
-    char FcObjectTypeNamePool_str43[sizeof("familylang")];
-    char FcObjectTypeNamePool_str44[sizeof("style")];
-    char FcObjectTypeNamePool_str46[sizeof("prgname")];
-    char FcObjectTypeNamePool_str47[sizeof("index")];
-    char FcObjectTypeNamePool_str48[sizeof("stylelang")];
-    char FcObjectTypeNamePool_str49[sizeof("decorative")];
-    char FcObjectTypeNamePool_str50[sizeof("variable")];
-    char FcObjectTypeNamePool_str51[sizeof("symbol")];
-    char FcObjectTypeNamePool_str52[sizeof("charset")];
-    char FcObjectTypeNamePool_str53[sizeof("embolden")];
-    char FcObjectTypeNamePool_str54[sizeof("charwidth")];
-    char FcObjectTypeNamePool_str55[sizeof("charheight")];
-    char FcObjectTypeNamePool_str59[sizeof("embeddedbitmap")];
-    char FcObjectTypeNamePool_str60[sizeof("lcdfilter")];
-    char FcObjectTypeNamePool_str68[sizeof("verticallayout")];
+    char FcObjectTypeNamePool_str27[sizeof("lcdfilter")];
+    char FcObjectTypeNamePool_str28[sizeof("family")];
+    char FcObjectTypeNamePool_str29[sizeof("fullnamelang")];
+    char FcObjectTypeNamePool_str30[sizeof("namelang")];
+    char FcObjectTypeNamePool_str31[sizeof("minspace")];
+    char FcObjectTypeNamePool_str32[sizeof("familylang")];
+    char FcObjectTypeNamePool_str33[sizeof("width")];
+    char FcObjectTypeNamePool_str34[sizeof("rgba")];
+    char FcObjectTypeNamePool_str35[sizeof("hintstyle")];
+    char FcObjectTypeNamePool_str36[sizeof("scale")];
+    char FcObjectTypeNamePool_str37[sizeof("fonthashint")];
+    char FcObjectTypeNamePool_str38[sizeof("postscriptname")];
+    char FcObjectTypeNamePool_str39[sizeof("style")];
+    char FcObjectTypeNamePool_str40[sizeof("color")];
+    char FcObjectTypeNamePool_str41[sizeof("embolden")];
+    char FcObjectTypeNamePool_str42[sizeof("variable")];
+    char FcObjectTypeNamePool_str43[sizeof("stylelang")];
+    char FcObjectTypeNamePool_str44[sizeof("pixelsize")];
+    char FcObjectTypeNamePool_str45[sizeof("globaladvance")];
+    char FcObjectTypeNamePool_str46[sizeof("decorative")];
+    char FcObjectTypeNamePool_str47[sizeof("fontversion")];
+    char FcObjectTypeNamePool_str48[sizeof("verticallayout")];
+    char FcObjectTypeNamePool_str49[sizeof("capability")];
+    char FcObjectTypeNamePool_str50[sizeof("fontvariations")];
+    char FcObjectTypeNamePool_str51[sizeof("rasterizer")];
+    char FcObjectTypeNamePool_str52[sizeof("fontformat")];
+    char FcObjectTypeNamePool_str53[sizeof("index")];
+    char FcObjectTypeNamePool_str54[sizeof("fontfeatures")];
+    char FcObjectTypeNamePool_str55[sizeof("symbol")];
+    char FcObjectTypeNamePool_str56[sizeof("foundry")];
+    char FcObjectTypeNamePool_str57[sizeof("prgname")];
+    char FcObjectTypeNamePool_str60[sizeof("embeddedbitmap")];
   };
 static const struct FcObjectTypeNamePool_t FcObjectTypeNamePool_contents =
   {
-    "file",
-    "color",
-    "foundry",
-    "fullname",
-    "pixelsize",
-    "size",
-    "fullnamelang",
-    "globaladvance",
-    "slant",
-    "hinting",
-    "minspace",
-    "hintstyle",
-    "fontformat",
-    "fontversion",
-    "fontfeatures",
-    "lang",
-    "fontvariations",
     "dpi",
-    "outline",
-    "autohint",
-    "weight",
-    "hash",
-    "postscriptname",
-    "rgba",
-    "scale",
-    "matrix",
-    "rasterizer",
-    "scalable",
-    "antialias",
+    "size",
+    "file",
     "spacing",
-    "width",
-    "family",
-    "capability",
-    "namelang",
+    "scalable",
+    "slant",
+    "matrix",
+    "outline",
+    "hash",
+    "antialias",
+    "lang",
     "aspect",
-    "familylang",
-    "style",
-    "prgname",
-    "index",
-    "stylelang",
-    "decorative",
-    "variable",
-    "symbol",
+    "weight",
     "charset",
-    "embolden",
     "charwidth",
+    "hinting",
     "charheight",
-    "embeddedbitmap",
+    "fullname",
+    "autohint",
     "lcdfilter",
-    "verticallayout"
+    "family",
+    "fullnamelang",
+    "namelang",
+    "minspace",
+    "familylang",
+    "width",
+    "rgba",
+    "hintstyle",
+    "scale",
+    "fonthashint",
+    "postscriptname",
+    "style",
+    "color",
+    "embolden",
+    "variable",
+    "stylelang",
+    "pixelsize",
+    "globaladvance",
+    "decorative",
+    "fontversion",
+    "verticallayout",
+    "capability",
+    "fontvariations",
+    "rasterizer",
+    "fontformat",
+    "index",
+    "fontfeatures",
+    "symbol",
+    "foundry",
+    "prgname",
+    "embeddedbitmap"
   };
 #define FcObjectTypeNamePool ((const char *) &FcObjectTypeNamePool_contents)
 const struct FcObjectTypeInfo *
@@ -193,123 +207,120 @@ FcObjectTypeLookup (register const char *str, register size_t len)
 {
   enum
     {
-      TOTAL_KEYWORDS = 50,
+      TOTAL_KEYWORDS = 51,
       MIN_WORD_LENGTH = 3,
       MAX_WORD_LENGTH = 14,
-      MIN_HASH_VALUE = 4,
-      MAX_HASH_VALUE = 68
+      MIN_HASH_VALUE = 5,
+      MAX_HASH_VALUE = 60
     };
 
   static const struct FcObjectTypeInfo wordlist[] =
     {
-      {-1}, {-1}, {-1}, {-1},
-#line 38 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str4,FC_FILE_OBJECT},
-#line 64 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str5,FC_COLOR_OBJECT},
-      {-1},
-#line 31 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str7,FC_FOUNDRY_OBJECT},
-#line 22 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str8,FC_FULLNAME_OBJECT},
-#line 29 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str9,FC_PIXEL_SIZE_OBJECT},
-#line 27 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str10,FC_SIZE_OBJECT},
-      {-1},
-#line 23 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str12,FC_FULLNAMELANG_OBJECT},
-#line 37 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str13,FC_GLOBAL_ADVANCE_OBJECT},
-#line 24 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str14,FC_SLANT_OBJECT},
-      {-1},
-#line 34 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str16,FC_HINTING_OBJECT},
-#line 46 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str17,FC_MINSPACE_OBJECT},
-#line 33 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str18,FC_HINT_STYLE_OBJECT},
-#line 54 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str19,FC_FONTFORMAT_OBJECT},
-#line 52 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str20,FC_FONTVERSION_OBJECT},
-#line 60 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str21,FC_FONT_FEATURES_OBJECT},
-#line 51 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str22,FC_LANG_OBJECT},
-#line 66 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str23,FC_FONT_VARIATIONS_OBJECT},
+      {-1}, {-1}, {-1}, {-1}, {-1},
 #line 43 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str24,FC_DPI_OBJECT},
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str5,FC_DPI_OBJECT},
+#line 27 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str6,FC_SIZE_OBJECT},
+#line 38 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str7,FC_FILE_OBJECT},
+      {-1}, {-1}, {-1},
+#line 30 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str11,FC_SPACING_OBJECT},
+#line 42 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str12,FC_SCALABLE_OBJECT},
+#line 24 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str13,FC_SLANT_OBJECT},
+#line 49 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str14,FC_MATRIX_OBJECT},
 #line 41 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str25,FC_OUTLINE_OBJECT},
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str15,FC_OUTLINE_OBJECT},
+#line 62 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str16,FC_HASH_OBJECT},
+#line 32 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str17,FC_ANTIALIAS_OBJECT},
+#line 51 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str18,FC_LANG_OBJECT},
+#line 28 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str19,FC_ASPECT_OBJECT},
+#line 25 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str20,FC_WEIGHT_OBJECT},
+#line 50 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str21,FC_CHARSET_OBJECT},
+#line 47 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str22,FC_CHARWIDTH_OBJECT},
+#line 34 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str23,FC_HINTING_OBJECT},
+#line 48 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str24,FC_CHAR_HEIGHT_OBJECT},
+#line 22 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str25,FC_FULLNAME_OBJECT},
 #line 36 "fcobjshash.gperf"
       {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str26,FC_AUTOHINT_OBJECT},
-#line 25 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str27,FC_WEIGHT_OBJECT},
-#line 62 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str28,FC_HASH_OBJECT},
-#line 63 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str29,FC_POSTSCRIPT_NAME_OBJECT},
-      {-1},
-#line 44 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str31,FC_RGBA_OBJECT},
-#line 45 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str32,FC_SCALE_OBJECT},
-#line 49 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str33,FC_MATRIX_OBJECT},
-#line 40 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str34,FC_RASTERIZER_OBJECT},
-#line 42 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str35,FC_SCALABLE_OBJECT},
-#line 32 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str36,FC_ANTIALIAS_OBJECT},
-#line 30 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str37,FC_SPACING_OBJECT},
-#line 26 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str38,FC_WIDTH_OBJECT},
-#line 18 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str39,FC_FAMILY_OBJECT},
-#line 53 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str40,FC_CAPABILITY_OBJECT},
-#line 59 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str41,FC_NAMELANG_OBJECT},
-#line 28 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str42,FC_ASPECT_OBJECT},
-#line 19 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str43,FC_FAMILYLANG_OBJECT},
-#line 20 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str44,FC_STYLE_OBJECT},
-      {-1},
-#line 61 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str46,FC_PRGNAME_OBJECT},
-#line 39 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str47,FC_INDEX_OBJECT},
-#line 21 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str48,FC_STYLELANG_OBJECT},
-#line 57 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str49,FC_DECORATIVE_OBJECT},
-#line 67 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str50,FC_VARIABLE_OBJECT},
-#line 65 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str51,FC_SYMBOL_OBJECT},
-#line 50 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str52,FC_CHARSET_OBJECT},
-#line 55 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str53,FC_EMBOLDEN_OBJECT},
-#line 47 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str54,FC_CHARWIDTH_OBJECT},
-#line 48 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str55,FC_CHAR_HEIGHT_OBJECT},
-      {-1}, {-1}, {-1},
-#line 56 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str59,FC_EMBEDDED_BITMAP_OBJECT},
 #line 58 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str60,FC_LCD_FILTER_OBJECT},
-      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str27,FC_LCD_FILTER_OBJECT},
+#line 18 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str28,FC_FAMILY_OBJECT},
+#line 23 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str29,FC_FULLNAMELANG_OBJECT},
+#line 59 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str30,FC_NAMELANG_OBJECT},
+#line 46 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str31,FC_MINSPACE_OBJECT},
+#line 19 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str32,FC_FAMILYLANG_OBJECT},
+#line 26 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str33,FC_WIDTH_OBJECT},
+#line 44 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str34,FC_RGBA_OBJECT},
+#line 33 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str35,FC_HINT_STYLE_OBJECT},
+#line 45 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str36,FC_SCALE_OBJECT},
+#line 68 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str37,FC_FONT_HAS_HINT_OBJECT},
+#line 63 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str38,FC_POSTSCRIPT_NAME_OBJECT},
+#line 20 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str39,FC_STYLE_OBJECT},
+#line 64 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str40,FC_COLOR_OBJECT},
+#line 55 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str41,FC_EMBOLDEN_OBJECT},
+#line 67 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str42,FC_VARIABLE_OBJECT},
+#line 21 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str43,FC_STYLELANG_OBJECT},
+#line 29 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str44,FC_PIXEL_SIZE_OBJECT},
+#line 37 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str45,FC_GLOBAL_ADVANCE_OBJECT},
+#line 57 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str46,FC_DECORATIVE_OBJECT},
+#line 52 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str47,FC_FONTVERSION_OBJECT},
 #line 35 "fcobjshash.gperf"
-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str68,FC_VERTICAL_LAYOUT_OBJECT}
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str48,FC_VERTICAL_LAYOUT_OBJECT},
+#line 53 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str49,FC_CAPABILITY_OBJECT},
+#line 66 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str50,FC_FONT_VARIATIONS_OBJECT},
+#line 40 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str51,FC_RASTERIZER_OBJECT},
+#line 54 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str52,FC_FONTFORMAT_OBJECT},
+#line 39 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str53,FC_INDEX_OBJECT},
+#line 60 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str54,FC_FONT_FEATURES_OBJECT},
+#line 65 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str55,FC_SYMBOL_OBJECT},
+#line 31 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str56,FC_FOUNDRY_OBJECT},
+#line 61 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str57,FC_PRGNAME_OBJECT},
+      {-1}, {-1},
+#line 56 "fcobjshash.gperf"
+      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str60,FC_EMBEDDED_BITMAP_OBJECT}
     };
 
   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
diff --git a/third_party/fontconfig/include/src/fcstdint.h b/third_party/fontconfig/include/src/fcstdint.h
index 2db863eb52d1..76ba174e8761 100644
--- a/third_party/fontconfig/include/src/fcstdint.h
+++ b/third_party/fontconfig/include/src/fcstdint.h
@@ -1,8 +1,8 @@
 #ifndef _FONTCONFIG_SRC_FCSTDINT_H
 #define _FONTCONFIG_SRC_FCSTDINT_H 1
 #ifndef _GENERATED_STDINT_H
-#define _GENERATED_STDINT_H "fontconfig 2.13.1"
-/* generated using gnu compiler gcc (Debian 8.2.0-6) 8.2.0 */
+#define _GENERATED_STDINT_H "fontconfig 2.13.91"
+/* generated using gnu compiler gcc (Debian 9.2.1-23) 9.2.1 20200110 */
 #define _STDINT_HAVE_STDINT_H 1
 #include <stdint.h>
 #endif
diff --git a/third_party/freetype/BUILD.gn b/third_party/freetype/BUILD.gn
index 82f11b1af4cb..5c916355a815 100644
--- a/third_party/freetype/BUILD.gn
+++ b/third_party/freetype/BUILD.gn
@@ -8,9 +8,10 @@ import("//third_party/harfbuzz-ng/harfbuzz.gni")
 
 assert(!use_system_freetype, "Not used when using system freetype.")
 
-config("freetype_config") {
+config("freetype_component_config") {
   include_dirs = [
     "include",
+    "include/freetype-custom",
     "src/include",
   ]
 
@@ -19,14 +20,13 @@ config("freetype_config") {
     # GN currently does not escape '<' and '>' when generating xml based Visual
     # Studio project files. As a result, use quotes instead of pointy brackets
     # in these defines.
-    "FT_CONFIG_CONFIG_H=\"freetype-custom-config/ftconfig.h\"",
-    "FT_CONFIG_MODULES_H=\"freetype-custom-config/ftmodule.h\"",
-    "FT_CONFIG_OPTIONS_H=\"freetype-custom-config/ftoption.h\"",
+    "FT_CONFIG_MODULES_H=\"freetype-custom/freetype/config/ftmodule.h\"",
+    "FT_CONFIG_OPTIONS_H=\"freetype-custom/freetype/config/ftoption.h\"",
   ]
 
   if (!is_android) {
     # Selects type1cid.c and type1.c modules in
-    # freetype-custom-config/ftmodule.h.
+    # freetype-custom-include/freetype/config/ftmodule.h.
     defines += [ "PDFIUM_REQUIRED_MODULES" ]
   } else {
     # Using HarfBuzz assisted autohinting has a performance impact that we do
@@ -39,13 +39,28 @@ config("freetype_config") {
   }
 }
 
+config("freetype_config") {
+  configs = [ ":freetype_component_config" ]
+
+  if (is_win && is_component_build) {
+    # Used for managing declspec(dllimport/export) visibility.
+    defines = [ "FT2_BUILD_DLL" ]
+  }
+}
+
 config("freetype-warnings") {
   cflags = []
 
   if (is_clang) {
     # The reduction of FreeType files to a minimum triggers -Wunused-function
     # warnings in ftbase.c
-    cflags += [ "-Wno-unused-function" ]
+    cflags += [
+      "-Wno-unused-function",
+
+      # TODO(drott): Remove once we can roll past a commit that fixes:
+      # https://savannah.nongnu.org/bugs/index.php?54852
+      "-Wno-deprecated-declarations",
+    ]
   }
 }
 
@@ -55,14 +70,19 @@ source_set("freetype_source") {
   defines = []
   include_dirs = []
 
+  # FreeType only exposes ft2build.h, all other FreeType headers are accessed by macro names.
+  # gn check does not expand macros, so list only this header.
+  public = [ "src/include/ft2build.h" ]
+
   sources = [
-    "include/freetype-custom-config/ftconfig.h",
-    "include/freetype-custom-config/ftmodule.h",
-    "include/freetype-custom-config/ftoption.h",
+    "include/freetype-custom/freetype/config/ftmodule.h",
+    "include/freetype-custom/freetype/config/ftoption.h",
+    "include/freetype-custom/freetype/config/public-macros.h",
     "src/src/autofit/autofit.c",
     "src/src/base/ftbase.c",
     "src/src/base/ftbbox.c",
     "src/src/base/ftbitmap.c",
+    "src/src/base/ftdebug.c",
     "src/src/base/ftfstype.c",
     "src/src/base/ftgasp.c",
     "src/src/base/ftglyph.c",
@@ -92,7 +112,7 @@ source_set("freetype_source") {
     # FT_CONFIG_CONFIG_H. The includes/freetype/config directory should not be
     # on the include path to avoid accidentally using the ftoption or ftmodule
     # from there.
-    include_dirs += [ "include/freetype-custom-config" ]
+    include_dirs += [ "src/include/freetype/config" ]
 
     # builds/unix/ftsystem.c requires the following defines to be set.
     defines += [
@@ -105,18 +125,17 @@ source_set("freetype_source") {
 
   if (!is_android) {
     sources += [
+      "src/src/base/ftcid.c",
       "src/src/cid/type1cid.c",
       "src/src/type1/type1.c",
     ]
   }
 
-  if (is_linux || is_chromecast) {
+  if (is_linux || is_chromeos || is_chromecast) {
     # Needed for content_shell on Linux and Chromecast, since fontconfig
     # requires FT_Get_BDF_Property.
     sources += [ "src/src/base/ftbdf.c" ]
-  }
 
-  if (is_linux || is_chromecast) {
     # Needed on Fedora whose libfreetype builds ftsynth.c containing
     # FT_GlyphSlot_Embolden, which we need to replace in content_shell if
     # we are linking against our own FreeType.
@@ -125,11 +144,6 @@ source_set("freetype_source") {
 
   defines += [ "FT2_BUILD_LIBRARY" ]
 
-  if (is_win && is_component_build) {
-    # Used for managing declspec(dllimport/export) visibility.
-    defines += [ "FT2_BUILD_DLL" ]
-  }
-
   if (use_system_harfbuzz) {
     configs += [ "//third_party/harfbuzz-ng:harfbuzz_from_pkgconfig" ]
   } else {
diff --git a/third_party/freetype/DIR_METADATA b/third_party/freetype/DIR_METADATA
new file mode 100644
index 000000000000..594a7d6501fc
--- /dev/null
+++ b/third_party/freetype/DIR_METADATA
@@ -0,0 +1,3 @@
+monorail {
+  component: "Blink>Fonts"
+}
diff --git a/third_party/freetype/OWNERS b/third_party/freetype/OWNERS
index 3277f87312e5..75d0b057cd57 100644
--- a/third_party/freetype/OWNERS
+++ b/third_party/freetype/OWNERS
@@ -1,2 +1,2 @@
 bungeman@chromium.org
-drott@chromium.org
+drott@chromium.org
\ No newline at end of file
diff --git a/third_party/freetype/README.chromium b/third_party/freetype/README.chromium
index 5828c9ae6227..8a5d44199260 100644
--- a/third_party/freetype/README.chromium
+++ b/third_party/freetype/README.chromium
@@ -1,7 +1,8 @@
 Name: FreeType
 URL: http://www.freetype.org/
-Version: VER-2-9-1-115
-Revision: b532d7ce708cb5ca9bf88abaa2eb213ddcf9babb
+Version: VER-2-10-4-188-ge9c50fa77
+Revision: e9c50fa77de58b749b4b95706f7b55bfff0dd27f
+CPEPrefix: cpe:/a:freetype:freetype:2.10.4
 License: Custom license "inspired by the BSD, Artistic, and IJG (Independent
          JPEG Group) licenses"
 License File: src/docs/FTL.TXT
diff --git a/third_party/freetype/include/freetype-custom-config/ftconfig.h b/third_party/freetype/include/freetype-custom-config/ftconfig.h
deleted file mode 100644
index 3b6bbaf22bdd..000000000000
--- a/third_party/freetype/include/freetype-custom-config/ftconfig.h
+++ /dev/null
@@ -1,596 +0,0 @@
-/***************************************************************************/
-/*                                                                         */
-/*  ftconfig.h                                                             */
-/*                                                                         */
-/*    ANSI-specific configuration file (specification only).               */
-/*                                                                         */
-/*  Copyright 1996-2018 by                                                 */
-/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
-/*                                                                         */
-/*  This file is part of the FreeType project, and may only be used,       */
-/*  modified, and distributed under the terms of the FreeType project      */
-/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
-/*  this file you indicate that you have read the license and              */
-/*  understand and accept it fully.                                        */
-/*                                                                         */
-/***************************************************************************/
-
-
-  /*************************************************************************/
-  /*                                                                       */
-  /* This header file contains a number of macro definitions that are used */
-  /* by the rest of the engine.  Most of the macros here are automatically */
-  /* determined at compile time, and you should not need to change it to   */
-  /* port FreeType, except to compile the library with a non-ANSI          */
-  /* compiler.                                                             */
-  /*                                                                       */
-  /* Note however that if some specific modifications are needed, we       */
-  /* advise you to place a modified copy in your build directory.          */
-  /*                                                                       */
-  /* The build directory is usually `builds/<system>', and contains        */
-  /* system-specific files that are always included first when building    */
-  /* the library.                                                          */
-  /*                                                                       */
-  /* This ANSI version should stay in `include/config/'.                   */
-  /*                                                                       */
-  /*************************************************************************/
-
-#ifndef FTCONFIG_H_
-#define FTCONFIG_H_
-
-#include <ft2build.h>
-#include FT_CONFIG_OPTIONS_H
-#include FT_CONFIG_STANDARD_LIBRARY_H
-
-
-FT_BEGIN_HEADER
-
-
-  /*************************************************************************/
-  /*                                                                       */
-  /*               PLATFORM-SPECIFIC CONFIGURATION MACROS                  */
-  /*                                                                       */
-  /* These macros can be toggled to suit a specific system.  The current   */
-  /* ones are defaults used to compile FreeType in an ANSI C environment   */
-  /* (16bit compilers are also supported).  Copy this file to your own     */
-  /* `builds/<system>' directory, and edit it to port the engine.          */
-  /*                                                                       */
-  /*************************************************************************/
-
-
-  /* There are systems (like the Texas Instruments 'C54x) where a `char' */
-  /* has 16 bits.  ANSI C says that sizeof(char) is always 1.  Since an  */
-  /* `int' has 16 bits also for this system, sizeof(int) gives 1 which   */
-  /* is probably unexpected.                                             */
-  /*                                                                     */
-  /* `CHAR_BIT' (defined in limits.h) gives the number of bits in a      */
-  /* `char' type.                                                        */
-
-#ifndef FT_CHAR_BIT
-#define FT_CHAR_BIT  CHAR_BIT
-#endif
-
-
-  /* The size of an `int' type.  */
-#if                                 FT_UINT_MAX == 0xFFFFUL
-#define FT_SIZEOF_INT  ( 16 / FT_CHAR_BIT )
-#elif                               FT_UINT_MAX == 0xFFFFFFFFUL
-#define FT_SIZEOF_INT  ( 32 / FT_CHAR_BIT )
-#elif FT_UINT_MAX > 0xFFFFFFFFUL && FT_UINT_MAX == 0xFFFFFFFFFFFFFFFFUL
-#define FT_SIZEOF_INT  ( 64 / FT_CHAR_BIT )
-#else
-#error "Unsupported size of `int' type!"
-#endif
-
-  /* The size of a `long' type.  A five-byte `long' (as used e.g. on the */
-  /* DM642) is recognized but avoided.                                   */
-#if                                  FT_ULONG_MAX == 0xFFFFFFFFUL
-#define FT_SIZEOF_LONG  ( 32 / FT_CHAR_BIT )
-#elif FT_ULONG_MAX > 0xFFFFFFFFUL && FT_ULONG_MAX == 0xFFFFFFFFFFUL
-#define FT_SIZEOF_LONG  ( 32 / FT_CHAR_BIT )
-#elif FT_ULONG_MAX > 0xFFFFFFFFUL && FT_ULONG_MAX == 0xFFFFFFFFFFFFFFFFUL
-#define FT_SIZEOF_LONG  ( 64 / FT_CHAR_BIT )
-#else
-#error "Unsupported size of `long' type!"
-#endif
-
-
-  /* FT_UNUSED is a macro used to indicate that a given parameter is not  */
-  /* used -- this is only used to get rid of unpleasant compiler warnings */
-#ifndef FT_UNUSED
-#define FT_UNUSED( arg )  ( (arg) = (arg) )
-#endif
-
-
-  /*************************************************************************/
-  /*                                                                       */
-  /*                     AUTOMATIC CONFIGURATION MACROS                    */
-  /*                                                                       */
-  /* These macros are computed from the ones defined above.  Don't touch   */
-  /* their definition, unless you know precisely what you are doing.  No   */
-  /* porter should need to mess with them.                                 */
-  /*                                                                       */
-  /*************************************************************************/
-
-
-  /*************************************************************************/
-  /*                                                                       */
-  /* Mac support                                                           */
-  /*                                                                       */
-  /*   This is the only necessary change, so it is defined here instead    */
-  /*   providing a new configuration file.                                 */
-  /*                                                                       */
-#if defined( __APPLE__ ) || ( defined( __MWERKS__ ) && defined( macintosh ) )
-  /* no Carbon frameworks for 64bit 10.4.x */
-  /* AvailabilityMacros.h is available since Mac OS X 10.2,        */
-  /* so guess the system version by maximum errno before inclusion */
-#include <errno.h>
-#ifdef ECANCELED /* defined since 10.2 */
-#include "AvailabilityMacros.h"
-#endif
-#if defined( __LP64__ ) && \
-    ( MAC_OS_X_VERSION_MIN_REQUIRED <= MAC_OS_X_VERSION_10_4 )
-#undef FT_MACINTOSH
-#endif
-
-#elif defined( __SC__ ) || defined( __MRC__ )
-  /* Classic MacOS compilers */
-#include "ConditionalMacros.h"
-#if TARGET_OS_MAC
-#define FT_MACINTOSH 1
-#endif
-
-#endif
-
-
-  /* Fix compiler warning with sgi compiler */
-#if defined( __sgi ) && !defined( __GNUC__ )
-#if defined( _COMPILER_VERSION ) && ( _COMPILER_VERSION >= 730 )
-#pragma set woff 3505
-#endif
-#endif
-
-
-  /**************************************************************************
-   *
-   * @section:
-   *   basic_types
-   *
-   */
-
-
-  /**************************************************************************
-   *
-   * @type:
-   *   FT_Int16
-   *
-   * @description:
-   *   A typedef for a 16bit signed integer type.
-   */
-  typedef signed short  FT_Int16;
-
-
-  /**************************************************************************
-   *
-   * @type:
-   *   FT_UInt16
-   *
-   * @description:
-   *   A typedef for a 16bit unsigned integer type.
-   */
-  typedef unsigned short  FT_UInt16;
-
-  /* */
-
-
-  /* this #if 0 ... #endif clause is for documentation purposes */
-#if 0
-
-  /**************************************************************************
-   *
-   * @type:
-   *   FT_Int32
-   *
-   * @description:
-   *   A typedef for a 32bit signed integer type.  The size depends on
-   *   the configuration.
-   */
-  typedef signed XXX  FT_Int32;
-
-
-  /**************************************************************************
-   *
-   * @type:
-   *   FT_UInt32
-   *
-   *   A typedef for a 32bit unsigned integer type.  The size depends on
-   *   the configuration.
-   */
-  typedef unsigned XXX  FT_UInt32;
-
-
-  /**************************************************************************
-   *
-   * @type:
-   *   FT_Int64
-   *
-   *   A typedef for a 64bit signed integer type.  The size depends on
-   *   the configuration.  Only defined if there is real 64bit support;
-   *   otherwise, it gets emulated with a structure (if necessary).
-   */
-  typedef signed XXX  FT_Int64;
-
-
-  /**************************************************************************
-   *
-   * @type:
-   *   FT_UInt64
-   *
-   *   A typedef for a 64bit unsigned integer type.  The size depends on
-   *   the configuration.  Only defined if there is real 64bit support;
-   *   otherwise, it gets emulated with a structure (if necessary).
-   */
-  typedef unsigned XXX  FT_UInt64;
-
-  /* */
-
-#endif
-
-#if FT_SIZEOF_INT == ( 32 / FT_CHAR_BIT )
-
-  typedef signed int      FT_Int32;
-  typedef unsigned int    FT_UInt32;
-
-#elif FT_SIZEOF_LONG == ( 32 / FT_CHAR_BIT )
-
-  typedef signed long     FT_Int32;
-  typedef unsigned long   FT_UInt32;
-
-#else
-#error "no 32bit type found -- please check your configuration files"
-#endif
-
-
-  /* look up an integer type that is at least 32 bits */
-#if FT_SIZEOF_INT >= ( 32 / FT_CHAR_BIT )
-
-  typedef int            FT_Fast;
-  typedef unsigned int   FT_UFast;
-
-#elif FT_SIZEOF_LONG >= ( 32 / FT_CHAR_BIT )
-
-  typedef long           FT_Fast;
-  typedef unsigned long  FT_UFast;
-
-#endif
-
-
-  /* determine whether we have a 64-bit int type for platforms without */
-  /* Autoconf                                                          */
-#if FT_SIZEOF_LONG == ( 64 / FT_CHAR_BIT )
-
-  /* FT_LONG64 must be defined if a 64-bit type is available */
-#define FT_LONG64
-#define FT_INT64   long
-#define FT_UINT64  unsigned long
-
-  /*************************************************************************/
-  /*                                                                       */
-  /* A 64-bit data type may create compilation problems if you compile     */
-  /* in strict ANSI mode.  To avoid them, we disable other 64-bit data     */
-  /* types if __STDC__ is defined.  You can however ignore this rule       */
-  /* by defining the FT_CONFIG_OPTION_FORCE_INT64 configuration macro.     */
-  /*                                                                       */
-#elif !defined( __STDC__ ) || defined( FT_CONFIG_OPTION_FORCE_INT64 )
-
-#if defined( __STDC_VERSION__ ) && __STDC_VERSION__ >= 199901L
-
-#define FT_LONG64
-#define FT_INT64   long long int
-#define FT_UINT64  unsigned long long int
-
-#elif defined( _MSC_VER ) && _MSC_VER >= 900  /* Visual C++ (and Intel C++) */
-
-  /* this compiler provides the __int64 type */
-#define FT_LONG64
-#define FT_INT64   __int64
-#define FT_UINT64  unsigned __int64
-
-#elif defined( __BORLANDC__ )  /* Borland C++ */
-
-  /* XXXX: We should probably check the value of __BORLANDC__ in order */
-  /*       to test the compiler version.                               */
-
-  /* this compiler provides the __int64 type */
-#define FT_LONG64
-#define FT_INT64   __int64
-#define FT_UINT64  unsigned __int64
-
-#elif defined( __WATCOMC__ )   /* Watcom C++ */
-
-  /* Watcom doesn't provide 64-bit data types */
-
-#elif defined( __MWERKS__ )    /* Metrowerks CodeWarrior */
-
-#define FT_LONG64
-#define FT_INT64   long long int
-#define FT_UINT64  unsigned long long int
-
-#elif defined( __GNUC__ )
-
-  /* GCC provides the `long long' type */
-#define FT_LONG64
-#define FT_INT64   long long int
-#define FT_UINT64  unsigned long long int
-
-#endif /* __STDC_VERSION__ >= 199901L */
-
-#endif /* FT_SIZEOF_LONG == (64 / FT_CHAR_BIT) */
-
-#ifdef FT_LONG64
-  typedef FT_INT64   FT_Int64;
-  typedef FT_UINT64  FT_UInt64;
-#endif
-
-
-#ifdef _WIN64
-  /* only 64bit Windows uses the LLP64 data model, i.e., */
-  /* 32bit integers, 64bit pointers                      */
-#define FT_UINT_TO_POINTER( x ) (void*)(unsigned __int64)(x)
-#else
-#define FT_UINT_TO_POINTER( x ) (void*)(unsigned long)(x)
-#endif
-
-
-  /*************************************************************************/
-  /*                                                                       */
-  /* miscellaneous                                                         */
-  /*                                                                       */
-  /*************************************************************************/
-
-
-#define FT_BEGIN_STMNT  do {
-#define FT_END_STMNT    } while ( 0 )
-#define FT_DUMMY_STMNT  FT_BEGIN_STMNT FT_END_STMNT
-
-
-  /* typeof condition taken from gnulib's `intprops.h' header file */
-#if ( ( defined( __GNUC__ ) && __GNUC__ >= 2 )                       || \
-      ( defined( __IBMC__ ) && __IBMC__ >= 1210 &&                      \
-        defined( __IBM__TYPEOF__ ) )                                 || \
-      ( defined( __SUNPRO_C ) && __SUNPRO_C >= 0x5110 && !__STDC__ ) )
-#define FT_TYPEOF( type )  ( __typeof__ ( type ) )
-#else
-#define FT_TYPEOF( type )  /* empty */
-#endif
-
-
-  /* Use FT_LOCAL and FT_LOCAL_DEF to declare and define, respectively, */
-  /* a function that gets used only within the scope of a module.       */
-  /* Normally, both the header and source code files for such a         */
-  /* function are within a single module directory.                     */
-  /*                                                                    */
-  /* Intra-module arrays should be tagged with FT_LOCAL_ARRAY and       */
-  /* FT_LOCAL_ARRAY_DEF.                                                */
-  /*                                                                    */
-#ifdef FT_MAKE_OPTION_SINGLE_OBJECT
-
-#define FT_LOCAL( x )      static  x
-#define FT_LOCAL_DEF( x )  static  x
-
-#else
-
-#ifdef __cplusplus
-#define FT_LOCAL( x )      extern "C"  x
-#define FT_LOCAL_DEF( x )  extern "C"  x
-#else
-#define FT_LOCAL( x )      extern  x
-#define FT_LOCAL_DEF( x )  x
-#endif
-
-#endif /* FT_MAKE_OPTION_SINGLE_OBJECT */
-
-#define FT_LOCAL_ARRAY( x )      extern const  x
-#define FT_LOCAL_ARRAY_DEF( x )  const  x
-
-
-  /* Use FT_BASE and FT_BASE_DEF to declare and define, respectively, */
-  /* functions that are used in more than a single module.  In the    */
-  /* current setup this implies that the declaration is in a header   */
-  /* file in the `include/freetype/internal' directory, and the       */
-  /* function body is in a file in `src/base'.                        */
-  /*                                                                  */
-#ifndef FT_BASE
-
-#ifdef __cplusplus
-#define FT_BASE( x )  extern "C"  x
-#else
-#define FT_BASE( x )  extern  x
-#endif
-
-#endif /* !FT_BASE */
-
-
-#ifndef FT_BASE_DEF
-
-#ifdef __cplusplus
-#define FT_BASE_DEF( x )  x
-#else
-#define FT_BASE_DEF( x )  x
-#endif
-
-#endif /* !FT_BASE_DEF */
-
-
-  /*   When compiling FreeType as a DLL or DSO with hidden visibility      */
-  /*   some systems/compilers need a special attribute in front OR after   */
-  /*   the return type of function declarations.                           */
-  /*                                                                       */
-  /*   Two macros are used within the FreeType source code to define       */
-  /*   exported library functions: FT_EXPORT and FT_EXPORT_DEF.            */
-  /*                                                                       */
-  /*     FT_EXPORT( return_type )                                          */
-  /*                                                                       */
-  /*       is used in a function declaration, as in                        */
-  /*                                                                       */
-  /*         FT_EXPORT( FT_Error )                                         */
-  /*         FT_Init_FreeType( FT_Library*  alibrary );                    */
-  /*                                                                       */
-  /*                                                                       */
-  /*     FT_EXPORT_DEF( return_type )                                      */
-  /*                                                                       */
-  /*       is used in a function definition, as in                         */
-  /*                                                                       */
-  /*         FT_EXPORT_DEF( FT_Error )                                     */
-  /*         FT_Init_FreeType( FT_Library*  alibrary )                     */
-  /*         {                                                             */
-  /*           ... some code ...                                           */
-  /*           return FT_Err_Ok;                                           */
-  /*         }                                                             */
-  /*                                                                       */
-  /*   You can provide your own implementation of FT_EXPORT and            */
-  /*   FT_EXPORT_DEF here if you want.                                     */
-  /*                                                                       */
-  /*   To export a variable, use FT_EXPORT_VAR.                            */
-  /*                                                                       */
-#if defined(_WIN32)
-
-#if defined(FT2_BUILD_DLL)
-#if defined(FT2_BUILD_LIBRARY)
-#define FT_EXPORT(x)     __declspec(dllexport) x
-#define FT_EXPORT_DEF(x) __declspec(dllexport) x
-#else
-#define FT_EXPORT(x)     __declspec(dllimport) x
-#define FT_EXPORT_DEF(x) __declspec(dllimport) x
-#endif
-#else
-#define FT_EXPORT(x)     x
-#define FT_EXPORT_DEF(x) x
-#endif
-
-#else
-#if !defined(CHROMIUM_RESTRICT_VISIBILITY)
-#define FT_EXPORT(x)     __attribute__((visibility ("default"))) x
-#define FT_EXPORT_DEF(x) __attribute__((visibility ("default"))) x
-#else
-#define FT_EXPORT(x)     x
-#define FT_EXPORT_DEF(x) x
-#endif
-#endif
-
-#ifndef FT_EXPORT
-
-#ifdef FT2_BUILD_LIBRARY
-
-#if defined( _WIN32 ) && ( defined( _DLL ) || defined( DLL_EXPORT ) )
-#define FT_EXPORT( x )  __declspec( dllexport )  x
-#elif defined( __GNUC__ ) && __GNUC__ >= 4
-#define FT_EXPORT( x )  __attribute__(( visibility( "default" ) ))  x
-#elif defined( __cplusplus )
-#define FT_EXPORT( x )  extern "C"  x
-#else
-#define FT_EXPORT( x )  extern  x
-#endif
-
-#else
-
-#if defined( FT2_DLLIMPORT )
-#define FT_EXPORT( x )  __declspec( dllimport )  x
-#elif defined( __cplusplus )
-#define FT_EXPORT( x )  extern "C"  x
-#else
-#define FT_EXPORT( x )  extern  x
-#endif
-
-#endif
-
-#endif /* !FT_EXPORT */
-
-
-#ifndef FT_EXPORT_DEF
-
-#ifdef __cplusplus
-#define FT_EXPORT_DEF( x )  extern "C"  x
-#else
-#define FT_EXPORT_DEF( x )  extern  x
-#endif
-
-#endif /* !FT_EXPORT_DEF */
-
-
-#ifndef FT_EXPORT_VAR
-
-#ifdef __cplusplus
-#define FT_EXPORT_VAR( x )  extern "C"  x
-#else
-#define FT_EXPORT_VAR( x )  extern  x
-#endif
-
-#endif /* !FT_EXPORT_VAR */
-
-
-  /* The following macros are needed to compile the library with a   */
-  /* C++ compiler and with 16bit compilers.                          */
-  /*                                                                 */
-
-  /* This is special.  Within C++, you must specify `extern "C"' for */
-  /* functions which are used via function pointers, and you also    */
-  /* must do that for structures which contain function pointers to  */
-  /* assure C linkage -- it's not possible to have (local) anonymous */
-  /* functions which are accessed by (global) function pointers.     */
-  /*                                                                 */
-  /*                                                                 */
-  /* FT_CALLBACK_DEF is used to _define_ a callback function,        */
-  /* located in the same source code file as the structure that uses */
-  /* it.                                                             */
-  /*                                                                 */
-  /* FT_BASE_CALLBACK and FT_BASE_CALLBACK_DEF are used to declare   */
-  /* and define a callback function, respectively, in a similar way  */
-  /* as FT_BASE and FT_BASE_DEF work.                                */
-  /*                                                                 */
-  /* FT_CALLBACK_TABLE is used to _declare_ a constant variable that */
-  /* contains pointers to callback functions.                        */
-  /*                                                                 */
-  /* FT_CALLBACK_TABLE_DEF is used to _define_ a constant variable   */
-  /* that contains pointers to callback functions.                   */
-  /*                                                                 */
-  /*                                                                 */
-  /* Some 16bit compilers have to redefine these macros to insert    */
-  /* the infamous `_cdecl' or `__fastcall' declarations.             */
-  /*                                                                 */
-#ifndef FT_CALLBACK_DEF
-#ifdef __cplusplus
-#define FT_CALLBACK_DEF( x )  extern "C"  x
-#else
-#define FT_CALLBACK_DEF( x )  static  x
-#endif
-#endif /* FT_CALLBACK_DEF */
-
-#ifndef FT_BASE_CALLBACK
-#ifdef __cplusplus
-#define FT_BASE_CALLBACK( x )      extern "C"  x
-#define FT_BASE_CALLBACK_DEF( x )  extern "C"  x
-#else
-#define FT_BASE_CALLBACK( x )      extern  x
-#define FT_BASE_CALLBACK_DEF( x )  x
-#endif
-#endif /* FT_BASE_CALLBACK */
-
-#ifndef FT_CALLBACK_TABLE
-#ifdef __cplusplus
-#define FT_CALLBACK_TABLE      extern "C"
-#define FT_CALLBACK_TABLE_DEF  extern "C"
-#else
-#define FT_CALLBACK_TABLE      extern
-#define FT_CALLBACK_TABLE_DEF  /* nothing */
-#endif
-#endif /* FT_CALLBACK_TABLE */
-
-
-FT_END_HEADER
-
-
-#endif /* FTCONFIG_H_ */
-
-
-/* END */
diff --git a/third_party/freetype/include/freetype-custom-config/ftmodule.h b/third_party/freetype/include/freetype-custom/freetype/config/ftmodule.h
similarity index 94%
rename from third_party/freetype/include/freetype-custom-config/ftmodule.h
rename to third_party/freetype/include/freetype-custom/freetype/config/ftmodule.h
index 72eda055abdb..f2f44469108f 100644
--- a/third_party/freetype/include/freetype-custom-config/ftmodule.h
+++ b/third_party/freetype/include/freetype-custom/freetype/config/ftmodule.h
@@ -23,8 +23,6 @@ FT_USE_MODULE( FT_Module_Class, pshinter_module_class )
 FT_USE_MODULE( FT_Renderer_Class, ft_raster1_renderer_class )
 FT_USE_MODULE( FT_Module_Class, sfnt_module_class )
 FT_USE_MODULE( FT_Renderer_Class, ft_smooth_renderer_class )
-FT_USE_MODULE( FT_Renderer_Class, ft_smooth_lcd_renderer_class )
-FT_USE_MODULE( FT_Renderer_Class, ft_smooth_lcdv_renderer_class )
 FT_USE_MODULE( FT_Module_Class, psaux_module_class )
 
 #if defined(PDFIUM_REQUIRED_MODULES)
@@ -38,4 +36,6 @@ FT_USE_MODULE( FT_Driver_ClassRec, t42_driver_class )
 FT_USE_MODULE( FT_Driver_ClassRec, winfnt_driver_class )
 FT_USE_MODULE( FT_Driver_ClassRec, pcf_driver_class )
 FT_USE_MODULE( FT_Driver_ClassRec, bdf_driver_class )
+FT_USE_MODULE( FT_Renderer_Class, ft_sdf_renderer_class )
+FT_USE_MODULE( FT_Renderer_Class, ft_bitmap_sdf_renderer_class )
 */
diff --git a/third_party/freetype/include/freetype-custom-config/ftoption.h b/third_party/freetype/include/freetype-custom/freetype/config/ftoption.h
similarity index 52%
rename from third_party/freetype/include/freetype-custom-config/ftoption.h
rename to third_party/freetype/include/freetype-custom/freetype/config/ftoption.h
index 34af6ed9ee81..f76a3718eb16 100644
--- a/third_party/freetype/include/freetype-custom-config/ftoption.h
+++ b/third_party/freetype/include/freetype-custom/freetype/config/ftoption.h
@@ -4,7 +4,7 @@
  *
  *   User-selectable configuration macros (specification only).
  *
- * Copyright 1996-2018 by
+ * Copyright (C) 1996-2021 by
  * David Turner, Robert Wilhelm, and Werner Lemberg.
  *
  * This file is part of the FreeType project, and may only be used,
@@ -29,37 +29,39 @@ FT_BEGIN_HEADER
    *
    *                USER-SELECTABLE CONFIGURATION MACROS
    *
-   * This file contains the default configuration macro definitions for
-   * a standard build of the FreeType library.  There are three ways to
-   * use this file to build project-specific versions of the library:
+   * This file contains the default configuration macro definitions for a
+   * standard build of the FreeType library.  There are three ways to use
+   * this file to build project-specific versions of the library:
    *
    * - You can modify this file by hand, but this is not recommended in
-   *   cases where you would like to build several versions of the
-   *   library from a single source directory.
+   *   cases where you would like to build several versions of the library
+   *   from a single source directory.
    *
    * - You can put a copy of this file in your build directory, more
-   *   precisely in `$BUILD/freetype/config/ftoption.h', where `$BUILD'
-   *   is the name of a directory that is included _before_ the FreeType
-   *   include path during compilation.
+   *   precisely in `$BUILD/freetype/config/ftoption.h`, where `$BUILD` is
+   *   the name of a directory that is included _before_ the FreeType include
+   *   path during compilation.
    *
-   *   The default FreeType Makefiles and Jamfiles use the build
-   *   directory `builds/<system>' by default, but you can easily change
-   *   that for your own projects.
+   *   The default FreeType Makefiles use the build directory
+   *   `builds/<system>` by default, but you can easily change that for your
+   *   own projects.
    *
-   * - Copy the file <ft2build.h> to `$BUILD/ft2build.h' and modify it
-   *   slightly to pre-define the macro FT_CONFIG_OPTIONS_H used to
-   *   locate this file during the build.  For example,
+   * - Copy the file <ft2build.h> to `$BUILD/ft2build.h` and modify it
+   *   slightly to pre-define the macro `FT_CONFIG_OPTIONS_H` used to locate
+   *   this file during the build.  For example,
    *
+   *   ```
    *     #define FT_CONFIG_OPTIONS_H  <myftoptions.h>
    *     #include <freetype/config/ftheader.h>
+   *   ```
    *
-   *   will use `$BUILD/myftoptions.h' instead of this file for macro
+   *   will use `$BUILD/myftoptions.h` instead of this file for macro
    *   definitions.
    *
    *   Note also that you can similarly pre-define the macro
-   *   FT_CONFIG_MODULES_H used to locate the file listing of the modules
+   *   `FT_CONFIG_MODULES_H` used to locate the file listing of the modules
    *   that are statically linked to the library at compile time.  By
-   *   default, this file is <freetype/config/ftmodule.h>.
+   *   default, this file is `<freetype/config/ftmodule.h>`.
    *
    * We highly recommend using the third method whenever possible.
    *
@@ -75,36 +77,39 @@ FT_BEGIN_HEADER
   /*************************************************************************/
 
 
-  /*#***********************************************************************/
-  /*                                                                       */
-  /* If you enable this configuration option, FreeType recognizes an       */
-  /* environment variable called `FREETYPE_PROPERTIES', which can be used  */
-  /* to control the various font drivers and modules.  The controllable    */
-  /* properties are listed in the section @properties.                     */
-  /*                                                                       */
-  /* You have to undefine this configuration option on platforms that lack */
-  /* the concept of environment variables (and thus don't have the         */
-  /* `getenv' function), for example Windows CE.                           */
-  /*                                                                       */
-  /* `FREETYPE_PROPERTIES' has the following syntax form (broken here into */
-  /* multiple lines for better readability).                               */
-  /*                                                                       */
-  /* {                                                                     */
-  /*   <optional whitespace>                                               */
-  /*   <module-name1> ':'                                                  */
-  /*   <property-name1> '=' <property-value1>                              */
-  /*   <whitespace>                                                        */
-  /*   <module-name2> ':'                                                  */
-  /*   <property-name2> '=' <property-value2>                              */
-  /*   ...                                                                 */
-  /* }                                                                     */
-  /*                                                                       */
-  /* Example:                                                              */
-  /*                                                                       */
-  /*   FREETYPE_PROPERTIES=truetype:interpreter-version=35 \               */
-  /*                       cff:no-stem-darkening=1 \                       */
-  /*                       autofitter:warping=1                            */
-  /*                                                                       */
+  /*#************************************************************************
+   *
+   * If you enable this configuration option, FreeType recognizes an
+   * environment variable called `FREETYPE_PROPERTIES`, which can be used to
+   * control the various font drivers and modules.  The controllable
+   * properties are listed in the section @properties.
+   *
+   * You have to undefine this configuration option on platforms that lack
+   * the concept of environment variables (and thus don't have the `getenv`
+   * function), for example Windows CE.
+   *
+   * `FREETYPE_PROPERTIES` has the following syntax form (broken here into
+   * multiple lines for better readability).
+   *
+   * ```
+   *   <optional whitespace>
+   *   <module-name1> ':'
+   *   <property-name1> '=' <property-value1>
+   *   <whitespace>
+   *   <module-name2> ':'
+   *   <property-name2> '=' <property-value2>
+   *   ...
+   * ```
+   *
+   * Example:
+   *
+   * ```
+   *   FREETYPE_PROPERTIES=truetype:interpreter-version=35 \
+   *                       cff:no-stem-darkening=1 \
+   *                       autofitter:warping=1
+   * ```
+   *
+   */
 #define FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
 
 
@@ -112,35 +117,32 @@ FT_BEGIN_HEADER
    *
    * Uncomment the line below if you want to activate LCD rendering
    * technology similar to ClearType in this build of the library.  This
-   * technology triples the resolution in the direction color subpixels.
-   * To mitigate color fringes inherent to this technology, you also need
-   * to explicitly set up LCD filtering.
+   * technology triples the resolution in the direction color subpixels.  To
+   * mitigate color fringes inherent to this technology, you also need to
+   * explicitly set up LCD filtering.
    *
-   * Note that this feature is covered by several Microsoft patents
-   * and should not be activated in any default build of the library.
    * When this macro is not defined, FreeType offers alternative LCD
-   * rendering technology that produces excellent output without LCD
-   * filtering.
+   * rendering technology that produces excellent output.
    */
 #define FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 
 
   /**************************************************************************
    *
-   * Many compilers provide a non-ANSI 64-bit data type that can be used
-   * by FreeType to speed up some computations.  However, this will create
-   * some problems when compiling the library in strict ANSI mode.
+   * Many compilers provide a non-ANSI 64-bit data type that can be used by
+   * FreeType to speed up some computations.  However, this will create some
+   * problems when compiling the library in strict ANSI mode.
    *
    * For this reason, the use of 64-bit integers is normally disabled when
-   * the __STDC__ macro is defined.  You can however disable this by
-   * defining the macro FT_CONFIG_OPTION_FORCE_INT64 here.
+   * the `__STDC__` macro is defined.  You can however disable this by
+   * defining the macro `FT_CONFIG_OPTION_FORCE_INT64` here.
    *
    * For most compilers, this will only create compilation warnings when
    * building the library.
    *
    * ObNote: The compiler-specific 64-bit integers are detected in the
-   *         file `ftconfig.h' either statically or through the
-   *         `configure' script on supported platforms.
+   *         file `ftconfig.h` either statically or through the `configure`
+   *         script on supported platforms.
    */
 #undef FT_CONFIG_OPTION_FORCE_INT64
 
@@ -148,21 +150,21 @@ FT_BEGIN_HEADER
   /**************************************************************************
    *
    * If this macro is defined, do not try to use an assembler version of
-   * performance-critical functions (e.g. FT_MulFix).  You should only do
-   * that to verify that the assembler function works properly, or to
-   * execute benchmark tests of the various implementations.
+   * performance-critical functions (e.g., @FT_MulFix).  You should only do
+   * that to verify that the assembler function works properly, or to execute
+   * benchmark tests of the various implementations.
    */
 /* #define FT_CONFIG_OPTION_NO_ASSEMBLER */
 
 
   /**************************************************************************
    *
-   * If this macro is defined, try to use an inlined assembler version of
-   * the `FT_MulFix' function, which is a `hotspot' when loading and
-   * hinting glyphs, and which should be executed as fast as possible.
+   * If this macro is defined, try to use an inlined assembler version of the
+   * @FT_MulFix function, which is a 'hotspot' when loading and hinting
+   * glyphs, and which should be executed as fast as possible.
    *
-   * Note that if your compiler or CPU is not supported, this will default
-   * to the standard and portable implementation found in `ftcalc.c'.
+   * Note that if your compiler or CPU is not supported, this will default to
+   * the standard and portable implementation found in `ftcalc.c`.
    */
 #define FT_CONFIG_OPTION_INLINE_MULFIX
 
@@ -172,12 +174,12 @@ FT_BEGIN_HEADER
    * LZW-compressed file support.
    *
    *   FreeType now handles font files that have been compressed with the
-   *   `compress' program.  This is mostly used to parse many of the PCF
+   *   `compress` program.  This is mostly used to parse many of the PCF
    *   files that come with various X11 distributions.  The implementation
-   *   uses NetBSD's `zopen' to partially uncompress the file on the fly
-   *   (see src/lzw/ftgzip.c).
+   *   uses NetBSD's `zopen` to partially uncompress the file on the fly (see
+   *   `src/lzw/ftgzip.c`).
    *
-   *   Define this macro if you want to enable this `feature'.
+   *   Define this macro if you want to enable this 'feature'.
    */
 #define FT_CONFIG_OPTION_USE_LZW
 
@@ -187,12 +189,12 @@ FT_BEGIN_HEADER
    * Gzip-compressed file support.
    *
    *   FreeType now handles font files that have been compressed with the
-   *   `gzip' program.  This is mostly used to parse many of the PCF files
-   *   that come with XFree86.  The implementation uses `zlib' to
-   *   partially uncompress the file on the fly (see src/gzip/ftgzip.c).
+   *   `gzip` program.  This is mostly used to parse many of the PCF files
+   *   that come with XFree86.  The implementation uses 'zlib' to partially
+   *   uncompress the file on the fly (see `src/gzip/ftgzip.c`).
    *
-   *   Define this macro if you want to enable this `feature'.  See also
-   *   the macro FT_CONFIG_OPTION_SYSTEM_ZLIB below.
+   *   Define this macro if you want to enable this 'feature'.  See also the
+   *   macro `FT_CONFIG_OPTION_SYSTEM_ZLIB` below.
    */
 #define FT_CONFIG_OPTION_USE_ZLIB
 
@@ -201,23 +203,23 @@ FT_BEGIN_HEADER
    *
    * ZLib library selection
    *
-   *   This macro is only used when FT_CONFIG_OPTION_USE_ZLIB is defined.
-   *   It allows FreeType's `ftgzip' component to link to the system's
+   *   This macro is only used when `FT_CONFIG_OPTION_USE_ZLIB` is defined.
+   *   It allows FreeType's 'ftgzip' component to link to the system's
    *   installation of the ZLib library.  This is useful on systems like
    *   Unix or VMS where it generally is already available.
    *
-   *   If you let it undefined, the component will use its own copy
-   *   of the zlib sources instead.  These have been modified to be
-   *   included directly within the component and *not* export external
-   *   function names.  This allows you to link any program with FreeType
-   *   _and_ ZLib without linking conflicts.
+   *   If you let it undefined, the component will use its own copy of the
+   *   zlib sources instead.  These have been modified to be included
+   *   directly within the component and **not** export external function
+   *   names.  This allows you to link any program with FreeType _and_ ZLib
+   *   without linking conflicts.
    *
-   *   Do not #undef this macro here since the build system might define
+   *   Do not `#undef` this macro here since the build system might define
    *   it for certain configurations only.
    *
-   *   If you use a build system like cmake or the `configure' script,
-   *   options set by those programs have precendence, overwriting the
-   *   value here with the configured one.
+   *   If you use a build system like cmake or the `configure` script,
+   *   options set by those programs have precedence, overwriting the value
+   *   here with the configured one.
    */
 /* #define FT_CONFIG_OPTION_SYSTEM_ZLIB */
 
@@ -227,28 +229,28 @@ FT_BEGIN_HEADER
    * Bzip2-compressed file support.
    *
    *   FreeType now handles font files that have been compressed with the
-   *   `bzip2' program.  This is mostly used to parse many of the PCF
-   *   files that come with XFree86.  The implementation uses `libbz2' to
-   *   partially uncompress the file on the fly (see src/bzip2/ftbzip2.c).
-   *   Contrary to gzip, bzip2 currently is not included and need to use
-   *   the system available bzip2 implementation.
+   *   `bzip2` program.  This is mostly used to parse many of the PCF files
+   *   that come with XFree86.  The implementation uses `libbz2` to partially
+   *   uncompress the file on the fly (see `src/bzip2/ftbzip2.c`).  Contrary
+   *   to gzip, bzip2 currently is not included and need to use the system
+   *   available bzip2 implementation.
    *
-   *   Define this macro if you want to enable this `feature'.
+   *   Define this macro if you want to enable this 'feature'.
    *
-   *   If you use a build system like cmake or the `configure' script,
-   *   options set by those programs have precendence, overwriting the
-   *   value here with the configured one.
+   *   If you use a build system like cmake or the `configure` script,
+   *   options set by those programs have precedence, overwriting the value
+   *   here with the configured one.
    */
 /* #define FT_CONFIG_OPTION_USE_BZIP2 */
 
 
   /**************************************************************************
    *
-   * Define to disable the use of file stream functions and types, FILE,
-   * fopen() etc.  Enables the use of smaller system libraries on embedded
-   * systems that have multiple system libraries, some with or without
-   * file stream support, in the cases where file stream support is not
-   * necessary such as memory loading of font files.
+   * Define to disable the use of file stream functions and types, `FILE`,
+   * `fopen`, etc.  Enables the use of smaller system libraries on embedded
+   * systems that have multiple system libraries, some with or without file
+   * stream support, in the cases where file stream support is not necessary
+   * such as memory loading of font files.
    */
 /* #define FT_CONFIG_OPTION_DISABLE_STREAM_SUPPORT */
 
@@ -259,14 +261,14 @@ FT_BEGIN_HEADER
    *
    *   FreeType now handles loading color bitmap glyphs in the PNG format.
    *   This requires help from the external libpng library.  Uncompressed
-   *   color bitmaps do not need any external libraries and will be
-   *   supported regardless of this configuration.
+   *   color bitmaps do not need any external libraries and will be supported
+   *   regardless of this configuration.
    *
-   *   Define this macro if you want to enable this `feature'.
+   *   Define this macro if you want to enable this 'feature'.
    *
-   *   If you use a build system like cmake or the `configure' script,
-   *   options set by those programs have precendence, overwriting the
-   *   value here with the configured one.
+   *   If you use a build system like cmake or the `configure` script,
+   *   options set by those programs have precedence, overwriting the value
+   *   here with the configured one.
    */
 #define FT_CONFIG_OPTION_USE_PNG
 
@@ -275,42 +277,58 @@ FT_BEGIN_HEADER
    *
    * HarfBuzz support.
    *
-   *   FreeType uses the HarfBuzz library to improve auto-hinting of
-   *   OpenType fonts.  If available, many glyphs not directly addressable
-   *   by a font's character map will be hinted also.
+   *   FreeType uses the HarfBuzz library to improve auto-hinting of OpenType
+   *   fonts.  If available, many glyphs not directly addressable by a font's
+   *   character map will be hinted also.
    *
-   *   Define this macro if you want to enable this `feature'.
+   *   Define this macro if you want to enable this 'feature'.
    *
-   *   If you use a build system like cmake or the `configure' script,
-   *   options set by those programs have precendence, overwriting the
-   *   value here with the configured one.
+   *   If you use a build system like cmake or the `configure` script,
+   *   options set by those programs have precedence, overwriting the value
+   *   here with the configured one.
    */
 #if !defined(WITHOUT_HARFBUZZ)
 #define FT_CONFIG_OPTION_USE_HARFBUZZ
 #endif
 
 
+  /**************************************************************************
+   *
+   * Brotli support.
+   *
+   *   FreeType uses the Brotli library to provide support for decompressing
+   *   WOFF2 streams.
+   *
+   *   Define this macro if you want to enable this 'feature'.
+   *
+   *   If you use a build system like cmake or the `configure` script,
+   *   options set by those programs have precedence, overwriting the value
+   *   here with the configured one.
+   */
+/* #define FT_CONFIG_OPTION_USE_BROTLI */
+
+
   /**************************************************************************
    *
    * Glyph Postscript Names handling
    *
-   *   By default, FreeType 2 is compiled with the `psnames' module.  This
-   *   module is in charge of converting a glyph name string into a
-   *   Unicode value, or return a Macintosh standard glyph name for the
-   *   use with the TrueType `post' table.
+   *   By default, FreeType 2 is compiled with the 'psnames' module.  This
+   *   module is in charge of converting a glyph name string into a Unicode
+   *   value, or return a Macintosh standard glyph name for the use with the
+   *   TrueType 'post' table.
    *
-   *   Undefine this macro if you do not want `psnames' compiled in your
+   *   Undefine this macro if you do not want 'psnames' compiled in your
    *   build of FreeType.  This has the following effects:
    *
-   *   - The TrueType driver will provide its own set of glyph names,
-   *     if you build it to support postscript names in the TrueType
-   *     `post' table, but will not synthesize a missing Unicode charmap.
+   *   - The TrueType driver will provide its own set of glyph names, if you
+   *     build it to support postscript names in the TrueType 'post' table,
+   *     but will not synthesize a missing Unicode charmap.
    *
-   *   - The Type 1 driver will not be able to synthesize a Unicode
-   *     charmap out of the glyphs found in the fonts.
+   *   - The Type~1 driver will not be able to synthesize a Unicode charmap
+   *     out of the glyphs found in the fonts.
    *
-   *   You would normally undefine this configuration macro when building
-   *   a version of FreeType that doesn't contain a Type 1 or CFF driver.
+   *   You would normally undefine this configuration macro when building a
+   *   version of FreeType that doesn't contain a Type~1 or CFF driver.
    */
 #define FT_CONFIG_OPTION_POSTSCRIPT_NAMES
 
@@ -319,16 +337,15 @@ FT_BEGIN_HEADER
    *
    * Postscript Names to Unicode Values support
    *
-   *   By default, FreeType 2 is built with the `PSNames' module compiled
-   *   in.  Among other things, the module is used to convert a glyph name
-   *   into a Unicode value.  This is especially useful in order to
-   *   synthesize on the fly a Unicode charmap from the CFF/Type 1 driver
-   *   through a big table named the `Adobe Glyph List' (AGL).
+   *   By default, FreeType~2 is built with the 'psnames' module compiled in.
+   *   Among other things, the module is used to convert a glyph name into a
+   *   Unicode value.  This is especially useful in order to synthesize on
+   *   the fly a Unicode charmap from the CFF/Type~1 driver through a big
+   *   table named the 'Adobe Glyph List' (AGL).
    *
-   *   Undefine this macro if you do not want the Adobe Glyph List
-   *   compiled in your `PSNames' module.  The Type 1 driver will not be
-   *   able to synthesize a Unicode charmap out of the glyphs found in the
-   *   fonts.
+   *   Undefine this macro if you do not want the Adobe Glyph List compiled
+   *   in your 'psnames' module.  The Type~1 driver will not be able to
+   *   synthesize a Unicode charmap out of the glyphs found in the fonts.
    */
 #define FT_CONFIG_OPTION_ADOBE_GLYPH_LIST
 
@@ -337,11 +354,11 @@ FT_BEGIN_HEADER
    *
    * Support for Mac fonts
    *
-   *   Define this macro if you want support for outline fonts in Mac
-   *   format (mac dfont, mac resource, macbinary containing a mac
-   *   resource) on non-Mac platforms.
+   *   Define this macro if you want support for outline fonts in Mac format
+   *   (mac dfont, mac resource, macbinary containing a mac resource) on
+   *   non-Mac platforms.
    *
-   *   Note that the `FOND' resource isn't checked.
+   *   Note that the 'FOND' resource isn't checked.
    */
 /* #define FT_CONFIG_OPTION_MAC_FONTS */
 
@@ -350,19 +367,17 @@ FT_BEGIN_HEADER
    *
    * Guessing methods to access embedded resource forks
    *
-   *   Enable extra Mac fonts support on non-Mac platforms (e.g.
-   *   GNU/Linux).
+   *   Enable extra Mac fonts support on non-Mac platforms (e.g., GNU/Linux).
    *
    *   Resource forks which include fonts data are stored sometimes in
    *   locations which users or developers don't expected.  In some cases,
    *   resource forks start with some offset from the head of a file.  In
-   *   other cases, the actual resource fork is stored in file different
-   *   from what the user specifies.  If this option is activated,
-   *   FreeType tries to guess whether such offsets or different file
-   *   names must be used.
+   *   other cases, the actual resource fork is stored in file different from
+   *   what the user specifies.  If this option is activated, FreeType tries
+   *   to guess whether such offsets or different file names must be used.
    *
    *   Note that normal, direct access of resource forks is controlled via
-   *   the FT_CONFIG_OPTION_MAC_FONTS option.
+   *   the `FT_CONFIG_OPTION_MAC_FONTS` option.
    */
 #ifdef FT_CONFIG_OPTION_MAC_FONTS
 #define FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK
@@ -371,19 +386,19 @@ FT_BEGIN_HEADER
 
   /**************************************************************************
    *
-   * Allow the use of FT_Incremental_Interface to load typefaces that
-   * contain no glyph data, but supply it via a callback function.
-   * This is required by clients supporting document formats which
-   * supply font data incrementally as the document is parsed, such
-   * as the Ghostscript interpreter for the PostScript language.
+   * Allow the use of `FT_Incremental_Interface` to load typefaces that
+   * contain no glyph data, but supply it via a callback function.  This is
+   * required by clients supporting document formats which supply font data
+   * incrementally as the document is parsed, such as the Ghostscript
+   * interpreter for the PostScript language.
    */
 #define FT_CONFIG_OPTION_INCREMENTAL
 
 
   /**************************************************************************
    *
-   * The size in bytes of the render pool used by the scan-line converter
-   * to do all of its work.
+   * The size in bytes of the render pool used by the scan-line converter to
+   * do all of its work.
    */
 #define FT_RENDER_POOL_SIZE  16384L
 
@@ -393,7 +408,7 @@ FT_BEGIN_HEADER
    * FT_MAX_MODULES
    *
    *   The maximum number of modules that can be registered in a single
-   *   FreeType library object.  32 is the default.
+   *   FreeType library object.  32~is the default.
    */
 #define FT_MAX_MODULES  32
 
@@ -403,52 +418,74 @@ FT_BEGIN_HEADER
    * Debug level
    *
    *   FreeType can be compiled in debug or trace mode.  In debug mode,
-   *   errors are reported through the `ftdebug' component.  In trace
-   *   mode, additional messages are sent to the standard output during
-   *   execution.
+   *   errors are reported through the 'ftdebug' component.  In trace mode,
+   *   additional messages are sent to the standard output during execution.
    *
-   *   Define FT_DEBUG_LEVEL_ERROR to build the library in debug mode.
-   *   Define FT_DEBUG_LEVEL_TRACE to build it in trace mode.
+   *   Define `FT_DEBUG_LEVEL_ERROR` to build the library in debug mode.
+   *   Define `FT_DEBUG_LEVEL_TRACE` to build it in trace mode.
    *
-   *   Don't define any of these macros to compile in `release' mode!
+   *   Don't define any of these macros to compile in 'release' mode!
    *
-   *   Do not #undef these macros here since the build system might define
+   *   Do not `#undef` these macros here since the build system might define
    *   them for certain configurations only.
    */
 /* #define FT_DEBUG_LEVEL_ERROR */
 /* #define FT_DEBUG_LEVEL_TRACE */
 
 
+  /**************************************************************************
+   *
+   * Logging
+   *
+   *   Compiling FreeType in debug or trace mode makes FreeType write error
+   *   and trace log messages to `stderr`.  Enabling this macro
+   *   automatically forces the `FT_DEBUG_LEVEL_ERROR` and
+   *   `FT_DEBUG_LEVEL_TRACE` macros and allows FreeType to write error and
+   *   trace log messages to a file instead of `stderr`.  For writing logs
+   *   to a file, FreeType uses an the external `dlg` library (the source
+   *   code is in `src/dlg`).
+   *
+   *   This option needs a C99 compiler.
+   */
+/* #define FT_DEBUG_LOGGING */
+
+
   /**************************************************************************
    *
    * Autofitter debugging
    *
-   *   If FT_DEBUG_AUTOFIT is defined, FreeType provides some means to
+   *   If `FT_DEBUG_AUTOFIT` is defined, FreeType provides some means to
    *   control the autofitter behaviour for debugging purposes with global
-   *   boolean variables (consequently, you should *never* enable this
-   *   while compiling in `release' mode):
+   *   boolean variables (consequently, you should **never** enable this
+   *   while compiling in 'release' mode):
    *
+   *   ```
    *     _af_debug_disable_horz_hints
    *     _af_debug_disable_vert_hints
    *     _af_debug_disable_blue_hints
+   *   ```
    *
    *   Additionally, the following functions provide dumps of various
-   *   internal autofit structures to stdout (using `printf'):
+   *   internal autofit structures to stdout (using `printf`):
    *
+   *   ```
    *     af_glyph_hints_dump_points
    *     af_glyph_hints_dump_segments
    *     af_glyph_hints_dump_edges
    *     af_glyph_hints_get_num_segments
    *     af_glyph_hints_get_segment_offset
+   *   ```
    *
    *   As an argument, they use another global variable:
    *
+   *   ```
    *     _af_debug_hints
+   *   ```
    *
-   *   Please have a look at the `ftgrid' demo program to see how those
+   *   Please have a look at the `ftgrid` demo program to see how those
    *   variables and macros should be used.
    *
-   *   Do not #undef these macros here since the build system might define
+   *   Do not `#undef` these macros here since the build system might define
    *   them for certain configurations only.
    */
 /* #define FT_DEBUG_AUTOFIT */
@@ -458,16 +495,16 @@ FT_BEGIN_HEADER
    *
    * Memory Debugging
    *
-   *   FreeType now comes with an integrated memory debugger that is
-   *   capable of detecting simple errors like memory leaks or double
-   *   deletes.  To compile it within your build of the library, you
-   *   should define FT_DEBUG_MEMORY here.
+   *   FreeType now comes with an integrated memory debugger that is capable
+   *   of detecting simple errors like memory leaks or double deletes.  To
+   *   compile it within your build of the library, you should define
+   *   `FT_DEBUG_MEMORY` here.
    *
-   *   Note that the memory debugger is only activated at runtime when
-   *   when the _environment_ variable `FT2_DEBUG_MEMORY' is defined also!
+   *   Note that the memory debugger is only activated at runtime when when
+   *   the _environment_ variable `FT2_DEBUG_MEMORY` is defined also!
    *
-   *   Do not #undef this macro here since the build system might define
-   *   it for certain configurations only.
+   *   Do not `#undef` this macro here since the build system might define it
+   *   for certain configurations only.
    */
 /* #define FT_DEBUG_MEMORY */
 
@@ -476,46 +513,30 @@ FT_BEGIN_HEADER
    *
    * Module errors
    *
-   *   If this macro is set (which is _not_ the default), the higher byte
-   *   of an error code gives the module in which the error has occurred,
-   *   while the lower byte is the real error code.
+   *   If this macro is set (which is _not_ the default), the higher byte of
+   *   an error code gives the module in which the error has occurred, while
+   *   the lower byte is the real error code.
    *
-   *   Setting this macro makes sense for debugging purposes only, since
-   *   it would break source compatibility of certain programs that use
-   *   FreeType 2.
+   *   Setting this macro makes sense for debugging purposes only, since it
+   *   would break source compatibility of certain programs that use
+   *   FreeType~2.
    *
-   *   More details can be found in the files ftmoderr.h and fterrors.h.
+   *   More details can be found in the files `ftmoderr.h` and `fterrors.h`.
    */
 #undef FT_CONFIG_OPTION_USE_MODULE_ERRORS
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* Position Independent Code                                             */
-  /*                                                                       */
-  /*   If this macro is set (which is _not_ the default), FreeType2 will   */
-  /*   avoid creating constants that require address fixups.  Instead the  */
-  /*   constants will be moved into a struct and additional intialization  */
-  /*   code will be used.                                                  */
-  /*                                                                       */
-  /*   Setting this macro is needed for systems that prohibit address      */
-  /*   fixups, such as BREW.  [Note that standard compilers like gcc or    */
-  /*   clang handle PIC generation automatically; you don't have to set    */
-  /*   FT_CONFIG_OPTION_PIC, which is only necessary for very special      */
-  /*   compilers.]                                                         */
-  /*                                                                       */
-  /*   Note that FT_CONFIG_OPTION_PIC support is not available for all     */
-  /*   modules (see `modules.cfg' for a complete list).  For building with */
-  /*   FT_CONFIG_OPTION_PIC support, do the following.                     */
-  /*                                                                       */
-  /*     0. Clone the repository.                                          */
-  /*     1. Define FT_CONFIG_OPTION_PIC.                                   */
-  /*     2. Remove all subdirectories in `src' that don't have             */
-  /*        FT_CONFIG_OPTION_PIC support.                                  */
-  /*     3. Comment out the corresponding modules in `modules.cfg'.        */
-  /*     4. Compile.                                                       */
-  /*                                                                       */
-/* #define FT_CONFIG_OPTION_PIC */
+  /**************************************************************************
+   *
+   * Error Strings
+   *
+   *   If this macro is set, `FT_Error_String` will return meaningful
+   *   descriptions.  This is not enabled by default to reduce the overall
+   *   size of FreeType.
+   *
+   *   More details can be found in the file `fterrors.h`.
+   */
+/* #define FT_CONFIG_OPTION_ERROR_STRINGS */
 
 
   /*************************************************************************/
@@ -529,47 +550,47 @@ FT_BEGIN_HEADER
 
   /**************************************************************************
    *
-   * Define TT_CONFIG_OPTION_EMBEDDED_BITMAPS if you want to support
-   * embedded bitmaps in all formats using the SFNT module (namely
-   * TrueType & OpenType).
+   * Define `TT_CONFIG_OPTION_EMBEDDED_BITMAPS` if you want to support
+   * embedded bitmaps in all formats using the 'sfnt' module (namely
+   * TrueType~& OpenType).
    */
 #define TT_CONFIG_OPTION_EMBEDDED_BITMAPS
 
 
   /**************************************************************************
    *
-   * Define TT_CONFIG_OPTION_COLOR_LAYERS if you want to support coloured
-   * outlines (from the COLR/CPAL tables) in all formats using the SFNT
-   * module (namely TrueType & OpenType).
+   * Define `TT_CONFIG_OPTION_COLOR_LAYERS` if you want to support colored
+   * outlines (from the 'COLR'/'CPAL' tables) in all formats using the 'sfnt'
+   * module (namely TrueType~& OpenType).
    */
 #define TT_CONFIG_OPTION_COLOR_LAYERS
 
 
   /**************************************************************************
    *
-   * Define TT_CONFIG_OPTION_POSTSCRIPT_NAMES if you want to be able to
-   * load and enumerate the glyph Postscript names in a TrueType or
-   * OpenType file.
+   * Define `TT_CONFIG_OPTION_POSTSCRIPT_NAMES` if you want to be able to
+   * load and enumerate the glyph Postscript names in a TrueType or OpenType
+   * file.
    *
-   * Note that when you do not compile the `PSNames' module by undefining
-   * the above FT_CONFIG_OPTION_POSTSCRIPT_NAMES, the `sfnt' module will
+   * Note that when you do not compile the 'psnames' module by undefining the
+   * above `FT_CONFIG_OPTION_POSTSCRIPT_NAMES`, the 'sfnt' module will
    * contain additional code used to read the PS Names table from a font.
    *
-   * (By default, the module uses `PSNames' to extract glyph names.)
+   * (By default, the module uses 'psnames' to extract glyph names.)
    */
 #define TT_CONFIG_OPTION_POSTSCRIPT_NAMES
 
 
   /**************************************************************************
    *
-   * Define TT_CONFIG_OPTION_SFNT_NAMES if your applications need to
-   * access the internal name table in a SFNT-based format like TrueType
-   * or OpenType.  The name table contains various strings used to
-   * describe the font, like family name, copyright, version, etc.  It
-   * does not contain any glyph name though.
+   * Define `TT_CONFIG_OPTION_SFNT_NAMES` if your applications need to access
+   * the internal name table in a SFNT-based format like TrueType or
+   * OpenType.  The name table contains various strings used to describe the
+   * font, like family name, copyright, version, etc.  It does not contain
+   * any glyph name though.
    *
    * Accessing SFNT names is done through the functions declared in
-   * `ftsnames.h'.
+   * `ftsnames.h`.
    */
 #define TT_CONFIG_OPTION_SFNT_NAMES
 
@@ -602,54 +623,53 @@ FT_BEGIN_HEADER
 
   /**************************************************************************
    *
-   * Define TT_CONFIG_OPTION_BYTECODE_INTERPRETER if you want to compile
-   * a bytecode interpreter in the TrueType driver.
+   * Define `TT_CONFIG_OPTION_BYTECODE_INTERPRETER` if you want to compile a
+   * bytecode interpreter in the TrueType driver.
    *
    * By undefining this, you will only compile the code necessary to load
    * TrueType glyphs without hinting.
    *
-   *   Do not #undef this macro here, since the build system might
-   *   define it for certain configurations only.
+   * Do not `#undef` this macro here, since the build system might define it
+   * for certain configurations only.
    */
 #define TT_CONFIG_OPTION_BYTECODE_INTERPRETER
 
 
   /**************************************************************************
    *
-   * Define TT_CONFIG_OPTION_SUBPIXEL_HINTING if you want to compile
+   * Define `TT_CONFIG_OPTION_SUBPIXEL_HINTING` if you want to compile
    * subpixel hinting support into the TrueType driver.  This modifies the
-   * TrueType hinting mechanism when anything but FT_RENDER_MODE_MONO is
+   * TrueType hinting mechanism when anything but `FT_RENDER_MODE_MONO` is
    * requested.
    *
    * In particular, it modifies the bytecode interpreter to interpret (or
-   * not) instructions in a certain way so that all TrueType fonts look
-   * like they do in a Windows ClearType (DirectWrite) environment.  See
-   * [1] for a technical overview on what this means.  See `ttinterp.h'
-   * for more details on the LEAN option.
+   * not) instructions in a certain way so that all TrueType fonts look like
+   * they do in a Windows ClearType (DirectWrite) environment.  See [1] for a
+   * technical overview on what this means.  See `ttinterp.h` for more
+   * details on the LEAN option.
    *
    * There are three possible values.
    *
    * Value 1:
-   *   This value is associated with the `Infinality' moniker,
-   *   contributed by an individual nicknamed Infinality with the goal of
-   *   making TrueType fonts render better than on Windows.  A high
-   *   amount of configurability and flexibility, down to rules for
-   *   single glyphs in fonts, but also very slow.  Its experimental and
-   *   slow nature and the original developer losing interest meant that
-   *   this option was never enabled in default builds.
+   *   This value is associated with the 'Infinality' moniker, contributed by
+   *   an individual nicknamed Infinality with the goal of making TrueType
+   *   fonts render better than on Windows.  A high amount of configurability
+   *   and flexibility, down to rules for single glyphs in fonts, but also
+   *   very slow.  Its experimental and slow nature and the original
+   *   developer losing interest meant that this option was never enabled in
+   *   default builds.
    *
    *   The corresponding interpreter version is v38.
    *
    * Value 2:
    *   The new default mode for the TrueType driver.  The Infinality code
-   *   base was stripped to the bare minimum and all configurability
-   *   removed in the name of speed and simplicity.  The configurability
-   *   was mainly aimed at legacy fonts like Arial, Times New Roman, or
-   *   Courier.  Legacy fonts are fonts that modify vertical stems to
-   *   achieve clean black-and-white bitmaps.  The new mode focuses on
-   *   applying a minimal set of rules to all fonts indiscriminately so
-   *   that modern and web fonts render well while legacy fonts render
-   *   okay.
+   *   base was stripped to the bare minimum and all configurability removed
+   *   in the name of speed and simplicity.  The configurability was mainly
+   *   aimed at legacy fonts like 'Arial', 'Times New Roman', or 'Courier'.
+   *   Legacy fonts are fonts that modify vertical stems to achieve clean
+   *   black-and-white bitmaps.  The new mode focuses on applying a minimal
+   *   set of rules to all fonts indiscriminately so that modern and web
+   *   fonts render well while legacy fonts render okay.
    *
    *   The corresponding interpreter version is v40.
    *
@@ -657,18 +677,18 @@ FT_BEGIN_HEADER
    *   Compile both, making both v38 and v40 available (the latter is the
    *   default).
    *
-   * By undefining these, you get rendering behavior like on Windows
-   * without ClearType, i.e., Windows XP without ClearType enabled and
-   * Win9x (interpreter version v35).  Or not, depending on how much
-   * hinting blood and testing tears the font designer put into a given
-   * font.  If you define one or both subpixel hinting options, you can
-   * switch between between v35 and the ones you define (using
-   * `FT_Property_Set').
+   * By undefining these, you get rendering behavior like on Windows without
+   * ClearType, i.e., Windows XP without ClearType enabled and Win9x
+   * (interpreter version v35).  Or not, depending on how much hinting blood
+   * and testing tears the font designer put into a given font.  If you
+   * define one or both subpixel hinting options, you can switch between
+   * between v35 and the ones you define (using `FT_Property_Set`).
    *
-   * This option requires TT_CONFIG_OPTION_BYTECODE_INTERPRETER to be
+   * This option requires `TT_CONFIG_OPTION_BYTECODE_INTERPRETER` to be
    * defined.
    *
-   * [1] https://www.microsoft.com/typography/cleartype/truetypecleartype.aspx
+   * [1]
+   * https://www.microsoft.com/typography/cleartype/truetypecleartype.aspx
    */
 /* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  1         */
 #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  2
@@ -677,16 +697,16 @@ FT_BEGIN_HEADER
 
   /**************************************************************************
    *
-   * Define TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED to compile the
+   * Define `TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED` to compile the
    * TrueType glyph loader to use Apple's definition of how to handle
    * component offsets in composite glyphs.
    *
-   * Apple and MS disagree on the default behavior of component offsets
-   * in composites.  Apple says that they should be scaled by the scaling
-   * factors in the transformation matrix (roughly, it's more complex)
-   * while MS says they should not.  OpenType defines two bits in the
-   * composite flags array which can be used to disambiguate, but old
-   * fonts will not have them.
+   * Apple and MS disagree on the default behavior of component offsets in
+   * composites.  Apple says that they should be scaled by the scaling
+   * factors in the transformation matrix (roughly, it's more complex) while
+   * MS says they should not.  OpenType defines two bits in the composite
+   * flags array which can be used to disambiguate, but old fonts will not
+   * have them.
    *
    *   https://www.microsoft.com/typography/otspec/glyf.htm
    *   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html
@@ -696,34 +716,34 @@ FT_BEGIN_HEADER
 
   /**************************************************************************
    *
-   * Define TT_CONFIG_OPTION_GX_VAR_SUPPORT if you want to include
-   * support for Apple's distortable font technology (fvar, gvar, cvar,
-   * and avar tables).  This has many similarities to Type 1 Multiple
-   * Masters support.
+   * Define `TT_CONFIG_OPTION_GX_VAR_SUPPORT` if you want to include support
+   * for Apple's distortable font technology ('fvar', 'gvar', 'cvar', and
+   * 'avar' tables).  Tagged 'Font Variations', this is now part of OpenType
+   * also.  This has many similarities to Type~1 Multiple Masters support.
    */
 #define TT_CONFIG_OPTION_GX_VAR_SUPPORT
 
 
   /**************************************************************************
    *
-   * Define TT_CONFIG_OPTION_BDF if you want to include support for
-   * an embedded `BDF ' table within SFNT-based bitmap formats.
+   * Define `TT_CONFIG_OPTION_BDF` if you want to include support for an
+   * embedded 'BDF~' table within SFNT-based bitmap formats.
    */
 /* #define TT_CONFIG_OPTION_BDF */
 
 
   /**************************************************************************
    *
-   * Option TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES controls the maximum
+   * Option `TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES` controls the maximum
    * number of bytecode instructions executed for a single run of the
-   * bytecode interpreter, needed to prevent infinite loops.  You don't
-   * want to change this except for very special situations (e.g., making
-   * a library fuzzer spend less time to handle broken fonts).
+   * bytecode interpreter, needed to prevent infinite loops.  You don't want
+   * to change this except for very special situations (e.g., making a
+   * library fuzzer spend less time to handle broken fonts).
    *
    * It is not expected that this value is ever modified by a configuring
-   * script; instead, it gets surrounded with #ifndef ... #endif so that
-   * the value can be set as a preprocessor option on the compiler's
-   * command line.
+   * script; instead, it gets surrounded with `#ifndef ... #endif` so that
+   * the value can be set as a preprocessor option on the compiler's command
+   * line.
    */
 #ifndef TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES
 #define TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES  1000000L
@@ -741,16 +761,15 @@ FT_BEGIN_HEADER
 
   /**************************************************************************
    *
-   * T1_MAX_DICT_DEPTH is the maximum depth of nest dictionaries and
-   * arrays in the Type 1 stream (see t1load.c).  A minimum of 4 is
-   * required.
+   * `T1_MAX_DICT_DEPTH` is the maximum depth of nest dictionaries and arrays
+   * in the Type~1 stream (see `t1load.c`).  A minimum of~4 is required.
    */
 #define T1_MAX_DICT_DEPTH  5
 
 
   /**************************************************************************
    *
-   * T1_MAX_SUBRS_CALLS details the maximum number of nested sub-routine
+   * `T1_MAX_SUBRS_CALLS` details the maximum number of nested sub-routine
    * calls during glyph loading.
    */
 #define T1_MAX_SUBRS_CALLS  16
@@ -758,19 +777,20 @@ FT_BEGIN_HEADER
 
   /**************************************************************************
    *
-   * T1_MAX_CHARSTRING_OPERANDS is the charstring stack's capacity.  A
-   * minimum of 16 is required.
+   * `T1_MAX_CHARSTRING_OPERANDS` is the charstring stack's capacity.  A
+   * minimum of~16 is required.
    *
-   * The Chinese font MingTiEG-Medium (CNS 11643 character set) needs 256.
+   * The Chinese font 'MingTiEG-Medium' (covering the CNS 11643 character
+   * set) needs 256.
    */
 #define T1_MAX_CHARSTRINGS_OPERANDS  512
 
 
   /**************************************************************************
    *
-   * Define this configuration macro if you want to prevent the
-   * compilation of `t1afm', which is in charge of reading Type 1 AFM
-   * files into an existing face.  Note that if set, the T1 driver will be
+   * Define this configuration macro if you want to prevent the compilation
+   * of the 't1afm' module, which is in charge of reading Type~1 AFM files
+   * into an existing face.  Note that if set, the Type~1 driver will be
    * unable to produce kerning distances.
    */
 #undef T1_CONFIG_OPTION_NO_AFM
@@ -778,19 +798,18 @@ FT_BEGIN_HEADER
 
   /**************************************************************************
    *
-   * Define this configuration macro if you want to prevent the
-   * compilation of the Multiple Masters font support in the Type 1
-   * driver.
+   * Define this configuration macro if you want to prevent the compilation
+   * of the Multiple Masters font support in the Type~1 driver.
    */
 #undef T1_CONFIG_OPTION_NO_MM_SUPPORT
 
 
   /**************************************************************************
    *
-   * T1_CONFIG_OPTION_OLD_ENGINE controls whether the pre-Adobe Type 1
+   * `T1_CONFIG_OPTION_OLD_ENGINE` controls whether the pre-Adobe Type~1
    * engine gets compiled into FreeType.  If defined, it is possible to
-   * switch between the two engines using the `hinting-engine' property of
-   * the type1 driver module.
+   * switch between the two engines using the `hinting-engine` property of
+   * the 'type1' driver module.
    */
 /* #define T1_CONFIG_OPTION_OLD_ENGINE */
 
@@ -806,14 +825,13 @@ FT_BEGIN_HEADER
 
   /**************************************************************************
    *
-   * Using CFF_CONFIG_OPTION_DARKENING_PARAMETER_{X,Y}{1,2,3,4} it is
+   * Using `CFF_CONFIG_OPTION_DARKENING_PARAMETER_{X,Y}{1,2,3,4}` it is
    * possible to set up the default values of the four control points that
-   * define the stem darkening behaviour of the (new) CFF engine.  For
-   * more details please read the documentation of the
-   * `darkening-parameters' property (file `ftdriver.h'), which allows the
-   * control at run-time.
+   * define the stem darkening behaviour of the (new) CFF engine.  For more
+   * details please read the documentation of the `darkening-parameters`
+   * property (file `ftdriver.h`), which allows the control at run-time.
    *
-   * Do *not* undefine these macros!
+   * Do **not** undefine these macros!
    */
 #define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1   500
 #define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1   400
@@ -830,10 +848,10 @@ FT_BEGIN_HEADER
 
   /**************************************************************************
    *
-   * CFF_CONFIG_OPTION_OLD_ENGINE controls whether the pre-Adobe CFF
-   * engine gets compiled into FreeType.  If defined, it is possible to
-   * switch between the two engines using the `hinting-engine' property of
-   * the cff driver module.
+   * `CFF_CONFIG_OPTION_OLD_ENGINE` controls whether the pre-Adobe CFF engine
+   * gets compiled into FreeType.  If defined, it is possible to switch
+   * between the two engines using the `hinting-engine` property of the 'cff'
+   * driver module.
    */
 /* #define CFF_CONFIG_OPTION_OLD_ENGINE */
 
@@ -849,18 +867,18 @@ FT_BEGIN_HEADER
 
   /**************************************************************************
    *
-   * There are many PCF fonts just called `Fixed' which look completely
-   * different, and which have nothing to do with each other.  When
-   * selecting `Fixed' in KDE or Gnome one gets results that appear rather
-   * random, the style changes often if one changes the size and one
-   * cannot select some fonts at all.  This option makes the PCF module
-   * prepend the foundry name (plus a space) to the family name.
+   * There are many PCF fonts just called 'Fixed' which look completely
+   * different, and which have nothing to do with each other.  When selecting
+   * 'Fixed' in KDE or Gnome one gets results that appear rather random, the
+   * style changes often if one changes the size and one cannot select some
+   * fonts at all.  This option makes the 'pcf' module prepend the foundry
+   * name (plus a space) to the family name.
    *
-   * We also check whether we have `wide' characters; all put together, we
-   * get family names like `Sony Fixed' or `Misc Fixed Wide'.
+   * We also check whether we have 'wide' characters; all put together, we
+   * get family names like 'Sony Fixed' or 'Misc Fixed Wide'.
    *
    * If this option is activated, it can be controlled with the
-   * `no-long-family-names' property of the pcf driver module.
+   * `no-long-family-names` property of the 'pcf' driver module.
    */
 /* #define PCF_CONFIG_OPTION_LONG_FAMILY_NAMES */
 
@@ -876,49 +894,58 @@ FT_BEGIN_HEADER
 
   /**************************************************************************
    *
-   * Compile autofit module with CJK (Chinese, Japanese, Korean) script
+   * Compile 'autofit' module with CJK (Chinese, Japanese, Korean) script
    * support.
    */
 #define AF_CONFIG_OPTION_CJK
 
-  /**************************************************************************
-   *
-   * Compile autofit module with fallback Indic script support, covering
-   * some scripts that the `latin' submodule of the autofit module doesn't
-   * (yet) handle.
-   */
-#define AF_CONFIG_OPTION_INDIC
 
   /**************************************************************************
    *
-   * Compile autofit module with warp hinting.  The idea of the warping
-   * code is to slightly scale and shift a glyph within a single dimension
-   * so that as much of its segments are aligned (more or less) on the
-   * grid.  To find out the optimal scaling and shifting value, various
-   * parameter combinations are tried and scored.
+   * Compile 'autofit' module with fallback Indic script support, covering
+   * some scripts that the 'latin' submodule of the 'autofit' module doesn't
+   * (yet) handle.  Currently, this needs option `AF_CONFIG_OPTION_CJK`.
+   */
+#ifdef AF_CONFIG_OPTION_CJK
+#define AF_CONFIG_OPTION_INDIC
+#endif
+
+
+  /**************************************************************************
    *
-   * This experimental option is active only if the rendering mode is
-   * FT_RENDER_MODE_LIGHT; you can switch warping on and off with the
-   * `warping' property of the auto-hinter (see file `ftdriver.h' for more
-   * information; by default it is switched off).
+   * Compile 'autofit' module with warp hinting.  The idea of the warping
+   * code is to slightly scale and shift a glyph within a single dimension so
+   * that as much of its segments are aligned (more or less) on the grid.  To
+   * find out the optimal scaling and shifting value, various parameter
+   * combinations are tried and scored.
+   *
+   * You can switch warping on and off with the `warping` property of the
+   * auto-hinter (see file `ftdriver.h` for more information; by default it
+   * is switched off).
+   *
+   * This experimental option is not active if the rendering mode is
+   * `FT_RENDER_MODE_LIGHT`.
    */
 /* #define AF_CONFIG_OPTION_USE_WARPER */
 
+
   /**************************************************************************
    *
-   * Use TrueType-like size metrics for `light' auto-hinting.
+   * Use TrueType-like size metrics for 'light' auto-hinting.
    *
    * It is strongly recommended to avoid this option, which exists only to
-   * help some legacy applications retain its appearance and behaviour
-   * with respect to auto-hinted TrueType fonts.
+   * help some legacy applications retain its appearance and behaviour with
+   * respect to auto-hinted TrueType fonts.
    *
    * The very reason this option exists at all are GNU/Linux distributions
    * like Fedora that did not un-patch the following change (which was
    * present in FreeType between versions 2.4.6 and 2.7.1, inclusive).
    *
+   * ```
    *   2011-07-16  Steven Chu  <steven.f.chu@gmail.com>
    *
    *     [truetype] Fix metrics on size request for scalable fonts.
+   * ```
    *
    * This problematic commit is now reverted (more or less).
    */
@@ -928,15 +955,15 @@ FT_BEGIN_HEADER
 
 
   /*
-   * This macro is obsolete.  Support has been removed in FreeType
-   * version 2.5.
+   * This macro is obsolete.  Support has been removed in FreeType version
+   * 2.5.
    */
 /* #define FT_CONFIG_OPTION_OLD_INTERNALS */
 
 
   /*
-   * This macro is defined if native TrueType hinting is requested by the
-   * definitions above.
+   * The next three macros are defined if native TrueType hinting is
+   * requested by the definitions above.  Don't change this.
    */
 #ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
 #define  TT_USE_BYTECODE_INTERPRETER
@@ -953,9 +980,24 @@ FT_BEGIN_HEADER
 #endif
 
 
+  /*
+   * The TT_SUPPORT_COLRV1 macro is defined to indicate to clients that this
+   * version of FreeType has support for 'COLR' v1 API.  This definition is
+   * useful to FreeType clients that want to build in support for 'COLR' v1
+   * depending on a tip-of-tree checkout before it is officially released in
+   * FreeType, and while the feature cannot yet be tested against using
+   * version macros.  Don't change this macro.  This may be removed once the
+   * feature is in a FreeType release version and version macros can be used
+   * to test for availability.
+   */
+#ifdef TT_CONFIG_OPTION_COLOR_LAYERS
+#define  TT_SUPPORT_COLRV1
+#endif
+
+
   /*
    * Check CFF darkening parameters.  The checks are the same as in function
-   * `cff_property_set' in file `cffdrivr.c'.
+   * `cff_property_set` in file `cffdrivr.c`.
    */
 #if CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 < 0   || \
     CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 < 0   || \
diff --git a/third_party/freetype/include/freetype-custom/freetype/config/public-macros.h b/third_party/freetype/include/freetype-custom/freetype/config/public-macros.h
new file mode 100644
index 000000000000..347cf344bf1d
--- /dev/null
+++ b/third_party/freetype/include/freetype-custom/freetype/config/public-macros.h
@@ -0,0 +1,112 @@
+/****************************************************************************
+ *
+ * config/public-macros.h
+ *
+ *   Define a set of compiler macros used in public FreeType headers.
+ *
+ * Copyright (C) 2020-2021 by
+ * David Turner, Robert Wilhelm, and Werner Lemberg.
+ *
+ * This file is part of the FreeType project, and may only be used,
+ * modified, and distributed under the terms of the FreeType project
+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute
+ * this file you indicate that you have read the license and
+ * understand and accept it fully.
+ *
+ */
+
+  /*
+   * The definitions in this file are used by the public FreeType headers
+   * and thus should be considered part of the public API.
+   *
+   * Other compiler-specific macro definitions that are not exposed by the
+   * FreeType API should go into
+   * `include/freetype/internal/compiler-macros.h` instead.
+   */
+#ifndef FREETYPE_CONFIG_PUBLIC_MACROS_H_
+#define FREETYPE_CONFIG_PUBLIC_MACROS_H_
+
+  /*
+   * `FT_BEGIN_HEADER` and `FT_END_HEADER` might have already been defined
+   * by `freetype/config/ftheader.h`, but we don't want to include this
+   * header here, so redefine the macros here only when needed.  Their
+   * definition is very stable, so keeping them in sync with the ones in the
+   * header should not be a maintenance issue.
+   */
+#ifndef FT_BEGIN_HEADER
+#ifdef __cplusplus
+#define FT_BEGIN_HEADER  extern "C" {
+#else
+#define FT_BEGIN_HEADER  /* empty */
+#endif
+#endif  /* FT_BEGIN_HEADER */
+
+#ifndef FT_END_HEADER
+#ifdef __cplusplus
+#define FT_END_HEADER  }
+#else
+#define FT_END_HEADER  /* empty */
+#endif
+#endif  /* FT_END_HEADER */
+
+
+FT_BEGIN_HEADER
+
+  /*
+   * Mark a function declaration as public.  This ensures it will be
+   * properly exported to client code.  Place this before a function
+   * declaration.
+   *
+   * NOTE: This macro should be considered an internal implementation
+   * detail, and not part of the FreeType API.  It is only defined here
+   * because it is needed by `FT_EXPORT`.
+   */
+#if defined(_WIN32)
+# if defined(FT2_BUILD_DLL)
+#  if defined(FT2_BUILD_LIBRARY)
+#   define FT_PUBLIC_FUNCTION_ATTRIBUTE __declspec(dllexport)
+#  else
+#   define FT_PUBLIC_FUNCTION_ATTRIBUTE __declspec(dllimport)
+#  endif
+# else
+#  define FT_PUBLIC_FUNCTION_ATTRIBUTE /* nothing */
+# endif
+#else
+# if defined(CHROMIUM_RESTRICT_VISIBILITY)
+#  define FT_PUBLIC_FUNCTION_ATTRIBUTE /* nothing */
+# else
+#  define FT_PUBLIC_FUNCTION_ATTRIBUTE __attribute__((visibility ("default")))
+# endif
+#endif
+
+  /*
+   * Define a public FreeType API function.  This ensures it is properly
+   * exported or imported at build time.  The macro parameter is the
+   * function's return type as in:
+   *
+   *   FT_EXPORT( FT_Bool )
+   *   FT_Object_Method( FT_Object  obj,
+   *                     ... );
+   *
+   * NOTE: This requires that all `FT_EXPORT` uses are inside
+   * `FT_BEGIN_HEADER ... FT_END_HEADER` blocks.  This guarantees that the
+   * functions are exported with C linkage, even when the header is included
+   * by a C++ source file.
+   */
+#define FT_EXPORT( x )  FT_PUBLIC_FUNCTION_ATTRIBUTE extern x
+
+  /*
+   * `FT_UNUSED` indicates that a given parameter is not used -- this is
+   * only used to get rid of unpleasant compiler warnings.
+   *
+   * Technically, this was not meant to be part of the public API, but some
+   * third-party code depends on it.
+   */
+#ifndef FT_UNUSED
+#define FT_UNUSED( arg )  ( (arg) = (arg) )
+#endif
+
+
+FT_END_HEADER
+
+#endif  /* FREETYPE_CONFIG_PUBLIC_MACROS_H_ */
diff --git a/third_party/freetype/roll-freetype.sh b/third_party/freetype/roll-freetype.sh
index 5e7f927fa2f9..2032d7a2fc31 100755
--- a/third_party/freetype/roll-freetype.sh
+++ b/third_party/freetype/roll-freetype.sh
@@ -6,37 +6,18 @@ rolldeps() {
   roll-dep -r "${REVIEWERS}" "$@" src/third_party/freetype/src/
 }
 
-previousrev() {
-  STEP="original revision" &&
-  PREVIOUS_FREETYPE_REV=$(git grep "'freetype_revision':" HEAD~1 -- DEPS | grep -Eho "[0-9a-fA-F]{32}")
-}
-
 addtrybots() {
   STEP="add trybots" &&
-  OLD_MSG=$(git show -s --format=%B HEAD) &&
-  git commit --amend -m"$OLD_MSG" -m"CQ_INCLUDE_TRYBOTS=luci.chromium.try:linux_chromium_msan_rel_ng"
+  (git show -s --format=%B HEAD \
+    | git interpret-trailers --trailer "Cq-Include-Trybots:luci.chromium.try:linux_chromium_msan_rel_ng" \
+    | git commit --amend -F -)
 }
 
 addotherprojectbugs() {
   STEP="add pdfium bug" &&
-  OLD_MSG=$(git show -s --format=%B HEAD) &&
-  git commit --amend -m"$OLD_MSG" -m"
-PDFium-Issue: pdfium:"
-}
-
-checkmodules() {
-  STEP="check modules.cfg: check list of modules and dependencies" &&
-  ! git -C third_party/freetype/src/ diff --name-only ${PREVIOUS_FREETYPE_REV} | grep -q modules.cfg
-}
-
-mergeinclude() {
-  INCLUDE=$1 &&
-  STEP="merge ${INCLUDE}: check for merge conflicts" &&
-  TMPFILE=$(mktemp) &&
-  git -C third_party/freetype/src/ cat-file blob ${PREVIOUS_FREETYPE_REV}:include/freetype/config/${INCLUDE} >> ${TMPFILE} &&
-  git merge-file third_party/freetype/include/freetype-custom-config/${INCLUDE} ${TMPFILE} third_party/freetype/src/include/freetype/config/${INCLUDE} &&
-  rm ${TMPFILE} &&
-  git add third_party/freetype/include/freetype-custom-config/${INCLUDE}
+  (git show -s --format=%B HEAD \
+    | git interpret-trailers --trailer "PDFium-Issue:pdfium:" \
+    | git commit --amend -F -)
 }
 
 updatereadme() {
@@ -48,18 +29,39 @@ updatereadme() {
   git add third_party/freetype/README.chromium
 }
 
+previousrev() {
+  STEP="original revision" &&
+  PREVIOUS_FREETYPE_REV=$(git grep "'freetype_revision':" HEAD~1 -- DEPS | grep -Eho "[0-9a-fA-F]{32}")
+}
+
+mergeinclude() {
+  INCLUDE=$1 &&
+  previousrev &&
+  STEP="merge ${INCLUDE}: check for merge conflicts" &&
+  TMPFILE=$(mktemp) &&
+  git -C third_party/freetype/src/ cat-file blob ${PREVIOUS_FREETYPE_REV}:include/${INCLUDE} >> ${TMPFILE} &&
+  git merge-file third_party/freetype/include/freetype-custom/${INCLUDE} ${TMPFILE} third_party/freetype/src/include/${INCLUDE} &&
+  rm ${TMPFILE} &&
+  git add third_party/freetype/include/freetype-custom/${INCLUDE}
+}
+
+checkmodules() {
+  previousrev &&
+  STEP="check modules.cfg: check list of modules and dependencies" &&
+  ! git -C third_party/freetype/src/ diff --name-only ${PREVIOUS_FREETYPE_REV} | grep -q modules.cfg
+}
+
 commit() {
   STEP="commit" &&
   git commit --quiet --amend --no-edit
 }
 
 rolldeps "$@" &&
-previousrev &&
 addtrybots &&
 addotherprojectbugs &&
-checkmodules &&
-mergeinclude ftoption.h &&
-mergeinclude ftconfig.h &&
 updatereadme &&
-commit &&
-true || echo "Failed step ${STEP}" && false
+mergeinclude "freetype/config/ftoption.h" &&
+mergeinclude "freetype/config/public-macros.h" &&
+checkmodules &&
+commit ||
+{ echo "Failed step ${STEP}"; exit 1; }
diff --git a/ui/gfx/font_fallback_linux.cc b/ui/gfx/font_fallback_linux.cc
index 9c2e99ca169a..d9138ab36a7e 100644
--- a/ui/gfx/font_fallback_linux.cc
+++ b/ui/gfx/font_fallback_linux.cc
@@ -9,11 +9,20 @@
 #include <map>
 #include <memory>
 #include <string>
-#include <vector>
 
+#include "base/containers/mru_cache.h"
+#include "base/files/file_path.h"
 #include "base/lazy_instance.h"
 #include "base/memory/ptr_util.h"
+#include "base/no_destructor.h"
+#include "base/trace_event/trace_event.h"
+#include "third_party/icu/source/common/unicode/uchar.h"
+#include "third_party/icu/source/common/unicode/utf16.h"
+#include "third_party/skia/include/core/SkFontMgr.h"
 #include "ui/gfx/font.h"
+#include "ui/gfx/font_fallback.h"
+#include "ui/gfx/linux/fontconfig_util.h"
+#include "ui/gfx/platform_font.h"
 
 namespace gfx {
 
@@ -22,49 +31,358 @@ namespace {
 const char kFontFormatTrueType[] = "TrueType";
 const char kFontFormatCFF[] = "CFF";
 
-typedef std::map<std::string, std::vector<Font> > FallbackCache;
-base::LazyInstance<FallbackCache>::Leaky g_fallback_cache =
-    LAZY_INSTANCE_INITIALIZER;
+bool IsValidFontFromPattern(FcPattern* pattern) {
+  // Ignore any bitmap fonts users may still have installed from last
+  // century.
+  if (!IsFontScalable(pattern))
+    return false;
+
+  // Take only supported font formats on board.
+  std::string format = GetFontFormat(pattern);
+  if (format != kFontFormatTrueType && format != kFontFormatCFF)
+    return false;
+
+  // Ignore any fonts FontConfig knows about, but that we don't have
+  // permission to read.
+  base::FilePath font_path = GetFontPath(pattern);
+  if (font_path.empty() || access(font_path.AsUTF8Unsafe().c_str(), R_OK))
+    return false;
+
+  return true;
+}
+
+// This class uniquely identified a typeface. A typeface can be identified by
+// its file path and it's ttc index.
+class TypefaceCacheKey {
+ public:
+  TypefaceCacheKey(const base::FilePath& font_path, int ttc_index)
+      : font_path_(font_path), ttc_index_(ttc_index) {}
+
+  const base::FilePath& font_path() const { return font_path_; }
+  int ttc_index() const { return ttc_index_; }
+
+  bool operator<(const TypefaceCacheKey& other) const {
+    return std::tie(ttc_index_, font_path_) <
+           std::tie(other.ttc_index_, other.font_path_);
+  }
+
+ private:
+  base::FilePath font_path_;
+  int ttc_index_;
+
+  DISALLOW_ASSIGN(TypefaceCacheKey);
+};
+
+// Returns a SkTypeface for a given font path and ttc_index. The typeface is
+// cached to avoid reloading the font from file. SkTypeface is not caching
+// these requests.
+sk_sp<SkTypeface> GetSkTypefaceFromPathAndIndex(const base::FilePath& font_path,
+                                                int ttc_index) {
+  using TypefaceCache = std::map<TypefaceCacheKey, sk_sp<SkTypeface>>;
+  static base::NoDestructor<TypefaceCache> typeface_cache;
+
+  if (font_path.empty())
+    return nullptr;
+
+  TypefaceCache* cache = typeface_cache.get();
+  TypefaceCacheKey key(font_path, ttc_index);
+  TypefaceCache::iterator entry = cache->find(key);
+  if (entry != cache->end())
+    return sk_sp<SkTypeface>(entry->second);
+
+  sk_sp<SkFontMgr> font_mgr = SkFontMgr::RefDefault();
+  std::string filename = font_path.AsUTF8Unsafe();
+  sk_sp<SkTypeface> typeface =
+      font_mgr->makeFromFile(filename.c_str(), ttc_index);
+  (*cache)[key] = typeface;
+
+  return sk_sp<SkTypeface>(typeface);
+}
+
+// Implements a fallback font cache over FontConfig API.
+//
+// A MRU cache is kept from a font to its potential fallback fonts.
+// The key (e.g. FallbackFontEntry) contains the font for which
+// fallback font must be returned.
+//
+// For each key, the cache is keeping a set (e.g. FallbackFontEntries) of
+// potential fallback font (e.g. FallbackFontEntry). Each fallback font entry
+// contains the supported codepoints (e.g. charset). The fallback font returned
+// by GetFallbackFont(...) depends on the input text and is using the charset
+// to determine the best candidate.
+class FallbackFontKey {
+ public:
+  FallbackFontKey(std::string locale, Font font)
+      : locale_(locale), font_(font) {}
+
+  FallbackFontKey(const FallbackFontKey&) = default;
+  ~FallbackFontKey() = default;
+
+  bool operator<(const FallbackFontKey& other) const {
+    if (font_.GetFontSize() != other.font_.GetFontSize())
+      return font_.GetFontSize() < other.font_.GetFontSize();
+    if (font_.GetStyle() != other.font_.GetStyle())
+      return font_.GetStyle() < other.font_.GetStyle();
+    if (font_.GetFontName() != other.font_.GetFontName())
+      return font_.GetFontName() < other.font_.GetFontName();
+    return locale_ < other.locale_;
+  }
+
+ private:
+  std::string locale_;
+  Font font_;
+
+  DISALLOW_ASSIGN(FallbackFontKey);
+};
+
+class FallbackFontEntry {
+ public:
+  FallbackFontEntry(const base::FilePath& font_path,
+                    int ttc_index,
+                    FontRenderParams font_params,
+                    FcCharSet* charset)
+      : font_path_(font_path),
+        ttc_index_(ttc_index),
+        font_params_(font_params),
+        charset_(FcCharSetCopy(charset)) {}
+
+  FallbackFontEntry(const FallbackFontEntry& other)
+      : font_path_(other.font_path_),
+        ttc_index_(other.ttc_index_),
+        font_params_(other.font_params_),
+        charset_(FcCharSetCopy(other.charset_)) {}
+
+  ~FallbackFontEntry() { FcCharSetDestroy(charset_); }
+
+  const base::FilePath& font_path() const { return font_path_; }
+  int ttc_index() const { return ttc_index_; }
+  FontRenderParams font_params() const { return font_params_; }
+
+  // Returns whether the fallback font support the codepoint.
+  bool HasGlyphForCharacter(UChar32 c) const {
+    return FcCharSetHasChar(charset_, static_cast<FcChar32>(c));
+  }
+
+ private:
+  // Font identity fields.
+  base::FilePath font_path_;
+  int ttc_index_;
+
+  // Font rendering parameters.
+  FontRenderParams font_params_;
+
+  // Font code points coverage.
+  FcCharSet* charset_;
+
+  DISALLOW_ASSIGN(FallbackFontEntry);
+};
+
+using FallbackFontEntries = std::vector<FallbackFontEntry>;
+using FallbackFontEntriesCache =
+    base::MRUCache<FallbackFontKey, FallbackFontEntries>;
+
+// The fallback font cache is a mapping from a font to the potential fallback
+// fonts with their codepoint coverage.
+FallbackFontEntriesCache* GetFallbackFontEntriesCacheInstance() {
+  constexpr int kFallbackFontCacheSize = 256;
+  static base::NoDestructor<FallbackFontEntriesCache> cache(
+      kFallbackFontCacheSize);
+  return cache.get();
+}
+
+// The fallback fonts cache is a mapping from a font family name to its
+// potential fallback fonts.
+using FallbackFontList = std::vector<Font>;
+using FallbackFontListCache = base::MRUCache<std::string, FallbackFontList>;
+
+FallbackFontListCache* GetFallbackFontListCacheInstance() {
+  constexpr int kFallbackCacheSize = 64;
+  static base::NoDestructor<FallbackFontListCache> fallback_cache(
+      kFallbackCacheSize);
+  return fallback_cache.get();
+}
 
 }  // namespace
 
-std::vector<Font> GetFallbackFonts(const Font& font) {
-  std::string font_family = font.GetFontName();
-  std::vector<Font>* fallback_fonts =
-      &g_fallback_cache.Get()[font_family];
-  if (!fallback_fonts->empty())
-    return *fallback_fonts;
+size_t GetFallbackFontEntriesCacheSizeForTesting() {
+  return GetFallbackFontEntriesCacheInstance()->size();
+}
 
+size_t GetFallbackFontListCacheSizeForTesting() {
+  return GetFallbackFontListCacheInstance()->size();
+}
+
+void ClearAllFontFallbackCachesForTesting() {
+  GetFallbackFontEntriesCacheInstance()->Clear();
+  GetFallbackFontListCacheInstance()->Clear();
+}
+
+bool GetFallbackFont(const Font& font,
+                     const std::string& locale,
+                     base::StringPiece16 text,
+                     Font* result) {
+  TRACE_EVENT0("fonts", "gfx::GetFallbackFont");
+
+  // The text passed must be at least length 1.
+  if (text.empty())
+    return false;
+
+  FallbackFontEntriesCache* cache = GetFallbackFontEntriesCacheInstance();
+  FallbackFontKey key(locale, font);
+  FallbackFontEntriesCache::iterator cache_entry = cache->Get(key);
+
+  // The cache entry for this font is missing, build it.
+  if (cache_entry == cache->end()) {
+    ScopedFcPattern pattern(FcPatternCreate());
+
+    // Add pattern for family name.
+    std::string font_family = font.GetFontName();
+    FcPatternAddString(pattern.get(), FC_FAMILY,
+                       reinterpret_cast<const FcChar8*>(font_family.c_str()));
+
+    // Prefer scalable font.
+    FcPatternAddBool(pattern.get(), FC_SCALABLE, FcTrue);
+
+    // Add pattern for locale.
+    FcPatternAddString(pattern.get(), FC_LANG,
+                       reinterpret_cast<const FcChar8*>(locale.c_str()));
+
+    // Add pattern for font style.
+    if ((font.GetStyle() & gfx::Font::ITALIC) != 0)
+      FcPatternAddInteger(pattern.get(), FC_SLANT, FC_SLANT_ITALIC);
+
+    // Match a font fallback.
+    FcConfig* config = GetGlobalFontConfig();
+    FcConfigSubstitute(config, pattern.get(), FcMatchPattern);
+    FcDefaultSubstitute(pattern.get());
+
+    FallbackFontEntries fallback_font_entries;
+    FcResult fc_result;
+    FcFontSet* fonts =
+        FcFontSort(config, pattern.get(), FcTrue, nullptr, &fc_result);
+    if (fonts) {
+      // Add each potential fallback font returned by font-config to the
+      // set of fallback fonts and keep track of their codepoints coverage.
+      for (int i = 0; i < fonts->nfont; ++i) {
+        FcPattern* current_font = fonts->fonts[i];
+        if (!IsValidFontFromPattern(current_font))
+          continue;
+
+        // Retrieve the font identity fields.
+        base::FilePath font_path = GetFontPath(current_font);
+        int font_ttc_index = GetFontTtcIndex(current_font);
+
+        // Retrieve the charset of the current font.
+        FcCharSet* char_set = nullptr;
+        fc_result = FcPatternGetCharSet(current_font, FC_CHARSET, 0, &char_set);
+        if (fc_result != FcResultMatch || char_set == nullptr)
+          continue;
+
+        // Retrieve the font render params.
+        FontRenderParams font_params;
+        GetFontRenderParamsFromFcPattern(current_font, &font_params);
+
+        fallback_font_entries.push_back(FallbackFontEntry(
+            font_path, font_ttc_index, font_params, char_set));
+      }
+      FcFontSetDestroy(fonts);
+    }
+
+    cache_entry = cache->Put(key, std::move(fallback_font_entries));
+  }
+
+  // Try each font in the cache to find the one with the highest coverage.
+  size_t fewest_missing_glyphs = text.length() + 1;
+  const FallbackFontEntry* prefered_entry = nullptr;
+
+  for (const auto& entry : cache_entry->second) {
+    // Validate that every character has a known glyph in the font.
+    size_t missing_glyphs = 0;
+    size_t matching_glyphs = 0;
+    size_t i = 0;
+    while (i < text.length()) {
+      UChar32 c = 0;
+      U16_NEXT(text.data(), i, text.length(), c);
+      if (entry.HasGlyphForCharacter(c)) {
+        ++matching_glyphs;
+      } else {
+        ++missing_glyphs;
+      }
+    }
+
+    if (matching_glyphs > 0 && missing_glyphs < fewest_missing_glyphs) {
+      fewest_missing_glyphs = missing_glyphs;
+      prefered_entry = &entry;
+    }
+
+    // The font has coverage for the given text and is a valid fallback font.
+    if (missing_glyphs == 0)
+      break;
+  }
+
+  // No fonts can be used as font fallback.
+  if (!prefered_entry)
+    return false;
+
+  sk_sp<SkTypeface> typeface = GetSkTypefaceFromPathAndIndex(
+      prefered_entry->font_path(), prefered_entry->ttc_index());
+  // The file can't be parsed (e.g. corrupt). This font can't be used as a
+  // fallback font.
+  if (!typeface)
+    return false;
+
+  Font fallback_font(PlatformFont::CreateFromSkTypeface(
+      typeface, font.GetFontSize(), prefered_entry->font_params()));
+
+  *result = fallback_font;
+  return true;
+}
+
+std::vector<Font> GetFallbackFonts(const Font& font) {
+  TRACE_EVENT0("fonts", "gfx::GetFallbackFonts");
+
+  std::string font_family = font.GetFontName();
+
+  // Lookup in the cache for already processed family.
+  FallbackFontListCache* font_cache = GetFallbackFontListCacheInstance();
+  auto cached_fallback_fonts = font_cache->Get(font_family);
+  if (cached_fallback_fonts != font_cache->end()) {
+    // Already in cache.
+    return cached_fallback_fonts->second;
+  }
+
+  // Retrieve the font fallbacks for a given family name.
+  FallbackFontList fallback_fonts;
   FcPattern* pattern = FcPatternCreate();
-  FcValue family;
-  family.type = FcTypeString;
-  family.u.s = reinterpret_cast<const FcChar8*>(font_family.c_str());
-  FcPatternAdd(pattern, FC_FAMILY, family, FcFalse);
-  if (FcConfigSubstitute(NULL, pattern, FcMatchPattern) == FcTrue) {
+  FcPatternAddString(pattern, FC_FAMILY,
+                     reinterpret_cast<const FcChar8*>(font_family.c_str()));
+
+  FcConfig* config = GetGlobalFontConfig();
+  if (FcConfigSubstitute(config, pattern, FcMatchPattern) == FcTrue) {
     FcDefaultSubstitute(pattern);
     FcResult result;
-    FcFontSet* fonts = FcFontSort(NULL, pattern, FcTrue, NULL, &result);
+    FcFontSet* fonts = FcFontSort(config, pattern, FcTrue, nullptr, &result);
     if (fonts) {
+      std::set<std::string> fallback_names;
       for (int i = 0; i < fonts->nfont; ++i) {
-        char* name = NULL;
-        FcPatternGetString(fonts->fonts[i], FC_FAMILY, 0,
-            reinterpret_cast<FcChar8**>(&name));
+        std::string name_str = GetFontName(fonts->fonts[i]);
+        if (name_str.empty())
+          continue;
+
         // FontConfig returns multiple fonts with the same family name and
         // different configurations. Check to prevent duplicate family names.
-        if (fallback_fonts->empty() ||
-            fallback_fonts->back().GetFontName() != name) {
-          fallback_fonts->push_back(Font(std::string(name), 13));
-        }
+        if (fallback_names.insert(name_str).second)
+          fallback_fonts.push_back(Font(name_str, 13));
       }
       FcFontSetDestroy(fonts);
     }
   }
   FcPatternDestroy(pattern);
 
-  if (fallback_fonts->empty())
-    fallback_fonts->push_back(Font(font_family, 13));
+  // Store the font fallbacks to the cache.
+  font_cache->Put(font_family, fallback_fonts);
 
-  return *fallback_fonts;
+  return fallback_fonts;
 }
 
 namespace {
@@ -79,7 +397,7 @@ class CachedFont {
     DCHECK(pattern);
     DCHECK(char_set);
     fallback_font_.name = GetFontName(pattern);
-    fallback_font_.filename = GetFontFilename(pattern);
+    fallback_font_.filepath = GetFontPath(pattern);
     fallback_font_.ttc_index = GetFontTtcIndex(pattern);
     fallback_font_.is_bold = IsFontBold(pattern);
     fallback_font_.is_italic = IsFontItalic(pattern);
@@ -92,42 +410,6 @@ class CachedFont {
   }
 
  private:
-  static std::string GetFontName(FcPattern* pattern) {
-    FcChar8* familyName = nullptr;
-    if (FcPatternGetString(pattern, FC_FAMILY, 0, &familyName) != FcResultMatch)
-      return std::string();
-    return std::string(reinterpret_cast<const char*>(familyName));
-  }
-
-  static std::string GetFontFilename(FcPattern* pattern) {
-    FcChar8* c_filename = nullptr;
-    if (FcPatternGetString(pattern, FC_FILE, 0, &c_filename) != FcResultMatch)
-      return std::string();
-    return std::string(reinterpret_cast<const char*>(c_filename));
-  }
-
-  static int GetFontTtcIndex(FcPattern* pattern) {
-    int ttcIndex = -1;
-    if (FcPatternGetInteger(pattern, FC_INDEX, 0, &ttcIndex) != FcResultMatch ||
-        ttcIndex < 0)
-      return 0;
-    return ttcIndex;
-  }
-
-  static bool IsFontBold(FcPattern* pattern) {
-    int weight = 0;
-    if (FcPatternGetInteger(pattern, FC_WEIGHT, 0, &weight) != FcResultMatch)
-      return false;
-    return weight >= FC_WEIGHT_BOLD;
-  }
-
-  static bool IsFontItalic(FcPattern* pattern) {
-    int slant = 0;
-    if (FcPatternGetInteger(pattern, FC_SLANT, 0, &slant) != FcResultMatch)
-      return false;
-    return slant != FC_SLANT_ROMAN;
-  }
-
   FallbackFontData fallback_font_;
   // supported_characters_ is owned by the parent
   // FcFontSet and should never be freed.
@@ -148,15 +430,16 @@ class CachedFontSet {
     FcFontSetDestroy(font_set_);
   }
 
-  FallbackFontData GetFallbackFontForChar(UChar32 c) {
+  bool GetFallbackFontForChar(UChar32 c, FallbackFontData* fallback_font) {
+    TRACE_EVENT0("fonts", "gfx::CachedFontSet::GetFallbackFontForChar");
+
     for (const auto& cached_font : fallback_list_) {
-      if (cached_font.HasGlyphForCharacter(c))
-        return cached_font.fallback_font();
+      if (cached_font.HasGlyphForCharacter(c)) {
+        *fallback_font = cached_font.fallback_font();
+        return true;
+      }
     }
-    // The previous code just returned garbage if the user didn't
-    // have the necessary fonts, this seems better than garbage.
-    // Current callers happen to ignore any values with an empty family string.
-    return FallbackFontData();
+    return false;
   }
 
  private:
@@ -192,6 +475,8 @@ class CachedFontSet {
   }
 
   void FillFallbackList() {
+    TRACE_EVENT0("fonts", "gfx::CachedFontSet::FillFallbackList");
+
     DCHECK(fallback_list_.empty());
     if (!font_set_)
       return;
@@ -199,34 +484,9 @@ class CachedFontSet {
     for (int i = 0; i < font_set_->nfont; ++i) {
       FcPattern* pattern = font_set_->fonts[i];
 
-      // Ignore any bitmap fonts users may still have installed from last
-      // century.
-      FcBool is_scalable;
-      if (FcPatternGetBool(pattern, FC_SCALABLE, 0, &is_scalable) !=
-              FcResultMatch ||
-          !is_scalable)
+      if (!IsValidFontFromPattern(pattern))
         continue;
 
-      // Ignore any fonts FontConfig knows about, but that we don't have
-      // permission to read.
-      FcChar8* c_filename;
-      if (FcPatternGetString(pattern, FC_FILE, 0, &c_filename) != FcResultMatch)
-        continue;
-      if (access(reinterpret_cast<char*>(c_filename), R_OK))
-        continue;
-
-      // Take only supported font formats on board.
-      FcChar8* font_format;
-      if (FcPatternGetString(pattern, FC_FONTFORMAT, 0, &font_format) !=
-          FcResultMatch) {
-        continue;
-      }
-      if (font_format &&
-          strcmp(reinterpret_cast<char*>(font_format), kFontFormatTrueType) &&
-          strcmp(reinterpret_cast<char*>(font_format), kFontFormatCFF)) {
-        continue;
-      }
-
       // Make sure this font can tell us what characters it has glyphs for.
       FcCharSet* char_set;
       if (FcPatternGetCharSet(pattern, FC_CHARSET, 0, &char_set) !=
@@ -252,11 +512,16 @@ base::LazyInstance<FontSetCache>::Leaky g_font_sets_by_locale =
 
 }  // namespace
 
-FallbackFontData GetFallbackFontForChar(UChar32 c, const std::string& locale) {
+FallbackFontData::FallbackFontData() = default;
+FallbackFontData::FallbackFontData(const FallbackFontData& other) = default;
+
+bool GetFallbackFontForChar(UChar32 c,
+                            const std::string& locale,
+                            FallbackFontData* fallback_font) {
   auto& cached_font_set = g_font_sets_by_locale.Get()[locale];
   if (!cached_font_set)
     cached_font_set = CachedFontSet::CreateForLocale(locale);
-  return cached_font_set->GetFallbackFontForChar(c);
+  return cached_font_set->GetFallbackFontForChar(c, fallback_font);
 }
 
 }  // namespace gfx
diff --git a/ui/gfx/font_render_params_linux.cc b/ui/gfx/font_render_params_linux.cc
index f12db00e1b97..3ab8b2ed3eeb 100644
--- a/ui/gfx/font_render_params_linux.cc
+++ b/ui/gfx/font_render_params_linux.cc
@@ -12,16 +12,19 @@
 
 #include "base/command_line.h"
 #include "base/containers/mru_cache.h"
-#include "base/hash.h"
+#include "base/hash/hash.h"
 #include "base/lazy_instance.h"
 #include "base/logging.h"
 #include "base/macros.h"
 #include "base/strings/string_util.h"
 #include "base/strings/stringprintf.h"
 #include "base/synchronization/lock.h"
+#include "base/trace_event/trace_event.h"
 #include "build/build_config.h"
+#include "build/chromeos_buildflags.h"
 #include "ui/gfx/font.h"
-#include "ui/gfx/linux_font_delegate.h"
+#include "ui/gfx/linux/fontconfig_util.h"
+#include "ui/gfx/skia_font_delegate.h"
 #include "ui/gfx/switches.h"
 
 namespace gfx {
@@ -102,44 +105,19 @@ struct SynchronizedCache {
 base::LazyInstance<SynchronizedCache>::Leaky g_synchronized_cache =
     LAZY_INSTANCE_INITIALIZER;
 
-// Converts Fontconfig FC_HINT_STYLE to FontRenderParams::Hinting.
-FontRenderParams::Hinting ConvertFontconfigHintStyle(int hint_style) {
-  switch (hint_style) {
-    case FC_HINT_SLIGHT: return FontRenderParams::HINTING_SLIGHT;
-    case FC_HINT_MEDIUM: return FontRenderParams::HINTING_MEDIUM;
-    case FC_HINT_FULL:   return FontRenderParams::HINTING_FULL;
-    default:             return FontRenderParams::HINTING_NONE;
-  }
-}
-
-// Converts Fontconfig FC_RGBA to FontRenderParams::SubpixelRendering.
-FontRenderParams::SubpixelRendering ConvertFontconfigRgba(int rgba) {
-  switch (rgba) {
-    case FC_RGBA_RGB:  return FontRenderParams::SUBPIXEL_RENDERING_RGB;
-    case FC_RGBA_BGR:  return FontRenderParams::SUBPIXEL_RENDERING_BGR;
-    case FC_RGBA_VRGB: return FontRenderParams::SUBPIXEL_RENDERING_VRGB;
-    case FC_RGBA_VBGR: return FontRenderParams::SUBPIXEL_RENDERING_VBGR;
-    default:           return FontRenderParams::SUBPIXEL_RENDERING_NONE;
-  }
-}
-
 // Queries Fontconfig for rendering settings and updates |params_out| and
 // |family_out| (if non-NULL). Returns false on failure.
 bool QueryFontconfig(const FontRenderParamsQuery& query,
                      FontRenderParams* params_out,
                      std::string* family_out) {
-  struct FcPatternDeleter {
-    void operator()(FcPattern* ptr) const { FcPatternDestroy(ptr); }
-  };
-  typedef std::unique_ptr<FcPattern, FcPatternDeleter> ScopedFcPattern;
+  TRACE_EVENT0("fonts", "gfx::QueryFontconfig");
 
   ScopedFcPattern query_pattern(FcPatternCreate());
   CHECK(query_pattern);
 
   FcPatternAddBool(query_pattern.get(), FC_SCALABLE, FcTrue);
 
-  for (std::vector<std::string>::const_iterator it = query.families.begin();
-       it != query.families.end(); ++it) {
+  for (auto it = query.families.begin(); it != query.families.end(); ++it) {
     FcPatternAddString(query_pattern.get(),
         FC_FAMILY, reinterpret_cast<const FcChar8*>(it->c_str()));
   }
@@ -156,7 +134,8 @@ bool QueryFontconfig(const FontRenderParamsQuery& query,
                         FontWeightToFCWeight(query.weight));
   }
 
-  FcConfigSubstitute(NULL, query_pattern.get(), FcMatchPattern);
+  FcConfig* config = GetGlobalFontConfig();
+  FcConfigSubstitute(config, query_pattern.get(), FcMatchPattern);
   FcDefaultSubstitute(query_pattern.get());
 
   ScopedFcPattern result_pattern;
@@ -170,11 +149,12 @@ bool QueryFontconfig(const FontRenderParamsQuery& query,
     FcPatternDel(result_pattern.get(), FC_FAMILY);
     FcPatternDel(result_pattern.get(), FC_PIXEL_SIZE);
     FcPatternDel(result_pattern.get(), FC_SIZE);
-    FcConfigSubstituteWithPat(NULL, result_pattern.get(), query_pattern.get(),
+    FcConfigSubstituteWithPat(config, result_pattern.get(), query_pattern.get(),
                               FcMatchFont);
   } else {
+    TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("fonts"), "FcFontMatch");
     FcResult result;
-    result_pattern.reset(FcFontMatch(NULL, query_pattern.get(), &result));
+    result_pattern.reset(FcFontMatch(config, query_pattern.get(), &result));
     if (!result_pattern)
       return false;
   }
@@ -187,42 +167,8 @@ bool QueryFontconfig(const FontRenderParamsQuery& query,
       family_out->assign(reinterpret_cast<const char*>(family));
   }
 
-  if (params_out) {
-    FcBool fc_antialias = 0;
-    if (FcPatternGetBool(result_pattern.get(), FC_ANTIALIAS, 0,
-                         &fc_antialias) == FcResultMatch) {
-      params_out->antialiasing = fc_antialias;
-    }
-
-    FcBool fc_autohint = 0;
-    if (FcPatternGetBool(result_pattern.get(), FC_AUTOHINT, 0, &fc_autohint) ==
-        FcResultMatch) {
-      params_out->autohinter = fc_autohint;
-    }
-
-    FcBool fc_bitmap = 0;
-    if (FcPatternGetBool(result_pattern.get(), FC_EMBEDDED_BITMAP, 0,
-                         &fc_bitmap) ==
-        FcResultMatch) {
-      params_out->use_bitmaps = fc_bitmap;
-    }
-
-    FcBool fc_hinting = 0;
-    if (FcPatternGetBool(result_pattern.get(), FC_HINTING, 0, &fc_hinting) ==
-        FcResultMatch) {
-      int fc_hint_style = FC_HINT_NONE;
-      if (fc_hinting) {
-        FcPatternGetInteger(
-            result_pattern.get(), FC_HINT_STYLE, 0, &fc_hint_style);
-      }
-      params_out->hinting = ConvertFontconfigHintStyle(fc_hint_style);
-    }
-
-    int fc_rgba = FC_RGBA_NONE;
-    if (FcPatternGetInteger(result_pattern.get(), FC_RGBA, 0, &fc_rgba) ==
-        FcResultMatch)
-      params_out->subpixel_rendering = ConvertFontconfigRgba(fc_rgba);
-  }
+  if (params_out)
+    GetFontRenderParamsFromFcPattern(result_pattern.get(), params_out);
 
   return true;
 }
@@ -241,6 +187,8 @@ uint32_t HashFontRenderParamsQuery(const FontRenderParamsQuery& query) {
 
 FontRenderParams GetFontRenderParams(const FontRenderParamsQuery& query,
                                      std::string* family_out) {
+  TRACE_EVENT0("fonts", "gfx::GetFontRenderParams");
+
   FontRenderParamsQuery actual_query(query);
   if (actual_query.device_scale_factor == 0)
     actual_query.device_scale_factor = device_scale_factor_;
@@ -267,7 +215,7 @@ FontRenderParams GetFontRenderParams(const FontRenderParamsQuery& query,
 
   // Start with the delegate's settings, but let Fontconfig have the final say.
   FontRenderParams params;
-  const LinuxFontDelegate* delegate = LinuxFontDelegate::instance();
+  const SkiaFontDelegate* delegate = SkiaFontDelegate::instance();
   if (delegate)
     params = delegate->GetDefaultFontRenderParams();
   QueryFontconfig(actual_query, &params, family_out);
@@ -280,7 +228,7 @@ FontRenderParams GetFontRenderParams(const FontRenderParamsQuery& query,
     params.subpixel_positioning = false;
   } else if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
                  switches::kDisableFontSubpixelPositioning)) {
-#if !defined(OS_CHROMEOS)
+#if !BUILDFLAG(IS_CHROMEOS_ASH)
     params.subpixel_positioning = actual_query.device_scale_factor > 1.0f;
 #else
     // We want to enable subpixel positioning for fractional dsf.
@@ -288,7 +236,7 @@ FontRenderParams GetFontRenderParams(const FontRenderParamsQuery& query,
         std::abs(std::round(actual_query.device_scale_factor) -
                  actual_query.device_scale_factor) >
         std::numeric_limits<float>::epsilon();
-#endif  // !defined(OS_CHROMEOS)
+#endif  // !BUILDFLAG(IS_CHROMEOS_ASH)
 
     // To enable subpixel positioning, we need to disable hinting.
     if (params.subpixel_positioning)
diff --git a/ui/gfx/font_render_params_linux_unittest.cc b/ui/gfx/font_render_params_linux_unittest.cc
index e654120dae51..770708d23d07 100644
--- a/ui/gfx/font_render_params_linux_unittest.cc
+++ b/ui/gfx/font_render_params_linux_unittest.cc
@@ -6,16 +6,19 @@
 
 #include <fontconfig/fontconfig.h>
 
+#include "base/check_op.h"
 #include "base/files/file_util.h"
 #include "base/files/scoped_temp_dir.h"
-#include "base/logging.h"
 #include "base/macros.h"
+#include "base/notreached.h"
 #include "base/strings/stringprintf.h"
 #include "base/test/fontconfig_util_linux.h"
 #include "build/build_config.h"
+#include "build/chromeos_buildflags.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/gfx/font.h"
-#include "ui/gfx/linux_font_delegate.h"
+#include "ui/gfx/linux/fontconfig_util.h"
+#include "ui/gfx/skia_font_delegate.h"
 
 namespace gfx {
 
@@ -33,9 +36,9 @@ const char kFontconfigMatchFontHeader[] = "  <match target=\"font\">\n";
 const char kFontconfigMatchPatternHeader[] = "  <match target=\"pattern\">\n";
 const char kFontconfigMatchFooter[] = "  </match>\n";
 
-// Implementation of LinuxFontDelegate that returns a canned FontRenderParams
+// Implementation of SkiaFontDelegate that returns a canned FontRenderParams
 // struct. This is used to isolate tests from the system's local configuration.
-class TestFontDelegate : public LinuxFontDelegate {
+class TestFontDelegate : public SkiaFontDelegate {
  public:
   TestFontDelegate() {}
   ~TestFontDelegate() override {}
@@ -59,35 +62,12 @@ class TestFontDelegate : public LinuxFontDelegate {
   DISALLOW_COPY_AND_ASSIGN(TestFontDelegate);
 };
 
-// Instructs Fontconfig to load |path|, an XML configuration file, into the
-// current config, returning true on success.
-bool LoadConfigFileIntoFontconfig(const base::FilePath& path) {
-  // Unlike other FcConfig functions, FcConfigParseAndLoad() doesn't default to
-  // the current config when passed NULL. So that's cool.
-  if (!FcConfigParseAndLoad(
-          FcConfigGetCurrent(),
-          reinterpret_cast<const FcChar8*>(path.value().c_str()), FcTrue)) {
-    LOG(ERROR) << "Fontconfig failed to load " << path.value();
-    return false;
-  }
-  return true;
-}
-
-// Writes |data| to a file in |temp_dir| and passes it to
-// LoadConfigFileIntoFontconfig().
-bool LoadConfigDataIntoFontconfig(const base::FilePath& temp_dir,
-                                  const std::string& data) {
-  base::FilePath path;
-  if (!base::CreateTemporaryFileInDir(temp_dir, &path)) {
-    PLOG(ERROR) << "Unable to create temporary file in " << temp_dir.value();
-    return false;
-  }
-  if (base::WriteFile(path, data.data(), data.size()) !=
-      static_cast<int>(data.size())) {
-    PLOG(ERROR) << "Unable to write config data to " << path.value();
-    return false;
-  }
-  return LoadConfigFileIntoFontconfig(path);
+// Loads XML-formatted |data| into the current font configuration.
+bool LoadConfigDataIntoFontconfig(const std::string& data) {
+  FcConfig* config = GetGlobalFontConfig();
+  constexpr FcBool kComplain = FcTrue;
+  return FcConfigParseAndLoadFromMemory(
+      config, reinterpret_cast<const FcChar8*>(data.c_str()), kComplain);
 }
 
 // Returns a Fontconfig <edit> stanza.
@@ -129,40 +109,46 @@ std::string CreateFontconfigAliasStanza(const std::string& original_family,
 class FontRenderParamsTest : public testing::Test {
  public:
   FontRenderParamsTest() {
-    CHECK(temp_dir_.CreateUniqueTempDir());
-    original_font_delegate_ = LinuxFontDelegate::instance();
-    LinuxFontDelegate::SetInstance(&test_font_delegate_);
+    original_font_delegate_ = SkiaFontDelegate::instance();
+    SkiaFontDelegate::SetInstance(&test_font_delegate_);
     ClearFontRenderParamsCacheForTest();
+
+    // Create a new fontconfig configuration and load the default fonts
+    // configuration. The default test config file is produced in the build
+    // folder under <build_dir>/etc/fonts/fonts.conf and the loaded tests fonts
+    // are under <build_dir>/test_fonts.
+    override_config_ = FcConfigCreate();
+    FcBool parse_success =
+        FcConfigParseAndLoad(override_config_, nullptr, FcTrue);
+    DCHECK_NE(parse_success, FcFalse);
+    FcBool load_success = FcConfigBuildFonts(override_config_);
+    DCHECK_NE(load_success, FcFalse);
+
+    original_config_ = GetGlobalFontConfig();
+    OverrideGlobalFontConfigForTesting(override_config_);
   }
 
   ~FontRenderParamsTest() override {
-    LinuxFontDelegate::SetInstance(
-        const_cast<LinuxFontDelegate*>(original_font_delegate_));
-  }
+    OverrideGlobalFontConfigForTesting(original_config_);
+    FcConfigDestroy(override_config_);
 
-  void SetUp() override {
-    // Fontconfig should already be set up by the test runner.
-    DCHECK(FcConfigGetCurrent());
-  }
-
-  void TearDown() override {
-    // We might have made a mess introducing new fontconfig settings.  Reset the
-    // state of fontconfig for the next test.
-    base::SetUpFontconfig();
+    SkiaFontDelegate::SetInstance(
+        const_cast<SkiaFontDelegate*>(original_font_delegate_));
   }
 
  protected:
-  base::ScopedTempDir temp_dir_;
-  const LinuxFontDelegate* original_font_delegate_;
+  const SkiaFontDelegate* original_font_delegate_;
   TestFontDelegate test_font_delegate_;
 
+  FcConfig* override_config_ = nullptr;
+  FcConfig* original_config_ = nullptr;
+
  private:
   DISALLOW_COPY_AND_ASSIGN(FontRenderParamsTest);
 };
 
 TEST_F(FontRenderParamsTest, Default) {
   ASSERT_TRUE(LoadConfigDataIntoFontconfig(
-      temp_dir_.GetPath(),
       std::string(kFontconfigFileHeader) +
           // Specify the desired defaults via a font match rather than a pattern
           // match (since this is the style generally used in
@@ -211,7 +197,6 @@ TEST_F(FontRenderParamsTest, Default) {
 
 TEST_F(FontRenderParamsTest, Size) {
   ASSERT_TRUE(LoadConfigDataIntoFontconfig(
-      temp_dir_.GetPath(),
       std::string(kFontconfigFileHeader) + kFontconfigMatchPatternHeader +
           CreateFontconfigEditStanza("antialias", "bool", "true") +
           CreateFontconfigEditStanza("hinting", "bool", "true") +
@@ -256,7 +241,6 @@ TEST_F(FontRenderParamsTest, Style) {
   // Load a config that disables subpixel rendering for bold text and disables
   // hinting for italic text.
   ASSERT_TRUE(LoadConfigDataIntoFontconfig(
-      temp_dir_.GetPath(),
       std::string(kFontconfigFileHeader) + kFontconfigMatchPatternHeader +
           CreateFontconfigEditStanza("antialias", "bool", "true") +
           CreateFontconfigEditStanza("hinting", "bool", "true") +
@@ -301,7 +285,6 @@ TEST_F(FontRenderParamsTest, Style) {
 TEST_F(FontRenderParamsTest, Scalable) {
   // Load a config that only enables antialiasing for scalable fonts.
   ASSERT_TRUE(LoadConfigDataIntoFontconfig(
-      temp_dir_.GetPath(),
       std::string(kFontconfigFileHeader) + kFontconfigMatchPatternHeader +
           CreateFontconfigEditStanza("antialias", "bool", "false") +
           kFontconfigMatchFooter + kFontconfigMatchPatternHeader +
@@ -318,7 +301,6 @@ TEST_F(FontRenderParamsTest, Scalable) {
 TEST_F(FontRenderParamsTest, UseBitmaps) {
   // Load a config that enables embedded bitmaps for fonts <= 10 pixels.
   ASSERT_TRUE(LoadConfigDataIntoFontconfig(
-      temp_dir_.GetPath(),
       std::string(kFontconfigFileHeader) + kFontconfigMatchPatternHeader +
           CreateFontconfigEditStanza("embeddedbitmap", "bool", "false") +
           kFontconfigMatchFooter + kFontconfigMatchPatternHeader +
@@ -339,7 +321,6 @@ TEST_F(FontRenderParamsTest, ForceFullHintingWhenAntialiasingIsDisabled) {
   // Load a config that disables antialiasing and hinting while requesting
   // subpixel rendering.
   ASSERT_TRUE(LoadConfigDataIntoFontconfig(
-      temp_dir_.GetPath(),
       std::string(kFontconfigFileHeader) + kFontconfigMatchPatternHeader +
           CreateFontconfigEditStanza("antialias", "bool", "false") +
           CreateFontconfigEditStanza("hinting", "bool", "false") +
@@ -383,18 +364,18 @@ TEST_F(FontRenderParamsTest, ForceSubpixelPositioning) {
     FontRenderParams params =
         GetFontRenderParams(FontRenderParamsQuery(), nullptr);
     EXPECT_TRUE(params.antialiasing);
-#if !defined(OS_CHROMEOS)
+#if !BUILDFLAG(IS_CHROMEOS_ASH)
     EXPECT_TRUE(params.subpixel_positioning);
 #else
     // Integral scale factor does not require subpixel positioning.
     EXPECT_FALSE(params.subpixel_positioning);
-#endif  // !defined(OS_CHROMEOS)
+#endif  // !BUILDFLAG(IS_CHROMEOS_ASH)
     SetFontRenderParamsDeviceScaleFactor(1.0f);
   }
 }
 
 TEST_F(FontRenderParamsTest, OnlySetConfiguredValues) {
-  // Configure the LinuxFontDelegate (which queries GtkSettings on desktop
+  // Configure the SkiaFontDelegate (which queries GtkSettings on desktop
   // Linux) to request subpixel rendering.
   FontRenderParams system_params;
   system_params.subpixel_rendering = FontRenderParams::SUBPIXEL_RENDERING_RGB;
@@ -403,7 +384,6 @@ TEST_F(FontRenderParamsTest, OnlySetConfiguredValues) {
   // Load a Fontconfig config that enables antialiasing but doesn't say anything
   // about subpixel rendering.
   ASSERT_TRUE(LoadConfigDataIntoFontconfig(
-      temp_dir_.GetPath(),
       std::string(kFontconfigFileHeader) + kFontconfigMatchPatternHeader +
           CreateFontconfigEditStanza("antialias", "bool", "true") +
           kFontconfigMatchFooter + kFontconfigFileFooter));
@@ -416,7 +396,8 @@ TEST_F(FontRenderParamsTest, OnlySetConfiguredValues) {
 
 TEST_F(FontRenderParamsTest, NoFontconfigMatch) {
   // A default configuration was set up globally.  Reset it to a blank config.
-  FcConfigSetCurrent(FcConfigCreate());
+  FcConfig* blank = FcConfigCreate();
+  OverrideGlobalFontConfigForTesting(blank);
 
   FontRenderParams system_params;
   system_params.antialiasing = true;
@@ -436,6 +417,9 @@ TEST_F(FontRenderParamsTest, NoFontconfigMatch) {
   EXPECT_EQ(system_params.hinting, params.hinting);
   EXPECT_EQ(system_params.subpixel_rendering, params.subpixel_rendering);
   EXPECT_EQ(query.families[0], suggested_family);
+
+  OverrideGlobalFontConfigForTesting(override_config_);
+  FcConfigDestroy(blank);
 }
 
 TEST_F(FontRenderParamsTest, MissingFamily) {
@@ -453,7 +437,6 @@ TEST_F(FontRenderParamsTest, MissingFamily) {
 TEST_F(FontRenderParamsTest, SubstituteFamily) {
   // Configure Fontconfig to use Tinos for both Helvetica and Arimo.
   ASSERT_TRUE(LoadConfigDataIntoFontconfig(
-      temp_dir_.GetPath(),
       std::string(kFontconfigFileHeader) +
           CreateFontconfigAliasStanza("Helvetica", "Tinos") +
           kFontconfigMatchPatternHeader +
